// %%%%%%%%%%%%%%%%%%%%%%%%%%%% begin opencl_backend %%%%%%%%%%%%%%%%%%%%%%%%%%%%

[appendix]
[[chapter:opencl-backend]]
= OpenCL backend specification

This chapter describes how the SYCL general programming model is mapped on top
of OpenCL, and how the SYCL generic interoperability interface must be
implemented by vendors providing SYCL for OpenCL implementations to ensure SYCL
applications written for the OpenCL backend are interoperable.


[[sec:opencl:native-interop-application]]
== SYCL application interoperability native backend objects

For each <<sycl-runtime>> class which supports <<sycl-application>>
interoperability, specializations of [code]#backend_traits::input_type# and
[code]#backend_traits::return_type# must be defined as the type of
<<sycl-application>> interoperability <<native-backend-object>> associated with
[code]#SyclType# for the <<backend>>.

The types of the native backend objects for <<sycl-application>>
interoperability are described in <<table.opencl.interop>>.

[[sec:opencl:native-interop-kernel]]
== Kernel function interoperability native backend objects

For each <<sycl-runtime>> class which supports kernel function interoperability,
a specialization of [code]#backend_traits::return_type# must be defined as the
type of kernel function interoperability <<native-backend-object>> associated
with [code]#SyclType# for the <<backend>>.

The types of the native backend objects for kernel function interoperability are
described in <<table.opencl.kernelfunctioninterop.nativeobjects>>.

[[table.opencl.kernelfunctioninterop.nativeobjects]]
.Types of native backend objects kernel function interoperability
[width="100%",options="header",cols="60%,40%"]
|====
| [code]#SyclType#                                                   | [code]#backend_return_t<backend::opencl, SyclType>#
| [code]#accessor<T, Dims, Mode, target::device>#                    | [code]#__global T*#
| [code]#accessor<T, Dims, Mode, target::constant_buffer>#           | [code]#__constant T*#
| [code]#accessor<T, Dims, Mode, target::local>#                     | [code]#__local T*#
| [code]#local_accessor<T, Dims>#                                    | [code]#__local T*#
| [code]#sampled_image_accessor<T, 1, Mode, image_target::device>#   | [code]#sampler_1dimage_pair_t#
| [code]#sampled_image_accessor<T, 2, Mode, image_target::device>#   | [code]#sampler_2dimage_pair_t#
| [code]#sampled_image_accessor<T, 3, Mode, image_target::device>#   | [code]#sampler_3dimage_pair_t#
| [code]#unsampled_image_accessor<T, 1, Mode, image_target::device># | [code]#image1d_t#
| [code]#unsampled_image_accessor<T, 2, Mode, image_target::device># | [code]#image2d_t#
| [code]#unsampled_image_accessor<T, 3, Mode, image_target::device># | [code]#image3d_t#
| [code]#stream#                                                     | [code]#__global cl_char*#
| [code]#device_event#                                               | [code]#event_t#
|====

The [code]#sampler_1dimage_pair_t#, [code]#sampler_1dimage_pair_t# and
[code]#sampler_1dimage_pair_t# types must be implemented as described below.

[source,,linenums]
----
include::{header_dir}/openclBackend/samplerImagePair.h[lines=4..-1]
----

[[sec:opencl:native-interop-destruction]]
== Destruction of interop constructed objects with reference semantics

On destruction of the last copy of an instance of a SYCL class which is
specified to have reference semantics as described in
<<sec:reference-semantics>> that was constructed using one of the <<backend>>
interoperability [code]#make_*# functions specified in
<<sec:backend-interoperability-make>> additional lifetime related operations may
be performed which are required for the underlying <<native-backend-object>>.

The additional behavior performed by the OpenCL <<backend>> for each SYCL class
is described in <<table.opencl.interop.destructors>>.

[[table.opencl.interop.destructors]]
.Destructor behavior of interop constructed objects with reference semantics
[width="100%",options="header",cols="30%,70%"]
|====
| SYCL object     | Destructor behavior
| accessor        | No additional behavior is performed.
| buffer          | [code]#clReleaseMemObject# will be called on the native [code]#cl_mem# object provided during construction.
| context         | [code]#clReleaseContext# will be called on the native [code]#cl_context# object provided during construction.
| device          | [code]#clReleaseDevice# will be called on the native [code]#cl_device# object provided during construction.
| event           | [code]#clReleaseEvent# will be called on the native [code]#cl_event# object provided during construction.
| kernel          | [code]#clReleaseKernel# will be called on the native [code]#cl_kernel# objects provided during construction.
| kernel_bundle   | [code]#clReleaseProgram# will be called on the native [code]#cl_program# objects provided during construction.
| platform        | No additional behavior is performed.
| queue           | [code]#clReleaseCommandQueue# will be called on the native [code]#cl_command_queue# object provided during construction.
| sampled_image   | [code]#clReleaseMemObject# will be called on the native [code]#cl_mem# object provided during construction.
| unsampled_image | [code]#clReleaseMemObject# will be called on the native [code]#cl_mem# object provided during construction.
|====

// From 3.8 SYCL for OpenCL Framework
== SYCL for OpenCL framework

The SYCL framework allows applications to use a host and one or more OpenCL
devices as a single heterogeneous parallel computer system.
The framework contains the following components:

  * <<sycl-library>>: The template library provides a set of {cpp} templates and
    classes which provide the programming model to the user.
    It enables the creation of runtime classes such as SYCL queues, buffers and
    images, as well as access to some underlying OpenCL runtime object, such as
    contexts, platforms, devices and program objects.
  * <<sycl-runtime>>: The <<sycl-runtime>> interfaces with the underlying OpenCL
    implementations and handles scheduling of commands in queues, moving of data
    between host and devices, manages contexts, programs, kernel compilation and
    memory management.
  * [keyword]#OpenCL Implementation(s)#: The SYCL system assumes the existence
    of one or more OpenCL implementations available on the host machine.
  * SYCL <<device-compiler,device compilers>>: The SYCL <<device-compiler,device
    compilers>> compile SYCL {cpp} kernels into a format which can be executed
    on an OpenCL device at runtime.
    There may be more than one SYCL device compiler in a SYCL implementation.
    The format of the compiled SYCL kernels is not defined.
    A SYCL device compiler may, or may not, also compile the host parts of the
    program.

The OpenCL backend is enabled using the [code]#sycl::backend::opencl# value of
[code]#enum class backend#.
That means that when the OpenCL backend is active, the value of
[code]#sycl::is_backend_active<sycl::backend::opencl>::value# will be
[code]#true#.


== Mapping of SYCL programming model on top of OpenCL

The SYCL programming model was originally designed as a high-level model for the
OpenCL API, hence the mapping of SYCL on the OpenCL API is mostly
straightforward.

When the OpenCL backend is active on a SYCL application, all visible OpenCL
platforms are exported as SYCL platforms.

// From Architecture, Section 3.3
When a SYCL implementation executes kernels on an OpenCL device, it achieves
this by enqueuing OpenCL *commands* to execute computations on the processing
elements within a device.
The processing elements within an OpenCL compute unit may execute a single
stream of instructions as ALUs within a SIMD unit (which execute in lockstep
with a single stream of instructions), as independent SPMD units (where each PE
maintains its own program counter) or as some combination of the two.


=== Backend specific information descriptors

Some of the SYCL information descriptors are backend-defined.
For the OpenCL backend these information descriptors map directly to OpenCL
properties as described in the table below:

[[table.opencl.info]]
.Mapping of SYCL information descriptors to OpenCL properties
[width="40%",options="header",cols="50%,50%"]
|====
| SYCL                                 | OpenCL
| [code]#info::platform::version#      | [code]#CL_PLATFORM_VERSION#
| [code]#info::device::version#        | [code]#CL_DEVICE_VERSION#
|====

=== OpenCL memory model

The memory model for SYCL devices running on OpenCL platforms follows the memory
model of the OpenCL version they conform to.

In addition to <<global-memory>> , <<local-memory>> and <<private-memory>>
memory, the OpenCL backend permits the use of <<constant-memory>> space in SYCL:

  * <<constant-memory,Constant-memory>> is a region of memory that remains
    constant during the execution of a kernel.
    A pointer to the generic address space cannot represent an address to this
    memory region.

Work-items executing in a kernel have access to four distinct memory regions,
with the mapping between SYCL and OpenCL described in <<table.opencl.memory>>.

[[table.opencl.memory]]
.Mapping of SYCL memory regions into OpenCL memory regions
[width="40%",options="header",cols="50%,50%"]
|====
| SYCL     | OpenCL
| Global   | Global memory
| Constant | Constant memory
| Local    | Local memory
| Private  | Private memory
|====

=== OpenCL interface for buffer command accessors

The enumerator [code]#target::constant_buffer# is deprecated, but will remain a
part of the OpenCL backend as an extension.
This enables SYCL kernel functions to access the contents of a buffer through
the OpenCL deviceâ€™s constant memory.

// From 3.4.1.1 OpenCL resources managed by SYCL Application
=== OpenCL resources managed by SYCL application

In OpenCL, a developer must create a <<context>> to be able to execute commands
on a device.
Creating a context involves choosing a <<platform>> and a list of
<<device,devices>>.
In SYCL, contexts, platforms and devices all exist, but the user can choose
whether to specify them or have the SYCL implementation create them
automatically.
The minimum required object for submitting work to devices in SYCL is the
<<queue>>, which contains references to a platform, device and context
internally.

The resources managed by SYCL are:

  . <<platform,Platforms>>: all features of OpenCL are implemented by platforms.
    A platform can be viewed as a given hardware vendor's runtime and the
    devices accessible through it.
    Some devices will only be accessible to one vendor's runtime and hence
    multiple platforms may be present.
    SYCL manages the different platforms for the user.
    In SYCL, a platform resource is accessible through a [code]#sycl::platform#
    object.
  . <<context,Contexts>>: any OpenCL resource that is acquired by the user is
    attached to a context.
    A context contains a collection of devices that the host can use and manages
    memory objects that can be shared between the devices.
    Data movement between devices within a context may be efficient and hidden
    by the underlying OpenCL runtime while data movement between contexts may
    involve the host.
    A given context can only wrap devices owned by a single platform.
    In SYCL, a context resource is accessible through a [code]#sycl::context#
    object.
  . <<device,Devices>>: platforms provide one or more devices for executing
    kernels.
    In SYCL, a device is accessible through a [code]#sycl::device# object.
  . <<kernel-bundle,Kernel bundles>>: OpenCL objects that store implementation
    data for the SYCL kernels.
    These objects are only required for advanced use in SYCL and are
    encapsulated in the [code]#sycl::kernel_bundle# class.
  . <<queue,Queues>>: SYCL kernels execute in command queues.
    The user must create a queue, which references an associated context,
    platform and device.
    The context, platform and device may be chosen automatically, or specified
    by the user.
    In SYCL, command queues are accessible through [code]#sycl::queue# objects.

// Removed from OpenCL Spec document
// In OpenCL, queues can operate using in-order execution or out-of-order
// execution. In SYCL, the implementation must provide out-of-order
// execution ordering when possible, regardless of whether the underlying
// OpenCL queue is in-order or out-of-order.


[[sec:opencl:interfacing-with-opencl]]
== Interoperability with the OpenCL API

// Original sections from 1.2.1
// From Architecture, 3.1;
//
// To ensure maximum backward-compatibility, a software developer can produce
// a program that mixes standard OpenCL C kernels and OpenCL API code with
// SYCL code and expect fully compatible interoperability.

The OpenCL backend for SYCL ensures maximum compatibility between SYCL and
OpenCL kernels and API.
This includes supporting devices with different capabilities and support for
different versions of the OpenCL C language, in addition to supporting SYCL
kernels written in {cpp}.

// Original from 3.6.11, Interfacing with OpenCL
// https://cvs.khronos.org/bugzilla/show_bug.cgi?id=10426

<<sycl-runtime>> classes which encapsulate an OpenCL opaque type such as SYCL
[code]#context# or SYCL [code]#queue# must provide an interoperability
constructor taking an instance of the OpenCL opaque type.
When the OpenCL object supports reference counting, these constructors must
retain that instance to increase the reference count of the OpenCL resource.
Likewise, the destructor for the <<sycl-runtime>> classes which encapsulate a
reference counted OpenCL opaque type must release that instance to decrease the
reference count of the OpenCL resource.
Since the OpenCL [code]#platform_id# is not reference counted, the encapsulating
SYCL [code]#platform# class neither retains nor releases this OpenCL resource.

Note that an instance of a <<sycl-runtime>> class which encapsulates an OpenCL
opaque type can encapsulate any number of instances of the OpenCL type, unless
it was constructed via the interoperability constructor, in which case it can
encapsulate only a single instance of the OpenCL type.

The lifetime of a <<sycl-runtime>> class that encapsulates an OpenCL opaque type
and the instance of that opaque type retrieved via the [code]#get_native()# free
function are not tied in either direction given correct usage of OpenCL
reference counting.
For example if a user were to retrieve a [code]#cl_command_queue# instance from
a SYCL [code]#queue# instance and then immediately destroy the SYCL
[code]#queue# instance, the [code]#cl_command_queue# instance is still valid.
Or if a user were to construct a SYCL [code]#queue# instance from a
[code]#cl_command_queue# instance and then immediately release the
[code]#cl_command_queue# instance, the SYCL [code]#queue# instance is still
valid.

Note that a <<sycl-runtime>> class that encapsulates an OpenCL opaque type is
not responsible for any incorrect use of OpenCL reference counting outside of
the <<sycl-runtime>>.
For example if a user were to retrieve a [code]#cl_command_queue# instance from
a SYCL [code]#queue# instance and then release the [code]#cl_command_queue#
instance more than once without any prior retain then the SYCL [code]#queue#
instance that the [code]#cl_command_queue# instance was retrieved from is now
undefined.

Note that an instance of the SYCL [code]#buffer# or SYCL [code]#image# class
templates constructed via the interoperability constructor is free to copy from
the [code]#cl_mem# into another memory allocation within the <<sycl-runtime>> to
achieve normal SYCL semantics, for as long as the SYCL [code]#buffer# or SYCL
[code]#image# instance is alive.

<<table.opencl.interop>> relates SYCL objects to their OpenCL native type in the
SYCL application.

[[table.opencl.interop]]
.List of native types per SYCL object in the OpenCL backend
[width="100%",options="header",separator="@",cols="15%,15%,15%,55%"]
|====
@ [code]#SyclType#
   @ [code]#backend_input_t<backend::opencl, SyclType>#
   @ [code]#backend_return_t<backend::opencl, SyclType>#
   @ Description
a@
[source]
----
platform
----
   a@ [code]#cl_platform_id#
   a@ [code]#cl_platform_id#
   a@ A SYCL platform object encapsulates an OpenCL platform ID.
a@
[source]
----
device
----
   a@ [code]#cl_device_id#
   a@ [code]#cl_device_id#
   a@ A SYCL device object encapsulates an OpenCL device ID.
a@
[source]
----
context
----
   a@ [code]#cl_context#
   a@ [code]#cl_context#
   a@ A SYCL context object encapsulates an OpenCL context object.
a@
[source]
----
queue
----
   a@ [code]#cl_command_queue#
   a@ [code]#cl_command_queue#
   a@ A SYCL queue object encapsulates an OpenCL queue object.
a@
[source]
----
kernel
----
   a@ [code]#cl_kernel#
   a@ [code]#cl_kernel#
   a@ A SYCL kernel object encapsulates an OpenCL kernel object.
a@
[source]
----
template <bundle_state State> kernel_bundle<State>
----
   a@ [code]#cl_program#
   a@ [code]#std::vector<cl_program>#
   a@ A SYCL kernel bundle can encapsulate one or more OpenCL program objects.
      It can also encapsulate one or more OpenCL kernel objects
      which can be retrieved using the appropriate [code]#kernel# object.
a@
[source]
----
event
----
   a@ [code]#std::vector<cl_event>#
   a@ [code]#std::vector<cl_event>#
   a@ // Original from 3.6.5.1 Synchronization in the SYCL application

A SYCL event can encapsulate one or multiple OpenCL events,
representing a number of dependencies in the same or different contexts,
that must be satisfied for the SYCL event to be complete.
a@
[source]
----
buffer
----
   a@ [code]#cl_mem#
   a@ [code]#std::vector<cl_mem>#
   a@ SYCL buffers containing OpenCL memory objects
      can handle multiple [code]#cl_mem# objects in the same or different context.
      The interoperability interface will return a list of active buffers in the SYCL runtime.
a@
[source]
----
sampled_image
----
   a@ [code]#cl_mem#
   a@ [code]#std::vector<cl_mem>#
   a@ SYCL sampled images containing OpenCL image objects
      can handle multiple underlying [code]#cl_mem# objects
      at the same time in the same or different OpenCL contexts.
      The interoperability interface will return a list of active images in the SYCL runtime.
a@
[source]
----
unsampled_image
----
   a@ [code]#cl_mem#
   a@ [code]#std::vector<cl_mem>#
   a@ SYCL unsampled images containing OpenCL image objects
      can handle multiple underlying [code]#cl_mem# objects
      at the same time in the same or different OpenCL contexts.
      The interoperability interface will return a list of active images in the SYCL runtime.
|====

Inside the SYCL kernel, the SYCL API offers interoperability with OpenCL device
types.
<<table.opencl.kerneltypes>> describes the mapping of kernel types.

[[table.opencl.kerneltypes]]
.List of native types per SYCL object on kernel code
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ SYCL kernel native types in OpenCL @ Description
a@
[source]
----
multi_ptr::get_decorated()
----
   a@ Returns a pointer in the OpenCL address space
      corresponding to the type of multi pointer object
|====

// \section{SYCL Programming interface}
// From 3.6 SYCL programming model (eliminated)
// SYCL programs are explicitly parallel and expose the full heterogeneous
// parallelism of the underlying machine model of OpenCL. This includes exposing
// the data-parallelism, multiple execution devices and multiple memory storage
// spaces of OpenCL. However, SYCL adds on top of OpenCL a higher level of
// abstraction allowing developers to hide much of the complexity from the source
// code, when a developer so chooses.


// From 3.7 memory object
When a buffer or image is allocated on more than one OpenCL device, if these
devices are on separate contexts then multiple [code]#cl_mem# objects may be
allocated for the memory object, depending on whether the object has actively
been used on these devices yet or not.


// From 3.10 Language restrictions in kernels

The OpenCL C function qualifier [code]#+__kernel+# and the access qualifiers:
[code]#+__read_only+#, [code]#+__write_only+# and [code]#+__read_write+# are not
exposed in SYCL via keywords, but are instead encapsulated in SYCL's parameter
passing system inside accessors.
Users wishing to achieve the OpenCL equivalent of these qualifiers in SYCL
should instead use SYCL accessors with equivalent semantics.

// From 3.10.1 SYCL Linker
Any OpenCL C function included in a pre-built OpenCL library can be defined as
an [code]#extern "C"# function and the OpenCL program has to be linked against
any SYCL program that contains kernels using the external function.
In this case, the data types used have to comply with the interoperability
aliases defined in <<table.types.aliases>>.


== Programming interface

The following section describes the OpenCL-specific API.

=== Construct SYCL objects from OpenCL ones

The OpenCL backend provides the following specializations of the
[code]#make_{sycl_class}# template functions which are defined in
<<sec:backend-interoperability-make>>.
These functions are in the [code]#sycl# namespace.

[width="100%",options="header",separator="@",cols="40%,60%"]
|====
@ OpenCL interoperability function @ Description
a@
[source]
----
context make_context(const cl_context& clContext,
                     const async_handler& asyncHandler = {})
----
   a@ Constructs a SYCL [code]#context# instance from an OpenCL [code]#cl_context# in accordance with the requirements described in <<sec:backend-interoperability>>.
a@
[source]
----
event make_event(const std::vector<cl_event>& clEvents,
                 const context& syclContext)
----
   a@ Constructs a SYCL [code]#event# instance from a vector of OpenCL
      [code]#cl_event# objects in accordance with the requirements described in
      <<sec:backend-interoperability>>.
a@
[source]
----
device make_device(const cl_device_id& clDeviceId)
----
   a@ Constructs a SYCL [code]#device# instance from an OpenCL [code]#cl_device_id# in accordance with the requirements described in <<sec:backend-interoperability>>.
a@
[source]
----
platform make_platform(const cl_platform_id& clPlatformId)
----
   a@ Constructs a SYCL [code]#platform# instance from an OpenCL [code]#cl_platform_id# in accordance with the requirements described in <<sec:backend-interoperability>>.
a@
[source]
----
queue make_queue(const cl_command_queue& clQueue, const context& syclContext,
                 const async_handler& asyncHandler = {})
----
   a@ Constructs a SYCL [code]#queue# instance with an optional
      [code]#async_handler# from an OpenCL [code]#cl_command_queue#
      in accordance with the requirements described
      in <<sec:backend-interoperability>>.
a@
[source]
----
template <typename T, int Dimensions = 1,
          typename AllocatorT = buffer_allocator<std::remove_const_t<T>>>
buffer<T, Dimensions, AllocatorT> make_buffer(const cl_mem& clMemObject,
                                              const context& syclContext,
                                              event availableEvent)
----
   a@ Available only when: [code]#Dimensions == 1#.

Constructs a SYCL [code]#buffer# instance from an OpenCL [code]#cl_mem# in accordance with the requirements described in <<sec:backend-interoperability>>.
The instance of the SYCL [code]#buffer# class template being constructed must wait for the SYCL [code]#event# parameter, [code]#availableEvent# to signal that the [code]#cl_mem# instance is ready to be used.
The SYCL [code]#context# parameter [code]#syclContext# is the context associated with the memory object.

a@
[source]
----
template <typename T, int Dimensions = 1,
          typename AllocatorT = buffer_allocator<std::remove_const_t<T>>>
buffer<T, Dimensions, AllocatorT> make_buffer(const cl_mem& clMemObject,
                                              const context& syclContext)
----
   a@ Available only when: [code]#Dimensions == 1#.

Constructs a SYCL [code]#buffer# instance from an OpenCL [code]#cl_mem# in accordance with the requirements described in <<sec:backend-interoperability>>.

a@
[source]
----
template <int Dimensions = 1, typename AllocatorT = image_allocator>
sampled_image<Dimensions, AllocatorT>
make_sampled_image(const cl_mem& clMemObject, const context& syclContext,
                   image_sampler syclImageSampler, event availableEvent)
----
   a@ Constructs a SYCL [code]#sampled_image# instance from an OpenCL [code]#cl_mem# in accordance with the requirements described in <<sec:backend-interoperability>>.
      The instance of the SYCL [code]#image# class template being constructed must wait for the SYCL [code]#event# parameter, [code]#availableEvent# to signal that the [code]#cl_mem# instance is ready to be used.
      The SYCL [code]#context# parameter [code]#syclContext# is the context associated with the memory object. 

a@
[source]
----
template <int Dimensions = 1, typename AllocatorT = image_allocator>
sampled_image<Dimensions, AllocatorT>
make_sampled_image(const cl_mem& clMemObject, const context& syclContext,
                   image_sampler syclImageSampler)
----
   a@ Constructs a SYCL [code]#sampled_image# instance from an OpenCL [code]#cl_mem# in accordance with the requirements described in <<sec:backend-interoperability>>.
      The SYCL [code]#context# parameter [code]#syclContext# is the context associated with the memory object.

a@
[source]
----
template <int Dimensions = 1, typename AllocatorT = image_allocator>
unsampled_image<Dimensions, AllocatorT>
make_unsampled_image(const cl_mem& clMemObject, const context& syclContext,
                     event availableEvent)
----
   a@ Constructs a SYCL [code]#unsampled_image# instance from an OpenCL [code]#cl_mem# in accordance with the requirements described in <<sec:backend-interoperability>>.
      The instance of the SYCL [code]#image# class template being constructed must wait for the SYCL [code]#event# parameter, [code]#availableEvent# to signal that the [code]#cl_mem# instance is ready to be used.
      The SYCL [code]#context# parameter [code]#syclContext# is the context associated with the memory object.

a@
[source]
----
template <int Dimensions = 1, typename AllocatorT = image_allocator>
unsampled_image<Dimensions, AllocatorT>
make_unsampled_image(const cl_mem& clMemObject, const context& syclContext)
----
   a@ Constructs a SYCL [code]#unsampled_image# instance from an OpenCL [code]#cl_mem# in accordance with the requirements described in <<sec:backend-interoperability>>.
a@
[source]
----
kernel make_kernel(const cl_kernel& clKernel, const context& syclContext);
----
   a@ Constructs a SYCL [code]#kernel# instance from an OpenCL kernel object.
a@
[source]
----
template <bundle_state State>
kernel_bundle<State> make_kernel_bundle(const cl_program& clProgram,
                                        const context& syclContext)
----
   a@ Constructs a SYCL [code]#kernel_bundle# instance from an OpenCL
      [code]#cl_program# for the devices in [code]#syclContext#
      in accordance with the requirements described in <<sec:backend-interoperability>>.
      The SYCL [code]#context# must represent the same underlying OpenCL
      context associated with the OpenCL program object.

The [code]#state# specifies the expected [code]#kernel_bundle# state.
      The mapping between the [code]#kernel_bundle# state
      and OpenCL program state ([code]#CL_PROGRAM_BINARY_TYPE#) is as follows:

      * [code]#bundle_state::input# - [code]#CL_PROGRAM_BINARY_TYPE_NONE#
      * [code]#bundle_state::object# -
         [code]#CL_PROGRAM_BINARY_TYPE_COMPILED_OBJECT# or
         [code]#CL_PROGRAM_BINARY_TYPE_INTERMEDIATE# or
         [code]#CL_PROGRAM_BINARY_TYPE_LIBRARY#.
      * [code]#bundle_state::executable# - [code]#CL_PROGRAM_BINARY_TYPE_EXECUTABLE#

If the internal state of the OpenCL program doesn't match [code]#state#,
      the kernel bundle will be compiled and linked as necessary.
      If the OpenCL program is already an executable binary,
      but the specified [code]#state# is not [code]#bundle_state::executable#,
      an [code]#exception# with the [code]#errc::invalid# error code is thrown.
      If the specified [code]#state# is [code]#bundle_state::input#,
      but the OpenCL program already has a binary associated with it,
      an [code]#exception# with the [code]#errc::invalid# error code is thrown.

Throws an [code]#exception# with the [code]#errc::invalid# error code
   if any error is produced by the <<backend>>.
|====


=== Extension query

Platforms and devices with an OpenCL backend may support extensions.
For convenience, the extensions supported by a platform or device can be queried
through the following functions provided in the [code]#sycl::opencl# namespace.

[width="100%",options="header",separator="@",cols="35%,65%"]
|====
@ Extension query @ Description
a@
[source]
----
bool has_extension(const sycl::platform& syclPlatform,
                   const std::string& extension)
----
   a@ Returns true if the OpenCL platform associated with [code]#syclPlatform#
   supports the extension identified by [code]#extension#, otherwise it returns
   false. If [code]#syclPlatform.get_backend() != sycl::backend::opencl# an
   [code]#exception# with the [code]#errc::backend_mismatch# error code is
   thrown.
a@
[source]
----
bool has_extension(const sycl::device& syclDevice, const std::string& extension)
----
   a@ Returns true if the OpenCL device associated with [code]#syclDevice#
   supports the extension identified by [code]#extension#, otherwise it returns
   false. If [code]#syclDevice.get_backend() != sycl::backend::opencl# an
   [code]#exception# with the [code]#errc::backend_mismatch# error code is
   thrown.
|====

=== Reference counting

Most OpenCL objects are reference counted.
The SYCL general programming model doesn't require that native objects are
reference counted.
However, for convenience, the following function is provided in the
[code]#sycl::opencl# namespace.

[width="100%",options="header",separator="@",cols="35%,65%"]
|====
@ Reference counting @ Description
a@
[source]
----
template <typename openCLT> cl_uint get_reference_count(openCLT obj)
----
   a@ Returns the reference count of the given object
|====


=== Errors and limitations

If there is an OpenCL error associated with an exception triggered, then the
OpenCL error code can be obtained by the free function [code]#cl_int
sycl::opencl::get_error_code(sycl::exception&)#.
In the case where there is no OpenCL error associated with the exception
triggered, the OpenCL error code will be [code]#CL_SUCCESS#.


// TODO: Errors and limitations
// The only exception to
// this rule is when a buffer is constructed from a [code]#cl_mem#
// object to interoperate with OpenCL. Use of an interoperability
// buffer on a queue mapping to a context other than that in which the
// [code]#cl_mem# was created is an error.

// Since data management and storage is handled by the <<sycl-runtime>>, the
// [code]#event# class is used for providing the appropriate interface for
// OpenCL/SYCL interoperability. In the case where SYCL objects contain
// OpenCL memory objects created outside of the SYCL mechanism, then events
// can be used to provide the <<sycl-runtime>> with the initial events that it has
// to synchronize against. However, the events mechanism does not provide
// full interoperability with OpenCL during SYCL code execution.
// Interoperability is achieved by using the synchronization rules with the
// [code]#buffer# and [code]#image# classes.


[[sec:opencl:interop-kernel-bundle]]
=== Interoperability with kernel bundles

In <<opencl12, OpenCL>> any kernel function that is enqueued over an nd-range is
represented by a [code]#cl_kernel# and must be compiled and linked via a
[code]#cl_program# using [code]#clBuildProgram#, [code]#clCompileProgram# and
[code]#clLinkProgram#.

For OpenCL <<backend>> this detail is abstracted away by <<kernel-bundle,kernel
bundles>> and a [code]#kernel_bundle# object containing all
<<sycl-kernel-function,SYCL kernel functions>> is retrieved by calling the free
function [code]#get_kernel_bundle#.

The OpenCL <<backend>> specification provides additional free functions which
provide convenience functions for constructing kernel bundles from OpenCL
specific objects.

[source,,linenums]
----
include::{header_dir}/openclBackend/createBundle.h[lines=4..-1]
----

[source,,linenums]
----
template <bundle_state State>
kernel_bundle<State> create_bundle(const context& ctxt,
                                   const std::vector<device>& devs,
                                   const std::vector<cl_program>& clPrograms)
----
  . _Preconditions:_ The <<context>> specified by [code]#ctxt# must be
    associated with the OpenCL <<backend>>.
    All devices in [code]#devs# must be associated with [code]#ctxt#.
    All OpenCL programs in [code]#clPrograms# must be associated with
    [code]#ctxt#.
+
--
_Effects:_ Constructs a <<kernel-bundle>> in the specified [code]#bundle_state#
from the provided list of OpenCL programs and associated with the <<context>>
specified by [code]#syclContext# by invoking the necessary OpenCL APIs.
Follows the same rules as calling [code]#make_kernel_bundle# on a single OpenCL
program, except that the rules apply to all OpenCL programs in
[code]#clPrograms#.
Multiple programs will be linked together into a single one if required by the
requested [code]#State#.
The constructed [code]#kernel_bundle# will retain all provided OpenCL programs
and will also release them on destruction.

_Throws:_ An [code]#exception# with the [code]#errc::build# error code if any
error is produced by invoking the OpenCL APIs.
--

[source,,linenums]
----
kernel_bundle<bundle_state::executable>
create_bundle(const context& ctxt, const std::vector<device>& devs,
              const std::vector<cl_kernel>& clKernels)
----
  . _Preconditions:_ The <<context>> specified by [code]#ctxt# must be
    associated with the OpenCL <<backend>>.
    All devices in [code]#devs# must be associated with [code]#ctxt#.
    All OpenCL kernels in [code]#clKernels# must be associated with
    [code]#ctxt#.
+
--
_Effects:_ Constructs an executable <<kernel-bundle>> from the provided list of
OpenCL kernels and associated with the <<context>> specified by
[code]#syclContext# by invoking the necessary OpenCL APIs.
[code]#cl_kernel# objects might be associated with different [code]#cl_program#
objects, the kernel bundle will encapsulate all of them.

_Throws:_ An [code]#exception# with the [code]#errc::build# error code if any
error is produced by invoking the OpenCL APIs.
--


=== Interoperability with kernels

A [code]#kernel_bundle# object contains one or multiple OpenCL programs and one
 or multiple OpenCL kernels.
 Calling [code]#kernel_bundle::get_kernel# returns a [code]#kernel# object which
 can be invoked by any of
<<kernel-invocation-command,kernel invocation commands>> such as
[code]#parallel_for# which take a [code]#kernel# but not
<<sycl-kernel-function>>.

Calling [code]#make_kernel# must trigger a call to [code]#clRetainKernel# and
the resulting [code]#kernel# object must call [code]#clReleaseKernel# on
destruction.

It is also possible to construct a <<kernel-bundle>> from previously created
OpenCL [code]#cl_kernel# objects by calling the free function
[code]#create_bundle# as described in <<sec:opencl:interop-kernel-bundle>>.

The kernel arguments for the OpenCL C kernel kernel can either be set prior to
creating the [code]#kernel# object or by calling [code]#set_arg# or
[code]#set_args# member functions of the [code]#handler# class.

If kernel arguments are set prior to creating the [code]#kernel# object the
<<sycl-runtime>> is not responsible for managing the data of these arguments.


[[sec:opencl:kernel-conventions-sycl]]
=== OpenCL kernel conventions and SYCL

OpenCL and SYCL use opposite conventions for the unit stride dimension.
SYCL aligns with {cpp} conventions, which is important to understand from a
performance perspective when porting code to SYCL.
The unit stride dimension, at least for data, is implicit in the linearization
equations in SYCL (<<sec:multi-dim-linearization>>) and OpenCL.
SYCL aligns with {cpp} array subscript ordering [code]#arr[a][b][c]#, in that
range constructor dimension ordering used to launch a kernel (e.g.
[code]#range<3> R{a,b,c}#) and range and ID queries within a kernel, are ordered
in the same way as the {cpp} multi-dimensional subscript operators (unit stride
on the right).

When specifying a [code]#range# as the global or local size in a
[code]#parallel_for# that invokes an OpenCL interop kernel (through
[code]#cl_kernel# interop), the highest dimension of the range in SYCL will map
to the lowest dimension within the OpenCL kernel.
That statement applies to both an underlying enqueue operation such as
[code]#clEnqueueNDRangeKernel# in OpenCL, and also ID and size queries within
the OpenCL kernel.
For example, a 3D global range specified in SYCL as:

[source]
----
range<3> R { r0, r1, r2 };
----

maps to an [code]#clEnqueueNDRangeKernel# [code]#global_work_size# argument of:

[source]
----
size_t cl_interop_range[3] = { r2, r1, r0 };
----

Likewise, a 2D global range specified in SYCL as:

[source]
----
range<2> R { r0, r1 };
----

maps to an [code]#clEnqueueNDRangeKernel# [code]#global_work_size# argument of:

[source]
----
size_t cl_interop_range[2] = { r1, r0 };
----

The mapping of highest dimension in SYCL to lowest dimension in OpenCL applies
to all operations where a multi-dimensional construct must be mapped, such as
when mapping SYCL explicit memory operations to OpenCL APIs like
[code]#clEnqueueCopyBufferRect#.

Work-item and work-group ID and range queries have the same reversed convention
for unit stride dimension between SYCL and OpenCL.
For example, with three, two, or one dimensional SYCL global ranges, OpenCL and
SYCL kernel code queries relate to the range as shown in
<<table.syclOpenCL.mapping>>.
The "SYCL kernel query" column applies for SYCL-defined kernels, and the "OpenCL
kernel query" column applies for kernels defined through OpenCL interop.

// Jon: Need to code-format most of these cells and use gray backgrounds on
// column-spanning sub-titles.

[[table.syclOpenCL.mapping]]
.Example range mapping from SYCL enqueued three dimensional global [code]#range# to OpenCL and SYCL queries
[width="100%",options="header",cols="60%,20%,20%"]
|====
| SYCL kernel query | OpenCL kernel query | Returned Value

3+|With enqueued 3D SYCL global [code]#range# of [code]#range<3> R{r0,r1,r2}#
| nd_item::get_global_range(0) / item::get_range(0)
    | get_global_size(2)
    | [code]#r0#
| nd_item::get_global_range(1) / item::get_range(1)
    | get_global_size(1)
    | [code]#r1#
| nd_item::get_global_range(2) / item::get_range(2)
    | get_global_size(0)
    | [code]#r2#
| nd_item::get_global_id(0) / item::get_id(0)
    | get_global_id(2)
    | Value in range 0..([code]#r0-1)}#
| nd_item::get_global_id(1) / item::get_id(1)
    | get_global_id(1)
    | Value in range 0..([code]#r1-1)}#
| nd_item::get_global_id(2) / item::get_id(2)
    | get_global_id(0)
    | Value in range 0..([code]#r2-1)}#

3+|With enqueued 2D SYCL global [code]#range# of [code]#range<2> R{r0,r1}#
| nd_item::get_global_range(0) / item::get_range(0)
    | get_global_size(1)
    | [code]#r0#
| nd_item::get_global_range(1) / item::get_range(1)
    | get_global_size(0)
    | [code]#r1#
| nd_item::get_global_id(0) / item::get_id(0)
    | get_global_id(1)
    | Value in range 0..([code]#r0-1)}#
| nd_item::get_global_id(1) / item::get_id(1)
    | get_global_id(0)
    | Value in range 0..([code]#r1-1)}#

3+|With enqueued 1D SYCL global [code]#range# of [code]#range<1> R{r0}#
| nd_item::get_global_range(0) / item::get_range(0)
    | get_global_size(0)
    | [code]#r0#
| nd_item::get_global_id(0) / item::get_id(0)
    | get_global_id(0)
    | Value in range 0..([code]#r0-1)}#

|====


=== Data types

The OpenCL C language standard <<opencl12, Section 6.11>> defines its own
built-in scalar data types, and these have additional requirements in terms of
size and signedness on top of what is guaranteed by ISO {cpp}.
For the purpose of interoperability and portability, SYCL defines a set of
aliases to {cpp} types within the [code]#sycl::opencl# namespace using the
[code]#cl_# prefix.
These aliases are described in <<table.types.aliases>>.


[[table.types.aliases]]
.Scalar data type aliases supported by SYCL OpenCL backend
[width="100%",options="header",separator="@",cols="25%,75%"]
|====
@ Scalar data type alias @ Description
a@
[source]
----
cl_bool
----
   a@ Alias to a conditional data type which can be either true or false. The value
      true expands to the integer constant 1 and the value false expands to the
      integer constant 0.

a@
[source]
----
cl_char
----
   a@ Alias to a signed 8-bit integer, as defined by the {cpp} core language.

a@
[source]
----
cl_uchar
----
   a@ Alias to an unsigned 8-bit integer, as defined by the {cpp} core language.

a@
[source]
----
cl_short
----
   a@ Alias to a signed 16-bit integer, as defined by the {cpp} core language.

a@
[source]
----
cl_ushort
----
   a@ Alias to an unsigned 16-bit integer, as defined by the {cpp} core language.

a@
[source]
----
cl_int
----
   a@ Alias to a signed 32-bit integer, as defined by the {cpp} core language.

a@
[source]
----
cl_uint
----
   a@ Alias to an unsigned 32-bit integer, as defined by the {cpp} core language.

a@
[source]
----
cl_long
----
   a@ Alias to a signed 64-bit integer, as defined by the {cpp} core language.

a@
[source]
----
cl_ulong
----
   a@ Alias to an unsigned 64-bit integer, as defined by the {cpp} core language.

a@
[source]
----
cl_float
----
   a@ Alias to a 32-bit floating-point. The float data type must conform to the IEEE
      754 single precision storage format.

a@
[source]
----
cl_double
----
   a@ Alias to a 64-bit floating-point. The double data type must conform to the IEEE
      754 double precision storage format.

a@
[source]
----
cl_half
----
   a@ Alias to a 16-bit floating-point. The half data type must conform to
      the IEEE 754-2008 half precision storage format. Kernels using this type
      are only supported on devices that have [code]#aspect::fp16#, as described
      in <<sec:optional-kernel-features>>.

|====



== Preprocessor directives and macros

  * [code]#SYCL_BACKEND_OPENCL# substitutes to [code]#1# if the OpenCL
    <<backend>> is active while building the SYCL application.


=== Offline linking with OpenCL C libraries

SYCL supports linking <<sycl-kernel-function,SYCL kernel functions>> with OpenCL
C libraries during offline compilation or during online compilation by the
<<sycl-runtime>> within a SYCL application.

Linking with OpenCL C kernel functions offline is an optional feature and is
unspecified.
Linking with OpenCL C kernel functions online is performed via the
[code]#sycl::make_kernel_bundle# or [code]#sycl::opencl::create_bundle#
functions, which both provide a mechanism to create an instance of a SYCL
[code]#kernel_bundle# from a [code]#cl_program#.

OpenCL C functions that are linked with, using either offline or online
compilation, must be declared as [code]#extern "C"# function declarations.
The function parameters of these function declarations must be defined as the
OpenCL C interoperability aliases; [code]#pointer# of the [code]#multi_ptr#
class template, and scalar data type aliases described in
<<table.types.aliases>>.

// \include{opencl_extensions}
// %%%%%%%%%%%%%%%%%%%%%%%%%%%% begin opencl_extensions %%%%%%%%%%%%%%%%%%%%%%%%%%%%

== SYCL support of non-core OpenCL features

In addition to the OpenCL core features, SYCL also provides support for OpenCL
extensions which provide features in OpenCL via khr extensions.

Some extensions are natively supported within the SYCL interface, however some
can only be used via the OpenCL interoperability interface.
The SYCL interface required for native extensions must be available.
However if the respective extension is not supported by the executing SYCL
[code]#device#, the <<sycl-runtime>> must throw an [code]#exception# with the
[code]#errc::feature_not_supported# or [code]#errc::kernel_not_supported# error
codes.

The OpenCL backend exposes some khr extensions to SYCL applications through the
[code]#sycl::aspect# enumerated type.
Therefore, applications can query for the existence of these khr extensions by
calling the [code]#device::has()# or [code]#platform::has()# member functions.

All OpenCL extensions are available through the OpenCL interoperability
interface, but some can also be used through core SYCL APIs.
<<table.extensionsupport>> shows which these are.
<<table.extensionsupport>> also shows the mapping from each OpenCL extension
name to its associated SYCL device [code]#aspect# when one is available.


[[table.extensionsupport]]
.SYCL support for OpenCL 1.2 extensions
[width="100%",options="header",cols="43%,37%,20%"]
|====
| SYCL Aspect              | OpenCL Extension                      | Core SYCL API
| [code]#aspect::atomic64# | [code]#cl_khr_int64_base_atomics#     | Yes
| [code]#aspect::atomic64# | [code]#cl_khr_int64_extended_atomics# | Yes
| [code]#aspect::fp16#     | [code]#cl_khr_fp16#                   | Yes
| -                        | [code]#cl_khr_3d_image_writes#        | Yes
| -                        | [code]#cl_khr_gl_sharing#             | No
| -                        | [code]#cl_apple_gl_sharing#           | No
| -                        | [code]#cl_khr_d3d10_sharing#          | No
| -                        | [code]#cl_khr_d3d11_sharing#          | No
| -                        | [code]#cl_khr_dx9_media_sharing#      | No
|====



[[sec:opencl:extension-fp16]]
=== Half precision floating-point

The half scalar data type: [code]#half# and the half vector data types:
[code]#half1#, [code]#half2#, [code]#half3#, [code]#half4#, [code]#half8# and
[code]#half16# must be available at compile-time.
However a kernel using these types is only supported on devices that have
[code]#aspect::fp16#, as described in <<sec:optional-kernel-features>>.

The conversion rules for half precision types follow the same rules as in the
OpenCL 1.2 extensions specification <<openclext12, par.
9.5.1>>.

The math functions for half precision types follow the same rules as in the
OpenCL 1.2 extensions specification <<opencl12, par.
9.5.2, 9.5.3, 9.5.4, 9.5.5>>.
The allowed error in ULP(Unit in the Last Place) is less than 8192,
corresponding to <<opencl12, Table 6.9 of the OpenCL 1.2 specification>>.


=== Writing to 3D image memory objects

The [code]#unsampled_image_accessor# class in SYCL supports member functions for
writing 3D image memory objects, but this functionality is only allowed on a
device if the extension [code]#cl_khr_3d_image_writes# is supported on that
<<device>>.

// TODO: Should opencl::aspect::3d_image_writes be promoted to a core SYCL aspect?


=== Interoperability with OpenGL

Interoperability between SYCL and OpenGL is not directly provided by the SYCL
interface, however can be achieved via the SYCL OpenCL interoperability
interface.


== Correspondence of some OpenCL features to SYCL

This section describes the correspondence between some OpenCL features and
features in the <<core-spec>> that provide similar functionality.
All content in this section is non-normative.

=== Work-item functions

The OpenCL 1.2 specification document <<opencl12, ch. 6.12.1 in Table 6.7>>
defines work-item functions that tell various information about the currently
executing work-item in an OpenCL kernel.
SYCL provides equivalent functionality through the item and group classes that
are defined in <<subsec:item.class>>, <<nditem-class>> and <<group-class>>.

=== Vector data load and store functions

The functionality from the OpenCL functions as defined in the OpenCL 1.2
specification document <<opencl12, par.
6.12.7>> is available in SYCL through the [code]#vec# class in
<<sec:vector.type>>.

=== Synchronization functions

In SYCL the OpenCL [keyword]#synchronization functions# are available through
the [code]#nd_item# class (<<nditem-class>>), as they are applied to work-items
for local or global address spaces.
Please see <<table.members.nditem>>.

=== [code]#printf# function

The functionality of the [code]#printf# function is covered by the
[code]#stream# class (<<subsec:stream>>), which has the capability to print to
standard output all of the SYCL classes and primitives, and covers the
capabilities defined in the OpenCL 1.2 specification document <<opencl12, par.
6.12.13>>.


== Precision of built-in math functions

When the SYCL built-in functions defined in sections <<sec:math-functions>>
through <<sec:relational-functions>> are called from a kernel running on the
OpenCL backend, their precision is the same as the corresponding OpenCL
functions as specified for the OpenCL profile.
See ch. 6.12.2 through ch. 6.12.6 of the OpenCL 1.2 specification for the
definition of these corresponding OpenCL functions.



// %%%%%%%%%%%%%%%%%%%%%%%%%%%% end opencl_extensions %%%%%%%%%%%%%%%%%%%%%%%%%%%%

// %%%%%%%%%%%%%%%%%%%%%%%%%%%% end opencl_backend %%%%%%%%%%%%%%%%%%%%%%%%%%%%
