// %%%%%%%%%%%%%%%%%%%%%%%%%%%% begin opencl_backend %%%%%%%%%%%%%%%%%%%%%%%%%%%%

[appendix]
[[chapter:opencl-backend]]
= OpenCL backend specification

This chapter describes how the SYCL general programming model is mapped on top
of OpenCL, and how the SYCL generic interoperability interface must be
implemented by vendors providing SYCL for OpenCL implementations to ensure SYCL
applications written for the OpenCL backend are interoperable.


[[sec:opencl:native-interop-application]]
== SYCL application interoperability native backend objects

For each <<sycl-runtime>> class which supports <<sycl-application>> interoperability,
specializations of [code]#backend_traits::input_type#
and [code]#backend_traits::return_type# must be defined as the
type of <<sycl-application>> interoperability <<native-backend-object>>
associated with [code]#SyclType# for the <<backend>>.

The types of the native backend objects for <<sycl-application>>
interoperability are described in <<table.opencl.interop>>.

[[sec:opencl:native-interop-kernel]]
== Kernel function interoperability native backend objects

For each <<sycl-runtime>> class which supports kernel function interoperability,
a specialization of [code]#backend_traits::return_type# must be defined as the type of kernel
function interoperability <<native-backend-object>> associated with [code]#SyclType#
for the <<backend>>.

The types of the native backend objects for kernel function interoperability are
described in <<table.opencl.kernelfunctioninterop.nativeobjects>>.

[[table.opencl.kernelfunctioninterop.nativeobjects]]
.Types of native backend objects kernel function interoperability
[width="100%",options="header",cols="60%,40%"]
|====
| [code]#SyclType#                                                   | [code]#backend_return_t<backend::opencl, SyclType>#
| [code]#accessor<T, Dims, Mode, target::device>#                    | [code]#__global T*#
| [code]#accessor<T, Dims, Mode, target::constant_buffer>#           | [code]#__constant T*#
| [code]#accessor<T, Dims, Mode, target::local>#                     | [code]#__local T*#
| [code]#local_accessor<T, Dims>#                                    | [code]#__local T*#
| [code]#sampled_image_accessor<T, 1, Mode, image_target::device>#   | [code]#sampler_1dimage_pair_t#
| [code]#sampled_image_accessor<T, 2, Mode, image_target::device>#   | [code]#sampler_2dimage_pair_t#
| [code]#sampled_image_accessor<T, 3, Mode, image_target::device>#   | [code]#sampler_3dimage_pair_t#
| [code]#unsampled_image_accessor<T, 1, Mode, image_target::device># | [code]#image1d_t#
| [code]#unsampled_image_accessor<T, 2, Mode, image_target::device># | [code]#image2d_t#
| [code]#unsampled_image_accessor<T, 3, Mode, image_target::device># | [code]#image3d_t#
| [code]#stream#                                                     | [code]#__global cl_char*#
| [code]#device_event#                                               | [code]#event_t#
|====

The [code]#sampler_1dimage_pair_t#, [code]#sampler_1dimage_pair_t# and
[code]#sampler_1dimage_pair_t# types must be implemented as described below.

[source,,linenums]
----
include::{header_dir}/openclBackend/samplerImagePair.h[lines=4..-1]
----

[[sec:opencl:native-interop-destruction]]
== Destruction of interop constructed objects with reference semantics

On destruction of the last copy of an instance of a SYCL class which is
specified to have reference semantics as described in
<<sec:reference-semantics>> that was constructed using one of the <<backend>>
interoperability [code]#make_*# functions specified in
<<sec:backend-interoperability-make>> additional lifetime related operations may
be performed which are required for the underlying <<native-backend-object>>.

The additional behavior performed by the OpenCL <<backend>> for each SYCL class
is described in <<table.opencl.interop.destructors>>.

[[table.opencl.interop.destructors]]
.Destructor behavior of interop constructed objects with reference semantics
[width="100%",options="header",cols="30%,70%"]
|====
| SYCL object     | Destructor behavior
| accessor        | No additional behavior is performed.
| buffer          | [code]#clReleaseMemObject# will be called on the native [code]#cl_mem# object provided during construction.
| context         | [code]#clReleaseContext# will be called on the native [code]#cl_context# object provided during construction.
| device          | [code]#clReleaseDevice# will be called on the native [code]#cl_device# object provided during construction.
| event           | [code]#clReleaseEvent# will be called on the native [code]#cl_event# object provided during construction.
| kernel          | [code]#clReleaseKernel# will be called on the native [code]#cl_kernel# objects provided during construction.
| kernel_bundle   | [code]#clReleaseProgram# will be called on the native [code]#cl_program# objects provided during construction.
| platform        | No additional behavior is performed.
| queue           | [code]#clReleaseCommandQueue# will be called on the native [code]#cl_command_queue# object provided during construction.
| sampled_image   | [code]#clReleaseMemObject# will be called on the native [code]#cl_mem# object provided during construction.
| unsampled_image | [code]#clReleaseMemObject# will be called on the native [code]#cl_mem# object provided during construction.
|====

// From 3.8 SYCL for OpenCL Framework
== SYCL for OpenCL framework

The SYCL framework allows applications to
use a host and one or more OpenCL devices as a single heterogeneous parallel
computer system. The framework contains the following components:

  * <<sycl-library>>: The template library provides a set of {cpp} templates
    and classes which provide the programming model to the user. It enables
    the creation of runtime classes such as SYCL queues, buffers and images,
    as well as access to some underlying OpenCL runtime object, such as
    contexts, platforms, devices and program objects.
  * <<sycl-runtime>>: The <<sycl-runtime>> interfaces with the
    underlying OpenCL implementations and handles scheduling of commands in
    queues, moving of data between host and devices, manages contexts,
    programs, kernel compilation and memory management.
  * [keyword]#OpenCL Implementation(s)#: The SYCL system assumes the
    existence of one or more OpenCL implementations available on the host
    machine.
  * SYCL <<device-compiler,device compilers>>: The SYCL <<device-compiler,device compilers>> compile
    SYCL {cpp} kernels into a format which can be executed on an OpenCL device
    at runtime. There may be more than one SYCL device compiler in a SYCL
    implementation. The format of the compiled SYCL kernels is not defined.
    A SYCL device compiler may, or may not, also compile the host parts of
    the program.

The OpenCL backend is enabled using the [code]#sycl::backend::opencl#
value of [code]#enum class backend#. That means that when the OpenCL
backend is active, the value of
[code]#sycl::is_backend_active<sycl::backend::opencl>::value# will be
[code]#true#.


== Mapping of SYCL programming model on top of OpenCL

The SYCL programming model was originally designed as a high-level model
for the OpenCL API, hence the mapping of SYCL on the OpenCL API is
mostly straightforward.

When the OpenCL backend is active on a SYCL application, all visible
OpenCL platforms are exported as SYCL platforms.

// From Architecture, Section 3.3
When a SYCL implementation executes kernels on an OpenCL
device, it achieves this by enqueuing OpenCL *commands* to
execute computations on the processing elements within a device.  The
processing elements within an OpenCL compute unit may execute a single
stream of instructions as ALUs within a SIMD unit (which execute in
lockstep with a single stream of instructions), as independent SPMD
units (where each PE maintains its own program counter) or as some
combination of the two.


// From Architecture, Section 3.3.1 (Platform mixed version support)
=== Platform mixed version support

The SYCL system presents the user with a set of devices, grouped into some
number of platforms.
The device version is an indication of the device's
capabilities, as represented by the device information returned by the
[code]#sycl::device::get_info()# member function.  Examples of attributes
associated with the device version are resource limits and information
about functionality beyond the requirements in the <<core-spec>>.
The version returned corresponds to the highest version of the OpenCL
specification for which the device is conformant, but is not higher than
the version of the device's platform which bounds the overall capabilities
of the runtime operating the device.


=== OpenCL memory model

The memory model for SYCL devices running on OpenCL platforms follows the
memory model of the OpenCL version they conform to.

In addition to <<global-memory>> , <<local-memory>> and <<private-memory>> memory,
the OpenCL backend permits the use of <<constant-memory>> space in SYCL:

  * <<constant-memory,Constant-memory>> is a region of memory that remains constant
    during the execution of a kernel. A pointer to the generic address space cannot
    represent an address to this memory region.

Work-items executing in a kernel have access to four distinct memory regions,
with the mapping between SYCL and OpenCL described in <<table.opencl.memory>>.

[[table.opencl.memory]]
.Mapping of SYCL memory regions into OpenCL memory regions
[width="40%",options="header",cols="50%,50%"]
|====
| SYCL     | OpenCL
| Global   | Global memory
| Constant | Constant memory
| Local    | Local memory
| Private  | Private memory
|====

=== OpenCL interface for buffer command accessors

The enumerator [code]#target::constant_buffer# is deprecated, but will remain a
part of the OpenCL backend as an extension. This enables SYCL kernel functions
to access the contents of a buffer through the OpenCL deviceâ€™s constant memory.

// From 3.4.1.1 OpenCL resources managed by SYCL Application
=== OpenCL resources managed by SYCL application

In OpenCL, a developer must create a <<context>> to be able to execute
commands on a device. Creating a context involves choosing a <<platform>>
and a list of <<device,devices>>. In SYCL, contexts, platforms and devices all
exist, but the user can choose whether to specify them or have the SYCL
implementation create them automatically.  The minimum required object for
submitting work to devices in SYCL is the <<queue>>, which contains
references to a platform, device and context internally.

The resources managed by SYCL are:

  . <<platform,Platforms>>: all features of OpenCL are implemented by platforms. A
    platform can be viewed as a given hardware vendor's runtime and the
    devices accessible through it. Some devices will only be accessible to
    one vendor's runtime and hence multiple platforms may be present. SYCL
    manages the different platforms for the user. In SYCL, a platform
    resource is accessible through a [code]#sycl::platform# object.
  . <<context,Contexts>>: any OpenCL resource that is acquired by the user is
    attached to a context. A context contains a collection of devices that
    the host can use and manages memory objects that can be shared between
    the devices. Data movement between devices within a context may be
    efficient and hidden by the underlying OpenCL runtime while data
    movement between contexts may involve the host. A given context can only
    wrap devices owned by a single platform. In SYCL, a context resource is
    accessible through a [code]#sycl::context# object.
  . <<device,Devices>>: platforms provide one or more devices for executing
    kernels. In SYCL, a device is accessible through a
    [code]#sycl::device# object.
  . <<kernel-bundle,Kernel bundles>>: OpenCL objects that store implementation
    data for the SYCL kernels. These objects are only required for advanced use
    in SYCL and are encapsulated in the [code]#sycl::kernel_bundle# class.
  . <<queue,Queues>>: SYCL kernels execute in command queues. The user must
    create a queue, which references an associated context, platform and
    device. The context, platform and device may be chosen automatically, or
    specified by the user. In SYCL, command queues are accessible through
    [code]#sycl::queue# objects.

// Removed from OpenCL Spec document
// In OpenCL, queues can operate using in-order execution or out-of-order
// execution. In SYCL, the implementation must provide out-of-order
// execution ordering when possible, regardless of whether the underlying
// OpenCL queue is in-order or out-of-order.


[[sec:opencl:interfacing-with-opencl]]
== Interoperability with the OpenCL API

// Original sections from 1.2.1
// From Architecture, 3.1;
//
// To ensure maximum backward-compatibility, a software developer can produce
// a program that mixes standard OpenCL C kernels and OpenCL API code with
// SYCL code and expect fully compatible interoperability.

The OpenCL backend for SYCL ensures maximum compatibility between SYCL
and OpenCL kernels and API. This includes supporting devices with
different capabilities and support for different versions of the
OpenCL C language, in addition to supporting SYCL kernels written in {cpp}.

// Original from 3.6.11, Interfacing with OpenCL
// https://cvs.khronos.org/bugzilla/show_bug.cgi?id=10426

<<sycl-runtime>> classes which encapsulate an OpenCL opaque type such as
SYCL [code]#context# or SYCL [code]#queue# must provide an
interoperability constructor taking an instance of the OpenCL opaque type.
When the OpenCL object supports reference counting, these constructors must
retain that instance to increase the reference count of the OpenCL resource.
Likewise, the destructor for the <<sycl-runtime>> classes which encapsulate a
reference counted OpenCL opaque type must release that instance to decrease the
reference count of the OpenCL resource.  Since the OpenCL [code]#platform_id#
is not reference counted, the encapsulating SYCL [code]#platform# class neither
retains nor releases this OpenCL resource.

Note that an instance of a <<sycl-runtime>> class which encapsulates an
OpenCL opaque type can encapsulate any number of instances of the OpenCL
type, unless it was constructed via the interoperability constructor, in
which case it can encapsulate only a single instance of the OpenCL type.

The lifetime of a <<sycl-runtime>> class that encapsulates an OpenCL
opaque type and the instance of that opaque type retrieved via the
[code]#get_native()# free function are not tied in either direction given
correct usage of OpenCL reference counting. For example if a user were to
retrieve a [code]#cl_command_queue# instance from a SYCL
[code]#queue# instance and then immediately destroy the SYCL
[code]#queue# instance, the [code]#cl_command_queue# instance is
still valid. Or if a user were to construct a SYCL [code]#queue#
instance from a [code]#cl_command_queue# instance and then immediately
release the [code]#cl_command_queue# instance, the SYCL
[code]#queue# instance is still valid.

Note that a <<sycl-runtime>> class that encapsulates an OpenCL opaque type
is not responsible for any incorrect use of OpenCL reference counting
outside of the <<sycl-runtime>>. For example if a user were to retrieve a
[code]#cl_command_queue# instance from a SYCL [code]#queue#
instance and then release the [code]#cl_command_queue# instance more
than once without any prior retain then the SYCL [code]#queue# instance
that the [code]#cl_command_queue# instance was retrieved from is now
undefined.

Note that an instance of the SYCL [code]#buffer# or SYCL
[code]#image# class templates constructed via the interoperability
constructor is free to copy from the [code]#cl_mem# into another memory
allocation within the <<sycl-runtime>> to achieve normal SYCL semantics,
for as long as the SYCL [code]#buffer# or SYCL [code]#image#
instance is alive.

<<table.opencl.interop>> relates SYCL objects
to their OpenCL native type in the SYCL application.

[[table.opencl.interop]]
.List of native types per SYCL object in the OpenCL backend
[width="100%",options="header",separator="@",cols="15%,15%,15%,55%"]
|====
@ [code]#SyclType#
   @ [code]#backend_input_t<backend::opencl, SyclType>#
   @ [code]#backend_return_t<backend::opencl, SyclType>#
   @ Description
a@
[source]
----
platform
----
   a@ [code]#cl_platform_id#
   a@ [code]#cl_platform_id#
   a@ A SYCL platform object encapsulates an OpenCL platform ID.
a@
[source]
----
device
----
   a@ [code]#cl_device_id#
   a@ [code]#cl_device_id#
   a@ A SYCL device object encapsulates an OpenCL device ID.
a@
[source]
----
context
----
   a@ [code]#cl_context#
   a@ [code]#cl_context#
   a@ A SYCL context object encapsulates an OpenCL context object.
a@
[source]
----
queue
----
   a@ [code]#cl_command_queue#
   a@ [code]#cl_command_queue#
   a@ A SYCL queue object encapsulates an OpenCL queue object.
a@
[source]
----
kernel
----
   a@ [code]#cl_kernel#
   a@ [code]#cl_kernel#
   a@ A SYCL kernel object encapsulates an OpenCL kernel object.
a@
[source]
----
template <bundle_state State>
kernel_bundle<State>
----
   a@ [code]#cl_program#
   a@ [code]#std::vector<cl_program>#
   a@ A SYCL kernel bundle can encapsulate one or more OpenCL program objects.
      It can also encapsulate one or more OpenCL kernel objects
      which can be retrieved using the appropriate [code]#kernel# object.
a@
[source]
----
event
----
   a@ [code]#std::vector<cl_event>#
   a@ [code]#std::vector<cl_event>#
   a@ // Original from 3.6.5.1 Synchronization in the SYCL application

A SYCL event can encapsulate one or multiple OpenCL events,
representing a number of dependencies in the same or different contexts,
that must be satisfied for the SYCL event to be complete.
a@
[source]
----
buffer
----
   a@ [code]#cl_mem#
   a@ [code]#std::vector<cl_mem>#
   a@ SYCL buffers containing OpenCL memory objects
      can handle multiple [code]#cl_mem# objects in the same or different context.
      The interoperability interface will return a list of active buffers in the SYCL runtime.
a@
[source]
----
sampled_image
----
   a@ [code]#cl_mem#
   a@ [code]#std::vector<cl_mem>#
   a@ SYCL sampled images containing OpenCL image objects
      can handle multiple underlying [code]#cl_mem# objects
      at the same time in the same or different OpenCL contexts.
      The interoperability interface will return a list of active images in the SYCL runtime.
a@
[source]
----
unsampled_image
----
   a@ [code]#cl_mem#
   a@ [code]#std::vector<cl_mem>#
   a@ SYCL unsampled images containing OpenCL image objects
      can handle multiple underlying [code]#cl_mem# objects
      at the same time in the same or different OpenCL contexts.
      The interoperability interface will return a list of active images in the SYCL runtime.
|====

Inside the SYCL kernel, the SYCL API offers interoperability with OpenCL device types.
<<table.opencl.kerneltypes>> describes the mapping of kernel types.

[[table.opencl.kerneltypes]]
.List of native types per SYCL object on kernel code
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ SYCL kernel native types in OpenCL @ Description
a@
[source]
----
multi_ptr::get_decorated()
----
   a@ Returns a pointer in the OpenCL address space
      corresponding to the type of multi pointer object
|====

// \section{SYCL Programming interface}
// From 3.6 SYCL programming model (eliminated)
// SYCL programs are explicitly parallel and expose the full heterogeneous
// parallelism of the underlying machine model of OpenCL. This includes exposing
// the data-parallelism, multiple execution devices and multiple memory storage
// spaces of OpenCL. However, SYCL adds on top of OpenCL a higher level of
// abstraction allowing developers to hide much of the complexity from the source
// code, when a developer so chooses.


// From 3.7 memory object
When a buffer or image is allocated on more than
one OpenCL device, if these devices are on separate contexts then multiple
[code]#cl_mem# objects may be allocated for the memory object, depending on
whether the object has actively been used on these devices yet or not.


// From 3.10 Language restrictions in kernels

Some types in SYCL vary according to pointer size or vary on the host
according to the host ABI, such as [code]#size_t# or [code]#long#. In order
for the SYCL device compiler to ensure that the sizes of
these types match the sizes on the host and to enable data of these types
to be shared between host and device, the OpenCL interoperability types
are defined, [code]#sycl::cl_int# and [code]#sycl::cl_size_t#.

The OpenCL C function qualifier [code]#+__kernel+# and the access
qualifiers: [code]#+__read_only+#, [code]#+__write_only+# and [code]#+__read_write+#
are not exposed in SYCL via keywords, but are instead encapsulated in
SYCL's parameter passing system inside accessors. Users wishing to
achieve the OpenCL equivalent of these qualifiers in SYCL should
instead use SYCL accessors with equivalent semantics.

// From 3.10.1 SYCL Linker
Any OpenCL C function included in a pre-built OpenCL library can be
defined as an [code]#extern "C"# function and the OpenCL program
has to be linked against any SYCL program that contains kernels using
the external function. In this case, the data types used have to comply with
the interoperability aliases defined in <<table.types.aliases>>.


== Programming interface

The following section describes the OpenCL-specific API.

=== Construct SYCL objects from OpenCL ones

The OpenCL backend provides the following specializations of the
[code]#make_{sycl_class}# template functions which are defined in
<<sec:backend-interoperability-make>>.  These functions are in the
[code]#sycl# namespace.

[width="100%",options="header",separator="@",cols="40%,60%"]
|====
@ OpenCL interoperability function @ Description
a@
[source]
----
context make_context(
    const cl_context &clContext,
    const async_handler &asyncHandler = {})
----
   a@ Constructs a SYCL [code]#context# instance from an OpenCL [code]#cl_context# in accordance with the requirements described in <<sec:backend-interoperability>>.
a@
[source]
----
event make_event(const cl_event &clEvent,
    const context &syclContext)
----
   a@ Constructs a SYCL [code]#event# instance from an OpenCL [code]#cl_event# in accordance with the requirements described in <<sec:backend-interoperability>>.
a@
[source]
----
device make_device(
    const cl_device_id &clDeviceId)
----
   a@ Constructs a SYCL [code]#device# instance from an OpenCL [code]#cl_device_id# in accordance with the requirements described in <<sec:backend-interoperability>>.
a@
[source]
----
platform make_platform(
    const cl_platform_id &clPlatformId)
----
   a@ Constructs a SYCL [code]#platform# instance from an OpenCL [code]#cl_platform_id# in accordance with the requirements described in <<sec:backend-interoperability>>.
a@
[source]
----
queue make_queue(
    const cl_command_queue &clQueue,
    const context &syclContext,
    const async_handler &asyncHandler = {})
----
   a@ Constructs a SYCL [code]#queue# instance with an optional
      [code]#async_handler# from an OpenCL [code]#cl_command_queue#
      in accordance with the requirements described
      in <<sec:backend-interoperability>>.
a@
[source]
----
template <typename T, int Dimensions = 1,
          typename AllocatorT = buffer_allocator<std::remove_const_t<T>>>
buffer<T, Dimensions, AllocatorT> make_buffer(
    const cl_mem &clMemObject,
    const context &syclContext,
    event availableEvent)
----
   a@ Available only when: [code]#Dimensions == 1#.

Constructs a SYCL [code]#buffer# instance from an OpenCL [code]#cl_mem# in accordance with the requirements described in <<sec:backend-interoperability>>.
The instance of the SYCL [code]#buffer# class template being constructed must wait for the SYCL [code]#event# parameter, [code]#availableEvent# to signal that the [code]#cl_mem# instance is ready to be used.
The SYCL [code]#context# parameter [code]#syclContext# is the context associated with the memory object.

a@
[source]
----
template <typename T, int Dimensions = 1,
          typename AllocatorT = buffer_allocator<std::remove_const_t<T>>>
buffer<T, Dimensions, AllocatorT> make_buffer(
    const cl_mem &clMemObject,
    const context &syclContext)
----
   a@ Available only when: [code]#Dimensions == 1#.

Constructs a SYCL [code]#buffer# instance from an OpenCL [code]#cl_mem# in accordance with the requirements described in <<sec:backend-interoperability>>.

a@
[source]
----
template <int Dimensions = 1,
          typename AllocatorT = image_allocator>
sampled_image<Dimensions, AllocatorT> make_sampled_image(
    const cl_mem &clMemObject,
    const context &syclContext,
    image_sampler syclImageSampler,
    event availableEvent)
----
   a@ Constructs a SYCL [code]#sampled_image# instance from an OpenCL [code]#cl_mem# in accordance with the requirements described in <<sec:backend-interoperability>>.
      The instance of the SYCL [code]#image# class template being constructed must wait for the SYCL [code]#event# parameter, [code]#availableEvent# to signal that the [code]#cl_mem# instance is ready to be used.
      The SYCL [code]#context# parameter [code]#syclContext# is the context associated with the memory object. 

a@
[source]
----
template <int Dimensions = 1,
          typename AllocatorT = image_allocator>
sampled_image<Dimensions, AllocatorT> make_sampled_image(
    const cl_mem &clMemObject,
    const context &syclContext,
    image_sampler syclImageSampler)
----
   a@ Constructs a SYCL [code]#sampled_image# instance from an OpenCL [code]#cl_mem# in accordance with the requirements described in <<sec:backend-interoperability>>.
      The SYCL [code]#context# parameter [code]#syclContext# is the context associated with the memory object.

a@
[source]
----
template <int Dimensions = 1,
          typename AllocatorT = image_allocator>
unsampled_image<Dimensions, AllocatorT> make_unsampled_image(
    const cl_mem &clMemObject,
    const context &syclContext,
    event availableEvent)
----
   a@ Constructs a SYCL [code]#unsampled_image# instance from an OpenCL [code]#cl_mem# in accordance with the requirements described in <<sec:backend-interoperability>>.
      The instance of the SYCL [code]#image# class template being constructed must wait for the SYCL [code]#event# parameter, [code]#availableEvent# to signal that the [code]#cl_mem# instance is ready to be used.
      The SYCL [code]#context# parameter [code]#syclContext# is the context associated with the memory object.

a@
[source]
----
template <int Dimensions = 1,
          typename AllocatorT = image_allocator>
unsampled_image<Dimensions, AllocatorT> make_unsampled_image(
    const cl_mem &clMemObject,
    const context &syclContext)
----
   a@ Constructs a SYCL [code]#unsampled_image# instance from an OpenCL [code]#cl_mem# in accordance with the requirements described in <<sec:backend-interoperability>>.
a@
[source]
----
kernel make_kernel(const cl_kernel &clKernel,
                   const context &syclContext);
----
   a@ Constructs a SYCL [code]#kernel# instance from an OpenCL kernel object.
a@
[source]
----
template <bundle_state State>
kernel_bundle<State> make_kernel_bundle(
    const cl_program &clProgram,
    const context& syclContext)
----
   a@ Constructs a SYCL [code]#kernel_bundle# instance from an OpenCL
      [code]#cl_program# for the devices in [code]#syclContext#
      in accordance with the requirements described in <<sec:backend-interoperability>>.
      The SYCL [code]#context# must represent the same underlying OpenCL
      context associated with the OpenCL program object.

The [code]#state# specifies the expected [code]#kernel_bundle# state.
      The mapping between the [code]#kernel_bundle# state
      and OpenCL program state ([code]#CL_PROGRAM_BINARY_TYPE#) is as follows:

      * [code]#bundle_state::input# - [code]#CL_PROGRAM_BINARY_TYPE_NONE#
      * [code]#bundle_state::object# -
         [code]#CL_PROGRAM_BINARY_TYPE_COMPILED_OBJECT# or
         [code]#CL_PROGRAM_BINARY_TYPE_INTERMEDIATE# or
         [code]#CL_PROGRAM_BINARY_TYPE_LIBRARY#.
      * [code]#bundle_state::executable# - [code]#CL_PROGRAM_BINARY_TYPE_EXECUTABLE#

If the internal state of the OpenCL program doesn't match [code]#state#,
      the kernel bundle will be compiled and linked as necessary.
      If the OpenCL program is already an executable binary,
      but the specified [code]#state# is not [code]#bundle_state::executable#,
      an [code]#exception# with the [code]#errc::invalid# error code is thrown.
      If the specified [code]#state# is [code]#bundle_state::input#,
      but the OpenCL program already has a binary associated with it,
      an [code]#exception# with the [code]#errc::invalid# error code is thrown.

Throws an [code]#exception# with the [code]#errc::invalid# error code
   if any error is produced by the <<backend>>.
|====


=== Extension query

Platforms and devices with an OpenCL backend may support extensions.
For convenience, the extensions supported by a platform or device can be queried
through the following functions provided in the [code]#sycl::opencl# namespace.

[width="100%",options="header",separator="@",cols="35%,65%"]
|====
@ Extension query @ Description
a@
[source]
----
bool has_extension(
    const sycl::platform &syclPlatform,
    const std::string &extension)
----
   a@ Returns true if the OpenCL platform associated with [code]#syclPlatform#
   supports the extension identified by [code]#extension#, otherwise it returns
   false. If [code]#syclPlatform.get_backend() != sycl::backend::opencl# an
   [code]#exception# with the [code]#errc::backend_mismatch# error code is
   thrown.
a@
[source]
----
bool has_extension(
    const sycl::device &syclDevice,
    const std::string &extension)
----
   a@ Returns true if the OpenCL device associated with [code]#syclDevice#
   supports the extension identified by [code]#extension#, otherwise it returns
   false. If [code]#syclDevice.get_backend() != sycl::backend::opencl# an
   [code]#exception# with the [code]#errc::backend_mismatch# error code is
   thrown.
|====

=== Reference counting

Most OpenCL objects are reference counted. The SYCL general programming model
doesn't require that native objects are reference counted. However, for
convenience, the following function is provided in the
[code]#sycl::opencl# namespace.

[width="100%",options="header",separator="@",cols="35%,65%"]
|====
@ Reference counting @ Description
a@
[source]
----
template <typename openCLT>
    cl_uint get_reference_count(openCLT obj)
----
   a@ Returns the reference count of the given object
|====


=== Errors and limitations

If there is an OpenCL error associated with an exception triggered, then the
OpenCL error code can be obtained by the free function [code]#cl_int sycl::opencl::get_error_code(sycl::exception&)#. In the case where there is
no OpenCL error associated with the exception triggered, the OpenCL error
code will be [code]#CL_SUCCESS#.


// TODO: Errors and limitations
// The only exception to
// this rule is when a buffer is constructed from a [code]#cl_mem#
// object to interoperate with OpenCL. Use of an interoperability
// buffer on a queue mapping to a context other than that in which the
// [code]#cl_mem# was created is an error.

// Since data management and storage is handled by the <<sycl-runtime>>, the
// [code]#event# class is used for providing the appropriate interface for
// OpenCL/SYCL interoperability. In the case where SYCL objects contain
// OpenCL memory objects created outside of the SYCL mechanism, then events
// can be used to provide the <<sycl-runtime>> with the initial events that it has
// to synchronize against. However, the events mechanism does not provide
// full interoperability with OpenCL during SYCL code execution.
// Interoperability is achieved by using the synchronization rules with the
// [code]#buffer# and [code]#image# classes.


[[sec:opencl:interop-kernel-bundle]]
=== Interoperability with kernel bundles

In <<opencl12, OpenCL>> any kernel function that is enqueued over an nd-range
is represented by a [code]#cl_kernel# and must be compiled and linked via a
[code]#cl_program# using [code]#clBuildProgram#,
[code]#clCompileProgram# and [code]#clLinkProgram#.

For OpenCL <<backend>> this detail is abstracted away by <<kernel bundle,kernel bundles>> and
a [code]#kernel_bundle# object containing all <<sycl-kernel-function,SYCL kernel functions>>
is retrieved by calling the free function [code]#get_kernel_bundle#.

The OpenCL <<backend>> specification provides additional free functions
which provide convenience functions for constructing kernel bundles
from OpenCL specific objects.

[source,,linenums]
----
include::{header_dir}/openclBackend/createBundle.h[lines=4..-1]
----

[source,,linenums]
----
template <bundle_state State>
kernel_bundle<State> create_bundle(const context &ctxt,
                                   const std::vector<device> &devs,
                                   const std::vector<cl_program> &clPrograms)
----
  . _Preconditions:_ The <<context>> specified by [code]#ctxt#
    must be associated with the OpenCL <<backend>>.
    All devices in [code]#devs# must be associated with [code]#ctxt#.
    All OpenCL programs in [code]#clPrograms# must be associated with [code]#ctxt#.
+
--
_Effects:_ Constructs a <<kernel-bundle>> in the specified [code]#bundle_state#
from the provided list of OpenCL programs and associated with the
<<context>> specified by [code]#syclContext# by invoking the necessary OpenCL APIs.
Follows the same rules as calling [code]#make_kernel_bundle# on a single OpenCL program,
except that the rules apply to all OpenCL programs in [code]#clPrograms#.
Multiple programs will be linked together into a single one
if required by the requested [code]#State#.
The constructed [code]#kernel_bundle# will retain all provided OpenCL programs
and will also release them on destruction.

_Throws:_ An [code]#exception# with the [code]#errc::build# error code if any error is produced
by invoking the OpenCL APIs.
--

[source,,linenums]
----
kernel_bundle<bundle_state::executable>
create_bundle(const context &ctxt, const std::vector<device> &devs,
              const std::vector<cl_kernel> &clKernels)
----
  . _Preconditions:_ The <<context>> specified by [code]#ctxt#
    must be associated with the OpenCL <<backend>>.
    All devices in [code]#devs# must be associated with [code]#ctxt#.
    All OpenCL kernels in [code]#clKernels# must be associated with [code]#ctxt#.
+
--
_Effects:_ Constructs an executable <<kernel-bundle>>
from the provided list of OpenCL kernels and associated with the
<<context>> specified by [code]#syclContext# by invoking the necessary OpenCL APIs.
[code]#cl_kernel# objects might be associated with different [code]#cl_program# objects,
the kernel bundle will encapsulate all of them.

_Throws:_ An [code]#exception# with the [code]#errc::build# error code if any error is produced
by invoking the OpenCL APIs.
--


=== Interoperability with kernels

A [code]#kernel_bundle# object contains one or multiple OpenCL programs
and one or multiple OpenCL kernels.
Calling [code]#kernel_bundle::get_kernel# returns a [code]#kernel# object
 which can be invoked by any of
<<kernel-invocation-command,kernel invocation commands>> such as [code]#parallel_for# which take
a [code]#kernel# but not <<sycl-kernel-function>>.

Calling [code]#make_kernel# must trigger a call to [code]#clRetainKernel#
and the resulting [code]#kernel# object must call
[code]#clReleaseKernel# on destruction.

It is also possible to construct a <<kernel-bundle>> from previously created OpenCL
[code]#cl_kernel# objects by calling the free function [code]#create_bundle#
as described in <<sec:opencl:interop-kernel-bundle>>.

The kernel arguments for the OpenCL C kernel kernel can either be set prior to
creating the [code]#kernel# object or by calling [code]#set_arg# or [code]#set_args#
member functions of the [code]#handler# class.

If kernel arguments are set prior to creating the [code]#kernel# object the
<<sycl-runtime>> is not responsible for managing the data of these arguments.


[[sec:opencl:kernel-conventions-sycl]]
=== OpenCL kernel conventions and SYCL

OpenCL and SYCL use opposite conventions for the unit stride dimension. SYCL
aligns with {cpp} conventions, which is important to understand from a
performance perspective when porting code to SYCL. The unit stride
dimension, at least for data, is implicit in the linearization equations in
SYCL (<<sec:multi-dim-linearization>>) and OpenCL. SYCL aligns with
{cpp} array subscript ordering [code]#arr[a][b][c]#, in that range
constructor dimension ordering used to launch a kernel (e.g.
[code]#range<3> R{a,b,c}#) and range and ID queries within a kernel,
are ordered in the same way as the {cpp} multi-dimensional subscript operators
(unit stride on the right).

When specifying a [code]#range# as the global or local size
in a [code]#parallel_for# that invokes an OpenCL interop kernel (through
[code]#cl_kernel# interop),
the highest dimension of the range in SYCL will map to the
lowest dimension within the OpenCL kernel.  That statement applies to both
an underlying enqueue operation such as [code]#clEnqueueNDRangeKernel#
in OpenCL, and also ID and size queries within the OpenCL kernel.
For example, a 3D global range specified in SYCL as:

[source]
----
range<3> R{r0,r1,r2};
----

maps to an [code]#clEnqueueNDRangeKernel# [code]#global_work_size# argument
of:

[source]
----
size_t cl_interop_range[3] = {r2,r1,r0};
----

Likewise, a 2D global range specified in SYCL as:

[source]
----
range<2> R{r0,r1};
----

maps to an [code]#clEnqueueNDRangeKernel# [code]#global_work_size# argument
of:

[source]
----
size_t cl_interop_range[2] = {r1,r0};
----

The mapping of highest dimension in SYCL to lowest dimension in OpenCL applies to all
operations where a multi-dimensional construct must be mapped, such as when mapping SYCL
explicit memory operations to OpenCL APIs like [code]#clEnqueueCopyBufferRect#.

Work-item and work-group ID and range queries have the same reversed
convention for unit stride dimension between SYCL and OpenCL. For example,
with three, two, or one dimensional SYCL global ranges, OpenCL and SYCL
kernel code queries relate to the range as shown in
<<table.syclOpenCL.mapping>>. The "SYCL kernel query" column
applies for SYCL-defined kernels, and the "OpenCL kernel query" column
applies for kernels defined through OpenCL interop.

// Jon: Need to code-format most of these cells and use gray backgrounds on
// column-spanning sub-titles.

[[table.syclOpenCL.mapping]]
.Example range mapping from SYCL enqueued three dimensional global [code]#range# to OpenCL and SYCL queries
[width="100%",options="header",cols="60%,20%,20%"]
|====
| SYCL kernel query | OpenCL kernel query | Returned Value

3+|With enqueued 3D SYCL global [code]#range# of [code]#range<3> R{r0,r1,r2}#
| nd_item::get_global_range(0) / item::get_range(0)
    | get_global_size(2)
    | [code]#r0#
| nd_item::get_global_range(1) / item::get_range(1)
    | get_global_size(1)
    | [code]#r1#
| nd_item::get_global_range(2) / item::get_range(2)
    | get_global_size(0)
    | [code]#r2#
| nd_item::get_global_id(0) / item::get_id(0)
    | get_global_id(2)
    | Value in range 0..([code]#r0-1)}#
| nd_item::get_global_id(1) / item::get_id(1)
    | get_global_id(1)
    | Value in range 0..([code]#r1-1)}#
| nd_item::get_global_id(2) / item::get_id(2)
    | get_global_id(0)
    | Value in range 0..([code]#r2-1)}#

3+|With enqueued 2D SYCL global [code]#range# of [code]#range<2> R{r0,r1}#
| nd_item::get_global_range(0) / item::get_range(0)
    | get_global_size(1)
    | [code]#r0#
| nd_item::get_global_range(1) / item::get_range(1)
    | get_global_size(0)
    | [code]#r1#
| nd_item::get_global_id(0) / item::get_id(0)
    | get_global_id(1)
    | Value in range 0..([code]#r0-1)}#
| nd_item::get_global_id(1) / item::get_id(1)
    | get_global_id(0)
    | Value in range 0..([code]#r1-1)}#

3+|With enqueued 1D SYCL global [code]#range# of [code]#range<1> R{r0}#
| nd_item::get_global_range(0) / item::get_range(0)
    | get_global_size(0)
    | [code]#r0#
| nd_item::get_global_id(0) / item::get_id(0)
    | get_global_id(0)
    | Value in range 0..([code]#r0-1)}#

|====


=== Data types

The OpenCL C language standard <<opencl12, Section 6.11>> defines its own built-in
scalar data types, and these have additional requirements in terms of size and
signedness on top of what is guaranteed by ISO {cpp}. For the purpose of
interoperability and portability, SYCL defines a set of aliases to {cpp} types
within the [code]#sycl::opencl# namespace using the [code]#cl_#
prefix. These aliases are described in <<table.types.aliases>>


[[table.types.aliases]]
.Scalar data type aliases supported by SYCL OpenCL backend
[width="100%",options="header",separator="@",cols="25%,75%"]
|====
@ Scalar data type alias @ Description
a@
[source]
----
cl_bool
----
   a@ Alias to a conditional data type which can be either true or false. The value
      true expands to the integer constant 1 and the value false expands to the
      integer constant 0.

a@
[source]
----
cl_char
----
   a@ Alias to a signed 8-bit integer, as defined by the {cpp} core language.

a@
[source]
----
cl_uchar
----
   a@ Alias to an unsigned 8-bit integer, as defined by the {cpp} core language.

a@
[source]
----
cl_short
----
   a@ Alias to a signed 16-bit integer, as defined by the {cpp} core language.

a@
[source]
----
cl_ushort
----
   a@ Alias to an unsigned 16-bit integer, as defined by the {cpp} core language.

a@
[source]
----
cl_int
----
   a@ Alias to a signed 32-bit integer, as defined by the {cpp} core language.

a@
[source]
----
cl_uint
----
   a@ Alias to an unsigned 32-bit integer, as defined by the {cpp} core language.

a@
[source]
----
cl_long
----
   a@ Alias to a signed 64-bit integer, as defined by the {cpp} core language.

a@
[source]
----
cl_ulong
----
   a@ Alias to an unsigned 64-bit integer, as defined by the {cpp} core language.

a@
[source]
----
cl_float
----
   a@ Alias to a 32-bit floating-point. The float data type must conform to the IEEE
      754 single precision storage format.

a@
[source]
----
cl_double
----
   a@ Alias to a 64-bit floating-point. The double data type must conform to the IEEE
      754 double precision storage format.

a@
[source]
----
cl_half
----
   a@ Alias to a 16-bit floating-point. The half data type must conform to
      the IEEE 754-2008 half precision storage format. Kernels using this type
      are only supported on devices that have [code]#aspect::fp16#, as described
      in <<sec:optional-kernel-features>>.

|====



== Preprocessor directives and macros

  * [code]#SYCL_BACKEND_OPENCL# substitutes to [code]#1# if the OpenCL <<backend>>
    is active while building the SYCL application.


=== Offline linking with OpenCL C libraries

SYCL supports linking <<sycl-kernel-function,SYCL kernel functions>> with OpenCL C libraries
during offline compilation or during online compilation by the
<<sycl-runtime>> within a SYCL application.

Linking with OpenCL C kernel functions offline is an optional feature
and is unspecified. Linking with OpenCL C kernel functions online is
performed by using the SYCL [code]#kernel_bundle# class to compile and
link an OpenCL C source; using the [code]#compile_with_source# or
[code]#build_with_source# member functions.

OpenCL C functions that are linked with, using either offline or online
compilation, must be declared as [code]#extern "C"# function
declarations. The function parameters of these function declarations must be
defined as the OpenCL C interoperability aliases; [code]#pointer# of
the [code]#multi_ptr# class template, [code]#vector_t# of the
[code]#vec# class template and scalar data type aliases described in
<<table.types.aliases>>.

// \include{opencl_extensions}
// %%%%%%%%%%%%%%%%%%%%%%%%%%%% begin opencl_extensions %%%%%%%%%%%%%%%%%%%%%%%%%%%%

== SYCL support of non-core OpenCL features

In addition to the OpenCL core features, SYCL also provides support for OpenCL
extensions which provide features in OpenCL via khr extensions.

Some extensions are natively supported within the SYCL interface, however some
can only be used via the OpenCL interoperability interface. The SYCL interface
required for native extensions must be available. However if the respective
extension is not supported by the executing SYCL [code]#device#, the
<<sycl-runtime>> must throw an [code]#exception# with the
[code]#errc::feature_not_supported# or [code]#errc::kernel_not_supported# error
codes.

The OpenCL backend exposes some khr extensions to SYCL applications through the
[code]#sycl::aspect# enumerated type.  Therefore, applications can query
for the existence of these khr extensions by calling the [code]#device::has()#
or [code]#platform::has()# member functions.

All OpenCL extensions are available through the OpenCL interoperability
interface, but some can also be used through core SYCL APIs.
<<table.extensionsupport>> shows which these are.
<<table.extensionsupport>> also shows the mapping from each OpenCL
extension name to its associated SYCL device [code]#aspect# when one is
available.


[[table.extensionsupport]]
.SYCL support for OpenCL 1.2 extensions
[width="100%",options="header",cols="43%,37%,20%"]
|====
| SYCL Aspect              | OpenCL Extension                      | Core SYCL API
| [code]#aspect::atomic64# | [code]#cl_khr_int64_base_atomics#     | Yes
| [code]#aspect::atomic64# | [code]#cl_khr_int64_extended_atomics# | Yes
| [code]#aspect::fp16#     | [code]#cl_khr_fp16#                   | Yes
| -                        | [code]#cl_khr_3d_image_writes#        | Yes
| -                        | [code]#cl_khr_gl_sharing#             | No
| -                        | [code]#cl_apple_gl_sharing#           | No
| -                        | [code]#cl_khr_d3d10_sharing#          | No
| -                        | [code]#cl_khr_d3d11_sharing#          | No
| -                        | [code]#cl_khr_dx9_media_sharing#      | No
|====



[[sec:opencl:extension-fp16]]
=== Half precision floating-point

The half scalar data type: [code]#half# and the half vector data types:
[code]#half1#, [code]#half2#, [code]#half3#,
[code]#half4#, [code]#half8# and [code]#half16# must be
available at compile-time. However a kernel using these types is only
supported on devices that have [code]#aspect::fp16#, as described in
<<sec:optional-kernel-features>>.

The conversion rules for half precision types follow the same rules as in
the OpenCL 1.2 extensions specification <<openclext12, par. 9.5.1>>.

The math functions for half precision types follow the same rules as in the
OpenCL 1.2 extensions specification <<opencl12,  par. 9.5.2, 9.5.3, 9.5.4,
9.5.5>>. The allowed error in ULP(Unit in the Last Place) is
less than 8192, corresponding to <<opencl12, Table 6.9 of the OpenCL 1.2 specification>>.


=== Writing to 3D image memory objects

The [code]#unsampled_image_accessor# class
in SYCL supports member functions for writing
3D image memory objects, but this functionality is only allowed on a device
if the extension [code]#cl_khr_3d_image_writes# is
supported on that <<device>>.

// TODO: Should opencl::aspect::3d_image_writes be promoted to a core SYCL aspect?


=== Interoperability with OpenGL

Interoperability between SYCL and OpenGL is not directly provided by the SYCL interface,
however can be achieved via the SYCL OpenCL interoperability interface.


== Correspondence of some OpenCL features to SYCL

This section describes the correspondence between some OpenCL features and
features in the <<core-spec>> that provide similar functionality.  All content
in this section is non-normative.

=== Work-item functions

The OpenCL 1.2 specification document <<opencl12, ch. 6.12.1 in Table 6.7>>
defines work-item functions that tell various information about the currently
executing work item in an OpenCL kernel.  SYCL provides equivalent
functionality through the item and group classes that are defined in
<<subsec:item.class>>, <<nditem-class>> and <<group-class>>.

=== Vector data load and store functions

The functionality from the OpenCL functions as defined in the OpenCL 1.2
specification document <<opencl12, par. 6.12.7>> is available in SYCL through
the [code]#vec# class in <<sec:vector.type>>.

=== Synchronization functions

In SYCL the OpenCL [keyword]#synchronization functions# are available through
the [code]#nd_item# class (<<nditem-class>>), as they are applied to
work-items for local or global address spaces. Please
see <<table.members.nditem>>.

=== [code]#printf# function

The functionality of the [code]#printf# function is covered by the
[code]#stream# class (<<subsec:stream>>), which has the
capability to print to standard output all of the SYCL classes and primitives,
and covers the capabilities defined in the OpenCL 1.2 specification
document <<opencl12, par. 6.12.13>>.

// %%%%%%%%%%%%%%%%%%%%%%%%%%%% end opencl_extensions %%%%%%%%%%%%%%%%%%%%%%%%%%%%

// %%%%%%%%%%%%%%%%%%%%%%%%%%%% end opencl_backend %%%%%%%%%%%%%%%%%%%%%%%%%%%%
