[[chapter:sycl-programming-interface]]
= SYCL programming interface

The SYCL programming interface provides a common abstracted feature set to one
or more <<backend>> APIs.
This section describes the {cpp} library interface to the <<sycl-runtime>> which
executes across those <<backend, SYCL backends>>.

The entirety of the SYCL interface defined in this section is required to be
available for any <<backend, SYCL backends>>, with the exception of the
interoperability interface, which is described in general terms in this
document, not pertaining to any particular <<backend>>.

SYCL guarantees that all the member functions and special member functions of
the SYCL classes described are thread safe.

The underlying types for all enumerations defined in this specification are
implementation-defined.
In addition, all enumerators within an enumeration have some
implementation-defined unique value unless the specification specifically
indicates a value for the enumerator.


[[sec:backends]]
== Backends

The <<backend, SYCL backends>> that can be supported by a SYCL implementation
are identified using the [code]#enum class backend#.

[source,,linenums]
----
include::{header_dir}/backends.h[lines=4..-1]
----

The [code]#enum class backend# is implementation-defined and must be populated
with a unique identifier for each <<backend>> that the SYCL implementation can
support.
Note that the <<backend, SYCL backends>> listed in the [code]#enum class
backend# are not guaranteed to be available in a given installation.

Each named <<backend>> enumerated in the [code]#enum class backend# must be
associated with a <<backend>> specification.
Many sections of this specification will refer to the associated <<backend>>
specification.


[[sec:backend-macros]]
=== Backend macros

As the identifiers defined in [code]#enum class backend# are
implementation-defined, and the associated backends are not guaranteed to be
available, a SYCL implementation must also define a preprocessor macro for each
of these identifiers.
If the <<backend>> is defined by the Khronos SYCL group, the name of the macro
has the form [code]#SYCL_BACKEND_<backend_name>#, where _backend_name_ is the
associated identifier from [code]#backend# in all upper-case.
See <<chapter.extensions>> for the name of the macro if the vendor defines the
<<backend>> outside of the Khronos SYCL group.

If a backend listed in the [code]#enum class backend# is not available, the
associated macro must be left undefined.

[[sec:generic-vs-non-generic]]
== Generic vs non-generic SYCL

The SYCL programming API is split into two categories; generic SYCL and
non-generic SYCL.
Almost everything in the SYCL programming API is considered generic SYCL.
However any usage of the [code]#enum class backend# is considered non-generic
SYCL and should only be used for <<backend>> specialized code paths, as the
identifiers defined in [code]#backend# are implementation-defined.

In any non-generic SYCL application code where the [code]#backend# enum class is
used, the expression must be guarded with a preprocessor [code]#{hash}ifdef#
guard using the associated preprocessor macro to ensure that the SYCL
application will compile even if the SYCL implementation does not support that
<<backend>> being specialized for.


[[sec:headers-and-namespaces]]
== Header files and namespaces

SYCL provides one standard header file: [code]#<sycl/sycl.hpp>#, which needs to
be included in every translation unit that uses the SYCL programming API.

All SYCL classes, constants, types and functions defined by this specification
should exist within the [code]#::sycl# namespace.

For compatibility with SYCL 1.2.1, SYCL provides another standard header file:
[code]#<CL/sycl.hpp>#, which can be included in place of
[code]#<sycl/sycl.hpp>#.
In that case, all SYCL classes, constants, types and functions defined by this
specification should exist within the [code]#::cl::sycl# {cpp} namespace.

For consistency, the programming API will only refer to the
[code]#<sycl/sycl.hpp># header and the [code]#::sycl# namespace, but this should
be considered synonymous with the SYCL 1.2.1 header and namespace.

Include paths starting with [code]#"sycl/ext/"# and [code]#"sycl/backend/"# are
reserved for extensions to SYCL and for backend interop headers respectively.
Other include paths starting with [code]#"sycl/"# and the [code]#sycl::detail#
namespace are reserved for implementation details.

When a <<backend>> is defined by the Khronos SYCL group, functionality for that
<<backend>> is available via the header
[code]#"sycl/backend/<backend_name>.hpp"#, and all <<backend>>-specific
functionality is made available in the namespace [code]#sycl::<backend_name>#
where [code]#<backend_name># is the name of the <<backend>> as defined in the
<<backend>> specification.

<<chapter.extensions>> defines the allowable header files and namespaces for any
extensions that a vendor may provide, including any <<backend>> that the vendor
may define outside of the Khronos SYCL group.

Unless otherwise specified, the behavior of a SYCL program is undefined if it
adds any entity to namespace [code]#sycl# or to a namespace within namespace
[code]#sycl#.


== Class availability

In SYCL some <<sycl-runtime>> classes are available to the SYCL application,
some are available within a <<sycl-kernel-function>> and some are available on
both and can be passed as arguments to a <<sycl-kernel-function>>.

Each of the following <<sycl-runtime>> classes: [code]#buffer#,
[code]#buffer_allocator#, [code]#context#, [code]#device#, [code]#device_image#,
[code]#event#, [code]#exception#, [code]#handler#, [code]#host_accessor#,
[code]#host_sampled_image_accessor#, [code]#host_unsampled_image_accessor#,
[code]#id#, [code]#image_allocator#, [code]#kernel#, [code]#kernel_id#,
[code]#marray#, [code]#kernel_bundle#, [code]#nd_range#, [code]#platform#,
[code]#queue#, [code]#range#, [code]#sampled_image#, [code]#image_sampler#,
[code]#stream#, [code]#unsampled_image# and [code]#vec# must be available to the
host application.

Each of the following <<sycl-runtime>> classes: [code]#accessor#,
[code]#atomic_ref#, [code]#device_event#, [code]#group#, [code]#h_item#,
[code]#id#, [code]#item#, [code]#local_accessor#, [code]#marray#,
[code]#multi_ptr#, [code]#nd_item#, [code]#range#, [code]#reducer#,
[code]#sampled_image_accessor#, [code]#stream#, [code]#sub_group#,
[code]#unsampled_image_accessor# and [code]#vec# must be available within a
<<sycl-kernel-function>>.

== Common interface

When a dimension template parameter is used in SYCL classes, it is defaulted as
1 in most cases.


[[sec:backend-interoperability]]
=== Backend interoperability

Many of the <<sycl-runtime>> classes may be implemented such that they
encapsulate an object unique to the <<backend>> that underpins the functionality
of that class.
Where appropriate, these classes may provide an interface for interoperating
between the <<sycl-runtime>> object and the <<native-backend-object>> in order
to support interoperability within an application between SYCL and the
associated <<backend-api>>.

There are three forms of interoperability with <<sycl-runtime>> classes:
interoperability on the <<sycl-application>> with the <<backend-api>>,
interoperability within a <<sycl-kernel-function>> with the equivalent kernel
language types of the <<backend>>, and interoperability within a <<host-task>>
with the [code]#interop_handle#.

<<sycl-application,SYCL application>> interoperability, <<sycl-kernel-function>>
interoperability and <<host-task>> interoperability are provided via different
interfaces and may have different behavior for the same SYCL object.

<<sycl-application,SYCL application>> interoperability may be provided for
[code]#buffer#, [code]#context#, [code]#device#, [code]#device_image#,
[code]#event#, [code]#kernel#, [code]#kernel_bundle#, [code]#platform#,
[code]#queue#, [code]#sampled_image#, and [code]#unsampled_image#.

<<sycl-kernel-function,SYCL kernel function>> interoperability may be provided
for [code]#accessor#, [code]#device_event#, [code]#local_accessor#,
[code]#sampled_image_accessor#, [code]#stream# and
[code]#unsampled_image_accessor# inside <<kernel-scope>> only and is not
available outside of that scope.

<<host-task>> interoperability may be provided for [code]#accessor#,
[code]#sampled_image_accessor#, [code]#unsampled_image_accessor#, [code]#queue#,
[code]#device#, [code]#context# inside the scope of a <<host-task>> only, see
<<subsec:interfaces.hosttasks>>.

Support for <<backend>> interoperability is optional and therefore not required
to be provided by a SYCL implementation.
A SYCL application using <<backend>> interoperability is considered to be
non-generic SYCL.

Details on the interoperability for a given <<backend>> are available on the
<<backend>> specification document for that <<backend>>.

==== Type traits [code]#backend_traits#

[source,,linenums]
----
include::{header_dir}/interop/typeTraitsBackendTraits.h[lines=4..-1]
----

A series of type traits are provided for <<backend>> interoperability, defined
in the [code]#backend_traits# class.

A specialization of [code]#backend_traits# must be provided for each named
<<backend>> enumerated in the enum class [code]#backend# that is available at
compile time.

  * For each <<sycl-runtime>> class [code]#T# which supports
    <<sycl-application>> interoperability with the <<backend>>, a specialization
    of [code]#input_type# must be defined as the type of <<sycl-application>>
    interoperability <<native-backend-object>> associated with [code]#T# for the
    <<backend>>, specified in the <<backend>> specification.
    [code]#input_type# is used when constructing SYCL objects from backend
    specific native objects.
    See the relevant backend specification for details.
  * For each <<sycl-runtime>> class [code]#T# which supports
    <<sycl-application>> interoperability with the <<backend>>, a specialization
    of [code]#return_type# must be defined as the type of <<sycl-application>>
    interoperability <<native-backend-object>> associated with [code]#T# for the
    <<backend>>, specified in the <<backend>> specification.
    [code]#return_type# is used when retrieving the backend specific native
    object from a SYCL object.
    See the relevant backend specification for details.
  * For each <<sycl-runtime>> class [code]#T# which supports kernel function
    interoperability with the <<backend>>, a specialization of
    [code]#return_type# within [code]#backend_traits# must be defined as the
    type of the kernel function interoperability <<native-backend-object>>
    associated with [code]#T# for the <<backend>>, specified in the backend
    specification.
    See the relevant backend specification for details.

The type alias [code]#backend_input_t# is provided to enable less verbose access
to the [code]#input_type# type within [code]#backend_traits# for a specific SYCL
object of type [code]#T#.
The type alias [code]#backend_return_t# is provided to enable less verbose
access to the [code]#return_type# type within [code]#backend_traits# for a
specific SYCL object of type [code]#T#.

==== Template function [code]#get_native#

[source,,linenums]
----
include::{header_dir}/interop/templateFunctionGetNative.h[lines=4..-1]
----

For each <<sycl-runtime>> class [code]#T# which supports <<sycl-application>>
interoperability, a specialization of [code]#get_native# must be defined, which
takes an instance of [code]#T# and returns a <<sycl-application>>
interoperability <<native-backend-object>> associated with [code]#syclObject#
which can be used for <<sycl-application>> interoperability.
The lifetime of the object returned is backend-defined and specified in the
backend specification.

For each <<sycl-runtime>> class [code]#T# which supports kernel function
interoperability, a specialization of [code]#get_native# must be defined, which
takes an instance of [code]#T# and returns the kernel function interoperability
<<native-backend-object>> associated with [code]#syclObject# which can be used
for kernel function interoperability.
The availability and behavior of these template functions are defined by the
<<backend>> specification document.

The [code]#get_native# function must throw an [code]#exception# with the
[code]#errc::backend_mismatch# error code if the backend of the SYCL object
doesn't match the target backend.

[[sec:backend-interoperability-make]]
==== Template functions [code]#make_*#

[source,,linenums]
----
include::{header_dir}/interop/templateFunctionMakeX.h[lines=4..-1]
----

For each <<sycl-runtime>> class [code]#T# which supports <<sycl-application>>
interoperability, a specialization of the appropriate template function
[code]#make_{sycl_class}# where [code]#{sycl_class}# is the class name of
[code]#T#, must be defined, which takes a <<sycl-application>> interoperability
<<native-backend-object>> and constructs and returns an instance of [code]#T#.
The availability and behavior of these template functions are defined by the
<<backend>> specification document.

Overloads of the [code]#make_{sycl_class}# function which take a SYCL
<<context>> object as an argument must throw an [code]#exception# with the
[code]#errc::backend_mismatch# error code if the backend of the provided SYCL
context doesn't match the target backend.

[[sec:reference-semantics]]
=== Common reference semantics

Each of the following <<sycl-runtime>> classes: [code]#accessor#,
[code]#buffer#, [code]#context#, [code]#device#, [code]#device_image#,
[code]#event#, [code]#host_accessor#, [code]#host_sampled_image_accessor#,
[code]#host_unsampled_image_accessor#, [code]#kernel#, [code]#kernel_id#,
[code]#kernel_bundle#, [code]#local_accessor#, [code]#platform#, [code]#queue#,
[code]#sampled_image#, [code]#sampled_image_accessor#, [code]#stream#,
[code]#unsampled_image# and [code]#unsampled_image_accessor# must obey the
following statements, where [code]#T# is the runtime class type:

  * [code]#T# must be copy constructible and copy assignable in the host
    application and within SYCL kernel functions in the case that [code]#T# is a
    valid kernel argument.
    Any instance of [code]#T# that is constructed as a copy of another instance,
    via either the copy constructor or copy assignment operator, must behave
    as-if it were the original instance and as-if any action performed on it
    were also performed on the original instance and must represent the same
    underlying <<native-backend-object>> as the original instance where
    applicable.
  * [code]#T# must be destructible in the host application and within SYCL
    kernel functions in the case that [code]#T# is a valid kernel argument.
    When any instance of [code]#T# is destroyed, including as a result of the
    copy assignment operator, any behavior specific to [code]#T# that is
    specified as performed on destruction is only performed if this instance is
    the last remaining host copy, in accordance with the above definition of a
    copy.
  * [code]#T# must be move constructible and move assignable in the host
    application and within SYCL kernel functions in the case that [code]#T# is a
    valid kernel argument.
    Any instance of [code]#T# that is constructed as a move of another instance,
    via either the move constructor or move assignment operator, must replace
    the original instance rendering said instance invalid and must represent the
    same underlying <<native-backend-object>> as the original instance where
    applicable.
  * [code]#T# must be equality comparable in the host application.
    Equality between two instances of [code]#T# (i.e. [code]#a == b#) must be
    true if one instance is a copy of the other and non-equality between two
    instances of [code]#T# (i.e. [code]#a != b#) must be true if neither
    instance is a copy of the other, in accordance with the above definition of
    a copy, unless either instance has become invalidated by a move operation.
    By extension of the requirements above, equality on [code]#T# must guarantee
    to be reflexive (i.e. [code]#a == a#), symmetric (i.e. [code]#a == b#
    implies [code]#b == a# and [code]#a != b# implies [code]#b != a#) and
    transitive (i.e. [code]#a == b && b == c# implies [code]#c == a#).
  * A specialization of [code]#std::hash# for [code]#T# must exist in the host
    application that returns a unique value such that if two instances of
    [code]#T# are equal, in accordance with the above definition, then their
    resulting hash values are also equal and subsequently if two hash values are
    not equal, then their corresponding instances are also not equal, in
    accordance with the above definition.

Some <<sycl-runtime>> classes will have additional behavior associated with
copy, movement, assignment or destruction semantics.
If these are specified they are in addition to those specified above unless
stated otherwise.

Each of the runtime classes mentioned above must provide a common interface of
special member functions in order to fulfill the copy, move, destruction
requirements and hidden friend functions in order to fulfill the equality
requirements.

A hidden friend function is a function first declared via a [code]#friend#
declaration with no additional out of class or namespace scope declarations.
Hidden friend functions are only visible to ADL (Argument Dependent Lookup) and
are hidden from qualified and unqualified lookup.
Hidden friend functions have the benefits of avoiding accidental implicit
conversions and faster compilation.

These common special member functions and hidden friend functions are described
in <<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>> respectively.

[source,,linenums]
----
include::{header_dir}/common-reference.h[lines=4..-1]
----

[[table.specialmembers.common.reference]]
.Common special member functions for reference semantics
[width="100%",options="header",separator="@",cols="1,2"]
|====
@ Special member function @ Description
a@
[source]
----
T(const T& rhs)
----
   a@ Constructs a [code]#T# instance as a copy of the RHS SYCL
      [code]#T# in accordance with the requirements set out above.

a@
[source]
----
T(T&& rhs)
----
   a@ Constructs a SYCL [code]#T# instance as a move of the RHS SYCL
      [code]#T# in accordance with the requirements set out above.

a@
[source]
----
T& operator=(const T& rhs)
----
   a@ Assigns this SYCL [code]#T# instance with a copy of the RHS SYCL
      [code]#T# in accordance with the requirements set out above.

a@
[source]
----
T& operator=(T&& rhs)
----
   a@ Assigns this SYCL [code]#T# instance with a move of the RHS SYCL
      [code]#T# in accordance with the requirements set out above.

a@
[source]
----
~T()
----
   a@ Destroys this SYCL [code]#T# instance in accordance with the
      requirements set out in <<sec:reference-semantics>>. On destruction
      of the last copy, may perform additional lifetime related operations
      required for the underlying <<native-backend-object>> specified in
      the <<backend>> specification document, if this SYCL [code]#T# instance
      was originally constructed using one of the backend interoperability
      [code]#make_*# functions specified in
      <<sec:backend-interoperability-make>>.
      See the relevant backend specification for details.

|====

[[table.hiddenfriends.common.reference]]
.Common hidden friend functions for reference semantics
[width="100%",options="header",separator="@"]
|====
@ Hidden friend function @ Description
a@
[source]
----
bool operator==(const T& lhs, const T& rhs)
----
   a@ Returns true if this LHS SYCL [code]#T# is equal to the RHS SYCL
      [code]#T# in accordance with the requirements set out above,
      otherwise returns false.

a@
[source]
----
bool operator!=(const T& lhs, const T& rhs)
----
   a@ Returns true if this LHS SYCL [code]#T# is not equal to the RHS
      SYCL [code]#T# in accordance with the requirements set out above,
      otherwise returns false.

|====


[[sec:byval-semantics]]
=== Common by-value semantics

Each of the following <<sycl-runtime>> classes: [code]#id#, [code]#range#,
[code]#item#, [code]#nd_item#, [code]#h_item#, [code]#group#, [code]#sub_group#
and [code]#nd_range# must follow the following statements, where [code]#T# is
the runtime class type:

  * [code]#T# must be default copy constructible and copy assignable in the host
    application (in the case where [code]#T# is available on the host) and
    within SYCL kernel functions.
  * [code]#T# must be default destructible in the host application (in the case
    where [code]#T# is available on the host) and within SYCL kernel functions.
  * [code]#T# must be default move constructible and default move assignable in
    the host application (in the case where [code]#T# is available on the host)
    and within SYCL kernel functions.
  * [code]#T# must be equality comparable in the host application (in the case
    where [code]#T# is available on the host) and within SYCL kernel functions.
    Equality between two instances of [code]#T# (i.e. [code]#a == b#) must be
    true if the value of all members are equal and non-equality between two
    instances of [code]#T# (i.e. [code]#a != b#) must be true if the value of
    any members are not equal, unless either instance has become invalidated by
    a move operation.
    By extension of the requirements above, equality on [code]#T# must guarantee
    to be reflexive (i.e. [code]#a == a#), symmetric (i.e. [code]#a == b#
    implies [code]#b == a# and [code]#a != b# implies [code]#b != a#) and
    transitive (i.e. [code]#a == b && b == c# implies [code]#c == a#).

Some <<sycl-runtime>> classes will have additional behavior associated with
copy, movement, assignment or destruction semantics.
If these are specified they are in addition to those specified above unless
stated otherwise.

Each of the runtime classes mentioned above must provide a common interface of
special member functions and member functions in order to fulfill the copy,
move, destruction and equality requirements, following the <<rule-of-five>> and
the <<rule-of-zero>>.

These common special member functions and hidden friend functions are described
in <<table.specialmembers.common.byval>> and
<<table.hiddenfriends.common.byval>> respectively.

[source,,linenums]
----
include::{header_dir}/common-byval.h[lines=4..-1]
----

[[table.specialmembers.common.byval]]
.Common special member functions for by-value semantics
[width="100%",options="header",separator="@",cols="2,1"]
|====
@ Special member function _(see <<rule-of-five>> and <<rule-of-zero>>)_ @ Description
a@
[source]
----
T(const T& rhs);
----
   a@ Copy constructor.

a@
[source]
----
T(T&& rhs);
----
   a@ Move constructor.

a@
[source]
----
T& operator=(const T& rhs);
----
   a@ Copy assignment operator.

a@
[source]
----
T& operator=(T&& rhs);
----
   a@ Move assignment operator.

a@
[source]
----
~T();
----
   a@ Destructor.

|====

[[table.hiddenfriends.common.byval]]
.Common hidden friend functions for by-value semantics
[width="100%",options="header",separator="@",cols="1,1"]
|====
@ Hidden friend function @ Description
a@
[source]
----
bool operator==(const T& lhs, const T& rhs)
----
   a@ Returns true if this LHS SYCL [code]#T# is equal to the RHS SYCL [code]#T# in accordance with the requirements set out above, otherwise returns false.

a@
[source]
----
bool operator!=(const T& lhs, const T& rhs)
----
   a@ Returns true if this LHS SYCL [code]#T# is not equal to the RHS SYCL [code]#T# in accordance with the requirements set out above, otherwise returns false.

|====

=== Properties

Each of the following <<sycl-runtime>> classes: [code]#accessor#,
[code]#buffer#, [code]#host_accessor#, [code]#host_sampled_image_accessor#,
[code]#host_unsampled_image_accessor#, [code]#context#, [code]#local_accessor#,
[code]#queue#, [code]#sampled_image#, [code]#sampled_image_accessor#,
[code]#stream#, [code]#unsampled_image#, [code]#unsampled_image_accessor# and
[code]#usm_allocator# provide an optional parameter in each of their
constructors to provide a [code]#property_list# which contains zero or more
properties.
Each of those properties augments the semantics of the class with a particular
feature.
Each of those classes must also provide [code]#has_property# and
[code]#get_property# member functions for querying for a particular property.

The listing below illustrates the usage of various buffer properties, described
in <<sec:buffer-properties>>.

The example illustrates how using properties does not affect the type of the
object, thus, does not prevent the usage of SYCL objects in containers.

[source,,linenums]
----
include::{code_dir}/propertyExample.cpp[lines=4..-1]
----

Each property is represented by a unique class and an instance of a property is
an instance of that type.
Some properties can be default constructed while others will require an argument
on construction.
A property may be applicable to more than one class, however some properties may
not be compatible with each other.
See the requirements for the properties of the SYCL [code]#buffer# class, SYCL
[code]#unsampled_image# class and SYCL [code]#sampled_image# class in
<<table.properties.buffer>> and <<table.properties.image>> respectively.

Properties can be passed to a <<sycl-runtime>> class via an instance of
[code]#property_list#.
These properties get tied to the <<sycl-runtime>> class instance and copies of
the object will contain the same properties.

A SYCL implementation or a <<backend>> may provide additional properties other
than those defined here, provided they are defined in accordance with the
requirements described in <<sec:headers-and-namespaces>>.

==== Properties interface

Each of the runtime classes mentioned above must provide a common interface of
member functions in order to fulfill the property interface requirements.

A synopsis of the common properties interface, the SYCL [code]#property_list#
class and the SYCL property classes is provided below.
The member functions of the common properties interface are listed in
<<table.members.propertyinterface>>.
The constructors of the SYCL [code]#property_list# class are listed in
<<table.constructors.propertylist>>.

[source,,linenums]
----
include::{header_dir}/properties.h[lines=4..-1]
----


[[table.traits.properties]]
.Traits for properties
[width="100%",options="header",separator="@"]
|====
@ Traits @ Description
a@
[source]
----
template <typename Property> struct is_property
----
   a@ An explicit specialization of [code]#is_property# that inherits
      from [code]#std::true_type# must be provided for each property,
      where [code]#Property# is the class defining the property.
      This includes both standard properties described in this
      specification and any additional non-standard properties defined by
      an implementation. All other specializations of
      [code]#is_property# must inherit from
      [code]#std::false_type#.
a@
[source,c++]
----
template <typename Property>
inline constexpr bool is_property_v;
----
   a@ Variable containing value of [code]#is_property<Property>#.

a@
[source]
----
template <typename Property, SyclObject> struct is_property_of
----
   a@ An explicit specialization of [code]#is_property_of# that
      inherits from [code]#std::true_type# must be provided for each
      property that can be used in constructing a given SYCL class, where
      [code]#Property# is the class defining the property and
      [code]#SyclObject# is the SYCL class. This includes both
      standard properties described in this specification and any
      additional non-standard properties defined by an implementation. All
      other specializations of [code]#is_property_of# must inherit
      from [code]#std::false_type#.
a@
[source,c++]
----
template <typename Property, SyclObject>
inline constexpr bool is_property_of_v;
----
   a@ Variable containing value of [code]#is_property_of<Property, SyclObject>#.

|====



[[table.members.propertyinterface]]
.Common member functions of the SYCL [code]#property# interface
[width="100%",options="header",separator="@",cols="2,3"]
|====
@ Member function @ Description
a@
[source]
----
template <typename Property> bool has_property() const noexcept
----
   a@ Returns true if [code]#T# was constructed with the property
      specified by [code]#Property#. Returns false if it was
      not.

a@
[source]
----
template <typename Property> Property get_property() const
----
   a@ Returns a copy of the property of type [code]#Property#
      that [code]#T# was constructed with. Must throw an
      [code]#exception# with the [code]#errc::invalid#
      error code if [code]#T# was not constructed with the
      [code]#Property# property.

|====



[[table.constructors.propertylist]]
.Constructors of the SYCL [code]#property_list# class
[width="100%",options="header",separator="@",cols="2,3"]
|====
@ Constructor @ Description
a@
[source]
----
template <typename... PropertyN> property_list(PropertyN... props)
----
   a@ Available only when: [code]#is_property<property>::value#
      evaluates to [code]#true# where [code]#property# is each
      property in [code]#PropertyN#.

Construct a SYCL [code]#property_list# with zero or more properties.

|====

=== Information queries

Several classes in SYCL provide a generic mechanism for querying the class for
information.

Each available query is described by an <<information-descriptor>>, which is a
class or class template that encapsulates an information query and its return
type.

==== Information query interface

The information query interface consists of two function templates, templated on
an <<information-descriptor>>:

* The [code]#get_info()# function template can be used to query general
  information that is available with any backend; and

* The [code]#get_backend_info()# function template can be used to query
  backend-specific information.

The information that can be queried with [code]#get_info()# for a specific class
is listed alongside the definition of that class.
The information that can be queried with [code]#get_backend_info()# is defined
in the corresponding <<backend>> specification.


== SYCL runtime classes


[[sec:device-selection]]
=== Device selection

Since a system can have several SYCL-compatible devices attached, it is useful
to have a way to select a specific device or a set of devices to construct a
specific object such as a [code]#device# (see <<sec:device-class>>) or a
[code]#queue# (see <<sec:queue-class>>), or perform some operations on a device
subset.

Device selection is done either by already having a specific instance of a
[code]#device# (see <<sec:device-class>>) or by providing a <<device-selector>>
which is a ranking function that will give an integer ranking value to all the
devices on the system.


[[sec:device-selector]]
==== Device selector

The interface for a <<device-selector>> is any object that meets the C++ named
requirement [code]#Callable#, taking a parameter of type [code]#const device &#
and returning a value that is implicitly convertible to [code]#int#.

At any point where the <<sycl-runtime>> needs to select a SYCL [code]#device#
using a <<device-selector>>, the system queries all <<root-device, root
devices>> from all <<backend, SYCL backends>> in the system, calls the
<<device-selector>> on each device and selects the one which returns the highest
score.
If the highest value is strictly negative no device is selected.

In places where only one device has to be picked and the high score is obtained
by more than one device, then one of the tied devices will be returned, but
which one is not defined and may depend on enumeration order, for example,
outside the control of the SYCL runtime.

Some predefined <<device-selector,device selectors>> are provided by the system
as described on <<table.device.selectors>> in a header file with some definition
similar to the following:


[[table.device.selectors]]
.Standard device selectors included with all SYCL implementations
[width="100%",options="header",separator="@",cols="50%,50%"]
|====
@ SYCL device selectors @ Description
a@
[source]
----
default_selector_v
----
   a@ Select a SYCL [code]#device# from any supported <<backend>>
      based on an implementation-defined heuristic. Since all
      implementations must support at least one device, this selector
      must always return a device.

[NOTE]
====
Implementations may choose to return an emulated device (with
[code]#aspect::emulated#) as a fallback if there is no physical device available
on the system.
====

a@
[source]
----
gpu_selector_v
----
   a@ Select a SYCL [code]#device# from any supported <<backend>>
      for which the device type is
      [code]#info::device_type::gpu#. The SYCL class
      constructor using it must throw an [code]#exception#
      with the [code]#errc::runtime# error code if no
      device matching this requirement can be found.

a@
[source]
----
accelerator_selector_v
----
   a@ Select a SYCL [code]#device# from any supported <<backend>>
      for which the device type is
      [code]#info::device_type::accelerator#. The SYCL
      class constructor using it must throw an [code]#exception#
      with the [code]#errc::runtime# error code if no device
      matching this requirement can be found.

a@
[source]
----
cpu_selector_v
----
   a@ Select a SYCL [code]#device# from any supported <<backend>>
      for which the device type is
      [code]#info::device_type::cpu#. The SYCL class
      constructor using it must throw an [code]#exception#
      with the [code]#errc::runtime# error code
      if no device matching this requirement can be found.

a@
[source]
----
__unspecified_callable__
aspect_selector(const std::vector<aspect>& aspectList,
                const std::vector<aspect>& denyList = {});

template <typename... AspectList>
__unspecified_callable__ aspect_selector(AspectList... aspectList);

template <aspect... AspectList> __unspecified_callable__ aspect_selector();
----
a@ The free function [code]#aspect_selector# has several overloads,
each of which returns a selector object that selects a
SYCL [code]#device# from any supported <<backend>>
which contains all the requested aspects,
i.e. for the specific device [code]#dev#
and each aspect [code]#devAspect# from [code]#aspectList#
[code]#dev.has(devAspect)# equals [code]#true#.
If no aspects are passed in,
the generated selector behaves like [code]#default_selector_v#.

Required aspects can be passed in as a vector, as function arguments,
or as template parameters, depending on the function overload.
The function overload that takes [code]#aspectList# as a vector
takes another vector argument [code]#denyList#
where the user can specify all the aspects that have to be avoided,
i.e. for the specific device [code]#dev#
and each aspect [code]#devAspect# from [code]#denyList#
[code]#dev.has(devAspect)# equals [code]#false#.

The SYCL class constructor using the generated selector
must throw an [code]#exception# with the [code]#errc::runtime# error code
if no device matching this requirement can be found.
There are multiple overloads of this function,
please refer to <<header:device-selector>> for full definitions
and to <<example:aspect-selector>> for examples.

|====


// Interface of the device selector
[[header:device-selector]]
[source,,linenums]
----
include::{header_dir}/deviceSelector.h[lines=4..-1]
----

Typical examples of default and user-provided <<device-selector,device
selectors>> could be:

[source,,linenums]
----
sycl::device my_gpu { sycl::gpu_selector_v };

sycl::queue my_accelerator { sycl::accelerator_selector_v };

int prefer_my_vendor(const sycl::device& d) {
  // Return 1 if the vendor name is "MyVendor" or 0 else.
  // 0 does not prevent another device to be picked as a second choice
  return d.get_info<info::device::vendor>() == "MyVendor";
}

// Get the preferred device or another one if not available
sycl::device preferred_device { prefer_my_vendor };

// This throws if there is no such device in the system
sycl::queue half_precision_controller {
  // Can use a lambda as a device ranking function.
  // Returns a negative number to fail in the case there is no such device
  [] (auto& d) { return d.has(sycl::aspect::fp16) ? 1 : -1; }
};

// To ease porting SYCL 1.2.1 code, there are types whose
// construction leads to the equivalent predefined device selector
sycl::queue my_old_style_gpu { sycl::gpu_selector {} };
----

Examples of using [code]#aspect_selector#:

[[example:aspect-selector]]
[source,,linenums]
----
using namespace sycl; // (optional) avoids need for "sycl::" before SYCL names

// Unrestrained selection, equivalent to default_selector_v
auto dev0 = device{aspect_selector()};

// Pass aspects in a vector
// Only accept CPUs that support half
auto dev1 = device{aspect_selector(std::vector{aspect::cpu, aspect::fp16})};

// Pass aspects without a vector
// Only accept GPUs that support half
auto dev2 = device{aspect_selector(aspect::gpu, aspect::fp16)};

// Pass aspects as compile-time parameters
// Only accept devices that can be debugged on host and support half
auto dev3 = device{aspect_selector<aspect::host_debuggable, aspect::fp16>()};

// Pass aspects in an allowlist and a denylist
// Only accept devices that support half and double floating point precision,
// but exclude emulated devices and devices of type "custom"
auto dev4 = device{aspect_selector(
   std::vector{aspect::fp16, aspect::fp64},
   std::vector{aspect::emulated, aspect::custom}
)};
----

[NOTE]
====
In SYCL 1.2.1 the predefined device selectors were actually types that had to be
instantiated to be used.
Now they are just instances.
To simplify porting code using the old type instantiations, a
backward-compatible API is still provided, though deprecated, such as
[code]#sycl::default_selector#.
The new predefined device selectors have their new names appended with "_v" to
avoid conflicts, thus following the naming style used by traits in the {cpp}
standard library.
There is no requirement for the implementation to have for example
[code]#sycl::gpu_selector_v# being an instance of [code]#sycl::gpu_selector#.
====


[[sec:platform-class]]
=== Platform class

The [code]#platform# class encapsulates a single SYCL platform on which kernel
functions may be executed.
A platform must be associated with a single <<backend>>.

A [code]#platform# also contains a set of devices that are associated with the
same <<backend>>.
A platform may contain no devices.

All member functions of the [code]#platform# class are synchronous and errors
are handled by throwing synchronous SYCL exceptions.

The execution environment for a SYCL application has a fixed number of platforms
which does not vary as the application executes.
The application can get a list of all these platforms via
[api]#platform::get_platforms#, and the order of the platform objects is the
same each time the application calls that function.
The [code]#platform# class also provides constructors, but constructing a new
[code]#platform# instance merely creates a new object that is a copy of one of
the objects returned by [api]#platform::get_platforms#.

Each platform has an associated default context which contains all of the
<<root-device,root devices>> in the platform.
This default context does not have an asynchronous error handler.
Applications can retrieve a copy of this default `context` object, for example,
by constructing a `queue`.
These copies follow the common reference semantics, as though they are all
copies of an internal per-platform `context` object representing the platform's
default context.

The [code]#platform# class provides the common reference semantics as defined in
<<sec:reference-semantics>>.

[source,role=synopsis]
----
include::{header_dir}/platform.h[lines=4..-1]
----

[[sec:platform-ctors]]
==== Constructors

.[apititle]#Default constructor#
[source,role=synopsis,id=api:platform-ctor]
----
platform()
----

_Effects:_ Constructs a [code]#platform# object that is a copy of the platform
which contains the device returned by [code]#default_selector_v#.

'''

.[apititle]#Selector constructor#
[source,role=synopsis,id=api:platform-ctor-selector]
----
template <typename DeviceSelector>
explicit platform(const DeviceSelector& selector)
----

_Constraints:_ The [code]#DeviceSelector# must be a type that satisfies the
requirements of a <<device-selector>> as defined in <<sec:device-selector>>.

_Effects:_ The [code]#selector# is called for every <<root-device>> as described
in <<sec:device-selector>>.
Constructs a [code]#platform# object that is a copy of the platform which
contains the device that is selected by [code]#selector#.

'''

[[sec:platform-member-funcs]]
==== Member functions

.[apidef]#platform::get_backend#
[source,role=synopsis,id=api:platform-get-backend]
----
backend get_backend() const noexcept
----

_Returns:_ The <<backend>> that is associated with this platform.

'''

.[apidef]#platform::get_info#
[source,role=synopsis,id=api:platform-get-info]
----
template <typename Param>
typename Param::return_type get_info() const
----

_Constraints:_ The [code]#Param# must be an information descriptor for the
platform class.

Each information descriptor specifies the return value and may also specify
preconditions, exceptions that are thrown, etc.
See <<sec:platform-info-descriptors>> for the platform information descriptors
that are defined by the <<core-spec>>.

'''

.[apidef]#platform::get_backend_info#
[source,role=synopsis,id=api:platform-get-backend-info]
----
template <typename Param>
typename Param::return_type get_backend_info() const
----

_Constraints:_ The [code]#Param# must be a backend information descriptor for
the platform class.

_Throws:_ An [code]#exception# with the [code]#errc::backend_mismatch# error
code if the backend that corresponds with [code]#Param# is different from the
backend that is associated with this platform.

Each information descriptor specifies the return value and may also specify
preconditions, additional exceptions that are thrown, etc.

'''

.[apidef]#platform::has#
[source,role=synopsis,id=api:platform-has]
----
bool has(aspect asp) const
----

_Returns:_ The value [code]#true# if all of the devices associated with this
platform have the given <<aspect>>.
Returns the value [code]#false# if this platform does not contain any devices.

'''

.[apidef]#platform::has_extension#
[source,role=synopsis,id=api:platform-has-extension]
----
bool has_extension(const std::string& extension) const
----

Deprecated by SYCL 2020.

{note}Use [api]#platform::has# instead.
{endnote}

_Returns:_ The value [code]#true# if this platform supports the extension
queried by the [code]#extension# parameter.
A platform only supports an extension if all associated devices support that
extension.
Returns [code]#false# if this platform does not contain any devices.

'''

.[apidef]#platform::get_devices#
[source,role=synopsis,id=api:platform-get-devices]
----
std::vector<device>
get_devices(info::device_type type = info::device_type::all) const
----

_Returns:_ A [code]#std::vector# containing all of the <<root-device,root
devices>> associated with this platform which have the device type specified by
[code]#type#.

'''

[[sec:platform-static-member-funcs]]
==== Static member functions

.[apidef]#platform::get_platforms#
[source,role=synopsis,id=api:platform-get-platforms]
----
static std::vector<platform> get_platforms()
----

_Returns:_ A [code]#std::vector# containing all of the platforms from all
<<backend, backends>> that are available in the system.

'''

[[sec:platform-info-descriptors]]
==== Information descriptors

This section describes the information descriptors that can be used as the
[code]#Param# template parameter to [api]#platform::get_info#.
When the description has a _Returns_, _Throws_, etc. paragraph, this indicates
the value returned by or the exceptions thrown by the [api]#platform::get_info#
function.

'''

.[apidef]#info::platform::version#
[source,role=synopsis,id=api:info-platform-version]
----
namespace sycl::info::platform {
struct version {
  using return_type = std::string;
};
} // namespace sycl::info::platform
----

_Remarks:_ Template parameter to [api]#platform::get_info#.

_Returns:_ An implementation-defined platform version string.

'''

.[apidef]#info::platform::name#
[source,role=synopsis,id=api:info-platform-name]
----
namespace sycl::info::platform {
struct name {
  using return_type = std::string;
};
} // namespace sycl::info::platform
----

_Remarks:_ Template parameter to [api]#platform::get_info#.

_Returns:_ An implementation-defined name for this platform.

'''

.[apidef]#info::platform::vendor#
[source,role=synopsis,id=api:info-platform-vendor]
----
namespace sycl::info::platform {
struct vendor {
  using return_type = std::string;
};
} // namespace sycl::info::platform
----

_Remarks:_ Template parameter to [api]#platform::get_info#.

_Returns:_ An implementation-defined name for the vendor providing this
platform.

'''

.[apidef]#info::platform::extensions#
[source,role=synopsis,id=api:info-platform-extensions]
----
namespace sycl::info::platform {
struct extensions {
  using return_type = std::vector<std::string>;
};
} // namespace sycl::info::platform
----

Deprecated by SYCL 2020.

{note}Use [code]#device::get_info()# with [code]#info::device::aspects# instead.
{endnote}

_Remarks:_ Template parameter to [api]#platform::get_info#.

_Returns:_ The extensions supported by this platform.
Returns an empty list if this platform does not contain any devices.

'''

[[sec:context-class]]
=== Context class

The [code]#context# class represents a SYCL context.
A context represents the runtime data structures and state required by a
<<backend>> API to interact with a group of devices associated with a platform.

All member functions of the [code]#context# class are synchronous and errors are
handled by throwing synchronous SYCL exceptions.

All constructors of the [code]#context# class construct an object that is
associated with a particular <<backend>>, determined by the constructor
parameters or, in the case of the default constructor, the SYCL [code]#device#
produced by the [code]#default_selector_v#.

A context can optionally be constructed with an [code]#async_handler# parameter.
In this case the [code]#async_handler# is used to report asynchronous
exceptions, as described in <<error-handling>>.

The [code]#context# class provides the common reference semantics as defined in
<<sec:reference-semantics>>.

[source,role=synopsis]
----
include::{header_dir}/context.h[lines=4..-1]
----

[[sec:context-ctors]]
==== Constructors

.[apititle]#Default constructor#
[source,role=synopsis,id=api:context-ctor]
----
explicit context(async_handler asyncHandler = {})
----

_Effects:_ Constructs a [code]#context# object using the
[code]#default_selector_v# to determine the associated platform and devices.
The associated platform is the platform which contains the device selected by
[code]#default_selector_v#.
The <<device,devices>> that are associated with the constructed context are
implementation-defined but must contain the device that is selected by
[code]#default_selector_v#.
The constructed context uses the [code]#asyncHandler# parameter to handle
exceptions.

'''

.[apititle]#Construct from device#
[source,role=synopsis,id=api:context-ctor-dev]
----
explicit context(const device& dev, async_handler asyncHandler = {})
----

_Effects:_ Constructs a [code]#context# object using the [code]#dev# parameter
to determine the associated platform and device.
The associated platform is the platform that contains [code]#dev#, and the
associated device is [code]#dev#.
The constructed context uses the [code]#asyncHandler# parameter to handle
exceptions.

'''

.[apititle]#Construct from device list#
[source,role=synopsis,id=api:context-ctor-dev-list]
----
explicit context(const std::vector<device>& deviceList,
                 async_handler asyncHandler = {})
----

_Preconditions:_ All devices in [code]#deviceList# must be associated with the
same platform.

_Effects:_ Constructs a [code]#context# object using the [code]#deviceList#
parameter to determine the associated platform and device.
The associated platform is the platform that contains all of the devices in
[code]#deviceList#.
The associated devices are those devices in [code]#deviceList#.
The constructed context uses the [code]#asyncHandler# parameter to handle
exceptions.

'''

[[sec:context-member-funcs]]
==== Member functions

.[apidef]#context::get_backend#
[source,role=synopsis,id=api:context-get-backend]
----
backend get_backend() const noexcept
----

_Returns:_ The <<backend>> that is associated with this context.

'''

.[apidef]#context::get_platform#
[source,role=synopsis,id=api:context-get-platform]
----
platform get_platform() const
----

_Returns:_ The <<platform>> that is associated with this context.

'''

.[apidef]#context::get_devices#
[source,role=synopsis,id=api:context-get-devices]
----
std::vector<device> get_devices() const
----

_Returns:_ A [code]#std::vector# containing all the <<device,devices>> that are
associated with this context.

'''

.[apidef]#context::get_info#
[source,role=synopsis,id=api:context-get-info]
----
template <typename Param>
typename Param::return_type get_info() const
----

_Constraints:_ The [code]#Param# must be an information descriptor for the
context class.

Each information descriptor specifies the return value and may also specify
preconditions, exceptions that are thrown, etc.
See <<sec:context-info-descriptors>> for the context information descriptors
that are defined by the <<core-spec>>.

'''

.[apidef]#context::get_backend_info#
[source,role=synopsis,id=api:context-get-backend-info]
----
template <typename Param>
typename Param::return_type get_backend_info() const
----

_Constraints:_ The [code]#Param# must be a backend information descriptor for
the context class.

_Throws:_ An [code]#exception# with the [code]#errc::backend_mismatch# error
code if the backend that corresponds with [code]#Param# is different from the
backend that is associated with this context.

Each information descriptor specifies the return value and may also specify
preconditions, additional exceptions that are thrown, etc.

'''

[[sec:context-info-descriptors]]
==== Information descriptors

This section describes the information descriptors that can be used as the
[code]#Param# template parameter to [api]#context::get_info#.
When the description has a _Returns_, _Throws_, etc. paragraph, this indicates
the value returned by or the exceptions thrown by the [api]#context::get_info#
function.

'''

.[apidef]#info::context::platform#
[source,role=synopsis,id=api:info-context-platform]
----
namespace sycl::info::context {
struct platform {
  using return_type = platform;
};
} // namespace sycl::info::context
----

_Remarks:_ Template parameter to [api]#context::get_info#.

_Returns:_ The <<platform>> that is associated with this context.

'''

.[apidef]#info::context::devices#
[source,role=synopsis,id=api:info-context-devices]
----
namespace sycl::info::context {
struct devices {
  using return_type = std::vector<device>;
};
} // namespace sycl::info::context
----

_Remarks:_ Template parameter to [api]#context::get_info#.

_Returns:_ A [code]#std::vector# containing all the <<device,devices>> that are
associated with this context.

'''

.[apidef]#info::context::atomic_memory_order_capabilities#
[source,role=synopsis,id=api:info-context-atomic-memory-order-capabilities]
----
namespace sycl::info::context {
struct atomic_memory_order_capabilities {
  using return_type = std::vector<memory_order>;
};
} // namespace sycl::info::context
----

_Remarks:_ Template parameter to [api]#context::get_info#.

_Returns:_ This query applies only to the capabilities of atomic operations that
are applied to memory that can be concurrently accessed by multiple devices in
the context.
If these capabilities are not uniform across all devices in the context, the
query reports only the capabilities that are common for all devices.

Returns the set of memory orders supported by these atomic operations.
When a context returns a "stronger" memory order in this set, it must also
return all "weaker" memory orders.
(See <<sec:memory-ordering>> for a definition of "stronger" and "weaker" memory
orders.)
The memory orders [code]#memory_order::acquire#, [code]#memory_order::release#,
and [code]#memory_order::acq_rel# are all the same strength.
If a context returns one of these, it must return them all.

At a minimum, each context must support [code]#memory_order::relaxed#.

'''

.[apidef]#info::context::atomic_fence_order_capabilities#
[source,role=synopsis,id=api:info-context-atomic-fence-order-capabilities]
----
namespace sycl::info::context {
struct atomic_fence_order_capabilities {
  using return_type = std::vector<memory_order>;
};
} // namespace sycl::info::context
----

_Remarks:_ Template parameter to [api]#context::get_info#.

_Returns:_ This query applies only to the capabilities of [code]#atomic_fence#
when applied to memory that can be concurrently accessed by multiple devices in
the context.
If these capabilities are not uniform across all devices in the context, the
query reports only the capabilities that are common for all devices.

Returns the set of memory orders supported by these [code]#atomic_fence#
operations.
When a context returns a "stronger" memory order in this set, it must also
return all "weaker" memory orders.
(See <<sec:memory-ordering>> for a definition of "stronger" and "weaker" memory
orders.)

At a minimum, each context must support [code]#memory_order::relaxed#,
[code]#memory_order::acquire#, [code]#memory_order::release#, and
[code]#memory_order::acq_rel#.

'''

.[apidef]#info::context::atomic_memory_scope_capabilities#
[source,role=synopsis,id=api:info-context-atomic-memory-scope-capabilities]
----
namespace sycl::info::context {
struct atomic_memory_scope_capabilities {
  using return_type = std::vector<memory_scope>;
};
} // namespace sycl::info::context
----

_Remarks:_ Template parameter to [api]#context::get_info#.

_Returns:_ The set of memory scopes supported by atomic operations on all
devices in the context.
When a context returns a "wider" memory scope in this set, it must also return
all "narrower" memory scopes.
(See <<sec:memory-scope>> for a definition of "wider" and "narrower" scopes.)
At a minimum, each context must support [code]#memory_scope::work_item#,
[code]#memory_scope::sub_group#, and [code]#memory_scope::work_group#.

'''

.[apidef]#info::context::atomic_fence_scope_capabilities#
[source,role=synopsis,id=api:info-context-atomic-fence-scope-capabilities]
----
namespace sycl::info::context {
struct atomic_fence_scope_capabilities {
  using return_type = std::vector<memory_scope>;
};
} // namespace sycl::info::context
----

_Remarks:_ Template parameter to [api]#context::get_info#.

_Returns:_ The set of memory orderings supported by [code]#atomic_fence# on all
devices in the context.
When a context returns a "wider" memory scope in this set, it must also return
all "narrower" memory scopes.
(See <<sec:memory-scope>> for a definition of "wider" and "narrower" scopes.)
At a minimum, each context must support [code]#memory_scope::work_item#,
[code]#memory_scope::sub_group#, and [code]#memory_scope::work_group#.

'''

[[sec:context-properties]]
==== Properties

The [code]#property_list# constructor parameters are present for extensibility.


[[sec:device-class]]
=== Device class

The [code]#device# class represents a single SYCL device on which <<kernel,
kernels>> can be executed.

All member functions of the [code]#device# class are synchronous and errors are
handled by throwing synchronous SYCL exceptions.

The execution environment for a SYCL application has a fixed number of
<<root-device, root devices>> which does not vary as the application executes.
The application can get a list of all these devices via
[api]#device::get_devices#, and the order of the device objects is the same each
time the application calls that function (assuming the parameter to that
function is the same for each call).
The [code]#device# class also provides constructors, but constructing a new
[code]#device# instance merely creates a new object that is a copy of one of the
objects returned by [api]#device::get_devices#.

A device can be partitioned into multiple devices, by calling the
[code]#device::create_sub_devices# member function template.
The resulting [code]#device# objects are considered sub devices, and it is valid
to partition these sub devices further.
The range of support for this feature is <<backend>> and device specific and can
be queried for through [api]#device::get_info#.

The [code]#device# class provides the common reference semantics as defined in
<<sec:reference-semantics>>.

[source,role=synopsis]
----
include::{header_dir}/device.h[lines=4..-1]
----

[[sec:device-ctors]]
==== Constructors

.[apititle]#Default constructor#
[source,role=synopsis,id=api:device-ctor]
----
device()
----

_Effects:_ Constructs a [code]#device# object that is a copy of the device
returned by [code]#default_selector_v#.

'''

.[apititle]#Selector constructor#
[source,role=synopsis,id=api:device-ctor-selector]
----
template <typename DeviceSelector>
explicit device(const DeviceSelector& selector)
----

_Constraints:_ Available only when the [code]#DeviceSelector# is a type that
satisfies the requirements of a <<device-selector>> as defined in
<<sec:device-selector>>.

_Effects:_ The [code]#selector# is called for every <<root-device>> as described
in <<sec:device-selector>>.
Constructs a [code]#device# object that is a copy of the device selected by
[code]#selector#.

'''

[[sec:device-member-funcs]]
==== Member functions

.[apidef]#device::get_backend#
[source,role=synopsis,id=api:device-get-backend]
----
backend get_backend() const noexcept
----

_Returns:_ The <<backend>> that is associated with this device.

'''

.[apidef]#device::get_platform#
[source,role=synopsis,id=api:device-get-platform]
----
platform get_platform() const
----

_Returns:_ The <<platform>> that is associated with this device.

'''

.[apidef]#device::is_cpu#
[source,role=synopsis,id=api:device-is-cpu]
----
bool is_cpu() const
----

_Returns:_ The same value as [code]#has(aspect::cpu)#.
See <<sec:device-aspects>>.

'''

.[apidef]#device::is_gpu#
[source,role=synopsis,id=api:device-is-gpu]
----
bool is_gpu() const
----

_Returns:_ The same value as [code]#has(aspect::gpu)#.
See <<sec:device-aspects>>.

'''

.[apidef]#device::is_accelerator#
[source,role=synopsis,id=api:device-is-accelerator]
----
bool is_accelerator() const
----

_Returns:_ The same value as [code]#has(aspect::accelerator)#.
See <<sec:device-aspects>>.

'''

.[apidef]#device::get_info#
[source,role=synopsis,id=api:device-get-info]
----
template <typename Param>
typename Param::return_type get_info() const
----

_Constraints:_ Available only when [code]#Param# is an information descriptor
for the device class.

Each information descriptor specifies the return value and may also specify
preconditions, exceptions that are thrown, etc.
See <<sec:device-info-descriptors>> for the device information descriptors that
are defined by the <<core-spec>>.

'''

.[apidef]#device::get_backend_info#
[source,role=synopsis,id=api:device-get-backend-info]
----
template <typename Param>
typename Param::return_type get_backend_info() const
----

_Constraints:_ Available only when [code]#Param# is a backend information
descriptor for the device class.

_Throws:_ An [code]#exception# with the [code]#errc::backend_mismatch# error
code if the backend that corresponds with [code]#Param# is different from the
backend that is associated with this device.

Each information descriptor specifies the return value and may also specify
preconditions, additional exceptions that are thrown, etc.

'''

.[apidef]#device::has#
[source,role=synopsis,id=api:device-has]
----
bool has(aspect asp) const
----

_Returns:_ The value [code]#true# if this device has the given <<aspect>>.
Applications can use this member function to determine which optional features
this device supports (if any).

'''

.[apidef]#device::has_extension#
[source,role=synopsis,id=api:device-has-extension]
----
bool has_extension(const std::string& extension) const
----

Deprecated by SYCL 2020.

{note}Use [api]#device::has# instead.
{endnote}

_Returns:_ The value [code]#true# if this device supports the extension queried
by the [code]#extension# parameter.

'''

.[apititle]#device::create_sub_devices (partition equally)#
[source,role=synopsis,id=api:device-create-sub-devices-partition-equally]
----
template <info::partition_property Prop>
std::vector<device> create_sub_devices(size_t count) const
----

_Constraints:_ Available only when [code]#Prop# is
[api]#info::partition_property::partition_equally#.

_Returns:_ A [code]#std::vector# of sub devices partitioned from this
[code]#device# object based on the [code]#count# parameter.
The returned vector contains as many sub devices as can be created such that
each sub device contains [code]#count# compute units.
If the device's total number of compute units (as returned by
[api]#info::device::max_compute_units#) is not evenly divided by [code]#count#,
then the remaining compute units are not included in any of the sub devices.

_Throws:_

* An [code]#exception# with the [code]#errc::feature_not_supported# error code
  if this device does not support
  [api]#info::partition_property::partition_equally#.

* An [code]#exception# with the [code]#errc::invalid# error code if
  [code]#count# exceeds the total number of compute units in the device.

'''

.[apititle]#device::create_sub_devices (partition by counts)#
[source,role=synopsis,id=api:device-create-sub-devices-partition-by-counts]
----
template <info::partition_property Prop>
std::vector<device> create_sub_devices(const std::vector<size_t>& counts) const
----

_Constraints:_ Available only when [code]#Prop# is
[api]#info::partition_property::partition_by_counts#.

_Returns:_ A [code]#std::vector# of sub devices partitioned from this
[code]#device# object based on the [code]#counts# parameter.
For each non-zero value _M_ in the [code]#counts# vector, a sub device with _M_
compute units is created.

_Throws:_

* An [code]#exception# with the [code]#errc::feature_not_supported# error code
  if this device does not support
  [api]#info::partition_property::partition_by_counts#.

* An [code]#exception# with the [code]#errc::invalid# error code if the number
  of non-zero values in [code]#counts# exceeds the device's maximum number of
  sub devices (as returned by [api]#info::device::partition_max_sub_devices#) or
  if the total of all the values in the [code]#counts# vector exceeds the total
  number of compute units in the device (as returned by
  [api]#info::device::max_compute_units#).

'''

.[apititle]#device::create_sub_devices (partition by affinity domain)#
[source,role=synopsis,id=api:device-create-sub-devices-partition-by-affinity-domain]
----
template <info::partition_property Prop>
std::vector<device>
create_sub_devices(info::partition_affinity_domain domain) const
----

_Constraints:_ Available only when [code]#Prop# is
[api]#info::partition_property::partition_by_affinity_domain#.

_Returns:_ A [code]#std::vector# of sub devices partitioned from this
[code]#device# object based on the [code]#domain# parameter, which must be one
of the following values:

* [api]#info::partition_affinity_domain::numa#: Split the device into sub
  devices comprised of compute units that share a NUMA node.

* [api]#info::partition_affinity_domain::L4_cache#: Split the device into sub
  devices comprised of compute units that share a level 4 data cache.

* [api]#info::partition_affinity_domain::L3_cache#: Split the device into sub
  devices comprised of compute units that share a level 3 data cache.

* [api]#info::partition_affinity_domain::L2_cache#: Split the device into sub
  devices comprised of compute units that share a level 2 data cache.

* [api]#info::partition_affinity_domain::L1_cache#: Split the device into sub
  devices comprised of compute units that share a level 1 data cache.

* [api]#info::partition_affinity_domain::next_partitionable#: Split the device
  along the next partitionable affinity domain.
  The implementation shall find the first level along which the device or sub
  device may be further subdivided in the order [code]#numa#, [code]#L4_cache#,
  [code]#L3_cache#, [code]#L2_cache#, [code]#L1_cache#, and partition the device
  into sub devices comprised of compute units that share memory subsystems at
  this level.
  The user may determine what happened via
  [api]#info::device::partition_type_affinity_domain#.

_Throws:_

* An [code]#exception# with the [code]#errc::feature_not_supported# error code
  if this device does not support
  [api]#info::partition_property::partition_by_affinity_domain# or if this
  device does not support the [api]#info::partition_affinity_domain# provided.

'''

[[sec:device-static-member-funcs]]
==== Static member functions

.[apidef]#device::get_devices#
[source,role=synopsis,id=api:device-get-devices]
----
static std::vector<device>
get_devices(info::device_type type = info::device_type::all)
----

_Returns:_ A [code]#std::vector# containing all the <<root-device, root
devices>> from all <<backend, SYCL backends>> available in the system which have
the device type [code]#type#.

'''

[[sec:device-info-descriptors]]
==== Information descriptors

This section describes the information descriptors that can be used as the
[code]#Param# template parameter to [api]#device::get_info#.
When the description has a _Returns_, _Throws_, etc. paragraph, this indicates
the value returned by or the exceptions thrown by the [api]#device::get_info#
function.

'''

.[apidef]#info::device::device_type#
[source,role=synopsis,id=api:info-device-device-type]
----
namespace sycl::info::device {
struct device_type {
  using return_type = info::device_type;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The device type associated with the device.
May not return [api]#info::device_type::all#.

'''

.[apidef]#info::device::vendor_id#
[source,role=synopsis,id=api:info-device-vendor-id]
----
namespace sycl::info::device {
struct vendor_id {
  using return_type = uint32_t;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ A unique vendor device identifier.

'''

.[apidef]#info::device::max_compute_units#
[source,role=synopsis,id=api:info-device-max-compute-units]
----
namespace sycl::info::device {
struct max_compute_units {
  using return_type = uint32_t;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The number of parallel compute units available to the device.
The minimum value is 1.

'''

.[apidef]#info::device::max_work_item_dimensions#
[source,role=synopsis,id=api:info-device-max-work-item-dimensions]
----
namespace sycl::info::device {
struct max_work_item_dimensions {
  using return_type = uint32_t;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The maximum dimensions that specify the global and local work-item
IDs used by the data parallel execution model.
The minimum value is 3 if this device is not of device type
[api]#info::device_type::custom#.

'''

.[apidef]#info::device::max_work_item_sizes#
[source,role=synopsis,id=api:info-device-max-work-item-sizes]
----
namespace sycl::info::device {
template<int Dimensions = 3>
struct max_work_item_sizes<Dimensions> {
  using return_type = range<Dimensions>;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Constraints_: Available only when [code]#Dimensions# is 1, 2, or 3.

_Returns:_ The maximum number of work-items that are permitted in a work-group
for a kernel running in an index space of [code]#Dimensions# dimensions.
When the device type is not [api]#info::device_type::custom#, the minimum value
returned from this query is: (1) when [code]#Dimensions# is 1, (1, 1) when
[code]#Dimensions# is 2, and (1, 1, 1) when [code]#Dimensions# is 3.

'''

.[apidef]#info::device::max_work_group_size#
[source,role=synopsis,id=api:info-device-max-work-group-size]
----
namespace sycl::info::device {
struct max_work_group_size {
  using return_type = size_t;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The maximum number of work-items that this device is capable of
executing in a work-group.
The minimum value is 1.
This value is an upper limit and will not necessarily maximize performance.
The maximum number of work-items in a work-group depends on the kernel and the
implementation.
Use [code]#info::kernel_device_specific::work_group_size# to query this limit.

'''

.[apidef]#info::device::max_num_sub_groups#
[source,role=synopsis,id=api:info-device-max-num-sub-groups]
----
namespace sycl::info::device {
struct max_num_sub_groups {
  using return_type = uint32_t;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The maximum number of sub-groups in a work-group for any kernel
executed on the device.
The minimum value is 1.

'''

.[apidef]#info::device::sub_group_sizes#
[source,role=synopsis,id=api:info-device-sub-group-sizes]
----
namespace sycl::info::device {
struct sub_group_sizes {
  using return_type = std::vector<size_t>;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ A [code]#std::vector# of [code]#size_t# containing the set of
sub-group sizes supported by the device.

'''

.[apititle]#info::device::preferred_vector_width#
[source,role=synopsis,id=api:info-device-preferred-vector-width]
----
namespace sycl::info::device {
struct preferred_vector_width_char {
  using return_type = uint32_t;
};
struct preferred_vector_width_short {
  using return_type = uint32_t;
};
struct preferred_vector_width_int {
  using return_type = uint32_t;
};
struct preferred_vector_width_long {
  using return_type = uint32_t;
};
struct preferred_vector_width_float {
  using return_type = uint32_t;
};
struct preferred_vector_width_double {
  using return_type = uint32_t;
};
struct preferred_vector_width_half {
  using return_type = uint32_t;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The preferred native vector width size for built-in scalar types that
can be put into vectors.
The vector width is defined as the number of scalar elements that can be stored
in the vector.
Must return 0 for [code]#info::device::preferred_vector_width_double# if the
device does not have [api]#aspect::fp64# and must return 0 for
[code]#info::device::preferred_vector_width_half# if the device does not have
[api]#aspect::fp16#.

'''

.[apititle]#info::device::native_vector_width#
[source,role=synopsis,id=api:info-device-native-vector-width]
----
namespace sycl::info::device {
struct native_vector_width_char {
  using return_type = uint32_t;
};
struct native_vector_width_short {
  using return_type = uint32_t;
};
struct native_vector_width_int {
  using return_type = uint32_t;
};
struct native_vector_width_long {
  using return_type = uint32_t;
};
struct native_vector_width_float {
  using return_type = uint32_t;
};
struct native_vector_width_double {
  using return_type = uint32_t;
};
struct native_vector_width_half {
  using return_type = uint32_t;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The native ISA vector width.
The vector width is defined as the number of scalar elements that can be stored
in the vector.
Must return 0 for [code]#info::device::native_vector_width_double# if the device
does not have [api]#aspect::fp64# and must return 0 for
[code]#info::device::native_vector_width_half# if the device does not have
[api]#aspect::fp16#.

'''

.[apidef]#info::device::max_clock_frequency#
[source,role=synopsis,id=api:info-device-max-clock-frequency]
----
namespace sycl::info::device {
struct max_clock_frequency {
  using return_type = uint32_t;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The maximum configured clock frequency of this device in MHz.

'''

.[apidef]#info::device::address_bits#
[source,role=synopsis,id=api:info-device-address-bits]
----
namespace sycl::info::device {
struct address_bits {
  using return_type = uint32_t;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The default compute device address space size in bits.
Must return either 32 or 64.

'''

.[apidef]#info::device::max_mem_alloc_size#
[source,role=synopsis,id=api:info-device-max-mem-alloc-size]
----
namespace sycl::info::device {
struct max_mem_alloc_size {
  using return_type = uint64_t;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The maximum size of memory object allocation in bytes.

'''

.[apidef]#info::device::image_support#
[source,role=synopsis,id=api:info-device-image-support]
----
namespace sycl::info::device {
struct image_support {
  using return_type = bool;
};
} // namespace sycl::info::device
----

Deprecated by SYCL 2020.

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The same value as [code]#device::has(aspect::image)#.

'''

.[apidef]#info::device::max_read_image_args#
[source,role=synopsis,id=api:info-device-max-read-image-args]
----
namespace sycl::info::device {
struct max_read_image_args {
  using return_type = uint32_t;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The maximum number of simultaneous image objects that can be read
from by a kernel.
The minimum value is 128 if the device has [api]#aspect::image#.

'''

.[apidef]#info::device::max_write_image_args#
[source,role=synopsis,id=api:info-device-max-write-image-args]
----
namespace sycl::info::device {
struct max_write_image_args {
  using return_type = uint32_t;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The maximum number of simultaneous image objects that can be written
to by a kernel.
The minimum value is 8 if the device has [api]#aspect::image#.

'''

.[apidef]#info::device::image2d_max_width#
[source,role=synopsis,id=api:info-device-image2d-max-width]
----
namespace sycl::info::device {
struct image2d_max_width {
  using return_type = size_t;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The maximum width of a 2D image or 1D image in pixels.
The minimum value is 8192 if the device has [api]#aspect::image#.

'''

.[apidef]#info::device::image2d_max_height#
[source,role=synopsis,id=api:info-device-image2d-max-height]
----
namespace sycl::info::device {
struct image2d_max_height {
  using return_type = size_t;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The maximum height of a 2D image in pixels.
The minimum value is 8192 if the device has [api]#aspect::image#.

'''

.[apidef]#info::device::image3d_max_width#
[source,role=synopsis,id=api:info-device-image3d-max-width]
----
namespace sycl::info::device {
struct image3d_max_width {
  using return_type = size_t;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The maximum width of a 3D image in pixels.
The minimum value is 2048 if the device has [api]#aspect::image#.

'''

.[apidef]#info::device::image3d_max_height#
[source,role=synopsis,id=api:info-device-image3d-max-height]
----
namespace sycl::info::device {
struct image3d_max_height {
  using return_type = size_t;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The maximum height of a 3D image in pixels.
The minimum value is 2048 if the device has [api]#aspect::image#.

'''

.[apidef]#info::device::image3d_max_depth#
[source,role=synopsis,id=api:info-device-image3d-max-depth]
----
namespace sycl::info::device {
struct image3d_max_depth {
  using return_type = size_t;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The maximum depth of a 3D image in pixels.
The minimum value is 2048 if the device has [api]#aspect::image#.

'''

.[apidef]#info::device::image_max_buffer_size#
[source,role=synopsis,id=api:info-device-image-max-buffer-size]
----
namespace sycl::info::device {
struct image_max_buffer_size {
  using return_type = size_t;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The number of pixels for a 1D image created from a buffer object.
The minimum value is 65536 if the device has [api]#aspect::image#.
Note that this information is intended for OpenCL interoperability only as this
feature is not supported in SYCL.

'''

.[apidef]#info::device::max_samplers#
[source,role=synopsis,id=api:info-device-max-samplers]
----
namespace sycl::info::device {
struct max_samplers {
  using return_type = uint32_t;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The maximum number of samplers that can be used in a kernel.
The minimum value is 16 if the device has [api]#aspect::image#.

'''

.[apidef]#info::device::max_parameter_size#
[source,role=synopsis,id=api:info-device-max-parameter-size]
----
namespace sycl::info::device {
struct max_parameter_size {
  using return_type = size_t;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The maximum size in bytes of the arguments that can be passed to a
kernel.
The minimum value is 1024 if this device is not of device type
[api]#info::device_type::custom#.
For this minimum value, only a maximum of 128 arguments can be passed to a
kernel.

'''

.[apidef]#info::device::mem_base_addr_align#
[source,role=synopsis,id=api:info-device-mem-base-addr-align]
----
namespace sycl::info::device {
struct mem_base_addr_align {
  using return_type = uint32_t;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The minimum value in bits of the largest supported SYCL built-in data
type if this device is not of device type [api]#info::device_type::custom#.

'''

.[apidef]#info::device::half_fp_config#
[source,role=synopsis,id=api:info-device-half-fp-config]
----
namespace sycl::info::device {
struct half_fp_config {
  using return_type = std::vector<info::fp_config>;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ A [code]#std::vector# of [api]#info::fp_config# values describing the
half precision floating-point capability of this device.
The [code]#std::vector# may contain zero or more of the following values:

* [api]#info::fp_config::denorm#
* [api]#info::fp_config::inf_nan#
* [api]#info::fp_config::round_to_nearest#
* [api]#info::fp_config::round_to_zero#
* [api]#info::fp_config::round_to_inf#
* [api]#info::fp_config::fma#
* [api]#info::fp_config::correctly_rounded_divide_sqrt#
* [api]#info::fp_config::soft_float#

If half precision is supported by this device (i.e. the device has
[api]#aspect::fp16#) there is no minimum floating-point capability.
If half support is not supported the returned [code]#std::vector# must be empty.

'''

.[apidef]#info::device::single_fp_config#
[source,role=synopsis,id=api:info-device-single-fp-config]
----
namespace sycl::info::device {
struct single_fp_config {
  using return_type = std::vector<info::fp_config>;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ A [code]#std::vector# of [api]#info::fp_config# values describing the
single precision floating-point capability of this device.
The [code]#std::vector# must contain one or more of the following values:

* [api]#info::fp_config::denorm#
* [api]#info::fp_config::inf_nan#
* [api]#info::fp_config::round_to_nearest#
* [api]#info::fp_config::round_to_zero#
* [api]#info::fp_config::round_to_inf#
* [api]#info::fp_config::fma#
* [api]#info::fp_config::correctly_rounded_divide_sqrt#
* [api]#info::fp_config::soft_float#

If this device is not of type [api]#info::device_type::custom# then the minimum
floating-point capability must be: [api]#info::fp_config::round_to_nearest# and
[api]#info::fp_config::inf_nan#.

'''

.[apidef]#info::device::double_fp_config#
[source,role=synopsis,id=api:info-device-double-fp-config]
----
namespace sycl::info::device {
struct double_fp_config {
  using return_type = std::vector<info::fp_config>;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ A [code]#std::vector# of [api]#info::fp_config# values describing the
double precision floating-point capability of this device.
The [code]#std::vector# may contain zero or more of the following values:

* [api]#info::fp_config::denorm#
* [api]#info::fp_config::inf_nan#
* [api]#info::fp_config::round_to_nearest#
* [api]#info::fp_config::round_to_zero#
* [api]#info::fp_config::round_to_inf#
* [api]#info::fp_config::fma#
* [api]#info::fp_config::soft_float#

If double precision is supported by this device (i.e. the device has
[api]#aspect::fp64#) and this device is not of type
[api]#info::device_type::custom# then the minimum floating-point capability must
be: [api]#info::fp_config::fma#, [api]#info::fp_config::round_to_nearest#,
[api]#info::fp_config::round_to_zero#, [api]#info::fp_config::round_to_inf#,
[api]#info::fp_config::inf_nan# and [api]#info::fp_config::denorm#.
If double support is not supported the returned [code]#std::vector# must be
empty.

'''

.[apidef]#info::device::global_mem_cache_type#
[source,role=synopsis,id=api:info-device-global-mem-cache-type]
----
namespace sycl::info::device {
struct global_mem_cache_type {
  using return_type = info::global_mem_cache_type;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The type of global memory cache supported.

'''

.[apidef]#info::device::global_mem_cache_line_size#
[source,role=synopsis,id=api:info-device-global-mem-cache-line-size]
----
namespace sycl::info::device {
struct global_mem_cache_line_size {
  using return_type = uint32_t;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The size of global memory cache line in bytes.

'''

.[apidef]#info::device::global_mem_cache_size#
[source,role=synopsis,id=api:info-device-global-mem-cache-size]
----
namespace sycl::info::device {
struct global_mem_cache_size {
  using return_type = uint64_t;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The size of global memory cache in bytes.

'''

.[apidef]#info::device::global_mem_size#
[source,role=synopsis,id=api:info-device-global-mem-size]
----
namespace sycl::info::device {
struct global_mem_size {
  using return_type = uint64_t;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The size of global device memory in bytes.

'''

.[apidef]#info::device::max_constant_buffer_size#
[source,role=synopsis,id=api:info-device-max-constant-buffer-size]
----
namespace sycl::info::device {
struct max_constant_buffer_size {
  using return_type = uint64_t;
};
} // namespace sycl::info::device
----

Deprecated by SYCL 2020.

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The maximum size in bytes of a constant buffer allocation.
The minimum value is 64 KB if this device is not of type
[api]#info::device_type::custom#.

'''

.[apidef]#info::device::max_constant_args#
[source,role=synopsis,id=api:info-device-max-constant-args]
----
namespace sycl::info::device {
struct max_constant_args {
  using return_type = uint32_t;
};
} // namespace sycl::info::device
----

Deprecated by SYCL 2020.

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The maximum number of constant arguments that can be declared in a
kernel.
The minimum value is 8 if this device is not of type
[api]#info::device_type::custom#.

'''

.[apidef]#info::device::local_mem_type#
[source,role=synopsis,id=api:info-device-local-mem-type]
----
namespace sycl::info::device {
struct local_mem_type {
  using return_type = info::local_mem_type;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The type of local memory supported.
This can be [api]#info::local_mem_type::local# implying dedicated local memory
storage such as SRAM, or [api]#info::local_mem_type::global#.
If this device is of type [api]#info::device_type::custom# this can also be
[api]#info::local_mem_type::none#, indicating local memory is not supported.

'''

.[apidef]#info::device::local_mem_size#
[source,role=synopsis,id=api:info-device-local-mem-size]
----
namespace sycl::info::device {
struct local_mem_size {
  using return_type = uint64_t;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The size of local memory arena in bytes.
The minimum value is 32 KB if this device is not of type
[api]#info::device_type::custom#.

'''

.[apidef]#info::device::error_correction_support#
[source,role=synopsis,id=api:info-device-error-correction-support]
----
namespace sycl::info::device {
struct error_correction_support {
  using return_type = bool;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The value [code]#true# if the device implements error correction for
all accesses to compute device memory (global and constant).
Returns [coee]#false# if the device does not implement such error correction.

'''

.[apidef]#info::device::host_unified_memory#
[source,role=synopsis,id=api:info-device-host-unified-memory]
----
namespace sycl::info::device {
struct host_unified_memory {
  using return_type = bool;
};
} // namespace sycl::info::device
----

Deprecated by SYCL 2020.

{note}Use [api]#device::has# with one of the [code]#aspect::usm_*# aspects
instead.
{endnote}

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The value [coee]#true# if the device and the host have a unified
memory subsystem and returns [code]#false# otherwise.

'''

.[apidef]#info::device::atomic_memory_order_capabilities#
[source,role=synopsis,id=api:info-device-atomic-memory-order-capabilities]
----
namespace sycl::info::device {
struct atomic_memory_order_capabilities {
  using return_type = std::vector<memory_order>;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The set of memory orders supported by atomic operations on this
device.
When a device returns a "stronger" memory order in this set, it must also return
all "weaker" memory orders.
(See <<sec:memory-ordering>> for a definition of "stronger" and "weaker" memory
orders.)
The memory orders [code]#memory_order::acquire#, [code]#memory_order::release#,
and [code]#memory_order::acq_rel# are all the same strength.
If a device returns one of these, it must return them all.

At a minimum, each device must support [code]#memory_order::relaxed#.

'''

.[apidef]#info::device::atomic_fence_order_capabilities#
[source,role=synopsis,id=api:info-device-atomic-fence-order-capabilities]
----
namespace sycl::info::device {
struct atomic_fence_order_capabilities {
  using return_type = std::vector<memory_order>;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The set of memory orders supported by [code]#atomic_fence# on this
device.
When a device returns a "stronger" memory order in this set, it must also return
all "weaker" memory orders.
(See <<sec:memory-ordering>> for a definition of "stronger" and "weaker" memory
orders.)
At a minimum, each device must support [code]#memory_order::relaxed#,
[code]#memory_order::acquire#, [code]#memory_order::release#, and
[code]#memory_order::acq_rel#.

'''

.[apidef]#info::device::atomic_memory_scope_capabilities#
[source,role=synopsis,id=api:info-device-atomic-memory-scope-capabilities]
----
namespace sycl::info::device {
struct atomic_memory_scope_capabilities {
  using return_type = std::vector<memory_scope>;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The set of memory scopes supported by atomic operations on this
device.
When a device returns a "wider" memory scope in this set, it must also return
all "narrower" memory scopes.
(See <<sec:memory-scope>> for a definition of "wider" and "narrower" scopes.)
At a minimum, each device must support [code]#memory_scope::work_item#,
[code]#memory_scope::sub_group#, and [code]#memory_scope::work_group#.

'''

.[apidef]#info::device::atomic_fence_scope_capabilities#
[source,role=synopsis,id=api:info-device-atomic-fence-scope-capabilities]
----
namespace sycl::info::device {
struct atomic_fence_scope_capabilities {
  using return_type = std::vector<memory_scope>;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The set of memory scopes supported by [code]#atomic_fence# on this
device.
When a device returns a "wider" memory scope in this set, it must also return
all "narrower" memory scopes.
(See <<sec:memory-scope>> for a definition of "wider" and "narrower" scopes.)
At a minimum, each device must support [code]#memory_scope::work_item#,
[code]#memory_scope::sub_group#, and [code]#memory_scope::work_group#.

'''

.[apidef]#info::device::profiling_timer_resolution#
[source,role=synopsis,id=api:info-device-profiling-timer-resolution]
----
namespace sycl::info::device {
struct profiling_timer_resolution {
  using return_type = size_t;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The resolution of device timer in nanoseconds.

'''

.[apidef]#info::device::is_endian_little#
[source,role=synopsis,id=api:info-device-is-endian-little]
----
namespace sycl::info::device {
struct is_endian_little {
  using return_type = bool;
};
} // namespace sycl::info::device
----

Deprecated by SYCL 2020.

{note}Check the byte order of the host system instead.
The host and device are required to have the same byte order.
{endnote}

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The value [code]#true# if this device is a little endian device and
returns [code]#false# otherwise.

'''

.[apidef]#info::device::is_available#
[source,role=synopsis,id=api:info-device-is-available]
----
namespace sycl::info::device {
struct is_available {
  using return_type = bool;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The value [code]#true# if the device is available and [code]#false#
if the device is not available.
A device is considered to be available if the device can be expected to
successfully execute commands enqueued to the device.
The conditions that lead to a device being considered available or not available
are implementation-defined.

'''

.[apidef]#info::device::is_compiler_available#
[source,role=synopsis,id=api:info-device-is-compiler-available]
----
namespace sycl::info::device {
struct is_compiler_available {
  using return_type = bool;
};
} // namespace sycl::info::device
----

Deprecated by SYCL 2020.

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The same value as [code]#device::has(aspect::online_compiler)#.

'''

.[apidef]#info::device::is_linker_available#
[source,role=synopsis,id=api:info-device-is-linker-available]
----
namespace sycl::info::device {
struct is_linker_available {
  using return_type = bool;
};
} // namespace sycl::info::device
----

Deprecated by SYCL 2020.

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The same value as [code]#device::has(aspect::online_linker)#.

'''

.[apidef]#info::device::execution_capabilities#
[source,role=synopsis,id=api:info-device-execution-capabilities]
----
namespace sycl::info::device {
struct execution_capabilities {
  using return_type = std::vector<info::execution_capability>;
};
} // namespace sycl::info::device
----

Deprecated by SYCL 2020.

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ Only supported when the backend of this device is OpenCL (see
<<chapter:opencl-backend>>).
Returns a [code]#std::vector# of the [api]#info::execution_capability# values
describing the supported execution capabilities.
Unless the device type is [api]#info::device_type::custom#, the returned vector
will always include [api]#info::execution_capability::exec_kernel#.

_Throws:_ An [code]#exception# with the [code]#errc::invalid# error code if the
backend of this device is not OpenCL.

'''

.[apidef]#info::device::queue_profiling#
[source,role=synopsis,id=api:info-device-queue-profiling]
----
namespace sycl::info::device {
struct queue_profiling {
  using return_type = bool;
};
} // namespace sycl::info::device
----

Deprecated by SYCL 2020.

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The same value as [code]#device::has(aspect::queue_profiling)#.

'''

.[apidef]#info::device::built_in_kernel_ids#
[source,role=synopsis,id=api:info-device-built-in-kernel-ids]
----
namespace sycl::info::device {
struct built_in_kernel_ids {
  using return_type = std::vector<kernel_id>;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ A [code]#std::vector# of identifiers for the built-in kernels
supported by this device.

'''

.[apidef]#info::device::built_in_kernels#
[source,role=synopsis,id=api:info-device-built-in-kernels]
----
namespace sycl::info::device {
struct built_in_kernels {
  using return_type = std::vector<std::string>;
};
} // namespace sycl::info::device
----

Deprecated by SYCL 2020.

{note}Use [api]#info::device::built_in_kernel_ids# instead.
{endnote}

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ A [code]#std::vector# of built-in OpenCL kernels supported by this
device.

'''

.[apidef]#info::device::platform#
[source,role=synopsis,id=api:info-device-platform]
----
namespace sycl::info::device {
struct platform {
  using return_type = platform;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The <<platform>> that is associated with this device.

'''

.[apidef]#info::device::name#
[source,role=synopsis,id=api:info-device-name]
----
namespace sycl::info::device {
struct name {
  using return_type = std::string;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ An implementation-defined name for this device.

'''

.[apidef]#info::device::vendor#
[source,role=synopsis,id=api:info-device-vendor]
----
namespace sycl::info::device {
struct vendor {
  using return_type = std::string;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ An implementation-defined name for the vendor providing this device.

'''

.[apidef]#info::device::driver_version#
[source,role=synopsis,id=api:info-device-driver-version]
----
namespace sycl::info::device {
struct driver_version {
  using return_type = std::string;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ An implementation-defined name describing the version of the
underlying software driver for this device.

'''

.[apidef]#info::device::profile#
[source,role=synopsis,id=api:info-device-profile]
----
namespace sycl::info::device {
struct profile {
  using return_type = std::string;
};
} // namespace sycl::info::device
----

Deprecated by SYCL 2020.

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ Only supported when the backend of this device is OpenCL (see
<<chapter:opencl-backend>>).
The value returned can be one of the following strings:

* FULL_PROFILE - if the device supports the OpenCL specification (functionality
  defined as part of the core specification and does not require any extensions
  to be supported).
* EMBEDDED_PROFILE - if the device supports the OpenCL embedded profile.

_Throws:_ An [code]#exception# with the [code]#errc::invalid# error code if the
backend of this device is not OpenCL.

'''

.[apidef]#info::device::version#
[source,role=synopsis,id=api:info-device-version]
----
namespace sycl::info::device {
struct version {
  using return_type = std::string;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ A backend-defined device version.

'''

.[apidef]#info::device::backend_version#
[source,role=synopsis,id=api:info-device-backend-version]
----
namespace sycl::info::device {
struct backend_version {
  using return_type = std::string;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ A string describing the version of the <<backend>> associated with
this device.
The value returned from this query is defined by the backend interoperation
specification that corresponds to this device's backend.

'''

.[apidef]#info::device::aspects#
[source,role=synopsis,id=api:info-device-aspects]
----
namespace sycl::info::device {
struct aspects {
  using return_type = std::vector<aspect>;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ A [code]#std::vector# of <<aspect>> values supported by this device.

'''

.[apidef]#info::device::extensions#
[source,role=synopsis,id=api:info-device-extensions]
----
namespace sycl::info::device {
struct extensions {
  using return_type = std::vector<std::string>;
};
} // namespace sycl::info::device
----

Deprecated by SYCL 2020.

{note}Use [api]#info::device::aspects# instead.
{endnote}

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ A [code]#std::vector# of extension names (the extension names do not
contain any spaces) supported by this device.
The extension names returned can be vendor supported extension names and one or
more of the following Khronos approved extension names:

* [code]#cl_khr_int64_base_atomics#
* [code]#cl_khr_int64_extended_atomics#
* [code]#cl_khr_3d_image_writes#
* [code]#cl_khr_fp16#
* [code]#cl_khr_gl_sharing#
* [code]#cl_khr_gl_event#
* [code]#cl_khr_d3d10_sharing#
* [code]#cl_khr_dx9_media_sharing#
* [code]#cl_khr_d3d11_sharing#
* [code]#cl_khr_depth_images#
* [code]#cl_khr_gl_depth_images#
* [code]#cl_khr_gl_msaa_sharing#
* [code]#cl_khr_image2d_from_buffer#
* [code]#cl_khr_initialize_memory#
* [code]#cl_khr_context_abort#
* [code]#cl_khr_spir#

If the backend associated with this device is OpenCL, then following approved
Khronos extension names must be returned by all device that support OpenCL C
1.2:

* [code]#cl_khr_global_int32_base_atomics#
* [code]#cl_khr_global_int32_extended_atomics#
* [code]#cl_khr_local_int32_base_atomics#
* [code]#cl_khr_local_int32_extended_atomics#
* [code]#cl_khr_byte_addressable_store#
* [code]#cl_khr_fp64# (for backward compatibility if double precision is
  supported)

Please refer to the OpenCL 1.2 Extension Specification for a detailed
description of these extensions.

'''

.[apidef]#info::device::printf_buffer_size#
[source,role=synopsis,id=api:info-device-printf-buffer-size]
----
namespace sycl::info::device {
struct printf_buffer_size {
  using return_type = size_t;
};
} // namespace sycl::info::device
----

Deprecated by SYCL 2020.

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The maximum size of the internal buffer that holds the output of
[code]#printf# calls from a kernel.
The minimum value is 1 MB if [api]#info::device::profile# returns true for this
device.

'''

.[apidef]#info::device::preferred_interop_user_sync#
[source,role=synopsis,id=api:info-device-preferred-interop-user-sync]
----
namespace sycl::info::device {
struct preferred_interop_user_sync {
  using return_type = bool;
};
} // namespace sycl::info::device
----

Deprecated by SYCL 2020.

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ Only supported when the backend of this device is OpenCL (see
<<chapter:opencl-backend>>).
Returns [code]#true# if the preference for this device is for the user to be
responsible for synchronization, when sharing memory objects between OpenCL and
other APIs such as DirectX, [code]#false# if the device/implementation has a
performant path for performing synchronization of memory object shared between
OpenCL and other APIs such as DirectX.

_Throws:_ An [code]#exception# with the [code]#errc::invalid# error code if the
backend of this device is not OpenCL.

'''

.[apidef]#info::device::parent_device#
[source,role=synopsis,id=api:info-device-parent-device]
----
namespace sycl::info::device {
struct parent_device {
  using return_type = device;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The parent device to which this sub device is a child if this is a
sub device.

_Throws:_ An [code]#exception# with the [code]#errc::invalid# error code if this
device is not a sub device.

'''

.[apidef]#info::device::partition_max_sub_devices#
[source,role=synopsis,id=api:info-device-partition-max-sub-devices]
----
namespace sycl::info::device {
struct partition_max_sub_devices {
  using return_type = uint32_t;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The maximum number of sub devices that can be created when this
device is partitioned.
The value returned cannot exceed the value returned by
[api]#info::device::max_compute_units#.

'''

.[apidef]#info::device::partition_properties#
[source,role=synopsis,id=api:info-device-partition-properties]
----
namespace sycl::info::device {
struct partition_properties {
  using return_type = std::vector<info::partition_property>;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ A [code]#std::vector# of the partition properties supported by this
device.
An element is returned in this vector only if the device can be partitioned into
at least two sub devices along that partition property.

'''

.[apidef]#info::device::partition_affinity_domains#
[source,role=synopsis,id=api:info-device-partition-affinity-domains]
----
namespace sycl::info::device {
struct partition_affinity_domains {
  using return_type = std::vector<info::partition_affinity_domain>;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ A [code]#std::vector# of the partition affinity domains supported by
this device when partitioning with
[api]#info::partition_property::partition_by_affinity_domain#.
An element is returned in this vector only if the device can be partitioned into
at least two sub devices along that affinity domain.

'''

.[apidef]#info::device::partition_type_property#
[source,role=synopsis,id=api:info-device-partition-type-property]
----
namespace sycl::info::device {
struct partition_type_property {
  using return_type = info::partition_property;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The partition property of this device.
If this device is not a sub device then the return value is
[api]#info::partition_property::no_partition#, otherwise it is one of the
following values:

* [api]#info::partition_property::partition_equally#
* [api]#info::partition_property::partition_by_counts#
* [api]#info::partition_property::partition_by_affinity_domain#

'''

.[apidef]#info::device::partition_type_affinity_domain#
[source,role=synopsis,id=api:info-device-partition-type-affinity-domain]
----
namespace sycl::info::device {
struct partition_type_affinity_domain {
  using return_type = info::partition_affinity_domain;
};
} // namespace sycl::info::device
----

_Remarks:_ Template parameter to [api]#device::get_info#.

_Returns:_ The partition affinity domain of this device.
If this device is not a sub device or the sub device was not partitioned with
[api]#info::partition_property::partition_by_affinity_domain# then the return
value is [api]#info::partition_affinity_domain::not_applicable#, otherwise it is
one of the following values:

* [api]#info::partition_affinity_domain::numa#
* [api]#info::partition_affinity_domain::L4_cache#
* [api]#info::partition_affinity_domain::L3_cache#
* [api]#info::partition_affinity_domain::L2_cache#
* [api]#info::partition_affinity_domain::L1_cache#

'''

[[sec:device-aspects]]
==== Aspects

Every device has an associated set of aspects which identify characteristics of
the device.
Aspects are defined via the [code]#aspect# enumeration:

[source,role=synopsis]
----
include::{header_dir}/deviceEnumClassAspect.h[lines=4..-1]
----

Applications can query the aspects of a device via [api]#device::has# in order
to determine whether the device supports any optional features.
The following list describes the aspects that are defined in the <<core-spec>>
and tells which optional features correspond to each.
Backends and extensions may provide additional aspects and additional optional
device features.
If so, the <<backend>> specification document or the extension document
describes them.

'''

.[apidef]#aspect::cpu#
[role=synopsis,id=api:aspect-cpu]
--
Indicates that the implementation identifies this device as a CPU that has
device type [api]#info::device_type::cpu#.

{note}A device with this aspect will typically share some or all of the
execution resources available to the host {cpp} application.
{endnote}
--

'''

.[apidef]#aspect::gpu#
[role=synopsis,id=api:aspect-gpu]
--
Indicates that the implementation identifies this device as a GPU that has
device type [api]#info::device_type::gpu#.

{note}A device with this aspect may have additional capabilities for
accelerating graphics operations, via SYCL image functionality and/or
interoperability with graphics APIs.
{endnote}
--

'''

.[apidef]#aspect::accelerator#
[role=synopsis,id=api:aspect-accelerator]
--
Indicates that the implementation identifies this device as an accelerator that
has device type [api]#info::device_type::accelerator#.

{note}A device with this aspect will typically be a dedicated accelerator
device, with a peripheral interconnect for communication.
{endnote}
--

'''

.[apidef]#aspect::custom#
[role=synopsis,id=api:aspect-custom]
--
Indicates that this device is a custom accelerator that exposes only fixed
functionality, and has device type [api]#info::device_type::custom#.

A device with this aspect does not support execution of arbitrary kernels, and
can only execute pre-defined kernels (see <<sec:pre-defined-kernels>>).
--

'''

.[apidef]#aspect::emulated#
[role=synopsis,id=api:aspect-emulated]
--
Indicates that the device is somehow emulated.

A device with this aspect is not intended for performance, and instead will
generally have another purpose such as emulation or profiling.
The precise definition of this aspect is left open to the SYCL implementation.

{note}As an example, a vendor might support both a hardware FPGA device and a
software emulated FPGA, where the emulated FPGA has all the same features as the
hardware one but runs more slowly and can provide additional profiling or
diagnostic information.
In such a case, an application's <<device-selector>> can use
[api]#aspect::emulated# to distinguish the two.
{endnote}
--

'''

.[apidef]#aspect::host_debuggable#
[role=synopsis,id=api:aspect-host-debuggable]
--
Indicates that <<kernel,kernels>> running on this device can be debugged using
standard debuggers that are normally available on the host system where the SYCL
implementation resides.
The precise definition of this aspect is left open to the SYCL implementation.
--

'''

.[apidef]#aspect::fp16#
[role=synopsis,id=api:aspect-fp16]
--
Indicates that kernels submitted to the device may use the [code]#sycl::half#
data type.
--

'''

.[apidef]#aspect::fp64#
[role=synopsis,id=api:aspect-fp64]
--
Indicates that kernels submitted to the device may use the [code]#double# data
type.
--

'''

.[apidef]#aspect::atomic64#
[role=synopsis,id=api:aspect-atomic64]
--
Indicates that kernels submitted to the device may perform 64-bit atomic
operations.
--

'''

.[apidef]#aspect::image#
[role=synopsis,id=api:aspect-image]
--
Indicates that the device supports <<subsec:images, images>>.
--

'''

.[apidef]#aspect::online_compiler#
[role=synopsis,id=api:aspect-online-compiler]
--
Indicates that the device supports online compilation of device code.
Devices that have this aspect support the [code]#build# and [code]#compile#
functions defined in <<sec:bundles.compile-link>>.
--

'''

.[apidef]#aspect::online_linker#
[role=synopsis,id=api:aspect-online-linker]
--
Indicates that the device supports online linking of device code.
Devices that have this aspect support the [code]#link# functions defined in
<<sec:bundles.compile-link>>.
All devices that have this aspect also have [api]#aspect::online_compiler#.
--

'''

.[apidef]#aspect::queue_profiling#
[role=synopsis,id=api:aspect-queue-profiling]
--
Indicates that the device supports queue profiling via
[code]#property::queue::enable_profiling#.
--

'''

.[apidef]#aspect::usm_device_allocations#
[role=synopsis,id=api:aspect-usm-device-allocations]
--
Indicates that the device supports explicit USM allocations as described in
<<sec:usm>>.
--

'''

.[apidef]#aspect::usm_host_allocations#
[role=synopsis,id=api:aspect-usm-host-allocations]
--
Indicates that the device can access USM memory allocated via
[code]#usm::alloc::host#.
The device only supports atomic modification of a host allocation if
[api]#aspect::usm_atomic_host_allocations# is also supported.
(See <<sec:usm>>.)
--

'''

.[apidef]#aspect::usm_atomic_host_allocations#
[role=synopsis,id=api:aspect-usm-atomic-host-allocations]
--
Indicates that the device supports USM memory allocated via
[code]#usm::alloc::host#.
The host and this device may concurrently access and atomically modify host
allocations.
(See <<sec:usm>>.)
--

'''

.[apidef]#aspect::usm_shared_allocations#
[role=synopsis,id=api:aspect-usm-shared-allocations]
--
Indicates that the device supports USM memory allocated via
[code]#usm::alloc::shared# on the same device.
Concurrent access and atomic modification of a shared allocation is only
supported if [api]#aspect::usm_atomic_shared_allocations# is also supported.
(See <<sec:usm>>.)
--

'''

.[apidef]#aspect::usm_atomic_shared_allocations#
[role=synopsis,id=api:aspect-usm-atomic-shared-allocations]
--
Indicates that the device supports USM memory allocated via
[code]#usm::alloc::shared#.
The host and other devices in the same context that also support this capability
may concurrently access and atomically modify shared allocations.
The allocation is free to migrate between the host and the appropriate devices.
(See <<sec:usm>>.)
--

'''

.[apidef]#aspect::usm_system_allocations#
[role=synopsis,id=api:aspect-usm-system-allocations]
--
Indicates that the system allocator may be used instead of SYCL USM allocation
mechanisms for [code]#usm::alloc::shared# allocations on this device.
(See <<sec:usm>>.)
--

'''

[[sec:device-aspect-traits]]
==== Aspect traits

The implementation also provides two traits that the application can use to
query aspects at compilation time.
The traits [code]#any_device_has<aspect># and [code]#all_devices_have<aspect>#
are set according to the collection of devices _D_ that can possibly execute
device code, as determined by the compilation environment.
The trait [code]#any_device_has<aspect># inherits from [code]#std::true_type#
only if at least one device in _D_ has the specified aspect.
The trait [code]#all_devices_have<aspect># inherits from [code]#std::true_type#
only if all devices in _D_ have the specified aspect.

[source,role=synopsis]
----
include::{header_dir}/aspectTraits.h[lines=4..-1]
----

Applications can use these traits to reduce their code size.
The following example demonstrates one way to use these traits to avoid
instantiating a templated kernel for device features that are not supported by
any device.

[source,,linenums]
----
include::{code_dir}/aspectTraitExample.cpp[lines=4..-1]
----

The kernel function [code]#MyKernel# is templated to use a different algorithm
depending on whether the device has the aspect [api]#aspect::fp16#, and the call
to [code]#dev.has()# chooses the kernel function instantiation that matches the
device's capabilities.
However, the use of [code]#any_device_has_v# and [code]#all_devices_have_v#
entirely avoid useless instantiations of the kernel function.
For example, when the compilation environment does not support any devices with
[api]#aspect::fp16#, [code]#any_device_has_v<aspect::fp16># is [code]#false#,
and the kernel function is never instantiated with support for the
[code]#sycl::half# type.

{note}Like any trait, the definitions of [code]#any_device_has# and
[code]#all_devices_have# are uniform across all parts of a SYCL application.
If an implementation uses <<smcp>>, all compiler passes define a particular
aspect's specialization of the traits the same way, regardless of whether that
compiler pass' device supports the aspect.
Thus, [code]#any_device_has# and [code]#all_devices_have# cannot be used to
determine whether any particular device supports an aspect.
Instead, applications must use [api]#device::has# or [code]#platform::has# for
this.
{endnote}

{note}An implementation could choose to provide command line options which
affect the set of devices that it supports.
If so, those command line options would also affect these traits.
For example, if an implementation provides a command line option that disables
[api]#aspect::accelerator# devices, the trait
[code]#any_device_has<aspect::accelerator># would inherit from
[code]#std::false_type# when that command line option was specified.
{endnote}

{note}These traits only reflect the supported devices at the time the SYCL
application is compiled.
It's possible that unsupported devices are still visible to the application when
it runs.
However, if a device _D_ is not supported when the application is compiled, the
application will not be able to submit kernels to that device _D_.
{endnote}

[[sec:device-other-enumerations]]
==== Other enumerations

[[sec:device-enum-device-type]]
===== Device type

[source,role=synopsis]
----
namespace sycl::info {
enum class device_type : /* unspecified */ {
  cpu,         // Maps to OpenCL CL_DEVICE_TYPE_CPU
  gpu,         // Maps to OpenCL CL_DEVICE_TYPE_GPU
  accelerator, // Maps to OpenCL CL_DEVICE_TYPE_ACCELERATOR
  custom,      // Maps to OpenCL CL_DEVICE_TYPE_CUSTOM
  automatic,   // Maps to OpenCL CL_DEVICE_TYPE_DEFAULT
  host,
  all // Maps to OpenCL CL_DEVICE_TYPE_ALL
};
} // namespace sycl::info
----

[[sec:device-enum-partition-property]]
===== Partition property

[source,role=synopsis]
----
namespace sycl::info {
enum class partition_property : /* unspecified */ {
  no_partition,
  partition_equally,
  partition_by_counts,
  partition_by_affinity_domain
};
} // namespace sycl::info
----

[[sec:device-enum-partition-affinity-domain]]
===== Partition affinity domain

[source,role=synopsis]
----
namespace sycl::info {
enum class partition_affinity_domain : /* unspecified */ {
  not_applicable,
  numa,
  L4_cache,
  L3_cache,
  L2_cache,
  L1_cache,
  next_partitionable
};
} // namespace sycl::info
----

[[sec:device-enum-fp-config]]
===== Floating point configuration

The [code]#info::fp_config# enumeration tells the behavior of floating point
operations on a device.

[source,role=synopsis]
----
namespace sycl::info {
enum class fp_config : /* unspecified */ {
  denorm,
  inf_nan,
  round_to_nearest,
  round_to_zero,
  round_to_inf,
  fma,
  correctly_rounded_divide_sqrt,
  soft_float
};
} // namespace sycl::info
----

'''

.[apidef]#info::fp_config::denorm#
[role=synopsis,id=api:info-fp-config-denorm]
--
Denormalized numbers are supported.
--

'''

.[apidef]#info::fp_config::inf_nan#
[role=synopsis,id=api:info-fp-config-inf-nan]
--
INF and NaNs are supported.
--

'''

.[apidef]#info::fp_config::round_to_nearest#
[role=synopsis,id=api:info-fp-config-round-to-nearest]
--
Round to nearest even rounding mode is supported.
--

'''

.[apidef]#info::fp_config::round_to_zero#
[role=synopsis,id=api:info-fp-config-round-to-zero]
--
Round to zero rounding mode is supported.
--

'''

.[apidef]#info::fp_config::round_to_inf#
[role=synopsis,id=api:info-fp-config-round-to-inf]
--
Round to positive and negative infinity rounding modes are supported.
--

'''

.[apidef]#info::fp_config::fma#
[role=synopsis,id=api:info-fp-config-fma]
--
IEEE754-2008 fused multiply-add is supported.
--

'''

.[apidef]#info::fp_config::correctly_rounded_divide_sqrt#
[role=synopsis,id=api:info-fp-config-correctly-rounded-divide-sqrt]
--
Deprecated by SYCL 2020.

Divide and sqrt are correctly rounded as defined by the IEEE754 specification.
--

'''

.[apidef]#info::fp_config::soft_float#
[role=synopsis,id=api:info-fp-config-soft-float]
--
Basic floating-point operations (such as addition, subtraction, multiplication)
are implemented in software.
--

'''

[[sec:device-enum-local-mem-type]]
===== Local memory type

[source,role=synopsis]
----
namespace sycl::info {
enum class local_mem_type : /* unspecified */ {
  none,
  local,
  global
};
} // namespace sycl::info
----

[[sec:device-enum-global-mem-cache-type]]
===== Global memory cache type

[source,role=synopsis]
----
namespace sycl::info {
enum class global_mem_cache_type : /* unspecified */ {
  none,
  read_only,
  read_write
};
} // namespace sycl::info
----

[[sec:device-enum-execution-capability]]
===== Execution capability

Deprecated by SYCL 2020.

The [code]#info::execution_capability# enumeration tells the type of kernels
that can be submitted to a device from the OpenCL backend.

[source,role=synopsis]
----
namespace sycl::info {
enum class execution_capability : /* unspecified */ {
  exec_kernel,
  exec_native_kernel
};
} // namespace sycl::info
----

'''

.[apidef]#info::execution_capability::exec_kernel#
[role=synopsis,id=api:info-execution-capability-exec-kernel]
--
Device can execute SYCL kernels.
--

'''

.[apidef]#info::execution_capability::exec_native_kernel#
[role=synopsis,id=api:info-execution-capability-exec-native-kernel]
--
Device can execute native OpenCL kernels.
--

'''


[[sec:queue-class]]
=== Queue class

The [code]#queue# class encapsulates a single SYCL queue which schedules kernels
on a device.

A [code]#queue# can be used to submit <<command-group,command groups>> to be
executed by the <<sycl-runtime>> using the [api]#queue::submit# member function.

All member functions of the [code]#queue# class are synchronous and errors are
handled by throwing synchronous SYCL exceptions.
The [api]#queue::submit# member function synchronously invokes the provided
<<command-group-function-object>> (as described in
<<sec:command-groups-exec-order>>) in the calling thread, thereby scheduling a
<<command-group>> for asynchronous execution.
Any error in the submission of a <<command-group>> is handled by throwing a
synchronous SYCL exception.
Any errors from the <<command-group>> after it has been submitted are handled by
passing <<async-error,asynchronous errors>> at specific times to an
<<async-handler>>, as described in <<error-handling>>.

The application can wait for all <<command-group,command groups>> submitted to a
queue calling [api]#queue::wait# or [api]#queue::wait_and_throw#.

A queue may be destroyed even when there are uncompleted <<command, commands>>
that have been submitted to the queue.
Doing so does not block.
Instead, any commands that have been submitted to the queue begin execution when
their requisites are satisfied, just as they would had the queue not been
destroyed.
Any event objects for those commands are signaled in the normal manner when the
command completes.
Resources associated with the queue are freed by the time the last command
completes.

The [code]#queue# class provides the common reference semantics as defined in
<<sec:reference-semantics>>.

[source,role=synopsis,subs="attributes+"]
----
include::{header_dir}/queue.h[lines=4..-1]
----

[[sec:queue-ctors]]
==== Constructors

All queue constructors take a parameter named [code]#propList# which allows the
application to pass zero or more properties.
These properties may specify additional effects of the constructor and may also
specify exceptions that the constructor throws.
See <<sec:queue-properties>> for the queue properties that are defined by the
<<core-spec>>.

'''

.[apititle]#Default constructor#
[source,role=synopsis,id=api:queue-ctor]
----
explicit queue(const property_list& propList = {})
----

_Effects:_ Constructs a [code]#queue# object using the device selected by
[code]#default_selector_v#.
The queue's platform is the platform that contains this device.
The queue's context is this platform's default context as described in
<<sec:platform-class>>.

'''

.[apititle]#Constructor with async handler#
[source,role=synopsis,id=api:queue-ctor-async-handler]
----
explicit queue(const async_handler& asyncHandler,
               const property_list& propList = {})
----

_Effects:_ Constructs a [code]#queue# object using the device selected by
[code]#default_selector_v#.
The queue's platform is the platform that contains this device.
The queue's context is this platform's default context as described in
<<sec:platform-class>>.
The queue has the asynchronous error handler [code]#asyncHandler#.

'''

.[apititle]#Constructor with device selector#
[source,role=synopsis,id=api:queue-ctor-selector]
----
template <typename DeviceSelector>
explicit queue(const DeviceSelector& deviceSelector,
               const property_list& propList = {})
----

_Constraints:_ Available only when the [code]#DeviceSelector# is a type that
satisfies the requirements of a <<device-selector>> as defined in
<<sec:device-selector>>.

_Effects:_ The [code]#deviceSelector# is called for every <<root-device>> as
described in <<sec:device-selector>>, and a [code]#queue# object is constructed
using the device it selects.
The queue's platform is the platform that contains this device.
The queue's context is this platform's default context as described in
<<sec:platform-class>>.

'''

.[apititle]#Constructor with device selector and async handler#
[source,role=synopsis,id=api:queue-ctor-selector-async-handler]
----
template <typename DeviceSelector>
explicit queue(const DeviceSelector& deviceSelector,
               const async_handler& asyncHandler,
               const property_list& propList = {})
----

_Constraints:_ Available only when the [code]#DeviceSelector# is a type that
satisfies the requirements of a <<device-selector>> as defined in
<<sec:device-selector>>.

_Effects:_ The [code]#deviceSelector# is called for every <<root-device>> as
described in <<sec:device-selector>>, and a [code]#queue# object is constructed
using the device it selects.
The queue's platform is the platform that contains this device.
The queue's context is this platform's default context as described in
<<sec:platform-class>>.
The queue has the asynchronous error handler [code]#asyncHandler#.

'''

.[apititle]#Constructor with device#
[source,role=synopsis,id=api:queue-ctor-device]
----
explicit queue(const device& syclDevice, const property_list& propList = {})
----

_Effects:_ Constructs a [code]#queue# object using the device
[code]#syclDevice#.
The queue's platform is the platform that contains this device.
The queue's context is this platform's default context as described in
<<sec:platform-class>>.

'''

.[apititle]#Constructor with device and async handler#
[source,role=synopsis,id=api:queue-ctor-device-async-handler]
----
explicit queue(const device& syclDevice, const async_handler& asyncHandler,
               const property_list& propList = {})
----

_Effects:_ Constructs a [code]#queue# object using the device
[code]#syclDevice#.
The queue's platform is the platform that contains this device.
The queue's context is this platform's default context as described in
<<sec:platform-class>>.
The queue has the asynchronous error handler [code]#asyncHandler#.

'''

.[apititle]#Constructor with context and device selector#
[source,role=synopsis,id=api:queue-ctor-context-selector]
----
template <typename DeviceSelector>
explicit queue(const context& syclContext, const DeviceSelector& deviceSelector,
               const property_list& propList = {})
----

_Constraints:_ Available only when the [code]#DeviceSelector# is a type that
satisfies the requirements of a <<device-selector>> as defined in
<<sec:device-selector>>.

_Effects:_ The [code]#deviceSelector# is called for every <<root-device>> as
described in <<sec:device-selector>>, and a [code]#queue# object is constructed
using the device it selects.
The queue's platform is the platform that contains this device.
The queue's context is [code]#syclContext#.

_Throws:_ An [code]#exception# with the [code]#errc::invalid# error code if
[code]#syclContext# does not contain the device selected by
[code]#deviceSelector#.

'''

.[apititle]#Constructor with context, device selector, and async handler#
[source,role=synopsis,id=api:queue-ctor-context-selector-async-handler]
----
template <typename DeviceSelector>
explicit queue(const context& syclContext, const DeviceSelector& deviceSelector,
               const async_handler& asyncHandler,
               const property_list& propList = {})
----

_Constraints:_ Available only when the [code]#DeviceSelector# is a type that
satisfies the requirements of a <<device-selector>> as defined in
<<sec:device-selector>>.

_Effects:_ The [code]#deviceSelector# is called for every <<root-device>> as
described in <<sec:device-selector>>, and a [code]#queue# object is constructed
using the device it selects.
The queue's platform is the platform that contains this device.
The queue's context is [code]#syclContext#.
The queue has the asynchronous error handler [code]#asyncHandler#.

_Throws:_ An [code]#exception# with the [code]#errc::invalid# error code if
[code]#syclContext# does not contain the device selected by
[code]#deviceSelector#.

'''

.[apititle]#Constructor with context and device#
[source,role=synopsis,id=api:queue-ctor-context-device]
----
explicit queue(const context& syclContext, const device& syclDevice,
               const property_list& propList = {})
----

_Effects:_ Constructs a [code]#queue# object using the device
[code]#syclDevice#.
The queue's platform is the platform that contains this device.
The queue's context is [code]#syclContext#.

_Throws:_ An [code]#exception# with the [code]#errc::invalid# error code unless
[code]#syclDevice# is contained by [code]#syclContext# or is a
<<descendent-device>> of some device that is contained by [code]#syclContext#.

'''

.[apititle]#Constructor with context, device, and async handler#
[source,role=synopsis,id=api:queue-ctor-context-device-async-handler]
----
explicit queue(const context& syclContext, const device& syclDevice,
               const async_handler& asyncHandler,
               const property_list& propList = {})
----

_Effects:_ Constructs a [code]#queue# object using the device
[code]#syclDevice#.
The queue's platform is the platform that contains this device.
The queue's context is [code]#syclContext#.
The queue has the asynchronous error handler [code]#asyncHandler#.

_Throws:_ An [code]#exception# with the [code]#errc::invalid# error code unless
[code]#syclDevice# is contained by [code]#syclContext# or is a
<<descendent-device>> of some device that is contained by [code]#syclContext#.

'''

[[sec:queue-member-funcs]]
==== Member functions

.[apidef]#queue::get_backend#
[source,role=synopsis,id=api:queue-get-backend]
----
backend get_backend() const noexcept
----

_Returns:_ The <<backend>> that is associated with this queue.

'''

.[apidef]#queue::get_context#
[source,role=synopsis,id=api:queue-get-context]
----
context get_context() const
----

_Returns:_ The context that is associated with this queue.

'''

.[apidef]#queue::get_device#
[source,role=synopsis,id=api:queue-get-device]
----
device get_device() const
----

_Returns:_ The device that is associated with this queue.

'''

.[apidef]#queue::is_in_order#
[source,role=synopsis,id=api:queue-is-in-order]
----
bool is_in_order() const
----

_Returns:_ The same value as [code]#has_property<property::queue::in_order>()#.

'''

.[apidef]#queue::get_info#
[source,role=synopsis,id=api:queue-get-info]
----
template <typename Param>
typename Param::return_type get_info() const
----

_Constraints:_ Available only when [code]#Param# is an information descriptor
for the queue class.

Each information descriptor specifies the return value and may also specify
preconditions, exceptions that are thrown, etc.
See <<sec:queue-info-descriptors>> for the queue information descriptors that
are defined by the <<core-spec>>.

'''

.[apidef]#queue::get_backend_info#
[source,role=synopsis,id=api:queue-get-backend-info]
----
template <typename Param>
typename Param::return_type get_backend_info() const
----

_Constraints:_ Available only when [code]#Param# is a backend information
descriptor for the queue class.

_Throws:_ An [code]#exception# with the [code]#errc::backend_mismatch# error
code if the backend that corresponds with [code]#Param# is different from the
backend that is associated with this queue.

Each information descriptor specifies the return value and may also specify
preconditions, additional exceptions that are thrown, etc.

'''

.[apidef]#queue::submit#
[source,role=synopsis,id=api:queue-submit]
----
template <typename T>
event submit(T cgf)
----

_Effects:_ Immediately calls the <<command-group-function-object>> [code]#cgf#,
which may submit no more than one <<command>> to the queue for execution on the
device.

_Returns:_ An event which represents the <<command>> which is submitted to the
queue.

'''

.[apititle]#queue::submit (with secondary queue)#
[source,role=synopsis,id=api:queue-submit-secondary-queue]
----
template <typename T>
event submit(T cgf, queue& secondaryQueue)
----

Deprecated in SYCL {SYCL_VERSION}.

_Effects:_ Immediately calls the <<command-group-function-object>> [code]#cgf#,
which may submit no more than one <<command>> to the queue for execution on the
device.
On a kernel error, this <<command-group-function-object>> may be scheduled for
execution on the secondary queue [code]#secondaryQueue# as described in
<<sec::fallback-mechanism>>.

_Returns:_ An event which represents the <<command>> which is submitted to the
queue.
If the command is scheduled on [code]#secondaryQueue#, the event is associated
with that queue.

'''

.[apidef]#queue::wait#
[source,role=synopsis,id=api:queue-wait]
----
void wait()
----

_Effects:_ Blocks the calling thread until all commands previously submitted to
this queue have completed.
Synchronous errors are reported through SYCL exceptions.

'''

.[apidef]#queue::wait_and_throw#
[source,role=synopsis,id=api:queue-wait-and-throw]
----
void wait_and_throw()
----

_Effects:_ Blocks the calling thread until all commands previously submitted to
this queue have completed.
Synchronous errors are reported through SYCL exceptions.

At least all unconsumed <<async-error,asynchronous errors>> held by this queue
(or its associated context) are passed to the appropriate <<async-handler>> as
described in <<subsubsec:async.handler.priorities>>.
'''

.[apidef]#queue::throw_asynchronous#
[source,role=synopsis,id=api:queue-throw-asynchronous]
----
void throw_asynchronous()
----

_Effects:_ Checks to see if any unconsumed <<async-error,asynchronous errors>>
have been produced by the queue and if so reports them by passing them to the
<<async-handler>> associated with the queue or to the <<async-handler>>
associated with the queue's context.
If no user defined asynchronous error handler is associated with the queue or
its context, then an implementation-defined default <<async-handler>> is called
to handle any errors, as described in <<subsubsec:exception.nohandler>>.

'''

[[sec:queue-shortcuts]]
==== Shortcut member functions

The functions described in this section are shortcuts for [api]#queue::submit#
that allow an application to submit a command to the queue without defining a
<<command-group-function-object>>.
Each of these functions implicitly creates a command group that acts as though
it calls one of the [code]#handler# member functions to submit a single command.
For example, [api]#queue::single_task# creates a command group that acts as
though it calls [code]#handler::single_task#.
These shortcut functions return an [code]#event# object that represents the
command that is submitted to the queue.
In addition, some forms of the shortcut functions allow the application to pass
input events, and these forms act as though the command group calls
[code]#handler::depends_on# with these same events.

Because there is no explicit command group function when using these shortcuts,
it is not possible to create accessors for the command that is submitted.
Therefore, kernels that are submitted using these shortcuts must not use
accessors.
Typically, applications use USM pointers instead.
However, there is a special exception for non-kernel commands (e.g. shortcuts
for the explicit memory copy commands).
These non-kernel commands may use placeholder accessors, and the implicit
command group function acts as though it calls [code]#handler::require# on each
of the placeholder accessors that the shortcut function uses.

The following example demonstrates the use of these shortcut functions.

[source,,linenums]
----
include::{code_dir}/queueShortcuts.cpp[lines=4..-1]
----

'''

.[apidef]#queue::single_task#
[source,role=synopsis,id=api:queue-single-task]
----
template <typename KernelName, typename KernelType>             (1)
event single_task(const KernelType& kernelFunc)

template <typename KernelName, typename KernelType>             (2)
event single_task(event depEvent, const KernelType& kernelFunc)

template <typename KernelName, typename KernelType>             (3)
event single_task(const std::vector<event>& depEvents,
                  const KernelType& kernelFunc)
----

_Effects (1):_ Equivalent to calling [api]#queue::submit# with a command group
function that calls [code]#handler::single_task(kernelFunc)#.

_Effects (2):_ Equivalent to calling [api]#queue::submit# with a command group
function that calls [code]#handler::depends_on(depEvent)# and
[code]#handler::single_task(kernelFunc)#.

_Effects (3):_ Equivalent to calling [api]#queue::submit# with a command group
function that calls [code]#handler::depends_on(depEvents)# and
[code]#handler::single_task(kernelFunc)#.

_Returns:_ An event which represents the <<command>> which is submitted to the
queue.

'''

.[apidef]#queue::parallel_for#
[source,role=synopsis,id=api:queue-parallel-for]
----
template <typename KernelName, int Dimensions, typename... Rest>        (1)
event parallel_for(range<Dimensions> numWorkItems, Rest&&... rest)

template <typename KernelName, int Dimensions, typename... Rest>        (2)
event parallel_for(range<Dimensions> numWorkItems, event depEvent,
                   Rest&&... rest)

template <typename KernelName, int Dimensions, typename... Rest>        (3)
event parallel_for(range<Dimensions> numWorkItems,
                   const std::vector<event>& depEvents, Rest&&... rest)

template <typename KernelName, int Dimensions, typename... Rest>        (4)
event parallel_for(nd_range<Dimensions> executionRange, Rest&&... rest)

template <typename KernelName, int Dimensions, typename... Rest>        (5)
event parallel_for(nd_range<Dimensions> executionRange, event depEvent,
                   Rest&&... rest)

template <typename KernelName, int Dimensions, typename... Rest>        (6)
event parallel_for(nd_range<Dimensions> executionRange,
                   const std::vector<event>& depEvents, Rest&&... rest)
----

_Effects (1):_ Equivalent to calling [api]#queue::submit# with a command group
function that calls [code]#handler::parallel_for(numWorkItems, rest)#.

_Effects (2):_ Equivalent to calling [api]#queue::submit# with a command group
function that calls [code]#handler::depends_on(depEvent)# and
[code]#handler::parallel_for(numWorkItems, rest)#.

_Effects (3):_ Equivalent to calling [api]#queue::submit# with a command group
function that calls [code]#handler::depends_on(depEvents)# and
[code]#handler::parallel_for(numWorkItems, rest)#.

_Effects (4):_ Equivalent to calling [api]#queue::submit# with a command group
function that calls [code]#handler::parallel_for(executionRange, rest)#.

_Effects (5):_ Equivalent to calling [api]#queue::submit# with a command group
function that calls [code]#handler::depends_on(depEvent)# and
[code]#handler::parallel_for(executionRange, rest)#.

_Effects (6):_ Equivalent to calling [api]#queue::submit# with a command group
function that calls [code]#handler::depends_on(depEvents)# and
[code]#handler::parallel_for(executionRange, rest)#.

_Returns:_ An event which represents the <<command>> which is submitted to the
queue.

'''

.[apidef]#queue::memcpy#
[source,role=synopsis,id=api:queue-memcpy]
----
event memcpy(void* dest, const void* src, size_t numBytes)                 (1)

event memcpy(void* dest, const void* src, size_t numBytes, event depEvent) (2)

event memcpy(void* dest, const void* src, size_t numBytes,                 (3)
             const std::vector<event>& depEvents)
----

_Effects (1):_ Equivalent to calling [api]#queue::submit# with a command group
function that calls [code]#handler::memcpy(dest, src, numBytes)#.

_Effects (2):_ Equivalent to calling [api]#queue::submit# with a command group
function that calls [code]#handler::depends_on(depEvent)# and
[code]#handler::memcpy(dest, src, numBytes)#.

_Effects (3):_ Equivalent to calling [api]#queue::submit# with a command group
function that calls [code]#handler::depends_on(depEvents)# and
[code]#handler::memcpy(dest, src, numBytes)#.

_Returns:_ An event which represents the <<command>> which is submitted to the
queue.

'''

.[apidef]#queue::copy#
[source,role=synopsis,id=api:queue-copy]
----
template <typename T>                                                         (1)
event copy(const T* src, T* dest, size_t count)

template <typename T>                                                         (2)
event copy(const T* src, T* dest, size_t count, event depEvent)

template <typename T>                                                         (3)
event copy(const T* srct, T* dest, size_t count,
           const std::vector<event>& depEvents)

template <typename SrcT, int SrcDims, access_mode SrcMode, target SrcTgt,     (4)
          access::placeholder IsPlaceholder, typename DestT>
event copy(accessor<SrcT, SrcDims, SrcMode, SrcTgt, IsPlaceholder> src,
           std::shared_ptr<DestT> dest)

template <typename SrcT, typename DestT, int DestDims, access_mode DestMode,  (5)
          target DestTgt, access::placeholder IsPlaceholder>
event copy(std::shared_ptr<SrcT> src,
           accessor<DestT, DestDims, DestMode, DestTgt, IsPlaceholder> dest)

template <typename SrcT, int SrcDims, access_mode SrcMode, target SrcTgt,     (6)
          access::placeholder IsPlaceholder, typename DestT>
event copy(accessor<SrcT, SrcDims, SrcMode, SrcTgt, IsPlaceholder> src,
           DestT* dest)

template <typename SrcT, typename DestT, int DestDims, access_mode DestMode,  (7)
          target DestTgt, access::placeholder IsPlaceholder>
event copy(const SrcT* src,
           accessor<DestT, DestDims, DestMode, DestTgt, IsPlaceholder> dest)

template <typename SrcT, int SrcDims, access_mode SrcMode, target SrcTgt,     (8)
          access::placeholder IsSrcPlaceholder, typename DestT, int DestDims,
          access_mode DestMode, target DestTgt,
          access::placeholder IsDestPlaceholder>
event copy(
    accessor<SrcT, SrcDims, SrcMode, SrcTgt, IsSrcPlaceholder> src,
    accessor<DestT, DestDims, DestMode, DestTgt, IsDestPlaceholder> dest)
----

_Effects (1):_ Equivalent to calling [api]#queue::submit# with a command group
function that calls [code]#handler::copy(src, dest, count)#.

_Effects (2):_ Equivalent to calling [api]#queue::submit# with a command group
function that calls [code]#handler::depends_on(depEvent)# and
[code]#handler::copy(src, dest, count)#.

_Effects (3):_ Equivalent to calling [api]#queue::submit# with a command group
function that calls [code]#handler::depends_on(depEvents)# and
[code]#handler::copy(src, dest, count)#.

_Effects (4):_ Equivalent to calling [api]#queue::submit# with a command group
function that calls [code]#handler::require(src)# and [code]#handler::copy(src,
dest)#.

_Effects (5):_ Equivalent to calling [api]#queue::submit# with a command group
function that calls [code]#handler::require(dest)# and [code]#handler::copy(src,
dest)#.

_Effects (6):_ Equivalent to calling [api]#queue::submit# with a command group
function that calls [code]#handler::require(src)# and [code]#handler::copy(src,
dest)#.

_Effects (7):_ Equivalent to calling [api]#queue::submit# with a command group
function that calls [code]#handler::require(dest)# and [code]#handler::copy(src,
dest)#.

_Effects (8):_ Equivalent to calling [api]#queue::submit# with a command group
function that calls [code]#handler::require(src)#,
[code]#handler::require(dest)#, and [code]#handler::copy(src, dest)#.

_Returns:_ An event which represents the <<command>> which is submitted to the
queue.

'''

.[apidef]#queue::memset#
[source,role=synopsis,id=api:queue-memset]
----
event memset(void* ptr, int value, size_t numBytes)                 (1)

event memset(void* ptr, int value, size_t numBytes, event depEvent) (2)

event memset(void* ptr, int value, size_t numBytes,                 (3)
             const std::vector<event>& depEvents)
----

_Effects (1):_ Equivalent to calling [api]#queue::submit# with a command group
function that calls [code]#handler::memset(ptr, value, numBytes)#.

_Effects (2):_ Equivalent to calling [api]#queue::submit# with a command group
function that calls [code]#handler::depends_on(depEvent)# and
[code]#handler::memset(ptr, value, numBytes)#.

_Effects (3):_ Equivalent to calling [api]#queue::submit# with a command group
function that calls [code]#handler::depends_on(depEvents)# and
[code]#handler::memcpy(ptr, value, numBytes)#.

_Returns:_ An event which represents the <<command>> which is submitted to the
queue.

'''

.[apidef]#queue::fill#
[source,role=synopsis,id=api:queue-fill]
----
template <typename T>                                                      (1)
event fill(void* ptr, const T& pattern, size_t count)

template <typename T>                                                      (2)
event fill(void* ptr, const T& pattern, size_t count, event depEvent)

template <typename T>                                                      (3)
event fill(void* ptr, const T& pattern, size_t count,
           const std::vector<event>& depEvents)

template <typename T, int Dims, access_mode Mode, target Tgt,              (4)
          access::placeholder IsPlaceholder>
event fill(accessor<T, Dims, Mode, Tgt, IsPlaceholder> dest, const T& src)
----

_Effects (1):_ Equivalent to calling [api]#queue::submit# with a command group
function that calls [code]#handler::fill(ptr, pattern, count)#.

_Effects (2):_ Equivalent to calling [api]#queue::submit# with a command group
function that calls [code]#handler::depends_on(depEvent)# and
[code]#handler::fill(ptr, pattern, count)#.

_Effects (3):_ Equivalent to calling [api]#queue::submit# with a command group
function that calls [code]#handler::depends_on(depEvents)# and
[code]#handler::fill(ptr, pattern, count)#.

_Effects (4):_ Equivalent to calling [api]#queue::submit# with a command group
function that calls [code]#handler::require(dest)# and
[code]#handler::fill(dest, src)#.

_Returns:_ An event which represents the <<command>> which is submitted to the
queue.

'''

.[apidef]#queue::prefetch#
[source,role=synopsis,id=api:queue-prefetch]
----
event prefetch(void* ptr, size_t numBytes)                                      (1)

event prefetch(void* ptr, size_t numBytes, event depEvent)                      (2)

event prefetch(void* ptr, size_t numBytes, const std::vector<event>& depEvents) (3)
----

_Effects (1):_ Equivalent to calling [api]#queue::submit# with a command group
function that calls [code]#handler::prefetch(ptr, numBytes)#.

_Effects (2):_ Equivalent to calling [api]#queue::submit# with a command group
function that calls [code]#handler::depends_on(depEvent)# and
[code]#handler::prefetch(ptr, numBytes)#.

_Effects (3):_ Equivalent to calling [api]#queue::submit# with a command group
function that calls [code]#handler::depends_on(depEvents)# and
[code]#handler::prefetch(ptr, numBytes)#.

_Returns:_ An event which represents the <<command>> which is submitted to the
queue.

'''

.[apidef]#queue::mem_advise#
[source,role=synopsis,id=api:queue-mem-advise]
----
event mem_advise(void* ptr, size_t numBytes, int advice)                 (1)

event mem_advise(void* ptr, size_t numBytes, int advice, event depEvent) (2)

event mem_advise(void* ptr, size_t numBytes, int advice,                 (3)
                 const std::vector<event>& depEvents)
----

_Effects (1):_ Equivalent to calling [api]#queue::submit# with a command group
function that calls [code]#handler::mem_advise(ptr, numBytes, advice)#.

_Effects (2):_ Equivalent to calling [api]#queue::submit# with a command group
function that calls [code]#handler::depends_on(depEvent)# and
[code]#handler::mem_advise(ptr, numBytes, advice)#.

_Effects (3):_ Equivalent to calling [api]#queue::submit# with a command group
function that calls [code]#handler::depends_on(depEvents)# and
[code]#handler::mem_advise(ptr, numBytes, advice)#.

_Returns:_ An event which represents the <<command>> which is submitted to the
queue.

'''

.[apidef]#queue::update_host#
[source,role=synopsis,id=api:queue-update-host]
----
template <typename T, int Dims, access_mode Mode, target Tgt,
          access::placeholder IsPlaceholder>
event update_host(accessor<T, Dims, Mode, Tgt, IsPlaceholder> acc)
----

_Effects:_ Equivalent to calling [api]#queue::submit# with a command group
function that calls [code]#handler::require(acc)# and
[code]#handler::update_host(acc)#.

_Returns:_ An event which represents the <<command>> which is submitted to the
queue.

'''

[[sec:queue-info-descriptors]]
==== Information descriptors

This section describes the information descriptors that can be used as the
[code]#Param# template parameter to [api]#queue::get_info#.
When the description has a _Returns_, _Throws_, etc. paragraph, this indicates
the value returned by or the exceptions thrown by the [api]#queue::get_info#
function.

'''

.[apidef]#info::queue::context#
[source,role=synopsis,id=api:info-queue-context]
----
namespace sycl::info::queue {
struct context {
  using return_type = context;
};
} // namespace sycl::info::queue
----

_Remarks:_ Template parameter to [api]#queue::get_info#.

_Returns:_ The <<context>> that is associated with this queue.

'''

.[apidef]#info::queue::device#
[source,role=synopsis,id=api:info-queue-device]
----
namespace sycl::info::queue {
struct device {
  using return_type = device;
};
} // namespace sycl::info::queue
----

_Remarks:_ Template parameter to [api]#queue::get_info#.

_Returns:_ The <<device>> that is associated with this queue.

'''

[[sec:queue-properties]]
==== Properties

This section describes the properties that can be passed in the [code]#propList#
parameter of the <<sec:queue-ctors, queue constructors>>.

'''

.[apidef]#property::queue::enable_profiling#
[source,role=synopsis,id=api:property-queue-enable-profiling]
----
namespace sycl::property::queue {
struct enable_profiling {
  enable_profiling();  (1)
};
} // namespace sycl::property::queue
----

When a queue is constructed with this property, the implementation captures
profiling information for the <<command-group,command groups>> that are
submitted to this queue.
Applications can retrieve this profiling information by calling
[code]#event::get_profiling_info# on the event that is returned when submitting
the command group.
If the queue's associated device does not have [code]#aspect::queue_profiling#,
passing this property to the queue's constructor causes the constructor to throw
a synchronous [code]#exception# with the [code]#errc::feature_not_supported#
error code.

_Effects (1):_ Constructs an [code]#enable_profiling# property object.

'''

.[apidef]#property::queue::in_order#
[source,role=synopsis,id=api:property-queue-in-order]
----
namespace sycl::property::queue {
struct in_order {
  in_order();  (1)
};
} // namespace sycl::property::queue
----

When a queue is constructed with this property, commands that are submitted to
the queue are guaranteed to execute in the order in which they are submitted, as
if there is an implicit dependency on the previous command that was submitted to
the same queue.
The [code]#in_order# property does not provide any guarantee about the order of
commands submitted to other queues with respect to commands submitted to this
queue.

_Effects (1):_ Constructs an [code]#in_order# property object.

'''

[[sec:queue-error-handling]]
==== Error handling

Queue errors come in two forms:

* Synchronous errors are those that we would expect to be reported directly at
  the point of waiting on an event, and hence waiting for a queue to complete,
  as well as any immediate errors reported by enqueuing work onto a queue.
  Such errors are reported through {cpp} exceptions.
* <<async-error,Asynchronous errors>> are those that are produced or detected
  after associated host API calls have returned (so can't be thrown as
  exceptions by the API call), and that are handled by an <<async-handler>>
  through which the errors are reported.
  Handling of asynchronous errors from a queue occurs at specific times, as
  described by <<error-handling>>.

Note that if there are <<async-error,asynchronous errors>> to be processed when
a queue is destroyed, the handler is called and this might delay or block the
destruction, according to the behavior of the handler.


[[sec:interface.event]]
=== Event class

An <<event>> in SYCL is an object that represents the status of an operation
that is being executed by the SYCL runtime.

Typically in SYCL, data dependency and execution order is handled implicitly by
the SYCL runtime.
However, in some circumstances developers want fine grain control of the
execution, or want to retrieve properties of a command that is running.

Note that, although an event represents the status of a particular operation,
the dependencies of a certain event can be used to keep track of multiple steps
required to block on the results of said operation.

A SYCL event is returned by the submission of a <<command-group>>.
The dependencies of the event returned via the submission of the command group
are the implementation-defined commands associated with the <<command-group>>
execution.

The SYCL [code]#event# class provides the common reference semantics (see
<<sec:reference-semantics>>).

The constructors and member functions of the SYCL [code]#event# class are listed
in <<table.constructors.event>> and <<table.members.event>>, respectively.
The additional common special member functions and common member functions are
listed in <<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>>, respectively.

// Interface for class: event.h
[source,,linenums]
----
include::{header_dir}/event.h[lines=4..-1]
----


[[table.constructors.event]]
.Constructors of the [code]#event# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
event()
----
   a@ Constructs an [code]#event# that is immediately ready.  The
      [code]#event# has no dependencies and no associated commands.
      Waiting on this [code]#event# will return immediately and querying
      its status will return [code]#info::event_command_status::complete#.

The event is constructed as though it was created from a default-constructed
[code]#queue#.  Therefore, its backend is the same as the backend from the
default device.

|====



[[table.members.event]]
.Member functions for the [code]#event# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
backend get_backend() const noexcept
----
   a@ Returns a [code]#backend# identifying the <<backend>> associated
      with this [code]#event#.

a@
[source]
----
std::vector<event> get_wait_list()
----
   a@ Return the list of events that this event waits for in
      the dependence graph.  Only direct dependencies are returned,
      and not transitive dependencies that direct dependencies wait on.
      Whether already completed events are included in the returned list
      is implementation-defined.

a@
[source]
----
void wait()
----
   a@ Blocks until all commands associated with this event and any dependent
      events have completed.

a@
[source]
----
void wait_and_throw()
----
   a@ Blocks until all commands associated with this event and any dependent
      events have completed.

At least all unconsumed <<async-error,asynchronous errors>> held by queues (or
their associated contexts) which were used to enqueue commands associated with
this event and any dependent events, are passed to the appropriate
<<async-handler>> as described in <<subsubsec:async.handler.priorities>>.

[NOTE]
====
This behavior is equivalent to calling [code]#queue::throw_asynchronous()# on
the queue associated with this event and any dependent events.
====

a@
[source]
----
static void wait(const std::vector<event>& eventList)
----
   a@ Behaves as if calling [code]#event::wait()# on each event in
      [code]#eventList#.

a@
[source]
----
static void wait_and_throw(const std::vector<event>& eventList)
----
   a@ Behaves as if calling [code]#event::wait_and_throw()# on each event in
      [code]#eventList#.

a@
[source]
----
template <typename Param> typename Param::return_type get_info() const
----
   a@ Queries this SYCL [code]#event# for information requested by the
      template parameter [code]#Param#.
      The type alias [code]#Param::return_type# must be defined in
      accordance with the info parameters in <<table.event.info>> to
      facilitate returning the type associated with the [code]#Param#
      parameter.

a@
[source]
----
template <typename Param> typename Param::return_type get_backend_info() const
----
   a@ Queries this SYCL [code]#event# for <<backend>>-specific information
      requested by the template parameter [code]#Param#.
      The type alias [code]#Param::return_type# must be defined in
      accordance with the <<backend>> specification.
      Must throw an [code]#exception# with the [code]#errc::backend_mismatch#
      error code if the <<backend>> that corresponds with [code]#Param# is different
      from the <<backend>> that is associated with this [code]#event#.

a@
[source]
----
template <typename Param> typename Param::return_type get_profiling_info() const
----
   a@ Queries this SYCL [code]#event# for profiling information requested
      by the parameter [code]#Param#. If the requested profiling information
      is unavailable when [code]#get_profiling_info# is called due to
      incompletion of <<command-group,command groups>> associated with the [code]#event#,
      then the call to [code]#get_profiling_info# will block until
      the requested profiling information is available. An example is asking for
      [code]#info::event_profiling::command_end# when the associated
      <<command-group>> action has yet to finish execution.
      Calls to [code]#get_profiling_info# must throw an [code]#exception#
      with the [code]#errc::invalid# error code if the SYCL
      [code]#queue# which submitted the <<command-group>> this
      SYCL [code]#event# is associated with was not constructed with
      the [code]#property::queue::enable_profiling# property.
      The type alias [code]#Param::return_type# must be defined in
      accordance with the info parameters in
      <<table.event.profilinginfo>> to facilitate returning the type
      associated with the [code]#Param# parameter.

|====


==== Event information and profiling descriptors

An <<event>> can be queried for information using the [code]#get_info# member
function of the [code]#event# class, specifying one of the info parameters in
[code]#info::event#.
The possible values for each info parameter and any restrictions are defined in
the specification of the <<backend>> associated with the <<event>>.
All info parameters in [code]#info::event# are specified in <<table.event.info>>
and the synopsis for [code]#info::event# is described in
<<appendix.event.descriptors>>.

[[table.event.info]]
.Event class information descriptors
[width="100%",options="header",separator="@",cols="37%,19%,44%"]
|====
@ Event Descriptors @ Return type @ Description
a@
[source]
----
info::event::command_execution_status
----

    @ [.code]#info::event_command_status#
   a@ Returns the event status of the command group and contained action
      (e.g. kernel invocation) associated with this SYCL [code]#event#.

|====

The [code]#info::event::command_execution_status# query returns one of the
values defined in <<table.event.command-status>>.

[[table.event.command-status]]
.Event command status
[width="100%",options="header",separator="@",cols="45%,55%"]
|====
@ Status @ Description
a@
[source]
----
info::event_command_status::submitted
----
   a@ Indicates that the command has been submitted to the SYCL queue but has
      not yet started running on the device.

a@
[source]
----
info::event_command_status::running
----
   a@ Indicates that the command has started running on the device but has not
      yet completed.

a@
[source]
----
info::event_command_status::complete
----
   a@ Indicates that the command has finished running on the device.
      Attempting to wait on such an event will not block.
      
Synchronization: When [code]#event::get_info# returns this value,
the synchronization is equivalent to [code]#event::wait#.

|====


An <<event>> can be queried for profiling information using the
[code]#get_profiling_info# member function of the [code]#event# class,
specifying one of the profiling info parameters enumerated in
[code]#info::event_profiling#.
The possible values for each info parameter and any restrictions are defined in
the specification of the <<backend>> associated with the <<event>>.
All info parameters in [code]#info::event_profiling# are specified in
<<table.event.profilinginfo>> and the synopsis for [code]#info::event_profiling#
is described in <<appendix.event.descriptors>>.

Each profiling descriptor returns a 64-bit timestamp that represents the number
of nanoseconds that have elapsed since some implementation-defined timebase.
All events that share the same backend are guaranteed to share the same
timebase, therefore the difference between two timestamps from the same backend
yields the number of nanoseconds that have elapsed between those events.

[[table.event.profilinginfo]]
.Profiling information descriptors for the SYCL [code]#event# class
[width="100%",options="header",separator="@",cols="43%,13%,44%"]
|====
@ Event information profiling descriptor @ Return type @ Description
a@
[source]
----
info::event_profiling::command_submit
----

    @ [.code]#uint64_t#
   a@ Returns a timestamp telling when the associated <<command-group>> was
      submitted to the [code]#queue#.  This is always some time after the
      <<command-group-function-object>> returns and before the associated call
      to [code]#queue::submit# returns.

a@
[source]
----
info::event_profiling::command_start
----

    @ [.code]#uint64_t#
   a@ Querying this profiling descriptor blocks until the event's state becomes
      either [code]#info::event_command_status::running# or
      [code]#info::event_command_status::complete#.  The returned timestamp
      tells when the action associated with the <<command-group>> (e.g. kernel
      invocation) started executing on the device.  For any given event, this
      timestamp is always greater than or equal to the
      [code]#info::event_profiling::command_submit# timestamp.  Implementations
      are encouraged to return a timestamp that is as close as possible to the
      point when the action starts running on the device, but there is no
      specific accuracy that is guaranteed.

a@
[source]
----
info::event_profiling::command_end
----

    @ [.code]#uint64_t#
   a@ Querying this profiling descriptor blocks until the event's state becomes
      [code]#info::event_command_status::complete#.  The returned timestamp
      tells when the action associated with the <<command-group>> (e.g. kernel
      invocation) finished executing on the device.  For any given event, this
      timestamp is always greater than or equal to the
      [code]#info::event_profiling::command_start# timestamp.


|====



[[sec:data.access.and.storage]]
== Data access and storage in SYCL

In SYCL, when using <<buffer,buffers>> and <<image,images>>, data storage and
access are handled by separate classes.
<<buffer,Buffers>> and <<image,images>> handle storage and ownership of the
data, whereas <<accessor,accessors>> handle access to the data.
Buffers and images in SYCL can be bound to more than one device or context,
including across different <<backend, SYCL backends>>.
They also handle ownership of the data, while allowing exception handling for
blocking and non-blocking data transfers.
Accessors manage data transfers between the host and all of the devices in the
system, as well as tracking of data dependencies.

Zero-sized buffers and accessors are permitted, but attempting to access data
within them produces undefined behavior, similar to dereferencing a null pointer
in {cpp}.
Note that zero-sized accessors can be created in several ways: by creating an
accessor from a zero-sized buffer, by creating an accessor with a zero-sized
buffer sub-range, or by creating an accessor with its default constructor.

When using <<usm>> allocations, data storage is managed by USM allocation
functions, and data access is via pointers.
See <<sec:usm>> for greater detail.

=== Host allocation

A <<sycl-runtime>> may need to allocate temporary objects on the host to handle
some operations (such as copying data from one context to another).
Allocation on the host is managed using an allocator object, following the
standard {cpp} allocator class definition.
The default allocator for memory objects is implementation-defined, but the user
can supply their own allocator class.

[source,,linenums]
----
{
    buffer<int, 1, UserDefinedAllocator<int>> b(d);
}
----

When an allocator returns a [code]#nullptr#, the runtime cannot allocate data on
the host.
Note that in this case the runtime will raise an error if it requires host
memory but it is not available (e.g when moving data across <<backend>>
contexts).

In some cases, the implementation may retain a copy of the allocator object even
after the buffer is destroyed.
For example, this can happen when the buffer object is destroyed before commands
using accessors to the buffer have completed.
Therefore, the application must be prepared for calls to the allocator even
after the buffer is destroyed.

[NOTE]
====
If the application needs to know when the implementation has destroyed all
copies of the allocator, it can maintain a reference count within the allocator.
====

The definition of allocators extends the current functionality of SYCL, ensuring
that users can define allocator functions for specific hardware or certain
complex shared memory mechanisms (e.g. NUMA), and improves interoperability with
STL-based libraries (e.g, Intel's TBB provides an allocator).


[[subsec:default.allocators]]
==== Default allocators

A default allocator is always defined by the implementation.
For allocations greater than size zero, when successful it is guaranteed to
return non-[code]#nullptr# and new memory positions every call.
The default allocator for const buffers will remove the const-ness of the type
(therefore, the default allocator for a buffer of type [code]#const int# will be
an [code]#Allocator<int>)#.
This implies that host <<accessor,accessors>> will not share memory with the
pointer given by the user in the buffer/image constructor, but will use the
memory returned by the [code]#Allocator# itself for that purpose.
The user can implement an allocator that returns the same address as the one
passed in the buffer constructor, but it is the responsibility of the user to
handle the potential race conditions.


[[table.default.allocators]]
.SYCL Default Allocators
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Allocators @ Description
a@
[source]
----
template <class T> buffer_allocator
----
   a@ It is the default buffer allocator used by the runtime, when no allocator is
      defined by the user.
      Meets the C++ named requirement [code]#Allocator#.
      A buffer of data type [code]#const T# uses [code]#buffer_allocator<T># by default.

a@
[source]
----
image_allocator
----
   a@ It is the default allocator used by the runtime for the SYCL [code]#unsampled_image# and [code]#sampled_image# classes when no allocator is provided by the user.
      The [code]#image_allocator# is required to allocate in elements of [code]#std::byte#.

|====


See <<subsec:mutex>> for details of using manual synchronization to avoid data
races between host and device.


[[subsec:buffers]]
=== Buffers

The [code]#buffer# class defines a shared array of one, two or three dimensions
that can be used by the SYCL <<kernel>> and has to be accessed using
<<accessor>> classes.
Buffers are templated on both the type of their data, and the number of
dimensions that the data is stored and accessed through.

A [code]#buffer# does not map to only one underlying backend object, and all
<<backend>> memory objects may be temporary for use within a command group on a
specific device.

The underlying data type of a buffer [code]#T# must be <<device-copyable>> as
defined in <<sec::device.copyable>>.
Some overloads of the [code]#buffer# constructor initialize the buffer contents
by copying objects from host memory while other overloads construct the buffer
without copying objects from the host.
For the overloads that do not copy host objects, the initial state of the
objects in the buffer depends on whether [code]#T# is an implicit-lifetime type
(as defined in the {cpp} core language).
If [code]#T# is an implicit-lifetime type, objects of that type are implicitly
created in the buffer with indeterminate values.
For other types, these constructor overloads merely allocate uninitialized
memory, and the application is responsible for constructing objects by calling
placement-new and for destroying them later by manually calling the object's
destructor.

For the overloads that do copy objects from host memory, the [code]#hostData#
pointer must point to at least _N_ bytes of memory where _N_ is [code]#sizeof(T) *
bufferRange.size()#.
If _N_ is zero, [code]#hostData# is permitted to be a null pointer.

A SYCL [code]#buffer# can construct an instance of a SYCL [code]#buffer# that
reinterprets the original SYCL [code]#buffer# with a different type,
dimensionality and range using the member function [code]#reinterpret#.
The reinterpreted SYCL [code]#buffer# that is constructed must behave as though
it were a copy of the SYCL [code]#buffer# that constructed it (see
<<sec:reference-semantics>>) with the exception that the type, dimensionality
and range of the reinterpreted SYCL [code]#buffer# must reflect the type,
dimensionality and range specified when calling the [code]#reinterpret# member
function.
By extension of this, the class member types [code]#value_type#,
[code]#reference# and [code]#const_reference#, and the member functions
[code]#get_range()# and [code]#size()# of the reinterpreted SYCL [code]#buffer#
must reflect the new type, dimensionality and range.
The data that the original SYCL [code]#buffer# and the reinterpreted SYCL
[code]#buffer# manage remains unaffected, though the representation of the data
when accessed through the reinterpreted SYCL [code]#buffer# may alter to reflect
the new type, dimensionality and range.
It is important to note that a reinterpreted SYCL [code]#buffer# is a copy of
the original SYCL [code]#buffer# only, and not a new SYCL [code]#buffer#.
Constructing more than one SYCL [code]#buffer# managing the same host pointer is
still undefined behavior.

The SYCL [code]#buffer# class template provides the common reference semantics
(see <<sec:reference-semantics>>).


==== Buffer interface

The constructors and member functions of the SYCL [code]#buffer# class template
are listed in <<table.constructors.buffer>> and <<table.members.buffer>>,
respectively.
The additional common special member functions and common member functions are
listed in <<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>>, respectively.

Each constructor takes as the last parameter an optional SYCL
[code]#property_list# to provide properties to the SYCL [code]#buffer#.

The SYCL [code]#buffer# class template takes a template parameter
[code]#AllocatorT# for specifying an allocator which is used by the
<<sycl-runtime>> when allocating temporary memory on the host.
If no template argument is provided, then the default allocator for the SYCL
[code]#buffer# class [code]#buffer_allocator<T># will be used (see
<<subsec:default.allocators>>).

// Interface for class: buffer

[source,,linenums]
----
include::{header_dir}/buffer.h[lines=4..-1]
----


[[table.constructors.buffer]]
.Constructors of the [code]#buffer# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
buffer(const range<Dimensions>& bufferRange,
       const property_list& propList = {})
----
   a@ Construct a SYCL [code]#buffer# instance with uninitialized memory.
      The constructed SYCL [code]#buffer# will use a default constructed [code]#AllocatorT# when allocating memory on the host.
      The range of the constructed SYCL [code]#buffer# is specified by the [code]#bufferRange# parameter provided.
      Data is not written back to the host on destruction of the [code]#buffer# unless the [code]#buffer# has a valid non-null pointer specified via the member function [code]#set_final_data()#.
      Zero or more properties can be provided to the constructed SYCL [code]#buffer# via an instance of [code]#property_list#.

a@
[source]
----
buffer(const range<Dimensions>& bufferRange,
       AllocatorT allocator,
       const property_list& propList = {})
----
   a@ Construct a SYCL [code]#buffer# instance with uninitialized memory.
      The constructed SYCL [code]#buffer# will use the [code]#allocator# parameter provided when allocating memory on the host.
      The range of the constructed SYCL [code]#buffer# is specified by the [code]#bufferRange# parameter provided.
      Data is not written back to the host on destruction of the [code]#buffer# unless the [code]#buffer# has a valid non-null pointer specified via the member function [code]#set_final_data()#.
      Zero or more properties can be provided to the constructed SYCL [code]#buffer# via an instance of [code]#property_list#.

a@
[source]
----
buffer(T* hostData, const range<Dimensions>& bufferRange,
       const property_list& propList = {})
----
   a@ Construct a SYCL [code]#buffer# instance with the [code]#hostData#
      parameter provided.  The buffer is initialized with the memory specified
      by [code]#hostData#, and the buffer assumes exclusive access to this
      memory for the duration of its lifetime.  The constructed SYCL
      [code]#buffer# will use a default constructed [code]#AllocatorT# when
      allocating memory on the host.  The range of the constructed SYCL
      [code]#buffer# is specified by the [code]#bufferRange# parameter
      provided.  Zero or more properties can be provided to the constructed
      SYCL [code]#buffer# via an instance of [code]#property_list#.

a@
[source]
----
buffer(T* hostData, const range<Dimensions>& bufferRange,
       AllocatorT allocator,
       const property_list& propList = {})
----
   a@ Construct a SYCL [code]#buffer# instance with the [code]#hostData#
      parameter provided.  The buffer is initialized with the memory specified
      by [code]#hostData#, and the buffer assumes exclusive access to this
      memory for the duration of its lifetime.  The constructed SYCL
      [code]#buffer# will use the [code]#allocator# parameter provided when
      allocating memory on the host.  The range of the constructed SYCL
      [code]#buffer# is specified by the [code]#bufferRange# parameter
      provided.  Zero or more properties can be provided to the constructed
      SYCL [code]#buffer# via an instance of [code]#property_list#.

a@
[source]
----
buffer(const T* hostData,
       const range<Dimensions>& bufferRange,
       const property_list& propList = {})
----
   a@ Construct a SYCL [code]#buffer# instance with the [code]#hostData#
      parameter provided.  The buffer assumes exclusive access to this memory
      for the duration of its lifetime.

The constructed SYCL [code]#buffer# will use a default
constructed [code]#AllocatorT# when allocating memory on
the host.

The host address is [code]#const T#, so the host accesses
can be read-only. However, the [code]#typename T# is not const so
the device accesses can be both read and write accesses. Since
the [code]#hostData# is const, this buffer is only initialized with
this memory and there is no write back after its destruction,
unless the [code]#buffer# has another valid non-null final
data address specified via the member function
[code]#set_final_data()# after construction of the
[code]#buffer#.

The range of the constructed SYCL [code]#buffer# is
specified by the [code]#bufferRange# parameter provided.

Zero or more properties can be provided to the constructed SYCL
[code]#buffer# via an instance of
[code]#property_list#.

a@
[source]
----
buffer(const T* hostData,
       const range<Dimensions>& bufferRange,
       AllocatorT allocator,
       const property_list& propList = {})
----
   a@ Construct a SYCL [code]#buffer# instance with the [code]#hostData#
      parameter provided.  The buffer assumes exclusive access to this
      memory for the duration of its lifetime.

The constructed SYCL [code]#buffer# will use the
[code]#allocator# parameter provided when allocating
memory on the host.

The host address is [code]#const T#, so the host accesses
can be read-only. However, the [code]#typename T# is not const so
the device accesses can be both read and write accesses. Since,
the [code]#hostData# is const, this buffer is only initialized
with this memory and there is no write back after its
destruction, unless the [code]#buffer# has another valid
non-null final data address specified via the member function
[code]#set_final_data()# after construction of the
[code]#buffer#.

The range of the constructed SYCL [code]#buffer# is
specified by the [code]#bufferRange# parameter provided.

Zero or more properties can be provided to the constructed SYCL
[code]#buffer# via an instance of
[code]#property_list#.


a@
[source]
----
template <typename Container>
buffer(Container& container,
       const property_list& propList = {})
----
   a@ Construct a one dimensional SYCL [code]#buffer# instance
      from the elements starting at [code]#std::data(container)#
      and containing [code]#std::size(container)# number of elements.
      The buffer is initialized with the contents of [code]#container#,
      and the buffer assumes exclusive access to [code]#container# for
      the duration of its lifetime.

Data is written back to [code]#container# before the completion of
[code]#buffer# destruction if the return type of [code]#std::data(container)#
is not [code]#const#.

The constructed SYCL [code]#buffer# will use a default constructed [code]#AllocatorT# when allocating memory on the host.

Zero or more properties can be provided to the constructed SYCL
[code]#buffer# via an instance of
[code]#property_list#.

This constructor is only defined for a [code]#buffer# parameterized
with [code]#Dimensions == 1#, and when [code]#std::data(container)#
is convertible to [code]#T*#.


a@
[source]
----
template <typename Container>
buffer(Container& container, AllocatorT allocator,
       const property_list& propList = {})
----
   a@ Construct a one dimensional SYCL [code]#buffer# instance
      from the elements starting at [code]#std::data(container)#
      and containing [code]#std::size(container)# number of elements.
      The buffer is initialized with the contents of [code]#container#,
      and the buffer assumes exclusive access to [code]#container# for
      the duration of its lifetime.

Data is written back to [code]#container# before the completion of
[code]#buffer# destruction if the return type of [code]#std::data(container)#
is not [code]#const#.

The constructed SYCL [code]#buffer# will use the [code]#allocator# parameter provided when allocating memory on the host.

Zero or more properties can be provided to the constructed SYCL
[code]#buffer# via an instance of
[code]#property_list#.

This constructor is only defined for a [code]#buffer# parameterized
with [code]#Dimensions == 1#, and when [code]#std::data(container)#
is convertible to [code]#T*#.


a@
[source]
----
buffer(const std::shared_ptr<T>& hostData,
       const range<Dimensions>& bufferRange,
       const property_list& propList = {})
----
   a@ When [code]#hostData# is not empty, construct a SYCL buffer with the
      contents of its stored pointer.  The buffer assumes exclusive access to
      this memory for the duration of its lifetime.  The buffer also creates
      its own internal copy of the [code]#shared_ptr# that shares ownership of
      the [code]#hostData# memory, which means the application can safely
      release ownership of this [code]#shared_ptr# when the constructor
      returns.

When [code]#hostData# is empty, construct a SYCL buffer with uninitialized
memory.

The constructed SYCL [code]#buffer# will use a default constructed
[code]#AllocatorT# when allocating memory on the host.  The range of the
constructed SYCL [code]#buffer# is specified by the [code]#bufferRange#
parameter provided.  Zero or more properties can be provided to the
constructed SYCL [code]#buffer# via an instance of [code]#property_list#.

a@
[source]
----
buffer(const std::shared_ptr<T>& hostData,
       const range<Dimensions>& bufferRange,
       AllocatorT allocator,
       const property_list& propList = {})
----
   a@ When [code]#hostData# is not empty, construct a SYCL buffer with the
      contents of its stored pointer.  The buffer assumes exclusive access to
      this memory for the duration of its lifetime.  The buffer also creates
      its own internal copy of the [code]#shared_ptr# that shares ownership of
      the [code]#hostData# memory, which means the application can safely
      release ownership of this [code]#shared_ptr# when the constructor
      returns.

When [code]#hostData# is empty, construct a SYCL buffer with uninitialized
memory.

The constructed SYCL [code]#buffer# will use the [code]#allocator# parameter
provided when allocating memory on the host.  The range of the constructed SYCL
[code]#buffer# is specified by the [code]#bufferRange# parameter provided.
Zero or more properties can be provided to the constructed SYCL [code]#buffer#
via an instance of [code]#property_list#.

a@
[source,c++]
----
buffer(const std::shared_ptr<T[]>& hostData,
       const range<Dimensions>&  bufferRange,
       const property_list& propList = {})
----
   a@ When [code]#hostData# is not empty, construct a SYCL buffer with the
      contents of its stored pointer.  The buffer assumes exclusive access to
      this memory for the duration of its lifetime.  The buffer also creates
      its own internal copy of the [code]#shared_ptr# that shares ownership of
      the [code]#hostData# memory, which means the application can safely
      release ownership of this [code]#shared_ptr# when the constructor
      returns.

When [code]#hostData# is empty, construct a SYCL buffer with uninitialized
memory.

The constructed SYCL [code]#buffer# will use a default constructed
[code]#AllocatorT# when allocating memory on the host.  The range of the
constructed SYCL [code]#buffer# is specified by the [code]#bufferRange#
parameter provided.  Zero or more properties can be provided to the
constructed SYCL [code]#buffer# via an instance of [code]#property_list#.

a@
[source,c++]
----
buffer(const std::shared_ptr<T[]>& hostData,
       const range<Dimensions>& bufferRange,
       AllocatorT allocator,
       const property_list& propList = {})
----
   a@ When [code]#hostData# is not empty, construct a SYCL buffer with the
      contents of its stored pointer.  The buffer assumes exclusive access to
      this memory for the duration of its lifetime.  The buffer also creates
      its own internal copy of the [code]#shared_ptr# that shares ownership of
      the [code]#hostData# memory, which means the application can safely
      release ownership of this [code]#shared_ptr# when the constructor
      returns.

When [code]#hostData# is empty, construct a SYCL buffer with uninitialized
memory.

The constructed SYCL [code]#buffer# will use the [code]#allocator# parameter
provided when allocating memory on the host.  The range of the constructed SYCL
[code]#buffer# is specified by the [code]#bufferRange# parameter provided.
Zero or more properties can be provided to the constructed SYCL [code]#buffer#
via an instance of [code]#property_list#.

a@
[source]
----
template <typename InputIterator>
buffer(InputIterator first, InputIterator last,
       const property_list& propList = {})
----
   a@ Create a new allocated 1D buffer initialized from the given elements
      ranging from [code]#first# up to one before [code]#last#.
      The data is copied to an intermediate memory position by the runtime.
      Data is not written back to the same iterator set provided. However, if the [code]#buffer# has a valid non-const iterator specified via the member function [code]#set_final_data()#, data will be copied back to that iterator.
      The constructed SYCL [code]#buffer# will use a default constructed [code]#AllocatorT# when allocating memory on the host.
      Zero or more properties can be provided to the constructed SYCL [code]#buffer# via an instance of [code]#property_list#.

a@
[source]
----
template <typename InputIterator>
buffer(InputIterator first, InputIterator last,
       AllocatorT allocator = {},
       const property_list& propList = {})
----
   a@ Create a new allocated 1D buffer initialized from the given elements
      ranging from [code]#first# up to one before [code]#last#.
      The data is copied to an intermediate memory position by the runtime.
      Data is not written back to the same iterator set provided. However, if the [code]#buffer# has a valid non-const iterator specified via the member function [code]#set_final_data()#, data will be copied back to that iterator.
      The constructed SYCL [code]#buffer# will use the [code]#allocator# parameter provided when allocating memory on the host.
      Zero or more properties can be provided to the constructed SYCL [code]#buffer# via an instance of [code]#property_list#.

a@
[source]
----
buffer(buffer& b, const id<Dimensions>& baseIndex,
       const range<Dimensions>& subRange)
----
   a@ Create a new sub-buffer without allocation to have separate
      accessors later. [code]#b# is the buffer with the real data, which must not be a sub-buffer.
      [code]#baseIndex# specifies the origin of the sub-buffer inside the
      buffer [code]#b#. [code]#subRange# specifies the size of the sub-buffer.
      The sum of [code]#baseIndex# and [code]#subRange# in any dimension must not
      exceed the parent buffer ([code]#b)# size ([code]#bufferRange)# in that dimension,
      and an [code]#exception# with the [code]#errc::invalid# error code must be thrown if violated.

The offset and range specified by [code]#baseIndex# and
[code]#subRange# together must represent a contiguous
region of the original SYCL [code]#buffer#.

If a non-contiguous region of a buffer is requested when
constructing a sub-buffer, then an [code]#exception# with
the [code]#errc::invalid# error code must be
thrown.

The origin (based on [code]#baseIndex#) of the sub-buffer being constructed
must be a multiple of the memory base address alignment of each SYCL
[code]#device# which accesses data from the buffer.  This value is retrievable
via the SYCL [code]#device# class info query
[code]#info::device::mem_base_addr_align#.  Violating this requirement causes
the implementation to throw an [code]#exception# with the [code]#errc::invalid#
error code from the [code]#accessor# constructor (if the accessor is not a
placeholder) or from [code]#handler::require()# (if the accessor is a
placeholder).  If the accessor is bound to a <<command-group>> with a secondary
queue, the sub-buffer's alignment must be compatible with both the primary
queue's device and the secondary queue's device, otherwise this exception is
thrown.

Must throw an [code]#exception# with the [code]#errc::invalid# error code if
[code]#b# is a sub-buffer.

|====



[[table.members.buffer]]
.Member functions for the [code]#buffer# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
range<Dimensions> get_range() const
----
   a@ Return a range object representing the
      size of the buffer in terms of number
      of elements in each dimension as passed
      to the constructor.

a@
[source]
----
size_t size() const noexcept
----
   a@ Returns the total number of elements in the buffer.
      Equal to [code]#+get_range()[0] * ... * get_range()[Dimensions-1]+#.
a@
[source]
----
size_t get_count() const
----
   a@ Returns the same value as [code]#size()#. Deprecated.
a@
[source]
----
size_t byte_size() const noexcept
----
   a@ Returns the size of the buffer storage in bytes.
      Equal to [code]#size()*sizeof(T)#.
a@
[source]
----
size_t get_size() const
----
   a@ Returns the same value as [code]#byte_size()#. Deprecated.
a@
[source]
----
AllocatorT get_allocator() const
----
   a@ Returns the allocator provided to the buffer.

a@
[source]
----
template <access_mode Mode = access_mode::read_write,
          target Targ = target::device>
accessor<T, Dimensions, Mode, Targ> get_access(handler& commandGroupHandler)
----
   a@ Returns a valid [code]#accessor# to the buffer with the specified
      access mode and target in the command group buffer.
      The value of target can be [code]#target::device#,
      [code]#target::constant_buffer# or
      [code]#target::host_task#.

a@
[source]
----
template <access_mode Mode>
accessor<T, Dimensions, Mode, target::host_buffer> get_access()
----
   a@ Deprecated in SYCL 2020.  Use [code]#get_host_access()# instead.

Returns a valid host [code]#accessor# to the buffer with the specified
access mode and target.

a@
[source]
----
template <access_mode Mode = access_mode::read_write,
          target Targ = target::device>
accessor<T, Dimensions, Mode, Targ> get_access(handler& commandGroupHandler,
                                               range<Dimensions> accessRange,
                                               id<Dimensions> accessOffset = {})
----
   a@ Returns a valid [code]#accessor# to the buffer with the specified access
      mode and target in the command group buffer.  The accessor is a
      <<ranged-accessor>>, where the range starts at the given offset from the
      beginning of the buffer.  The value of target can be
      [code]#target::device#, [code]#target::constant_buffer# or
      [code]#target::host_task#.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
the sum of [code]#accessRange# and [code]#accessOffset# exceeds the range of
the buffer in any dimension.

a@
[source]
----
template <access_mode Mode>
accessor<T, Dimensions, Mode, target::host_buffer>
get_access(range<Dimensions> accessRange, id<Dimensions> accessOffset = {})
----
   a@ Deprecated in SYCL 2020.  Use [code]#get_host_access()# instead.

Returns a valid host [code]#accessor# to the buffer with the specified access
mode and target.  The accessor is a <<ranged-accessor>>, where the range starts
at the given offset from the beginning of the buffer.  The value of target can
only be [code]#target::host_buffer#.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
the sum of [code]#accessRange# and [code]#accessOffset# exceeds the range of
the buffer in any dimension.

a@
[source]
----
template <typename... Ts> auto get_access(Ts... args)
----
   a@ Returns a valid [code]#accessor# as if constructed via passing the buffer
      and all provided arguments to the [code]#accessor# constructor.

Possible implementation:

[code]#+return accessor{*this, args...};+#

a@
[source]
----
template <typename... Ts> auto get_host_access(Ts... args)
----
   a@ Returns a valid [code]#host_accessor# as if constructed via passing the
      buffer and all provided arguments to the [code]#host_accessor#
      constructor.

Possible implementation:

[code]#+return host_accessor{*this, args...};+#

a@
[source]
----
template <typename Destination = std::nullptr_t>
void set_final_data(Destination finalData = nullptr)
----
   a@ The [code]#finalData# points to where the outcome of all
      the buffer processing is going to be copied to at destruction
      time, if the buffer was involved with a write accessor.

Destination can be either an output iterator or a
[code]#std::weak_ptr<T>#.

Note that a raw pointer is a special case of output iterator and
thus defines the host memory to which the result is to be
copied.

In the case of a weak pointer, the output is not updated if the
weak pointer has expired.

If [code]#Destination# is [code]#std::nullptr_t#, then
the copy back will not happen.

a@
[source]
----
void set_write_back(bool flag = true)
----
   a@ This member function allows dynamically forcing or canceling the
      write-back of the data of a buffer on destruction according to
      the value of [code]#flag#.

Forcing the write-back is similar to what happens during a
normal write-back as described in <<sec:buf-sync-rules>>
and <<sec:sharing-host-memory-with-dm>>.

If there is nowhere to write-back, using this function does not
have any effect.

a@
[source]
----
bool is_sub_buffer() const
----
   a@ Returns true if this SYCL [code]#buffer# is a sub-buffer, otherwise
      returns false.

a@
[source]
----
template <typename ReinterpretT, int ReinterpretDim>
buffer<ReinterpretT, ReinterpretDim,
       typename std::allocator_traits<AllocatorT>::template rebind_alloc<
           std::remove_const_t<ReinterpretT>>>
reinterpret(range<ReinterpretDim> reinterpretRange) const
----
   a@ Creates and returns a reinterpreted SYCL [code]#buffer#
      with the type specified by [code]#ReinterpretT#,
      dimensions specified by [code]#ReinterpretDim# and range
      specified by [code]#reinterpretRange#.  The buffer object
      being reinterpreted can be a SYCL sub-buffer that was created
      from a SYCL [code]#buffer# and must throw
      [code]#exception# with the
      [code]#errc::invalid# error code if the total
      size in bytes represented by the type and range of the
      reinterpreted SYCL [code]#buffer# (or sub-buffer) does not
      equal the total size in bytes represented by the type and range
      of this SYCL [code]#buffer# (or sub-buffer).
      Reinterpreting a sub-buffer provides a reinterpreted view of
      the sub-buffer only, and does not change the offset or size of
      the sub-buffer view (in bytes) relative to the parent
      [code]#buffer#.

a@
[source]
----
template <typename ReinterpretT, int ReinterpretDim = Dimensions>
buffer<ReinterpretT, ReinterpretDim,
       typename std::allocator_traits<AllocatorT>::template rebind_alloc<
           std::remove_const_t<ReinterpretT>>>
reinterpret() const
----
   a@ Creates and returns a reinterpreted SYCL [code]#buffer#
      with the type specified by [code]#ReinterpretT# and
      dimensions specified by [code]#ReinterpretDim#.
      Only valid when [code]#(ReinterpretDim == 1)# or when
      [code]#\((ReinterpretDim == Dimensions) && (sizeof(ReinterpretT) == sizeof(T)))#.
      The buffer object being reinterpreted can be a SYCL sub-buffer
      that was created from a SYCL [code]#buffer#.  The implementation must
      throw an [code]#exception# with the [code]#errc::invalid# error code
      if the total size in bytes represented by this SYCL [code]#buffer# (or
      sub-buffer) is not evenly divisible by [code]#sizeof(ReinterpretT)#.
      Reinterpreting a sub-buffer provides a reinterpreted view
      of the sub-buffer only,
      and does not change the offset or size of the sub-buffer view (in bytes)
      relative to the parent [code]#buffer#.

|====



[[sec:buffer-properties]]
==== Buffer properties

The properties that can be provided when constructing the SYCL [code]#buffer#
class are described in <<table.properties.buffer>>.


[[table.properties.buffer]]
.Properties supported by the SYCL [code]#buffer# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Property @ Description
a@
[source]
----
property::buffer::use_host_ptr
----
   a@ The [code]#use_host_ptr# property adds the requirement that the <<sycl-runtime>> must not allocate any memory for the SYCL [code]#buffer# and instead uses the provided host pointer directly. This prevents the <<sycl-runtime>> from allocating additional temporary storage on the host.

This property has a special guarantee for buffers that are constructed from a
[code]#hostData# pointer.  If a [code]#host_accessor# is constructed from such
a buffer, then the address of the [code]#reference# type returned from the
accessor's member functions such as [code]#operator[](id<>)# will be the same
as the corresponding [code]#hostData# address.

a@
[source]
----
property::buffer::use_mutex
----
   a@ The [code]#use_mutex# property is valid for the SYCL
      [code]#buffer#, [code]#unsampled_image# and
      [code]#sampled_image# classes. The property adds the
      requirement that the memory which is owned by the SYCL
      [code]#buffer# can be shared with the application via a
      [code]#std::mutex# provided to the property. The mutex
      [code]#m# is locked by the runtime whenever the data is in
      use and unlocked otherwise. The contents of [code]#hostData# are
      guaranteed to reflect the contents of the buffer when the
      [code]#std::mutex# is unlocked by the runtime.

a@
[source]
----
property::buffer::context_bound
----
   a@ The [code]#context_bound# property adds the requirement that the SYCL [code]#buffer# can only be associated with a single SYCL [code]#context# that is provided to the property.

|====


The constructors and special member functions of the buffer property classes are
listed in <<table.constructors.properties.buffer>> and
<<table.members.properties.buffer>> respectively.


[[table.constructors.properties.buffer]]
.Constructors of the [code]#buffer# [code]#property# classes
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
property::buffer::use_host_ptr::use_host_ptr()
----
   a@ Constructs a SYCL [code]#use_host_ptr# property instance.

a@
[source]
----
property::buffer::use_mutex::use_mutex(std::mutex& mutexRef)
----
   a@ Constructs a SYCL [code]#use_mutex# property instance with a reference to [code]#mutexRef# parameter provided.

a@
[source]
----
property::buffer::context_bound::context_bound(context boundContext)
----
   a@ Constructs a SYCL [code]#context_bound# property instance with a copy of a SYCL [code]#context#.

|====



[[table.members.properties.buffer]]
.Member functions of the [code]#buffer# [code]#property# classes
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
std::mutex* property::buffer::use_mutex::get_mutex_ptr() const
----
   a@ Returns the [code]#std::mutex# which was specified when
      constructing this SYCL [code]#use_mutex# property.

a@
[source]
----
context property::buffer::context_bound::get_context() const
----
   a@ Returns the [code]#context# which was specified when
      constructing this SYCL [code]#context_bound# property.

|====



[[sec:buf-sync-rules]]
==== Buffer destruction rules

Buffers are reference-counted.
When a buffer value is constructed from another buffer, the two values reference
the same buffer and a reference count is incremented.
When a buffer value is destroyed, the reference count is decremented.
Only when there are no more buffer values that reference a specific buffer is
the actual buffer destroyed and the buffer destruction behavior defined below is
followed.

If any error occurs on buffer destruction, it is reported via the associated
queue's asynchronous error handling mechanism.

The basic rule for the blocking behavior of a buffer destructor is that it
blocks if there is some data to write back because a write accessor on it has
been created, or if the buffer was constructed with attached host memory and is
still in use.

More precisely:

  . A buffer can be constructed from a [code]#range# (and without a
    [code]#hostData# pointer).
    The memory management for this type of buffer is entirely handled by the
    SYCL system.
    The destructor for this type of buffer does not need to block, even if work
    on the buffer has not completed.
    Instead, the SYCL system frees any storage required for the buffer
    asynchronously when it is no longer in use in queues.
    The initial contents of the buffer are unspecified.
  . A buffer can be constructed from a [code]#hostData# pointer.
    The buffer will use this host memory for its full lifetime, but the contents
    of this host memory are unspecified for the lifetime of the buffer.
    If the host memory is modified on the host or if it is used to construct
    another buffer or image during the lifetime of this buffer, then the results
    are undefined.
    The initial contents of the buffer will be the contents of the host memory
    at the time of construction.
+
--
When the buffer is destroyed, the destructor will block until all work in queues
on the buffer have completed, then copy the contents of the buffer back to the
host memory (if required) and then return.

  .. If the type of the host data is [code]#const#, then the buffer is
    read-only; only read accessors are allowed on the buffer and no-copy-back to
    host memory is performed (although the host memory must still be kept
    available for use by SYCL).
    When using the default buffer allocator, the const-ness of the type will be
    removed in order to allow host allocation of memory, which will allow
    temporary host copies of the data by the <<sycl-runtime>>, for example for
    speeding up host accesses.
+
When the buffer is destroyed, the destructor will block until all work in queues
on the buffer have completed and then return, as there is no copy of data back
to host.
  .. If the type of the host data is not [code]#const# but the pointer to host
    data is [code]#const#, then the read-only restriction applies only on host
    and not on device accesses.
+
When the buffer is destroyed, the destructor will block until all work in queues
on the buffer have completed.
--
  . A buffer can be constructed using a [code]#shared_ptr# to host data.
    This pointer is shared between the SYCL application and the runtime.
    In order to allow synchronization between the application and the runtime a
    [code]#mutex# is used which will be locked by the runtime whenever the data
    is in use, and unlocked when it is no longer needed.
+
--
The [code]#shared_ptr# reference counting is used in order to prevent destroying
the buffer host data prematurely.
If the [code]#shared_ptr# is deleted from the user application before buffer
destruction, the buffer can continue securely because the pointer hasn't been
destroyed yet.
It will not copy data back to the host before destruction, however, as the
application side has already deleted its copy.

Note that since there is an implicit conversion of a [code]#std::unique_ptr# to
a [code]#std::shared_ptr#, a [code]#std::unique_ptr# can also be used to pass
the ownership to the <<sycl-runtime>>.
--
  . A buffer can be constructed from a pair of iterator values.
    In this case, the buffer construction will copy the data from the data range
    defined by the iterator pair.
    The destructor will not copy back any data and does not need to block.

  . A buffer can be constructed from a container on which
    [code]#std::data(container)# and [code]#std::size(container)# are
    well-formed.
    The initial contents of the buffer will be the contents of the container at
    the time of construction.
+
--
The buffer may use the memory within the container for its full lifetime, and
the contents of this memory are unspecified for the lifetime of the buffer.
If the container memory is modified by the host during the lifetime of this
buffer, then the results are undefined.

When the buffer is destroyed, the destructor will block until all work in queues
on the buffer have completed.
If the return type of [code]#std::data(container)# is not [code]#const# then the
destructor will also copy the contents of the buffer to the container (if
required).
--


If [code]#set_final_data()# is used to change where to write the data back to,
then the destructor of the buffer will block if a write accessor on it has been
created.

A sub-buffer object can be created which is a sub-range reference to a base
buffer.
This sub-buffer can be used to create accessors to the base buffer, which have
access to the range specified at time of construction of the sub-buffer.
Sub-buffers cannot be created from sub-buffers, but only from a base buffer
which is not already a sub-buffer.

Sub-buffers must be constructed from a contiguous region of memory in a buffer.
This requirement is potentially non-intuitive when working with buffers that
have dimensionality larger than one, but maps to one-dimensional <<backend>>
native allocations without performance cost due to index mapping computation.
For example:

[source,,linenums]
----
include::{code_dir}/subbuffer.cpp[lines=4..-1]
----


[[subsec:images]]
=== Images

The classes [code]#unsampled_image# (<<table.constructors.unsampledImage>>) and
[code]#sampled_image# (<<table.constructors.sampledImage>>) define shared image
data of one, two or three dimensions, that can be used by kernels in queues and
have to be accessed using the image <<accessor>> classes.

The constructors and member functions of the SYCL [code]#unsampled_image# and
[code]#sampled_image# class templates are listed in
<<table.constructors.unsampledImage>>, <<table.members.unsampledImage>>,
<<table.constructors.sampledImage>> and <<table.members.sampledImage>>,
respectively.
The additional common special member functions and common member functions are
listed in <<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>>, respectively.

Where relevant, it is the responsibility of the user to ensure that the format
of the data matches the format described by [code]#image_format#.

The allocator template parameter of the SYCL [code]#unsampled_image# and
[code]#sampled_image# classes can be any allocator type including a custom
allocator, however it must allocate in units of [code]#std::byte#.

For any image that is constructed with the range latexmath:[(r1,r2,r3)] with an
element type size in bytes of _s_, the image row pitch and image slice pitch
should be calculated as follows:

[[image-row-pitch]]
[latexmath]
++++
r1 \cdot s
++++

[[image-slice-pitch]]
[latexmath]
++++
r1 \cdot r2 \cdot s
++++

The SYCL [code]#unsampled_image# and [code]#sampled_image# class templates
provide the common reference semantics (see <<sec:reference-semantics>>).


==== Unsampled image interface

Each constructor of the [code]#unsampled_image# takes an [code]#image_format# to
describe the data layout of the image data.

Each constructor additionally takes as the last parameter an optional SYCL
[code]#property_list# to provide properties to the SYCL [code]#unsampled_image#.

The SYCL [code]#unsampled_image# class template takes a template parameter
[code]#AllocatorT# for specifying an allocator which is used by the
<<sycl-runtime>> when allocating temporary memory on the host.
If no template argument is provided, the default allocator for the SYCL
[code]#unsampled_image# class [code]#image_allocator# is used (see
<<subsec:default.allocators>>).

// Interface for class: unsampled image
[source,,linenums]
----
include::{header_dir}/unsampledImage.h[lines=4..-1]
----


[[table.constructors.unsampledImage]]
.Constructors of the [code]#unsampled_image# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
unsampled_image(image_format format,
                const range<Dimensions>& rangeRef,
                const property_list& propList = {})
----
   a@ Construct a SYCL [code]#unsampled_image# instance with
      uninitialized memory.
      The constructed SYCL [code]#unsampled_image# will use a default
      constructed [code]#AllocatorT# when allocating memory on the
      host.
      The element size of the constructed SYCL [code]#unsampled_image#
      will be derived from the [code]#format# parameter.
      The range of the constructed SYCL [code]#unsampled_image# is
      specified by the [code]#rangeRef# parameter provided.
      The pitch of the constructed SYCL [code]#unsampled_image# will be
      the default size determined by the <<sycl-runtime>>.
      Unless the member function [code]#set_final_data()# is called
      with a valid non-null pointer, there will be no write back on
      destruction.
      Zero or more properties can be provided to the constructed SYCL
      [code]#unsampled_image# via an instance of
      [code]#property_list#.

a@
[source]
----
unsampled_image(image_format format,
                const range<Dimensions>& rangeRef,
                AllocatorT allocator,
                const property_list& propList = {})
----
   a@ Construct a SYCL [code]#unsampled_image# instance with
      uninitialized memory.
      The constructed SYCL [code]#unsampled_image# will use the
      [code]#allocator# parameter provided when allocating memory on
      the host.
      The element size of the constructed SYCL [code]#unsampled_image#
      will be derived from the [code]#format# parameter.
      The range of the constructed SYCL [code]#unsampled_image# is
      specified by the [code]#rangeRef# parameter provided.
      The pitch of the constructed SYCL [code]#unsampled_image# will be
      the default size determined by the <<sycl-runtime>>.
      Unless the member function [code]#set_final_data()# is called
      with a valid non-null pointer, there will be no write back on
      destruction.
      Zero or more properties can be provided to the constructed SYCL
      [code]#unsampled_image# via an instance of
      [code]#property_list#.

a@
[source]
----
unsampled_image(image_format format,
                const range<Dimensions>& rangeRef,
                const range<Dimensions - 1>& pitch,
                const property_list& propList = {})
----
   a@ Available only when: [code]#Dimensions > 1#.

Construct a SYCL [code]#unsampled_image# instance with
uninitialized memory.
The constructed SYCL [code]#unsampled_image# will use a default
constructed [code]#AllocatorT# when allocating memory on the
host.
The element size of the constructed SYCL [code]#unsampled_image#
will be derived from the [code]#format# parameter.
The range of the constructed SYCL [code]#unsampled_image# is
specified by the [code]#rangeRef# parameter provided.
The pitch of the constructed SYCL [code]#unsampled_image# will be
the [code]#pitch# parameter provided.
Unless the member function [code]#set_final_data()# is called
with a valid non-null pointer, there will be no write back on
destruction.
Zero or more properties can be provided to the constructed SYCL
[code]#unsampled_image# via an instance of
[code]#property_list#.

a@
[source]
----
unsampled_image(image_format format,
                const range<Dimensions>& rangeRef,
                const range<Dimensions - 1>& pitch,
                AllocatorT allocator,
                const property_list& propList = {})
----
   a@ Available only when: [code]#Dimensions > 1#.

Construct a SYCL [code]#unsampled_image# instance with
uninitialized memory.
The constructed SYCL [code]#unsampled_image# will use the
[code]#allocator# parameter provided when allocating memory on
the host.
The element size of the constructed SYCL [code]#unsampled_image#
will be derived from the [code]#format# parameter.
The range of the constructed SYCL [code]#unsampled_image# is
specified by the [code]#rangeRef# parameter provided.
The pitch of the constructed SYCL [code]#unsampled_image# will be
the [code]#pitch# parameter provided.
Unless the member function [code]#set_final_data()# is called
with a valid non-null pointer, there will be no write back on
destruction.
Zero or more properties can be provided to the constructed SYCL
[code]#unsampled_image# via an instance of
[code]#property_list#.

a@
[source]
----
unsampled_image(void* hostPointer, image_format format,
                const range<Dimensions>& rangeRef,
                const property_list& propList = {})
----
   a@ Construct a SYCL [code]#unsampled_image# instance with the
      [code]#hostPointer# parameter provided.  The [code]#unsampled_image#
      assumes exclusive access to this memory for the duration of its lifetime.
      The constructed SYCL [code]#unsampled_image# will use a default
      constructed [code]#AllocatorT# when allocating memory on the
      host.
      The element size of the constructed SYCL [code]#unsampled_image#
      will be derived from the [code]#format# parameter.
      The range of the constructed SYCL [code]#unsampled_image# is
      specified by the [code]#rangeRef# parameter provided.
      The pitch of the constructed SYCL [code]#unsampled_image# will be
      the default size determined by the <<sycl-runtime>>.
      Unless the member function [code]#set_final_data()# is called
      with a valid non-null pointer, any memory allocated by the
      <<sycl-runtime>> is written back to [code]#hostPointer#.
      Zero or more properties can be provided to the constructed SYCL
      [code]#unsampled_image# via an instance of
      [code]#property_list#.

a@
[source]
----
unsampled_image(void* hostPointer, image_format format,
                const range<Dimensions>& rangeRef,
                AllocatorT allocator,
                const property_list& propList = {})
----
   a@ Construct a SYCL [code]#unsampled_image# instance with the
      [code]#hostPointer# parameter provided.  The [code]#unsampled_image#
      assumes exclusive access to this memory for the duration of its lifetime.
      The constructed SYCL [code]#unsampled_image# will use the
      [code]#allocator# parameter provided when allocating memory on
      the host.
      The element size of the constructed SYCL [code]#unsampled_image#
      will be derived from the [code]#format# parameter.
      The range of the constructed SYCL [code]#unsampled_image# is
      specified by the [code]#rangeRef# parameter provided.
      The pitch of the constructed SYCL [code]#unsampled_image# will be
      the default size determined by the <<sycl-runtime>>.
      Unless the member function [code]#set_final_data()# is called
      with a valid non-null pointer, any memory allocated by the
      <<sycl-runtime>> is written back to [code]#hostPointer#.
      Zero or more properties can be provided to the constructed SYCL
      [code]#unsampled_image# via an instance of [code]#property_list#.

a@
[source]
----
unsampled_image(void* hostPointer, image_format format,
                const range<Dimensions>& rangeRef,
                const range<Dimensions - 1>& pitch,
                const property_list& propList = {})
----
   a@ Available only when: [code]#Dimensions > 1#

Construct a SYCL [code]#unsampled_image# instance with the
[code]#hostPointer# parameter provided.  The [code]#unsampled_image# assumes
exclusive access to this memory for the duration of its lifetime.
The constructed SYCL [code]#unsampled_image# will use a default
constructed [code]#AllocatorT# when allocating memory on the
host.
The element size of the constructed SYCL [code]#unsampled_image#
will be derived from the [code]#format# parameter.
The range of the constructed SYCL [code]#unsampled_image# is
specified by the [code]#rangeRef# parameter provided.
The pitch of the constructed SYCL [code]#unsampled_image# will be
the [code]#pitch# parameter provided.
Unless the member function [code]#set_final_data()# is called
with a valid non-null pointer, any memory allocated by the
<<sycl-runtime>> is written back to [code]#hostPointer#.
Zero or more properties can be provided to the constructed SYCL
[code]#unsampled_image# via an instance of
[code]#property_list#.

a@
[source]
----
unsampled_image(void* hostPointer, image_format format,
                const range<Dimensions>& rangeRef,
                const range<Dimensions - 1>& pitch,
                AllocatorT allocator,
                const property_list& propList = {})
----
   a@ Available only when: [code]#Dimensions > 1#.

Construct a SYCL [code]#unsampled_image# instance with the
[code]#hostPointer# parameter provided. The [code]#unsampled_image# assumes
exclusive access to this memory for the duration of its lifetime.
The constructed SYCL [code]#unsampled_image# will use the
[code]#allocator# parameter provided when allocating memory on
the host.
The element size of the constructed SYCL [code]#unsampled_image#
will be derived from the [code]#format# parameter.
The range of the constructed SYCL [code]#unsampled_image# is
specified by the [code]#rangeRef# parameter provided.
The pitch of the constructed SYCL [code]#unsampled_image# will be
the [code]#pitch# parameter provided.
Unless the member function [code]#set_final_data()# is called
with a valid non-null pointer, any memory allocated by the
<<sycl-runtime>> is written back to [code]#hostPointer#.
Zero or more properties can be provided to the constructed SYCL
[code]#unsampled_image# via an instance of [code]#property_list#.

a@
[source]
----
unsampled_image(std::shared_ptr<void>& hostPointer,
                image_format format,
                const range<Dimensions>& rangeRef,
                const property_list& propList = {})
----
   a@ When [code]#hostPointer# is not empty, construct a SYCL
      [code]#unsampled_image# with the contents of its stored pointer.  The
      [code]#unsampled_image# assumes exclusive access to this memory for the
      duration of its lifetime.  The [code]#unsampled_image# also creates its
      own internal copy of the [code]#shared_ptr# that shares ownership of the
      [code]#hostData# memory, which means the application can safely release
      ownership of this [code]#shared_ptr# when the constructor returns.

When [code]#hostPointer# is empty, construct a SYCL [code]#unsampled_image#
with uninitialized memory.

The constructed SYCL [code]#unsampled_image# will use a default
constructed [code]#AllocatorT# when allocating memory on the
host.
The element size of the constructed SYCL [code]#unsampled_image#
will be derived from the [code]#format# parameter.
The range of the constructed SYCL [code]#unsampled_image# is
specified by the [code]#rangeRef# parameter provided.
The pitch of the constructed SYCL [code]#unsampled_image# will be
the default size determined by the <<sycl-runtime>>.
Unless the member function [code]#set_final_data()# is called
with a valid non-null pointer, any memory allocated by the
<<sycl-runtime>> is written back to [code]#hostPointer#.
Zero or more properties can be provided to the constructed SYCL
[code]#unsampled_image# via an instance of [code]#property_list#.

a@
[source]
----
unsampled_image(std::shared_ptr<void>& hostPointer,
                image_format format,
                const range<Dimensions>& rangeRef,
                AllocatorT allocator,
                const property_list& propList = {})
----
   a@ When [code]#hostPointer# is not empty, construct a SYCL
      [code]#unsampled_image# with the contents of its stored pointer.  The
      [code]#unsampled_image# assumes exclusive access to this memory for the
      duration of its lifetime.  The [code]#unsampled_image# also creates its
      own internal copy of the [code]#shared_ptr# that shares ownership of the
      [code]#hostData# memory, which means the application can safely release
      ownership of this [code]#shared_ptr# when the constructor returns.

When [code]#hostPointer# is empty, construct a SYCL [code]#unsampled_image#
with uninitialized memory.

The constructed SYCL [code]#unsampled_image# will use the
[code]#allocator# parameter provided when allocating memory on
the host.
The element size of the constructed SYCL [code]#unsampled_image#
will be derived from the [code]#format# parameter.
The range of the constructed SYCL [code]#unsampled_image# is
specified by the [code]#rangeRef# parameter provided.
The pitch of the constructed SYCL [code]#unsampled_image# will be
the default size determined by the <<sycl-runtime>>.
Unless the member function [code]#set_final_data()# is called
with a valid non-null pointer, any memory allocated by the
<<sycl-runtime>> is written back to [code]#hostPointer#.
Zero or more properties can be provided to the constructed SYCL
[code]#unsampled_image# via an instance of [code]#property_list#.

a@
[source]
----
unsampled_image(std::shared_ptr<void>& hostPointer,
                image_format format,
                const range<Dimensions>& rangeRef,
                const range<Dimensions - 1>& pitch,
                const property_list& propList = {})
----
   a@ When [code]#hostPointer# is not empty, construct a SYCL
      [code]#unsampled_image# with the contents of its stored pointer.  The
      [code]#unsampled_image# assumes exclusive access to this memory for the
      duration of its lifetime.  The [code]#unsampled_image# also creates its
      own internal copy of the [code]#shared_ptr# that shares ownership of the
      [code]#hostData# memory, which means the application can safely release
      ownership of this [code]#shared_ptr# when the constructor returns.

When [code]#hostPointer# is empty, construct a SYCL [code]#unsampled_image#
with uninitialized memory.

The constructed SYCL [code]#unsampled_image# will use a default
constructed [code]#AllocatorT# when allocating memory on the
host.
The element size of the constructed SYCL [code]#unsampled_image#
will be derived from the [code]#format# parameter.
The range of the constructed SYCL [code]#unsampled_image# is
specified by the [code]#rangeRef# parameter provided.
The pitch of the constructed SYCL [code]#unsampled_image# will be
the [code]#pitch# parameter provided.
Unless the member function [code]#set_final_data()# is called
with a valid non-null pointer, any memory allocated by the
<<sycl-runtime>> is written back to [code]#hostPointer#.
Zero or more properties can be provided to the constructed SYCL
[code]#unsampled_image# via an instance of [code]#property_list#.

a@
[source]
----
unsampled_image(std::shared_ptr<void>& hostPointer,
                image_format format,
                const range<Dimensions>& rangeRef,
                const range<Dimensions - 1>& pitch,
                AllocatorT allocator,
                const property_list& propList = {})
----
   a@ When [code]#hostPointer# is not empty, construct a SYCL
      [code]#unsampled_image# with the contents of its stored pointer.  The
      [code]#unsampled_image# assumes exclusive access to this memory for the
      duration of its lifetime.  The [code]#unsampled_image# also creates its
      own internal copy of the [code]#shared_ptr# that shares ownership of the
      [code]#hostData# memory, which means the application can safely release
      ownership of this [code]#shared_ptr# when the constructor returns.

When [code]#hostPointer# is empty, construct a SYCL [code]#unsampled_image#
with uninitialized memory.

The constructed SYCL [code]#unsampled_image# will use the
[code]#allocator# parameter provided when allocating memory on
the host.
The element size of the constructed SYCL [code]#unsampled_image#
will be derived from the [code]#format# parameter.
The range of the constructed SYCL [code]#unsampled_image# is
specified by the [code]#rangeRef# parameter provided.
The pitch of the constructed SYCL [code]#unsampled_image# will be
the [code]#pitch# parameter provided.
Unless the member function [code]#set_final_data()# is called
with a valid non-null pointer, any memory allocated by the
<<sycl-runtime>> is written back to [code]#hostPointer#.
Zero or more properties can be provided to the constructed SYCL
[code]#unsampled_image# via an instance of [code]#property_list#.

|====



[[table.members.unsampledImage]]
.Member functions of the [code]#unsampled_image# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
range<Dimensions> get_range() const
----
   a@ Return a range object representing the
      size of the image in terms of the number
      of elements in each dimension as passed
      to the constructor.

a@
[source]
----
range<Dimensions - 1> get_pitch() const
----
   a@ Available only when: [code]#Dimensions > 1#.

Return a range object representing the
pitch of the image in bytes.

a@
[source]
----
size_t size() const noexcept
----
   a@ Returns the total number of elements in the image.
      Equal to [code]#+get_range()[0] * ... * get_range()[Dimensions-1]+#.

a@
[source]
----
size_t byte_size() const noexcept
----
   a@ Returns the size of the image storage in bytes.  The number of
      bytes may be greater than [code]#size()*element size#
      due to padding of elements, rows and slices of the image for
      efficient access.

a@
[source]
----
AllocatorT get_allocator() const
----
   a@ Returns the allocator provided to the image.

a@
[source]
----
template <typename DataT,
         access_mode Mode = (std::is_const_v<DataT>
                                 ? access_mode::read
                                 : access_mode::read_write),
         image_target Targ = image_target::device>
unsampled_image_accessor<DataT, Dimensions, Mode, Targ>
get_access(handler& commandGroupHandler)
----
   a@ Returns a valid [code]#unsampled_image_accessor# to the unsampled image
      with the specified data type, access mode and target in the command group.

a@
[source]
----
template <typename DataT, access_mode Mode = (std::is_const_v<DataT>
                                                   ? access_mode::read
                                                   : access_mode::read_write)>
host_unsampled_image_accessor<DataT, Dimensions, Mode> get_host_access();
----
   a@ Returns a valid [code]#host_unsampled_image_accessor# to the unsampled
      image with the specified data type and access mode.

a@
[source]
----
template <typename Destination = std::nullptr_t>
void set_final_data(Destination finalData = nullptr)
----
   a@ The [code]#finalData# point to where the output of all
      the image processing is going to be copied to at destruction
      time, if the image was involved with a write accessor.

Destination can be either an output iterator, or a
[code]#std::weak_ptr<T>#.

Note that a raw pointer is a special case of output iterator and
thus defines the host memory to which the result is to be
copied.

In the case of a weak pointer, the output is not copied if the
weak pointer has expired.

If [code]#Destination# is [code]#std::nullptr_t#, then
the copy back will not happen.

a@
[source]
----
void set_write_back(bool flag = true)
----
   a@ This member function allows dynamically forcing or canceling the
      write-back of the data of an image on destruction according to
      the value of [code]#flag#.

Forcing the write-back is similar to what happens during a
normal write-back as described in <<sec:image-sync-rules>>
and <<sec:sharing-host-memory-with-dm>>.

If there is nowhere to write-back, using this function does not
have any effect.

|====



==== Sampled image interface

Each constructor of the [code]#sampled_image# class requires a pointer to the
host data the image will sample, an [code]#image_format# to describe the data
layout and an [code]#image_sampler# (<<subsec:samplers>>) to describe how to
sample the image data.

Each constructor additionally takes as the last parameter an optional SYCL
[code]#property_list# to provide properties to the SYCL [code]#sampled_image#.

// Interface for class: sampled image
[source,,linenums]
----
include::{header_dir}/sampledImage.h[lines=4..-1]
----


[[table.constructors.sampledImage]]
.Constructors of the [code]#sampled_image# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
sampled_image(const void* hostPointer, image_format format,
              image_sampler sampler,
              const range<Dimensions>& rangeRef,
              const property_list& propList = {})
----
   a@ Construct a SYCL [code]#sampled_image# instance with the
      [code]#hostPointer# parameter provided.  The [code]#sampled_image#
      assumes exclusive access to this memory for the duration of its lifetime.
      The host address is [code]#const#, so the host accesses must be
      read-only. Since, the [code]#hostPointer# is [code]#const#, this image is only
      initialized with this memory and there is no write after its
      destruction.
      The element size of the constructed SYCL [code]#sampled_image#
      will be derived from the [code]#format# parameter.
      Accessors that read the constructed SYCL [code]#sampled_image# will
      use the [code]#sampler# parameter to sample the image.
      The range of the constructed SYCL [code]#sampled_image# is
      specified by the [code]#rangeRef# parameter provided.
      The pitch of the constructed SYCL [code]#sampled_image# will be
      the default size determined by the <<sycl-runtime>>.
      Zero or more properties can be provided to the constructed SYCL
      [code]#sampled_image# via an instance of
      [code]#property_list#.

a@
[source]
----
sampled_image(const void* hostPointer, image_format format,
              image_sampler sampler,
              const range<Dimensions>& rangeRef,
              const range<Dimensions - 1>& pitch,
              const property_list& propList = {})
----
   a@ Available only when: [code]#Dimensions > 1#.

Construct a SYCL [code]#sampled_image# instance with the [code]#hostPointer#
parameter provided.  The [code]#sampled_image# assumes exclusive access to this
memory for the duration of its lifetime.
The host address is [code]#const#, so the host accesses must be
read-only. Since, the [code]#hostPointer# is [code]#const#, this
image is only initialized with this memory and there is no write after
destruction.
The element size of the constructed SYCL [code]#sampled_image#
will be derived from the [code]#format# parameter.
Accessors that read the constructed SYCL [code]#sampled_image# will
use the [code]#sampler# parameter to sample the image.
The range of the constructed SYCL [code]#sampled_image# is
specified by the [code]#rangeRef# parameter provided.
The pitch of the constructed SYCL [code]#sampled_image# will be
the [code]#pitch# parameter provided.
Zero or more properties can be provided to the constructed SYCL
[code]#sampled_image# via an instance of
[code]#property_list#.

a@
[source]
----
sampled_image(std::shared_ptr<const void>& hostPointer,
              image_format format,
              image_sampler sampler,
              const range<Dimensions>& rangeRef,
              const property_list& propList = {})
----
   a@ When [code]#hostPointer# is not empty, construct a SYCL
      [code]#sampled_image# with the contents of its stored pointer.  The
      [code]#sampled_image# assumes exclusive access to this memory for the
      duration of its lifetime.  The [code]#sampled_image# also creates its
      own internal copy of the [code]#shared_ptr# that shares ownership of the
      [code]#hostData# memory, which means the application can safely release
      ownership of this [code]#shared_ptr# when the constructor returns.

When [code]#hostPointer# is empty, construct a SYCL [code]#sampled_image#
with uninitialized memory.

The host address is [code]#const#, so the host accesses must be
read-only. Since, the [code]#hostPointer# is [code]#const#, this image is only
initialized with this memory and there is no write after its
destruction.
The element size of the constructed SYCL [code]#sampled_image#
will be derived from the [code]#format# parameter.
Accessors that read the constructed SYCL [code]#sampled_image# will
use the [code]#sampler# parameter to sample the image.
The range of the constructed SYCL [code]#sampled_image# is
specified by the [code]#rangeRef# parameter provided.
The pitch of the constructed SYCL [code]#sampled_image# will be
the default size determined by the <<sycl-runtime>>.
Zero or more properties can be provided to the constructed SYCL
[code]#sampled_image# via an instance of
[code]#property_list#.

a@
[source]
----
sampled_image(std::shared_ptr<const void>& hostPointer,
              image_format format,
              image_sampler sampler,
              const range<Dimensions>& rangeRef,
              const range<Dimensions - 1>& pitch,
              const property_list& propList = {})
----
   a@ When [code]#hostPointer# is not empty, construct a SYCL
      [code]#sampled_image# with the contents of its stored pointer.  The
      [code]#sampled_image# assumes exclusive access to this memory for the
      duration of its lifetime.  The [code]#sampled_image# also creates its
      own internal copy of the [code]#shared_ptr# that shares ownership of the
      [code]#hostData# memory, which means the application can safely release
      ownership of this [code]#shared_ptr# when the constructor returns.

When [code]#hostPointer# is empty, construct a SYCL [code]#sampled_image#
with uninitialized memory.

The host address is [code]#const#, so the host accesses can be
read-only. Since, the [code]#hostPointer# is [code]#const#, this image is only
initialized with this memory and there is no write after its
destruction.
The element size of the constructed SYCL [code]#sampled_image#
will be derived from the [code]#format# parameter.
Accessors that read the constructed SYCL [code]#sampled_image# will
use the [code]#sampler# parameter to sample the image.
The range of the constructed SYCL [code]#sampled_image# is
specified by the [code]#rangeRef# parameter provided.
The pitch of the constructed SYCL [code]#sampled_image# will be
the [code]#pitch# parameter provided.
Zero or more properties can be provided to the constructed SYCL
[code]#sampled_image# via an instance of
[code]#property_list#.

|====



[[table.members.sampledImage]]
.Member functions of the [code]#sampled_image# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
range<Dimensions> get_range() const
----
   a@ Return a range object representing the
      size of the image in terms of the number
      of elements in each dimension as passed
      to the constructor.

a@
[source]
----
range<Dimensions - 1> get_pitch() const
----
   a@ Available only when: [code]#Dimensions > 1#.

Return a range object representing the
pitch of the image in bytes.

a@
[source]
----
size_t size() const noexcept
----
   a@ Returns the total number of elements in the image.
      Equal to [code]#+get_range()[0] * ... * get_range()[Dimensions-1]+#.

a@
[source]
----
size_t byte_size() const noexcept
----
   a@ Returns the size of the image storage in bytes.  The number of
      bytes may be greater than [code]#size()*element size#
      due to padding of elements, rows and slices of the image for
      efficient access.

a@
[source]
----
template <typename DataT, image_target Targ = image_target::device>
sampled_image_accessor<DataT, Dimensions, Targ>
get_access(handler& commandGroupHandler)
----
   a@ Returns a valid [code]#sampled_image_accessor# to the sampled image with
      the specified data type and target in the command group.

a@
[source]
----
template <typename DataT>
host_sampled_image_accessor<DataT, Dimensions> get_host_access()
----
   a@ Returns a valid [code]#host_sampled_image_accessor# to the sampled image
      with the specified data type in the command group.

|====



[[sec:image-properties]]
==== Image properties

The properties that can be provided when constructing the SYCL
[code]#unsampled_image# and [code]#sampled_image# classes are described in
<<table.properties.image>>.

// Interface for image properties
[source,,linenums]
----
include::{header_dir}/imageProperties.h[lines=4..-1]
----


[[table.properties.image]]
.Properties supported by the SYCL image classes
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Property @ Description
a@
[source]
----
property::image::use_host_ptr
----
   a@ The [code]#use_host_ptr# property adds the requirement that the <<sycl-runtime>> must not allocate any memory for the [code]#image# and instead uses the provided host pointer directly. This prevents the <<sycl-runtime>> from allocating additional temporary storage on the host.

a@
[source]
----
property::image::use_mutex
----
   a@ The property adds the requirement that the memory which
      is owned by the SYCL [code]#image# can be shared with the
      application via a [code]#std::mutex# provided to the
      property. The [code]#std::mutex# is locked by
      the runtime whenever the data is in use and unlocked
      otherwise. The contents of [code]#hostData# are
      guaranteed to reflect the contents of the image when the
      [code]#std::mutex# is unlocked by the runtime.

a@
[source]
----
property::image::context_bound
----
   a@ The [code]#context_bound# property adds the requirement that the SYCL [code]#image# can only be associated with a single SYCL [code]#context# that is provided to the property.

|====


The constructors and member functions of the image [code]#property# classes are
listed in <<table.constructors.properties.image>> and
<<table.members.properties.image>>


[[table.constructors.properties.image]]
.Constructors of the image [code]#property# classes
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
property::image::use_host_ptr::use_host_ptr()
----
   a@ Constructs a SYCL [code]#use_host_ptr# property instance.

a@
[source]
----
property::image::use_mutex::use_mutex(std::mutex& mutexRef)
----
   a@ Constructs a SYCL [code]#use_mutex# property instance with a reference to [code]#mutexRef# parameter provided.

a@
[source]
----
property::image::context_bound::context_bound(context boundContext)
----
   a@ Constructs a SYCL [code]#context_bound# property instance with a copy of a SYCL [code]#context#.

|====



[[table.members.properties.image]]
.Member functions of the image [code]#property# classes
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
std::mutex* property::image::use_mutex::get_mutex_ptr() const
----
   a@ Returns the [code]#std::mutex# which was specified when
      constructing this SYCL [code]#use_mutex# property.

a@
[source]
----
context property::image::context_bound::get_context() const
----
   a@ Returns the [code]#context# which was specified when
      constructing this SYCL [code]#context_bound# property.

|====



[[sec:image-sync-rules]]
==== Image destruction rules

The rules are similar to those described in <<sec:buf-sync-rules>>.

For the lifetime of the image object, the associated host memory must be left
available to the <<sycl-runtime>> and the contents of the associated host memory
is unspecified until the image object is destroyed.
If an image object value is copied, then only a reference to the underlying
image object is copied.
The underlying image object is reference-counted.
Only after all image value references to the underlying image object have been
destroyed is the actual image object itself destroyed.

If an image object is constructed with associated host memory, then its
destructor blocks until all operations in all SYCL queues on that image object
have completed.
Any modifications to the image data will be copied back, if necessary, to the
associated host memory.
Any errors occurring during destruction are reported to any associated context's
asynchronous error handler.
If an image object is constructed with a storage object, then the storage object
defines what blocking or copying behavior occurs on image object destruction.


[[sec:sharing-host-memory-with-dm]]
=== Sharing host memory with the SYCL data management classes

In order to allow the <<sycl-runtime>> to do memory management and allow for
data dependencies, there are two classes defined, buffer and image.
The default behavior for them is that a "`raw`" pointer is given during the
construction of the data management class, with full ownership to use it until
the destruction of the SYCL object.

In this section we go in greater detail on sharing or explicitly not sharing
host memory with the SYCL data classes, and we will use the buffer class as an
example.
The same rules will apply to images as well.


==== Default behavior

When using a SYCL buffer, the ownership of the pointer passed to the constructor
of the class is, by default, passed to <<sycl-runtime>>, and that pointer cannot
be used on the host side until the buffer or image is destroyed.
A SYCL application can access the contents of the memory managed by a SYCL
buffer by using a [code]#host_accessor# as defined in <<subsec:accessors>>.
However, there is no guarantee that the host accessor will copy data back to the
original host address used in its constructor.

The pointer passed in is the one used to copy data back to the host, if needed,
before buffer destruction.
The memory pointed by <<host-pointer>> will not be de-allocated by the runtime,
and the data is copied back from the device if there is a need for it.


==== SYCL ownership of the host memory

In the case where there is host memory to be used for initialization of data but
there is no intention of using that host memory after the buffer is destroyed,
then the buffer can take full ownership of that host memory.

When a buffer owns the <<host-pointer>> there is no copy back, by default.
In this situation, the SYCL application may pass a unique pointer to the host
data, which will be then used by the runtime internally to initialize the data
in the device.

For example, the following could be used:

[source,,linenums]
----
{
  auto ptr = std::make_unique<int>(-1234);
  buffer<int, 1> b { std::move(ptr), range { 1 } };
  // ptr is not valid anymore.
  // There is nowhere to copy data back
}
----

However, optionally the [code]#buffer::set_final_data()# can be set to a
[code]#std::weak_ptr# to enable copying data back, to another host memory
address that will be valid when the buffer is destroyed.

[source,,linenums]
----
{
  auto ptr = std::make_unique<int>(-42);
  buffer<int, 1> b { std::move(ptr), range { 1 } };
  // ptr is not valid anymore.
  // There is nowhere to copy data back.
  // To get copy back, a location can be specified:
  b.set_final_data(std::weak_ptr<int> { .... })
}
----


==== Shared SYCL ownership of the host memory

When an instance of [code]#std::shared_ptr# is passed to the buffer constructor,
then the buffer object and the developer's application share the memory region.
If the shared pointer is still used on the application's side then the data will
be copied back from the buffer or image and will be available to the application
after the buffer or image is destroyed.

If the [code]#shared_ptr# is not empty, the contents of the referenced memory
are used to initialize the buffer.
If the [code]#shared_ptr# is empty, then the buffer is created with
uninitialized memory.

When the buffer is destroyed and the data have potentially been updated, if the
number of copies of the shared pointer outside the runtime is 0, there is no
user-side shared pointer to read the data.
Therefore the data is not copied out, and the buffer destructor does not need to
wait for the data processes to be finished, as the outcome is not needed on the
application's side.

This behavior can be overridden using the [code]#set_final_data()# member
function of the buffer class, which will by any means force the buffer
destructor to wait until the data is copied to wherever the
[code]#set_final_data()# member function has put the data (or not wait nor copy
if set final data is [code]#nullptr)#.

[source,,linenums]
----
{
  std::shared_ptr<int> ptr { data };
  {
    buffer<int, 2> b { ptr, { 10, 10 } };
    // update the data
    [...]
  } // Data is copied back because there is an user side shared_ptr
}
----

[source,,linenums]
----
{
  std::shared_ptr<int> ptr { data };
  {
    buffer<int, 2> b { ptr, { 10, 10 } };
    // update the data
    [...]
    ptr.reset();
  } // Data is not copied back, there is no user side shared_ptr.
}
----


[[subsec:mutex]]
=== Synchronization primitives

To prevent race conditions between accesses to the host memory owned by a
[code]#buffer# in the <<sycl-runtime>> (e.g., by accessors) and in host code, it
is necessary to use manual synchronization through a [code]#host_accessor#, or
by passing a [code]#std::mutex# to the [code]#buffer# constructor through a
[code]#property#.

When a [code]#buffer# was constructed with a [code]#std::mutex# property, the
SYCL runtime is required to lock the mutex whenever the data is in use by the
runtime, and unlock the mutex when the data is not in use by the SYCL runtime.

[source,,linenums]
----
{
  std::mutex m;
  auto shD = std::make_shared<int>(42)
  sycl::buffer b { shD, { sycl::property::buffer::use_mutex { m } } };
  {
    std::lock_guard lck { m };

    // User accesses the data
    do_something(shD);

    /* m is unlocked when lck goes out of scope, either at normal ending of this
       block or if an exception is thrown */
  }
}
----

When the runtime releases the mutex, the user is guaranteed that the data has
been copied back through the shared pointer --- unless the final data
destination has been changed using the member function [code]#set_final_data()#.


[[subsec:accessors]]
=== Accessors

// \input{accessors}
// %%%%%%%%%%%%%%%%%%%%%%%%%%%% begin accessors %%%%%%%%%%%%%%%%%%%%%%%%%%%%

<<accessor,Accessors>> provide three different capabilities: they provide access
to the data managed by a <<buffer>> or <<image>>, they provide access to local
memory on a <<device>>, and they define the *requirements* to memory objects
which determine the scheduling of <<kernel,kernels>> (see
<<sub.section.memmodel.app>>).

A memory object requirement is created when an accessor is constructed, unless
the accessor is a placeholder in which case the requirement is created when the
accessor is bound to a <<command>> by calling [code]#handler::require()#.

There are several different {cpp} classes that implement accessors:

* The [code]#accessor# class provides access to data in a [code]#buffer# from
  within a <<command>>.

* The [code]#host_accessor# class provides access to data in a [code]#buffer#
  from host code that is outside of a <<command>>.
  These accessors are typically used in <<application-scope>>.

* The [code]#local_accessor# class provides access to device local memory from
  within a <<sycl-kernel-function>>.

* The [code]#unsampled_image_accessor# and [code]#sampled_image_accessor#
  classes provide access to data in an [code]#unsampled_image# and
  [code]#sampled_image# from within a <<command>>.

* The [code]#host_unsampled_image_accessor# and
  [code]#host_sampled_image_accessor# classes provide access to data in an
  [code]#unsampled_image# and [code]#sampled_image# from host code that is
  outside of a <<command>>.
  These accessors are typically used in <<application-scope>>.

Accessor objects must always be constructed in host code, either in
<<command-group-scope>> or in <<application-scope>>.
Whether the constructor blocks until data is available depends on the type of
accessor.
Those accessors which provide access to data within a <<command>> do not block.
Instead, these accessors define a requirement which influences the scheduling of
the <<command>>.
Those accessors which provide access to data from host code do block until the
data is available on the host.

For those accessors which provide access to data within a <<command>>, the
member functions which access data should only be called from within the
<<command>>.
Programs which call these member functions from outside of the <<command>> are
ill formed.
The sections below describe exactly which member functions fall into this
category.


==== Data type

All accessors have a [code]#DataT# template parameter which specifies the type
of each element that the accessor accesses.
For [code]#accessor# and [code]#host_accessor#, this type must either match the
type of each element in the underlying [code]#buffer#, or it must be a
[code]#const# qualified version of that type.

For the image accessors ([code]#unsampled_image_accessor#,
[code]#sampled_image_accessor#, [code]#host_unsampled_image_accessor#, and
[code]#host_sampled_image_accessor#), [code]#DataT# must be one of:

* [code]#int4# ([code]#vec<int32_t,4>#),
* [code]#uint4# ([code]#vec<uint32_t,4>#),
* [code]#float4# ([code]#vec<float,4>#), or
* [code]#half4# ([code]#vec<half,4>#)

For [code]#local_accessor# see <<sec:accessor.local>> for the allowable
[code]#DataT# types.


==== Access modes

Most accessors have an [code]#AccessMode# template parameter which specifies
whether the accessor can read or write the underlying data.
This information is used by the runtime when defining the requirements for the
associated <<command>>, and it tells the runtime whether data needs to be
transferred to or from a device before data can be accessed through the
accessor.

The [code]#access_mode# enumeration, shown in <<table.accessors.accessmode>>,
describes the potential modes of an accessor.
However, not all accessor classes support all modes, so see the description of
each class for more details.

[source,,linenums]
----
include::{header_dir}/accessMode.h[lines=4..-1]
----

[[table.accessors.accessmode]]
.Enumeration of access modes available to accessors
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ access_mode @ Description
a@
[source]
----
access_mode::read
----
   a@ Read-only access.

a@
[source]
----
access_mode::write
----
   a@ Write-only access.

a@
[source]
----
access_mode::read_write
----
   a@ Read and write access.

|====


==== Deduction tags

Some accessor constructors take a [code]#TagT# parameter, which is used to
deduce template arguments for the constructor's class.
Each of the access modes in <<table.accessors.accessmode>> has an associated
tag, but there are additional tags which set other template parameters in
addition to the access mode.
The synopsis below shows the namespace scope variables that the implementation
provides as possible values for the [code]#TagT# parameter.

[source,,linenums]
----
include::{header_dir}/accessTags.h[lines=4..-1]
----

The precise meaning of these tags depends on the specific accessor class that is
being constructed, so they are described more fully below in the section that
pertains to each of the accessor types.


==== Properties

All accessor constructors accept a [code]#property_list# parameter, which
affects the semantics of the accessor.
<<table.accessors.properties>> shows the set of all possible accessor properties
and tells which properties are allowed when constructing each accessor class.

[source,,linenums]
----
include::{header_dir}/accessProperties.h[lines=4..-1]
----

[[table.accessors.properties]]
.Properties supported by accessors
[width="100%",options="header",cols="20%,35%,45%"]
|====
|Property |Allowed with |Description

|[code]#property::no_init#
|[code]#accessor# +
 [code]#host_accessor# +
 [code]#unsampled_image_accessor# +
 [code]#host_unsampled_image_accessor#
|This property is useful when an application expects to write new values to all
of the accessor's elements without reading their previous values.  The
implementation can use this information to avoid copying the accessor's data in
some cases.  Following is a more formal description.

This property is allowed only for accessors with [code]#access_mode::write# or
[code]#access_mode::read_write# access modes.  Attempting to construct an
[code]#access_mode::read# accessor with this property causes an
[code]#exception# with the [code]#errc::invalid# error code to be thrown.

The usage of this property is different depending on whether the accessor's
underlying data type [code]#DataT# is an implicit-lifetime type (as defined in
the {cpp} core language).  If it is an implicit-lifetime type, the accessor
implicitly creates objects of that type with indeterminate values.  The
application is not required to write values to each element of the accessor,
but unwritten elements of the accessor's buffer or image receive indeterminate
values, even if those buffer or image elements previously had defined values.
If this is a <<ranged-accessor>>, this applies only to the elements within the
accessor's range.  The values of unwritten elements outside of this range are
preserved.

If [code]#DataT# is not an implicit-lifetime type, the accessor merely
allocates uninitialized memory, and the application is responsible for
constructing objects in that memory (e.g. by calling placement-new).  The
application must create an object in each element of the accessor unless the
corresponding element of the underlying buffer did not previously contain an
object.  If this is a <<ranged-accessor>>, this applies only to the elements
within the accessor's range.  The content of objects in the buffer outside of
this range is preserved.
|====

[NOTE]
====
As stated above, the [code]#property::no_init# property requires the application
to construct an object for each accessor element when the element's type is not
an implicit-lifetime type (except in the case when the corresponding buffer
element did not previously contain an object).
The reason for this requirement is to avoid the possibility of overwriting a
valid object with indeterminate bytes, for example, when a <<command>> using the
accessor completes.
This means that the implementation can unconditionally copy memory from the
device back to the host when the <<command>> completes, regardless of whether
the [code]#DataT# type is an implicit-lifetime type.
====

The constructors of the accessor property classes are listed in
<<table.accessors.properties.constructors>>.

[[table.accessors.properties.constructors]]
.Constructors of the accessor property classes
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
property::no_init::no_init()
----
   a@ Constructs a [code]#no_init# property instance.

|====


==== Read only accessors

Accessors which have an [code]#AccessMode# template parameter can be declared as
read-only by specifying [code]#access_mode::read# for the template parameter.
A read-only accessor provides read-only access to the underlying data and
provides a "read" requirement for the memory object when it is constructed.

The [code]#DataT# template parameter for a read-only accessor can optionally be
[code]#const# qualified, and the semantics of the accessor are unchanged.
For example, an accessor declared with [code]#const DataT# and
[code]#access_mode::read# has the same semantics as an accessor declared with
[code]#DataT# and [code]#access_mode::read#.

As detailed in the sections below, some accessor types have a default value for
[code]#AccessMode#, which depends on whether the [code]#DataT# parameter is
[code]#const# qualified.
This provides a convenient way to declare a read-only accessor without
explicitly specifying the access mode.

A [code]#const# qualified [code]#DataT# is only allowed for a read-only
accessor.
Programs which specify a [code]#const# qualified [code]#DataT# and any access
mode other than [code]#access_mode::read# are ill formed, and the implementation
must issue a diagnostic in this case.

Each accessor class also provides implicit conversions between the two forms of
read-only accessors.
This makes it possible, for example, to assign an accessor whose type has
[code]#const DataT# and [code]#access_mode::read# to an accessor whose type has
[code]#DataT# and [code]#access_mode::read#, so long as the other template
parameters are the same.
There is also an implicit conversion from a read-write accessor to either of the
forms of a read-only accessor.
These implicit conversions are described in detail for each accessor class in
the sections that follow.


==== Accessing elements of an accessor

Accessors of type [code]#accessor#, [code]#host_accessor#, and
[code]#local_accessor# can have zero, one, two, or three Dimensions.
A zero dimension accessor provides access to a single scalar element via an
implicit conversion operator to the underlying type of that element and via an
overloaded copy/move assignment operators from the underlying type of the
element.

One, two, or three dimensional specializations of these accessors provide access
to the elements they contain in two ways.
The first way is through a subscript operator that takes an instance of an
[code]#id# class which has the same dimensionality as the accessor.
The second way is by passing a single [code]#size_t# value to multiple
consecutive subscript operators as specified in <<sec:multi-dim-subscript>>.

In all these cases, the reference to the contained element is of type
[code]#const DataT&# for read-only accessors and of type [code]#DataT&# for
other accessors.

Accessors of all types have a range that defines the set of indices that may be
used to access elements.
For buffer accessors, this is the range of the underlying buffer, unless it is a
<<ranged-accessor>> in which case the range comes from the accessor's
constructor.
For image accessors, this is the range of the underlying image.
Local accessors specify the range when the accessor is constructed.
Any attempt to access an element via an index that is outside of this range
produces undefined behavior.


==== Container interface

Accessors of type [code]#accessor#, [code]#host_accessor#, and
[code]#local_accessor# meet the {cpp} requirement of
[code]#ReversibleContainer#.
The exception to this is that only [code]#local_accessor# owns the underlying
data, meaning that its destructor destroys elements and frees the memory.
The [code]#accessor# and [code]#host_accessor# types don't destroy any elements
or free the memory on destruction.
The iterator for the container interface meets the {cpp} requirement of
[code]#LegacyRandomAccessIterator# and the underlying pointers/references
correspond to the address space specified by the accessor type.
For multidimensional accessors the iterator linearizes the data according to
<<sec:multi-dim-linearization>>.


[[sec:accessors.ranged]]
==== Ranged accessors

Accessors of type [code]#accessor# and [code]#host_accessor# can be constructed
from a sub-range of a [code]#buffer# by providing a range and offset to the
constructor.
This limits the elements that can be accessed to the specified sub-range, which
allows the implementation to perform certain optimizations such as reducing the
amount of memory that needs to be copied to or from a device.

If the ranged accessor is multi-dimensional, the sub-range is allowed to
describe a region of memory in the underlying buffer that is not contiguous in
the linear address space.
It is also legal to construct several ranged accessors for the same underlying
buffer, either overlapping or non-overlapping.

A ranged accessor still creates a requisite for the entire underlying buffer,
even for the portions not within the range.
For example, if one command writes through a ranged accessor to one region of a
buffer and a second command reads through a ranged accessor from a
non-overlapping region of the same buffer, the second command must still be
scheduled after the first because the requisites for the two commands are on the
entire buffer, not on the sub-ranges of the ranged accessors.

Most of the accessor member functions which provide a reference to the
underlying buffer elements are affected by a ranged accessor's offset and range.
For example, calling [code]#operator[](0)# on a one-dimensional ranged accessor
returns a reference to the element at the position specified by the accessor's
offset, which is not necessarily the first element in the buffer.
In addition, the accessor's iterator functions iterate only over the elements
that are within the sub-range.

The only exceptions are the [code]#get_pointer# and [code]#get_multi_ptr# member
functions, which return a pointer to the beginning of the underlying buffer
regardless of the accessor's offset.
Applications using these functions must take care to manually add the offset
before dereferencing the pointer because accessing an element that is outside of
the accessor's range results in undefined behavior.

[NOTE]
====
There is no change in behavior for ranged accessors with a range of zero.
It still creates a requisite for the entire underlying buffer, and an attempt to
access an element produces undefined behavior.
====

==== Buffer accessor for commands

The [code]#accessor# class provides access to data in a [code]#buffer# in three
different ways.
It can be used to access the buffer's data from within a
<<sycl-kernel-function>> via the device's <<global-memory>>.
It can also be used to access the buffer's data on host from within a host task.
Finally, it can be used to get a native backend handle to the buffer from within
a host task.
The AccessTarget template parameter helps distinguish these three cases as shown
in <<table.accessors.command.buffer.capabilities>>.

[[table.accessors.command.buffer.capabilities]]
.Description of access targets for buffer accessors
[width="100%",options="header",cols="25%,75%"]
|====
| Access target | Meaning
| [code]#target::device#
    | Access a buffer from a <<sycl-kernel-function>> via device global memory.
      Also used to get a native backend handle to the buffer from within a host
      task.
| [code]#target::host_task#
    | Access a buffer's data on host from within a <<host-task>>.
|====

When an [code]#accessor# is used from within a <<sycl-kernel-function>>, the
access target must be [code]#target::device#, [code]#target::constant_buffer#,
or [code]#target::local#; otherwise the behavior is undefined.
See <<sec:accessor.deprecated.target.constant.buffer>> and
<<sec:accessor.deprecated.target.local>> for a description of the deprecated
[code]#target::constant_buffer# and [code]#target::local# targets.

When an [code]#accessor# is used from within a host task, the use of the
accessor must correspond to the access target, otherwise the behavior is
undefined.
If the access target is [code]#target::host_task#, the accessor may only be used
to access the buffer's data on host, from within the host task function.
If the access target is [code]#target::device#, the accessor may only be used to
get a native backend handle for the buffer as described in
<<subsec:interfaces.hosttasks.interophandle>>.

The dimensionality of the accessor must match the underlying buffer, however,
there is a special case if the buffer is one-dimensional.
In this case, the accessor may either be one-dimensional or it may be
zero-dimensional.
A zero-dimensional accessor has access to just the first element of the buffer,
whereas a one-dimensional accessor has access to the entire buffer.

Certain [code]#accessor# constructors create a "placeholder" accessor.
Such an accessor is bound to a [code]#buffer# and its semantics such as access
target and access mode are defined.
However, a placeholder accessor is not yet bound to a <<command-group>>.
Before such an accessor can be used in a <<command>>, it must be bound by
calling [code]#handler::require()#.
Passing a placeholder accessor as an argument to a <<command>> without first
being bound to a <<command-group>> with [code]#handler::require()# will result
in undefined behavior.

[NOTE]
====
Implementations are encouraged to throw either a synchronous or an asynchronous
exception when a placeholder accessor, that has not been bound to the
corresponding <<command-group>> with [code]#handler::require()#, is either
passed as an argument to or is used inside a <<command>>.
====


===== Interface for buffer command accessors

A synopsis of the [code]#accessor# class is provided below, showing the
interface when it is specialized with [code]#target::device# or
[code]#target::host_task#.
Since some of the class types and member functions have the same name and
meaning as other accessors, the common types and functions are described in
<<sec:accessor.common.members>>.
The member types are listed in <<table.accessors.common.types>> and
<<table.accessors.command.buffer.types>>.
The constructors are listed in <<table.accessors.command.buffer.constructors>>,
and the member functions are listed in <<table.accessors.common.members>> and
<<table.accessors.command.buffer.members>>.

The additional common special member functions and common member functions are
listed in <<sec:reference-semantics>> in
<<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>>, respectively.
For valid implicit conversions between accessor types refer to
<<sec:accessor.command.buffer.conversions>>.
Additionally, accessors of the same type must be equality comparable both in the
host application and also in <<sycl-kernel-function,SYCL kernel functions>>.

[source,,linenums]
----
include::{header_dir}/accessorBuffer.h[lines=4..-1]
----


[[table.accessors.command.buffer.types]]
.Member types of the [code]#accessor# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member types @ Description
a@
[source]
----
template <access::decorated IsDecorated> accessor_ptr
----
   a@ If [code]#(AccessTarget == target::device)#:
      [code]#multi_ptr<value_type, access::address_space::global_space, IsDecorated>#.

The definition of this type is not specified when
[code]#(AccessTarget == target::host_task)#.

|====


[[table.accessors.command.buffer.constructors]]
.Constructors of the [code]#accessor# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
accessor()
----
   a@ Constructs an empty accessor which fulfills the following
      post-conditions:
--
  * [code]#(empty() == true)#
  * All size queries return [code]#0#.
  * The return values of [code]#get_pointer()# and [code]#get_multi_ptr()# are
    unspecified.
  * A default constructed accessor can be passed to a <<sycl-kernel-function>>,
    but attempting to access data elements from it produces undefined behavior.
--

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, 1, AllocatorT>& bufferRef,
         const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions == 0)#.

Constructs a placeholder [code]#accessor# for accessing the first element of a
[code]#buffer#.  The optional [code]#property_list# provides properties for the
constructed accessor.

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, 1, AllocatorT>& bufferRef,
         handler& commandGroupHandlerRef, const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions == 0)#.

Constructs an [code]#accessor# for accessing the first element of a
[code]#buffer# within a <<sycl-kernel-function>> on the [code]#queue#
associated with [code]#commandGroupHandlerRef#.  The optional
[code]#property_list# provides properties for the constructed accessor.

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs a placeholder [code]#accessor# for accessing a [code]#buffer#.  The
optional [code]#property_list# provides properties for the constructed
accessor.

a@
[source]
----
template <typename AllocatorT, typename TagT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef, TagT tag,
         const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs a placeholder [code]#accessor# for accessing a [code]#buffer#.  The
[code]#tag# is used to deduce template arguments of the accessor as described
in <<sec:accessor.command.buffer.tags>>.  The optional [code]#property_list#
provides properties for the constructed accessor.

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         handler& commandGroupHandlerRef, const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs an [code]#accessor# for accessing a [code]#buffer# within a
<<sycl-kernel-function>> on the [code]#queue# associated with
[code]#commandGroupHandlerRef#.  The optional [code]#property_list# provides
properties for the constructed accessor.

a@
[source]
----
template <typename AllocatorT, typename TagT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         handler& commandGroupHandlerRef, TagT tag,
         const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs an [code]#accessor# for accessing a [code]#buffer# within a
<<sycl-kernel-function>> on the [code]#queue# associated with
[code]#commandGroupHandlerRef#.  The [code]#tag# is used to deduce template
arguments of the accessor as described in <<sec:accessor.command.buffer.tags>>.
The optional [code]#property_list# provides properties for the constructed
accessor.

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         range<Dimensions> accessRange, const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs a placeholder [code]#accessor# that is a <<ranged-accessor>>, where
the range starts at the beginning of the [code]#buffer#.  The optional
[code]#property_list# provides properties for the constructed accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
[code]#accessRange# exceeds the range of [code]#bufferRef# in any dimension.

a@
[source]
----
template <typename AllocatorT, typename TagT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         range<Dimensions> accessRange, TagT tag,
         const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs a placeholder [code]#accessor# that is a <<ranged-accessor>>, where
the range starts at the beginning of the [code]#buffer#.  The [code]#tag# is
used to deduce template arguments of the accessor as described in
<<sec:accessor.command.buffer.tags>>.  The optional [code]#property_list#
provides properties for the constructed accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
[code]#accessRange# exceeds the range of [code]#bufferRef# in any dimension.

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         range<Dimensions> accessRange, id<Dimensions> accessOffset,
         const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs a placeholder [code]#accessor# that is a <<ranged-accessor>>, where
the range starts at an offset from the beginning of the [code]#buffer#.  The
optional [code]#property_list# provides properties for the constructed
accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
the sum of [code]#accessRange# and [code]#accessOffset# exceeds the range of
[code]#bufferRef# in any dimension.

a@
[source]
----
template <typename AllocatorT, typename TagT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         range<Dimensions> accessRange, id<Dimensions> accessOffset, TagT tag,
         const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs a placeholder [code]#accessor# that is a <<ranged-accessor>>, where
the range starts at an offset from the beginning of the [code]#buffer#.  The
[code]#tag# is used to deduce template arguments of the accessor as described
in <<sec:accessor.command.buffer.tags>>.  The optional [code]#property_list#
provides properties for the constructed accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
the sum of [code]#accessRange# and [code]#accessOffset# exceeds the range of
[code]#bufferRef# in any dimension.

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         handler& commandGroupHandlerRef, range<Dimensions> accessRange,
         const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs an [code]#accessor# that is a <<ranged-accessor>>, where the range
starts at the beginning of the [code]#buffer#.  The accessor can only be used
in a <<sycl-kernel-function>> on the [code]#queue# associated with
[code]#commandGroupHandlerRef#.  The optional [code]#property_list# provides
properties for the constructed accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
[code]#accessRange# exceeds the range of [code]#bufferRef# in any dimension.

a@
[source]
----
template <typename AllocatorT, typename TagT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         handler& commandGroupHandlerRef, range<Dimensions> accessRange,
         TagT tag, const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs an [code]#accessor# that is a <<ranged-accessor>>, where the range
starts at the beginning of the [code]#buffer#.  The accessor can only be used
in a <<sycl-kernel-function>> on the [code]#queue# associated with
[code]#commandGroupHandlerRef#.  The [code]#tag# is used to deduce template
arguments of the accessor as described in <<sec:accessor.command.buffer.tags>>.
The optional [code]#property_list# provides properties for the constructed
accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
[code]#accessRange# exceeds the range of [code]#bufferRef# in any dimension.

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         handler& commandGroupHandlerRef, range<Dimensions> accessRange,
         id<Dimensions> accessOffset, const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs an [code]#accessor# that is a <<ranged-accessor>>, where the range
starts at an offset from the beginning of the [code]#buffer#.  The accessor can
only be used in a <<sycl-kernel-function>> on the [code]#queue# associated with
[code]#commandGroupHandlerRef#.  The optional [code]#property_list# provides
properties for the constructed accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
the sum of [code]#accessRange# and [code]#accessOffset# exceeds the range of
[code]#bufferRef# in any dimension.

a@
[source]
----
template <typename AllocatorT, typename TagT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         handler& commandGroupHandlerRef, range<Dimensions> accessRange,
         id<Dimensions> accessOffset, TagT tag,
         const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs an [code]#accessor# that is a <<ranged-accessor>>, where the range
starts at an offset from the beginning of the [code]#buffer#.  The accessor can
only be used in a <<sycl-kernel-function>> on the [code]#queue# associated with
[code]#commandGroupHandlerRef#.  The [code]#tag# is used to deduce template
arguments of the accessor as described in <<sec:accessor.command.buffer.tags>>.
The optional [code]#property_list# provides properties for the constructed
accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
the sum of [code]#accessRange# and [code]#accessOffset# exceeds the range of
[code]#bufferRef# in any dimension.

|====


[[table.accessors.command.buffer.members]]
.Member functions of the [code]#accessor# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
void swap(accessor& other);
----
   a@ Swaps the contents of the current accessor with the contents of
      [code]#other#.

a@
[source]
----
bool is_placeholder() const
----
   a@ Returns [code]#true# if the accessor is a placeholder.  Otherwise returns
      [code]#false#.

a@
[source]
----
id<Dimensions> get_offset() const
----
   a@ Available only when [code]#(Dimensions > 0)#.

If this is a <<ranged-accessor>>, returns the offset that was specified when the
accessor was constructed.  For other accessors, returns the default constructed
[code]#id<Dimensions>{}#.

a@
[source]
----
global_ptr<value_type> get_pointer() const noexcept
----
   a@ Available only when [code]#(AccessTarget == target::device)#.

Returns a [code]#multi_ptr# to the start of this accessor's underlying buffer,
even if this is a <<ranged-accessor>> whose range does not start at the
beginning of the buffer.  The return value is unspecified if the accessor is
empty.

This function may only be called from within a <<command>>.

Deprecated in SYCL 2020.  Use [code]#get_multi_ptr# instead.

a@
[source]
----
std::add_pointer_t<value_type> get_pointer() const noexcept
----
   a@ Available only when [code]#(AccessTarget == target::host_task)#.

Returns a pointer to the start of this accessor's underlying buffer, even if
this is a <<ranged-accessor>> whose range does not start at the beginning of
the buffer.  The return value is unspecified if the accessor is empty.

This function may only be called from within a <<command>>.

a@
[source]
----
template <access::decorated IsDecorated>
accessor_ptr<IsDecorated> get_multi_ptr() const noexcept
----
   a@ Available only when [code]#(AccessTarget == target::device)#.

Returns a [code]#multi_ptr# to the start of this accessor's underlying buffer,
even if this is a <<ranged-accessor>> whose range does not start at the
beginning of the buffer.  The return value is unspecified if the accessor is
empty.

This function may only be called from within a <<command>>.

a@
[source]
----
const accessor& operator=(const value_type& other) const
----
   a@ Available only when
      [code]#(AccessMode != access_mode::atomic &&
      AccessMode != access_mode::read && Dimensions == 0)#.

Assignment to the single element that is accessed by this accessor.

This function may only be called from within a <<command>>.

a@
[source]
----
const accessor& operator=(value_type&& other) const
----
   a@ Available only when
      [code]#(AccessMode != access_mode::atomic &&
      AccessMode != access_mode::read && Dimensions == 0)#.

Assignment to the single element that is accessed by this accessor.

This function may only be called from within a <<command>>.

|====


[[sec:accessor.command.buffer.tags]]
===== Deduction tags for buffer command accessors

Some [code]#accessor# constructors take a [code]#TagT# parameter, which is used
to deduce template arguments.
The permissible values for this parameter are listed in
<<table.accessors.command.buffer.tags>> along with the access mode and accessor
target that they imply.

[[table.accessors.command.buffer.tags]]
.Enumeration of tags available for [code]#accessor# construction
[width="100%",options="header",cols="33%,33%,34%"]
|====
| Tag value | Access mode | Accessor target
| [code]#read_write#
    | [code]#access_mode::read_write#
    | [code]#target::device#
| [code]#read_only#
    | [code]#access_mode::read#
    | [code]#target::device#
| [code]#write_only#
    | [code]#access_mode::write#
    | [code]#target::device#
| [code]#read_write_host_task#
    | [code]#access_mode::read_write#
    | [code]#target::host_task#
| [code]#read_only_host_task#
    | [code]#access_mode::read#
    | [code]#target::host_task#
| [code]#write_only_host_task#
    | [code]#access_mode::write#
    | [code]#target::host_task#
|====


[[sec:accessor.command.buffer.conversions]]
===== Read only buffer command accessors and implicit conversions

<<table.accessors.command.buffer.read-only>> shows the specializations of
[code]#accessor# with [code]#target::device# or [code]#target::host_task# that
are read-only accessors.
There is an implicit conversion between any of these specializations, provided
that all other template parameters are the same.

[[table.accessors.command.buffer.read-only]]
.Specializations of [code]#accessor# that are read-only
[width="100%",options="header",cols="50%,50%"]
|====
| Data type | Access mode
| not const-qualified | [code]#access_mode::read#
| const-qualified | [code]#access_mode::read#
|====

There is also an implicit conversion from the read-write specialization shown in
<<table.accessors.command.buffer.read-write>> to any of the read-only
specializations shown in <<table.accessors.command.buffer.read-only>>, provided
that all other template parameters are the same.

[[table.accessors.command.buffer.read-write]]
.Specializations of [code]#accessor# that are read-write
[width="100%",options="header",cols="50%,50%"]
|====
| Data type | Access mode
| not const-qualified | [code]#access_mode::read_write#
|====


===== Deprecated features of the [code]#accessor# class

All of the features defined in this section are deprecated and will likely be
removed from a future version of the specification.


====== Aliased names

The enumerated value [code]#target::global_buffer# is an alias for
[code]#target:::device#.
It has the same type and value as its alias.

The enumerated type [code]#access::target# is an alias for [code]#target#, and
the enumerated type [code]#access::mode# is an alias for [code]#access_mode#.


====== Discard access modes

An [code]#accessor# instance specialized with access mode
[code]#access_mode::discard_write# has the same behavior as an [code]#accessor#
instance of mode [code]#access_mode::write# that is constructed with the
property [code]#property::no_init#.

An [code]#accessor# instance specialized with access mode
[code]#access_mode::discard_read_write# has the same behavior as an
[code]#accessor# instance of mode [code]#access_mode::read_write# that is
constructed with the property [code]#property::no_init#.


====== Placeholder template parameter

The [code]#accessor# template parameter [code]#IsPlaceholder# is allowed to be
specified, but it has no bearing on whether the [code]#accessor# instance is a
placeholder.
This is determined solely by the constructor used to create the instance.

The associated type [code]#access::placeholder# is also deprecated.


====== Additional member functions for [code]#target::device# specialization

Specializations of the [code]#accessor# class with [code]#target::device# have
the additional member functions described in
<<table.accessors.deprecated.command.buffer.members>>.

[[table.accessors.deprecated.command.buffer.members]]
.Deprecated member functions of the [code]#accessor# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
size_t get_size() const
----
   a@ Returns the same value as [code]#byte_size()#.
a@
[source]
----
size_t get_count() const
----
   a@ Returns the same value as [code]#size()#.

|====


[[sec:accessor.deprecated.target.constant.buffer]]
====== Accessor specialization with [code]#target::constant_buffer#

The [code]#accessor# class may be specialized with target
[code]#target::constant_buffer#, which results in an accessor that can be used
within a <<sycl-kernel-function>> to access the contents of a buffer through the
device's <<constant-memory>>.

As with other [code]#accessor# specializations, the dimensionality must match
the underlying buffer, however there is a special case if the buffer is
one-dimensional.
In this case, the accessor may either be one-dimensional or it may be
zero-dimensional.
A zero-dimensional accessor has access to just the first element of the buffer,
whereas a one-dimensional accessor has access to the entire buffer.

This specialization of [code]#accessor# is available only for the access mode
[code]#access_mode::read#.

This accessor type can be constructed as a "placeholder" accessor.
As with other [code]#accessor# specializations that are placeholders,
[code]#handler::require()# must be called before passing a placeholder accessor
to a <<command>>.
Passing a placeholder accessor as an argument to a <<command>> without first
being bound to a <<command-group>> with [code]#handler::require()# will result
in undefined behavior.

A synopsis for this specialization of [code]#accessor# is provided below.
Since some of the class types and member functions have the same name and
meaning as other accessors, the common types and functions are described in
<<sec:accessor.deprecated.common.members>>.
The member types are listed in <<table.accessors.deprecated.common.types>>.
The constructors are listed in
<<table.accessors.deprecated.constant.constructors>>, and the member functions
are listed in <<table.accessors.deprecated.common.members>> and
<<table.accessors.deprecated.constant.members>>.

The additional common special member functions and common member functions are
listed in <<sec:reference-semantics>> in
<<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>>, respectively.
Additionally, accessors of the same type must be equality comparable.

[source,,linenums]
----
include::{header_dir}/accessorDeprecatedConstant.h[lines=4..-1]
----


[[table.accessors.deprecated.constant.constructors]]
.Constructors of the deprecated constant accessor
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, 1, AllocatorT>& bufferRef,
         const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions == 0)#.

Constructs a placeholder [code]#accessor# for accessing the first element of a
[code]#buffer#.  The optional [code]#property_list# provides properties for the
constructed accessor.

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, 1, AllocatorT>& bufferRef,
         handler& commandGroupHandlerRef, const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions == 0)#.

Constructs an [code]#accessor# for accessing the first element of a
[code]#buffer# within a <<sycl-kernel-function>> on the [code]#queue#
associated with [code]#commandGroupHandlerRef#.  The optional
[code]#property_list# provides properties for the constructed accessor.

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs a placeholder [code]#accessor# for accessing a [code]#buffer#.  The
optional [code]#property_list# provides properties for the constructed
accessor.

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         handler& commandGroupHandlerRef, const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs an [code]#accessor# for accessing a [code]#buffer# within a
<<sycl-kernel-function>> on the [code]#queue# associated with
[code]#commandGroupHandlerRef#.  The optional [code]#property_list# provides
properties for the constructed accessor.

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         range<Dimensions> accessRange, const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs a placeholder [code]#accessor# that is a <<ranged-accessor>>, where
the range starts at the beginning of the [code]#buffer#.  The optional
[code]#property_list# provides properties for the constructed accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
[code]#accessRange# exceeds the range of [code]#bufferRef# in any dimension.

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         range<Dimensions> accessRange, id<Dimensions> accessOffset,
         const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs a placeholder [code]#accessor# that is a <<ranged-accessor>>, where
the range starts at an offset from the beginning of the [code]#buffer#.  The
optional [code]#property_list# provides properties for the constructed
accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
the sum of [code]#accessRange# and [code]#accessOffset# exceeds the range of
[code]#bufferRef# in any dimension.

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         handler& commandGroupHandlerRef, range<Dimensions> accessRange,
         const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs an [code]#accessor# that is a <<ranged-accessor>>, where the range
starts at the beginning of the [code]#buffer#.  The accessor can only be used
in a <<sycl-kernel-function>> on the [code]#queue# associated with
[code]#commandGroupHandlerRef#.  The optional [code]#property_list# provides
properties for the constructed accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
[code]#accessRange# exceeds the range of [code]#bufferRef# in any dimension.

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         handler& commandGroupHandlerRef, range<Dimensions> accessRange,
         id<Dimensions> accessOffset, const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs an [code]#accessor# that is a <<ranged-accessor>>, where the range
starts at an offset from the beginning of the [code]#buffer#.  The accessor can
only be used in a <<sycl-kernel-function>> on the [code]#queue# associated with
[code]#commandGroupHandlerRef#.  The optional [code]#property_list# provides
properties for the constructed accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
the sum of [code]#accessRange# and [code]#accessOffset# exceeds the range of
[code]#bufferRef# in any dimension.

|====


[[table.accessors.deprecated.constant.members]]
.Member functions of the deprecated constant accessor
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
bool is_placeholder() const
----
   a@ Returns [code]#true# if the accessor was constructed as a placeholder and
      returns [code]#false# otherwise.

a@
[source]
----
id<Dimensions> get_offset() const
----
   a@ Available only when [code]#(Dimensions > 0)#.

If this is a <<ranged-accessor>>, returns the offset that was specified when
the accessor was constructed, otherwise returns the default constructed
[code]#id<Dimensions>{}#.

a@
[source]
----
constant_ptr<DataT> get_pointer() const noexcept
----
   a@ Returns a [code]#multi_ptr# to the start of this accessor's underlying
      buffer, even if this is a <<ranged-accessor>> whose range does not start
      at the beginning of the buffer.  The return value is unspecified if the
      accessor is empty.

This function may only be called from within a <<command>>.

|====

====== Accessor specialization with [code]#target::host_buffer#

The [code]#accessor# class may be specialized with target
[code]#target::host_buffer#, which results in a host accessor similar to
[code]#host_accessor#.
This specialization provides access to data in a [code]#buffer# from host code
that is outside of a <<command>>, and constructors of this specialization block
until the requested data is available on the host.

As with other [code]#accessor# specializations, the dimensionality must match
the underlying buffer, however there is a special case if the buffer is
one-dimensional.
In this case, the accessor may either be one-dimensional or it may be
zero-dimensional.
A zero-dimensional accessor has access to just the first element of the buffer,
whereas a one-dimensional accessor has access to the entire buffer.

This specialization of [code]#accessor# is available for all access modes except
for [code]#access_mode::atomic#.

A synopsis for this specialization of [code]#accessor# is provided below.
Since some of the class types and member functions have the same name and
meaning as other accessors, the common types and functions are described in
<<sec:accessor.deprecated.common.members>>.
The member types are listed in <<table.accessors.deprecated.common.types>>.
The constructors are listed in <<table.accessors.deprecated.host.constructors>>,
and the member functions are listed in
<<table.accessors.deprecated.common.members>> and
<<table.accessors.deprecated.host.members>>.

The additional common special member functions and common member functions are
listed in <<sec:reference-semantics>> in
<<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>>, respectively.
Additionally, accessors of the same type must be equality comparable.

[source,,linenums]
----
include::{header_dir}/accessorDeprecatedHost.h[lines=4..-1]
----


[[table.accessors.deprecated.host.constructors]]
.Constructors of the deprecated host buffer accessor
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, 1, AllocatorT>& bufferRef,
         const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions == 0)#.

Constructs an [code]#accessor# for accessing the first element of a
[code]#buffer# immediately on the host.  The optional [code]#property_list#
provides properties for the constructed accessor.

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs an [code]#accessor# for accessing a [code]#buffer# immediately on
the host.  The optional [code]#property_list# provides properties for the
constructed accessor.

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         range<Dimensions> accessRange, const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs an [code]#accessor# that is a <<ranged-accessor>> which accesses a
buffer immediately on the host, where the range starts at the beginning of the
buffer.  The optional [code]#property_list# provides properties for the
constructed accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
[code]#accessRange# exceeds the range of [code]#bufferRef# in any dimension.

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         range<Dimensions> accessRange, id<Dimensions> accessOffset,
         const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs an [code]#accessor# that is a <<ranged-accessor>> which accesses a
buffer immediately on the host, where the range starts at an offset from the
beginning of the buffer.  The optional [code]#property_list# provides
properties for the constructed accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
the sum of [code]#accessRange# and [code]#accessOffset# exceeds the range of
[code]#bufferRef# in any dimension.

|====


[[table.accessors.deprecated.host.members]]
.Member functions of the deprecated host buffer accessor
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
bool is_placeholder() const
----
   a@ Always returns [code]#false#.

a@
[source]
----
id<Dimensions> get_offset() const
----
   a@ Available only when [code]#(Dimensions > 0)#.

If this is a <<ranged-accessor>>, returns the offset that was specified when
the accessor was constructed, otherwise returns the default constructed
[code]#id<Dimensions>{}#.

a@
[source]
----
std::add_pointer_t<value_type> get_pointer() const noexcept
----
   a@ Returns a pointer to the start of this accessor's underlying buffer, even
      if this is a <<ranged-accessor>> whose range does not start at the
      beginning of the buffer.  The return value is unspecified if the accessor
      is empty.

|====


[[sec:accessor.deprecated.target.local]]
====== Accessor specialization with [code]#target::local#

The [code]#accessor# class may be specialized with target [code]#target::local#,
which results in a local accessor that has the same semantics and restrictions
as [code]#local_accessor#.

This specialization of [code]#accessor# is only available for access modes
[code]#access_mode::read_write# and [code]#access_mode::atomic#.

A synopsis for this specialization of [code]#accessor# is provided below.
Since some of the class types and member functions have the same name and
meaning as other accessors, the common types and functions are described in
<<sec:accessor.deprecated.common.members>>.
The member types are listed in <<table.accessors.deprecated.common.types>>.
The constructors are listed in
<<table.accessors.deprecated.local.constructors>>, and the member functions are
listed in <<table.accessors.deprecated.common.members>> and
<<table.accessors.deprecated.local.members>>.

The additional common special member functions and common member functions are
listed in <<sec:reference-semantics>> in
<<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>>, respectively.
Additionally, accessors of the same type must be equality comparable.

[source,,linenums]
----
include::{header_dir}/accessorDeprecatedLocal.h[lines=4..-1]
----


[[table.accessors.deprecated.local.constructors]]
.Constructors of the deprecated local accessor
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
accessor(handler& commandGroupHandlerRef, const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions == 0)#.

Constructs an [code]#accessor# instance for accessing <<local-memory>> of a
single [code]#DataT# element within a <<sycl-kernel-function>> on the queue
associated with [code]#commandGroupHandlerRef#.  The optional
[code]#property_list# provides properties for the constructed accessor.

a@
[source]
----
accessor(range<Dimensions> allocationSize, handler& commandGroupHandlerRef,
         const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs an [code]#accessor# instance for accessing <<local-memory>> of an
array of [code]#DataT# elements within a <<sycl-kernel-function>> on the queue
associated with [code]#commandGroupHandlerRef#.  The number of elements in the
array is defined by [code]#allocationSize#.  The optional [code]#property_list#
provides properties for the constructed accessor.

|====


[[table.accessors.deprecated.local.members]]
.Member functions of the deprecated local accessor
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
operator atomic<DataT, access::address_space::local_space>() const
----
   a@ Available only when
      [code]#(AccessMode == access_mode::atomic && Dimensions == 0)#.

Returns an instance of [code]#atomic# of type [code]#DataT# providing atomic
access to the element stored within the work-group's local memory allocation
that this accessor is accessing.

This function may only be called from within a <<command>>.

a@
[source]
----
atomic<DataT, access::address_space::local_space>
operator[](id<Dimensions> index) const
----
   a@ Available only when
      [code]#(AccessMode == access_mode::atomic && Dimensions > 0)#.

Returns an instance of [code]#atomic# of type [code]#DataT# providing atomic
access to the element stored within the work-group's local memory allocation
that this accessor is accessing, at the index specified by [code]#index#.

This function may only be called from within a <<command>>.

a@
[source]
----
atomic<DataT, access::address_space::local_space> operator[](size_t index) const
----
   a@ Available only when
      [code]#(AccessMode == access_mode::atomic && Dimensions == 1)#.

Returns an instance of [code]#atomic# of type [code]#DataT# providing atomic
access to the element stored within the work-group's local memory allocation
that this accessor is accessing, at the index specified by [code]#index#.

This function may only be called from within a <<command>>.

a@
[source]
----
local_ptr<DataT> get_pointer() const noexcept
----
   a@ Returns a [code]#multi_ptr# to the work-group's local memory allocation
      that this accessor is accessing.  The return value is unspecified if the
      accessor is empty.

This function may only be called from within a <<command>>.

|====


[[sec:accessor.deprecated.common.members]]
====== Common members for deprecated accessors

Specializations of the [code]#accessor# class with
[code]#target::constant_buffer#, [code]#target::host_buffer# and
[code]#target::local# have many member types and member functions with the same
name and meaning.
<<table.accessors.deprecated.common.types>> describes these common types and
<<table.accessors.deprecated.common.members>> describes the common member
functions.


[[table.accessors.deprecated.common.types]]
.Common member types of the deprecated accessors
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member types @ Description
a@
[source]
----
value_type
----
   a@ If [code]#(AccessMode == access_mode::read)#, equal to
      [code]#const DataT#, otherwise equal to [code]#DataT#.

a@
[source]
----
reference
----
   a@ Equal to [code]#value_type&#.

a@
[source]
----
const_reference
----
   a@ Equal to [code]#const DataT&#.

|====


[[table.accessors.deprecated.common.members]]
.Common member functions of the deprecated accessors
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
size_t get_size() const noexcept
----
   a@ Returns the size in bytes of the memory region this accessor may access.

When [code]#AccessTarget# is [code]#target::constant_buffer# or
[code]#target::host_buffer#, the returned value is the size of the elements in
the underlying buffer, unless this is a <<ranged-accessor>> in which case it is
the size of the elements within the accessor's range.

When [code]#AccessTarget# is [code]#target::local#, the returned value is the
size in bytes of the accessor's local memory allocation, per work-group.

a@
[source]
----
size_t get_count() const noexcept
----
   a@ Returns the number of [code]#DataT# elements of the memory region this
      accessor may access.

When [code]#AccessTarget# is [code]#target::constant_buffer# or
[code]#target::host_buffer#, the returned value is the number of elements in
the underlying buffer, unless this is a <<ranged-accessor>> in which case it is
the number of elements within the accessor's range.

When [code]#AccessTarget# is [code]#target::local#, the returned value is the
number of elements in the accessor's local memory allocation, per work-group.

a@
[source]
----
range<Dimensions> get_range() const
----
   a@ Available only when [code]#(Dimensions > 0)#.

Returns a [code]#range# object which represents the number of elements of
[code]#DataT# per dimension that this accessor may access.

When [code]#AccessTarget# is [code]#target::constant_buffer# or
[code]#target::host_buffer#, the returned value is the range of the underlying
buffer, unless this is a <<ranged-accessor>> in which case it is the range that
was specified when the accessor was constructed.

When [code]#AccessTarget# is [code]#target::local#, the returned value is the
range that was specified when the accessor was constructed.

a@
[source]
----
operator reference() const
----
   a@ When [code]#AccessTarget# is [code]#target::constant_buffer# or
      [code]#target::host_buffer#, available only when
      [code]#(Dimensions == 0)#.

When [code]#AccessTarget# is [code]#target::local#, available only when
[code]#(AccessMode == access_mode::read_write && Dimensions == 0)#.

Returns a reference to the single element that is accessed by this accessor.

When [code]#AccessTarget# is [code]#target::local# or
[code]#target::constant_buffer#, this function may only be called from within a
<<command>>.

a@
[source]
----
reference operator[](id<Dimensions> index) const
----
   a@ When [code]#AccessTarget# is [code]#target::constant_buffer# or
      [code]#target::host_buffer#, available only when
      [code]#(Dimensions > 0)#.

When [code]#AccessTarget# is [code]#target::local#, available only when
[code]#(AccessMode == access_mode::read_write && Dimensions > 0)#.

Returns a reference to the element at the location specified by [code]#index#.
If this is a <<ranged-accessor>>, the element is determined by adding
[code]#index# to the accessor's offset.

When [code]#AccessTarget# is [code]#target::local# or
[code]#target::constant_buffer#, this function may only be called from within a
<<command>>.

a@
[source]
----
__unspecified__ operator[](size_t index) const
----
   a@ Available only when [code]#(Dimensions > 1)#.

Returns an instance of an undefined intermediate type representing this
accessor, with the dimensionality [code]#Dimensions-1# and containing an
implicit [code]#id# with index [code]#Dimensions# set to [code]#index#.  The
intermediate type returned must provide all available subscript operators which
take a [code]#size_t# parameter defined by this accessor class that are
appropriate for the type it represents (including this subscript operator).

If this is a <<ranged-accessor>>, the implicit [code]#id# in the returned
instance also includes the accessor's offset.

When [code]#AccessTarget# is [code]#target::local# or
[code]#target::constant_buffer#, this function may only be called from within a
<<command>>.

a@
[source]
----
reference operator[](size_t index) const
----
   a@ When [code]#AccessTarget# is [code]#target::constant_buffer# or
      [code]#target::host_buffer#, available only when
      [code]#(Dimensions == 1)#.

When [code]#AccessTarget# is [code]#target::local#, available only when
[code]#(AccessMode == access_mode::read_write && Dimensions == 1)#.

Returns a reference to the element at the location specified by [code]#index#.
If this is a <<ranged-accessor>>, the element is determined by adding
[code]#index# to the accessor's offset.

When [code]#AccessTarget# is [code]#target::local# or
[code]#target::constant_buffer#, this function may only be called from within a
<<command>>.

|====


====== Accessor specialization with [code]#access_mode::atomic#

The [code]#accessor# class may be specialized with target [code]#target::device#
and access mode [code]#access_mode::atomic#.
This specialization provides additional member functions beyond those that are
provided for other [code]#target::device# specializations as described in
<<table.accessors.deprecated.atomic.members>>.


[[table.accessors.deprecated.atomic.members]]
.Deprecated atomic member functions of the [code]#accessor# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
operator atomic<DataT, access::address_space::global_space>() const
----
   a@ Available only when
      [code]#(AccessMode == access_mode::atomic && Dimensions == 0)#.

Returns an instance of [code]#atomic# of type [code]#DataT# providing atomic
access to the single element that is accessed by this accessor.

a@
[source]
----
atomic<DataT, access::address_space::global_space>
operator[](id<Dimensions> index) const
----
   a@ Available only when
      [code]#(AccessMode == access_mode::atomic && Dimensions > 0)#.

Returns an instance of [code]#atomic# of type [code]#DataT# providing atomic
access to the element stored within the accessor's buffer at the index
specified by [code]#index#.

If this is a <<ranged-accessor>>, the returned [code]#atomic# instance
provides access to the buffer element whose location is determined by adding
the accessor's offset to [code]#index#.

a@
[source]
----
atomic<DataT, access::address_space::global_space>
operator[](size_t index) const
----
   a@ Available only when
      [code]#(AccessMode == access_mode::atomic && Dimensions == 1)#.

Returns an instance of [code]#atomic# of type [code]#DataT# providing atomic
access to the element stored within the accessor's buffer at the index
specified by [code]#index#.

If this is a <<ranged-accessor>>, the returned [code]#atomic# instance
provides access to the buffer element whose location is determined by adding
the accessor's offset to [code]#index#.

|====


==== Buffer accessor for host code

The [code]#host_accessor# class provides access to data in a [code]#buffer# from
host code that is outside of a <<command>> (i.e. do not use this class to access
a buffer inside a host task).

As with [code]#accessor#, the dimensionality of [code]#host_accessor# must match
the underlying buffer, however, there is a special case if the buffer is
one-dimensional.
In this case, the accessor may either be one-dimensional or it may be
zero-dimensional.
A zero-dimensional accessor has access to just the first element of the buffer,
whereas a one-dimensional accessor has access to the entire buffer.

The [code]#host_accessor# class supports the following access modes:
[code]#access_mode::read#, [code]#access_mode::write# and
[code]#access_mode::read_write#.


===== Interface for buffer host accessors

A synopsis of the [code]#host_accessor# class is provided below.
Since some of the class types and member functions have the same name and
meaning as other accessors, the common types and functions are described in
<<sec:accessor.common.members>>.
The member types are listed in <<table.accessors.common.types>>.
The constructors are listed in <<table.accessors.host.buffer.constructors>>, and
the member functions are listed in <<table.accessors.common.members>> and
<<table.accessors.host.buffer.members>>.

The additional common special member functions and common member functions are
listed in <<sec:reference-semantics>> in
<<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>>, respectively.
For valid implicit conversions between accessor types refer to
<<sec:accessor.host.buffer.conversions>>.
Additionally, accessors of the same type must be equality comparable.

[source,,linenums]
----
include::{header_dir}/accessorHost.h[lines=4..-1]
----


[[table.accessors.host.buffer.constructors]]
.Constructors of the [code]#host_accessor# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
host_accessor()
----
   a@ Constructs an empty accessor which fulfills the following
      post-conditions:
--
  * [code]#(empty() == true)#
  * All size queries return [code]#0#.
  * The return value of [code]#get_pointer()# is unspecified.
  * Trying to access the underlying memory is undefined behavior.
--

a@
[source]
----
template <typename AllocatorT>
host_accessor(buffer<DataT, 1, AllocatorT>& bufferRef,
              const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions == 0)#.

Constructs a [code]#host_accessor# for accessing the first element of a
[code]#buffer# immediately on the host.  The optional [code]#property_list#
provides properties for the constructed accessor.

a@
[source]
----
template <typename AllocatorT>
host_accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
              const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs a [code]#host_accessor# for accessing a [code]#buffer# immediately
on the host.  The optional [code]#property_list# provides properties for the
constructed accessor.

a@
[source]
----
template <typename AllocatorT, typename TagT>
host_accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef, TagT tag,
              const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs a [code]#host_accessor# for accessing a [code]#buffer# immediately
on the host.  The [code]#tag# is used to deduce template arguments of the
accessor as described in <<sec:accessor.host.buffer.tags>>.  The optional
[code]#property_list# provides properties for the constructed accessor.

a@
[source]
----
template <typename AllocatorT>
host_accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
              range<Dimensions> accessRange, const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs a [code]#host_accessor# that is a <<ranged-accessor>> which accesses
a buffer immediately on the host, where the range starts at the beginning of
the [code]#buffer#.  The optional [code]#property_list# provides properties for
the constructed accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
[code]#accessRange# exceeds the range of [code]#bufferRef# in any dimension.


a@
[source]
----
template <typename AllocatorT, typename TagT>
host_accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
              range<Dimensions> accessRange, TagT tag,
              const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs a [code]#host_accessor# that is a <<ranged-accessor>> which accesses
a buffer immediately on the host, where the range starts at the beginning of
the [code]#buffer#.  The [code]#tag# is used to deduce template arguments of
the accessor as described in <<sec:accessor.host.buffer.tags>>.  The optional
[code]#property_list# provides properties for the constructed accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
[code]#accessRange# exceeds the range of [code]#bufferRef# in any dimension.

a@
[source]
----
template <typename AllocatorT>
host_accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
              range<Dimensions> accessRange, id<Dimensions> accessOffset,
              const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs a [code]#host_accessor# that is a <<ranged-accessor>> which accesses
a buffer immediately on the host, where the range starts at an offset from the
beginning of the buffer.  The optional [code]#property_list# provides
properties for the constructed accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
the sum of [code]#accessRange# and [code]#accessOffset# exceeds the range of
[code]#bufferRef# in any dimension.

a@
[source]
----
template <typename AllocatorT, typename TagT>
host_accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
              range<Dimensions> accessRange, id<Dimensions> accessOffset,
              TagT tag, const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs a [code]#host_accessor# that is a <<ranged-accessor>> which accesses
a buffer immediately on the host, where the range starts at an offset from the
beginning of the buffer.  The [code]#tag# is used to deduce template arguments
of the accessor as described in <<sec:accessor.host.buffer.tags>>.  The
optional [code]#property_list# provides properties for the constructed
accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
the sum of [code]#accessRange# and [code]#accessOffset# exceeds the range of
[code]#bufferRef# in any dimension.

|====


[[table.accessors.host.buffer.members]]
.Member functions of the [code]#host_accessor# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
void swap(host_accessor& other);
----
   a@ Swaps the contents of the current accessor with the contents of
      [code]#other#.

a@
[source]
----
id<Dimensions> get_offset() const
----
   a@ Available only when [code]#(Dimensions > 0)#.

If this is a <<ranged-accessor>>, returns the offset that was specified when the
accessor was constructed.  For other accessors, returns the default constructed
[code]#id<Dimensions>{}#.

a@
[source]
----
std::add_pointer_t<value_type> get_pointer() const noexcept
----
   a@ Returns a pointer to the start of this accessor's underlying
      buffer, even if this is a <<ranged-accessor>> whose range does not start
      at the beginning of the buffer.  The return value is unspecified if the
      accessor is empty.

a@
[source]
----
const host_accessor& operator=(const value_type& other) const
----
   a@ Available only when [code]#(AccessMode != access_mode::read &&
      Dimensions == 0)#.

Assignment to the single element that is accessed by this accessor.

a@
[source]
----
const host_accessor& operator=(value_type&& other) const
----
   a@ Available only when [code]#(AccessMode != access_mode::read &&
      Dimensions == 0)#.

Assignment to the single element that is accessed by this accessor.

|====


[[sec:accessor.host.buffer.tags]]
===== Deduction tags for buffer host accessors

Some [code]#host_accessor# constructors take a [code]#TagT# parameter, which is
used to deduce template arguments.
The permissible values for this parameter are listed in
<<table.accessors.host.buffer.tags>> along with the access mode that they imply.

[[table.accessors.host.buffer.tags]]
.Enumeration of tags available for [code]#host_accessor# construction
[width="100%",options="header",cols="50%,50%"]
|====
| Tag value | Access mode
| [code]#read_write#
    | [code]#access_mode::read_write#
| [code]#read_only#
    | [code]#access_mode::read#
| [code]#write_only#
    | [code]#access_mode::write#
|====


[[sec:accessor.host.buffer.conversions]]
===== Read only buffer host accessors and implicit conversions

<<table.accessors.host.buffer.read-only>> shows the specializations of
[code]#host_accessor# that are read-only accessors.
There is an implicit conversion between any of these specializations, provided
that all other template parameters are the same.

[[table.accessors.host.buffer.read-only]]
.Specializations of [code]#host_accessor# that are read-only
[width="100%",options="header",cols="50%,50%"]
|====
| Data type | Access mode
| not const-qualified | [code]#access_mode::read#
| const-qualified | [code]#access_mode::read#
|====

There is also an implicit conversion from the read-write [code]#host_accessor#
type shown in <<table.accessors.host.buffer.read-write>> to any of the read-only
accessors in <<table.accessors.host.buffer.read-only>>, provided that all other
template parameters are the same.

[[table.accessors.host.buffer.read-write]]
.Specializations of [code]#host_accessor# that are read-write
[width="100%",options="header",cols="50%,50%"]
|====
| Data type | Access mode
| not const-qualified | [code]#access_mode::read_write#
|====


[[sec:accessor.local]]
==== Local accessor

The [code]#local_accessor# class allocates device local memory and provides
access to this memory from within a <<sycl-kernel-function>>.
The <<local-memory>> that is allocated is shared between all
<<work-item,work-items>> of a <<work-group>>.
If multiple work-groups execute simultaneously in an implementation, each
work-group receives its own independent copy of the allocated local memory.

The underlying [code]#DataT# type can be any {cpp} type that the device
supports.
If [code]#DataT# is an implicit-lifetime type (as defined in the {cpp} core
language), the local accessor implicitly creates objects of that type with
indeterminate values.
For other types, the local accessor merely allocates uninitialized memory, and
the application is responsible for constructing objects in that memory (e.g. by
calling placement-new).

A local accessor must not be used in a <<sycl-kernel-function>> that is invoked
via [code]#single_task# or via the simple form of [code]#parallel_for# that
takes a [code]#range# parameter.
In these cases submitting the kernel to a queue must throw a synchronous
[code]#exception# with the [code]#errc::kernel_argument# error code.


===== Interface for local accessors

A synopsis of the [code]#local_accessor# class is provided below.
Since some of the class types and member functions have the same name and
meaning as other accessors, the common types and functions are described in
<<sec:accessor.common.members>>.
The member types are listed in <<table.accessors.common.types>> and
<<table.accessors.local.types>>.
The constructors are listed in <<table.accessors.local.constructors>>, and the
member functions are listed in <<table.accessors.common.members>> and
<<table.accessors.local.members>>.

The additional common special member functions and common member functions are
listed in <<sec:reference-semantics>> in
<<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>>, respectively.
For valid implicit conversions between accessor types refer to
<<sec:accessor.local.conversions>>.
Additionally, accessors of the same type must be equality comparable.

[source,,linenums]
----
include::{header_dir}/accessorLocal.h[lines=4..-1]
----


[[table.accessors.local.types]]
.Member types of the [code]#local_accessor# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member types @ Description
a@
[source]
----
template <access::decorated IsDecorated> accessor_ptr
----
   a@ Equal to
      [code]#multi_ptr<value_type, access::address_space::local_space, IsDecorated>#.

|====


[[table.accessors.local.constructors]]
.Constructors of the [code]#local_accessor# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
local_accessor()
----
   a@ Constructs an empty local accessor which fulfills the following
      post-conditions:
--
  * [code]#(empty() == true)#
  * All size queries return [code]#0#.
  * The return values of [code]#get_pointer()# and [code]#get_multi_ptr()# are
    unspecified.
  * A default constructed local accessor can be passed to a
    <<sycl-kernel-function>>, but attempting to access data elements from it
    produces undefined behavior.
--

a@
[source]
----
local_accessor(handler& commandGroupHandlerRef,
               const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions == 0)#.

Constructs a [code]#local_accessor# for accessing <<local-memory>> of a single
[code]#DataT# element within a <<sycl-kernel-function>> on the queue associated
with [code]#commandGroupHandlerRef#.  The optional [code]#property_list#
provides properties for the constructed accessor.

a@
[source]
----
local_accessor(range<Dimensions> allocationSize,
               handler& commandGroupHandlerRef,
               const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs a [code]#local_accessor# for accessing <<local-memory>> of an array
of [code]#DataT# elements within a <<sycl-kernel-function>> on the queue
associated with [code]#commandGroupHandlerRef#.  The number of elements in the
array is defined by [code]#allocationSize#.  The optional [code]#property_list#
provides properties for the constructed accessor.

|====


[[table.accessors.local.members]]
.Member functions of the [code]#local_accessor# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
void swap(local_accessor& other);
----
   a@ Swaps the contents of the current accessor with the contents of
      [code]#other#.

a@
[source]
----
local_ptr<value_type> get_pointer() const noexcept
----
   a@ Returns a [code]#multi_ptr# to the start of this accessor's local memory
      region which corresponds to the calling work-group. The return value is
      unspecified if the accessor is empty.

This function may only be called from within a <<command>>.

Deprecated in SYCL 2020.  Use [code]#get_multi_ptr# instead.


a@
[source]
----
template <access::decorated IsDecorated>
accessor_ptr<IsDecorated> get_multi_ptr() const noexcept
----
   a@ Returns a [code]#multi_ptr# to the start of the accessor's local memory
      region which corresponds to the calling work-group.  The return value is
      unspecified if the accessor is empty.

This function may only be called from within a <<sycl-kernel-function>>.

a@
[source]
----
const local_accessor& operator=(const value_type& other) const
----
   a@ Available only when [code]#(!std::is_const_v<DataT> && Dimensions == 0)#.

Assignment to the single element that is accessed by this accessor.

This function may only be called from within a <<command>>.

a@
[source]
----
const local_accessor& operator=(const value_type&& other) const
----
   a@ Available only when [code]#(!std::is_const_v<DataT> && Dimensions == 0)#.

Assignment to the single element that is accessed by this accessor.

This function may only be called from within a <<command>>.

|====


[[sec:accessor.local.conversions]]
===== Read only local accessors and implicit conversions

Since [code]#local_accessor# has no template parameter for the access mode, the
only specialization for a read-only local accessor is by providing a
[code]#const# qualified [code]#DataT# parameter.
Specializations with a non-[code]#const# qualified [code]#DataT# parameter are
read-write.
There is an implicit conversion from the read-write specialization to the
read-only specialization, provided that all other template parameters are the
same.


[[sec:accessor.common.members]]
==== Common members for buffer and local accessors

The [code]#accessor#, [code]#host_accessor#, and [code]#local_accessor# classes
have many member types and member functions with the same name and meaning.
<<table.accessors.common.types>> describes these common types and
<<table.accessors.common.members>> describes the common member functions.


[[table.accessors.common.types]]
.Common buffer and local accessor member types
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member types @ Description
a@
[source]
----
value_type
----
   a@ If the accessor is read-only, equal to [code]#const DataT#, otherwise
      equal to [code]#DataT#.

See <<sec:accessor.command.buffer.conversions>>,
<<sec:accessor.host.buffer.conversions>> and <<sec:accessor.local.conversions>>
for which accessors are considered read-only.

a@
[source]
----
reference
----
   a@ Equal to [code]#value_type&#.

a@
[source]
----
const_reference
----
   a@ Equal to [code]#const DataT&#.

a@
[source]
----
iterator
----
   a@ Iterator that can provide ranged access.  Cannot be written to if the
      accessor is read-only.  The underlying pointer is address space qualified
      for [code]#accessor# specializations with [code]#target::device# and for
      [code]#local_accessor#.

a@
[source]
----
const_iterator
----
   a@ Iterator that can provide ranged access.  Cannot be written to.  The
      underlying pointer is address space qualified for [code]#accessor#
      specializations with [code]#target::device# and for
      [code]#local_accessor#.

a@
[source]
----
reverse_iterator
----
   a@ Iterator adaptor that reverses the direction of [code]#iterator#.

a@
[source]
----
const_reverse_iterator
----
   a@ Iterator adaptor that reverses the direction of [code]#const_iterator#.

a@
[source]
----
difference_type
----
   a@ Equal to
      [code]#typename std::iterator_traits<iterator>::difference_type#.

a@
[source]
----
size_type
----
   a@ Equal to [code]#size_t#.

|====


[[table.accessors.common.members]]
.Common buffer and local accessor member functions
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
size_type byte_size() const noexcept
----
   a@ Returns the size in bytes of the memory region this accessor may access.

For a buffer accessor this is the size of the underlying buffer, unless it is a
<<ranged-accessor>> in which case it is the size of the elements within the
accessor's range.

For a local accessor this is the size of the accessor's local memory
allocation, per work-group.

a@
[source]
----
size_type size() const noexcept
----
   a@ Returns the number of [code]#DataT# elements of the memory region this
      accessor may access.

For a buffer accessor this is the number of elements in the underlying buffer,
unless it is a <<ranged-accessor>> in which case it is the number of elements
within the accessor's range.

For a local accessor this is the number of elements in the accessor's local
memory allocation, per work-group.

a@
[source]
----
size_type max_size() const noexcept
----
   a@ Returns the maximum number of elements any accessor of this type would be
      able to access.

a@
[source]
----
bool empty() const noexcept
----
   a@ Returns [code]#true# if [code]#(size() == 0)#.

a@
[source]
----
range<Dimensions> get_range() const
----
   a@ Available only when [code]#(Dimensions > 0)#.

Returns a [code]#range# object which represents the number of elements of
[code]#DataT# per dimension that this accessor may access.

For a buffer accessor this is the range of the underlying buffer, unless it is
a <<ranged-accessor>> in which case it is the range that was specified when the
accessor was constructed.

a@
[source]
----
operator reference() const
----
   a@ For [code]#accessor# available only when
      [code]#(AccessMode != access_mode::atomic && Dimensions == 0)#.

For [code]#host_accessor# and [code]#local_accessor# available only when
[code]#(Dimensions == 0)#.

Returns a reference to the single element that is accessed by this accessor.

For [code]#accessor# and [code]#local_accessor#, this function may only be
called from within a <<command>>.

a@
[source]
----
reference operator[](id<Dimensions> index) const
----
   a@ For [code]#accessor# available only when
      [code]#(AccessMode != access_mode::atomic && Dimensions > 0)#.

For [code]#host_accessor# and [code]#local_accessor# available only when
[code]#(Dimensions > 0)#.

Returns a reference to the element at the location specified by [code]#index#.
If this is a <<ranged-accessor>>, the element is determined by adding
[code]#index# to the accessor's offset.

For [code]#accessor# and [code]#local_accessor#, this function may only be
called from within a <<command>>.

a@
[source]
----
__unspecified__ operator[](size_t index) const
----
   a@ Available only when [code]#(Dimensions > 1)#.

Returns an instance of an undefined intermediate type representing this
accessor, with the dimensionality [code]#Dimensions-1# and containing an
implicit [code]#id# with index [code]#Dimensions# set to [code]#index#.  The
intermediate type returned must provide all available subscript operators which
take a [code]#size_t# parameter defined by this accessor class that are
appropriate for the type it represents (including this subscript operator).

If this is a <<ranged-accessor>>, the implicit [code]#id# in the returned
instance also includes the accessor's offset.

For [code]#accessor# and [code]#local_accessor#, this function may only be
called from within a <<command>>.

a@
[source]
----
reference operator[](size_t index) const
----
   a@ For [code]#accessor# available only when
      [code]#(AccessMode != access_mode::atomic && Dimensions == 1)#.

For [code]#host_accessor# and [code]#local_accessor# available only when
[code]#(Dimensions == 1)#.

Returns a reference to the element at the location specified by [code]#index#.
If this is a <<ranged-accessor>>, the element is determined by adding
[code]#index# to the accessor's offset.

For [code]#accessor# and [code]#local_accessor#, this function may only be
called from within a <<command>>.

a@
[source]
----
iterator begin() const noexcept
----
   a@ Returns an iterator to the first element of the memory this accessor may
      access.

For a buffer accessor this is an iterator to the first element of the
underlying buffer, unless this is a <<ranged-accessor>> in which case it is an
iterator to first element within the accessor's range.

For [code]#accessor# and [code]#local_accessor#, this function may only be
called from within a <<command>>.

a@
[source]
----
iterator end() const noexcept
----
   a@ Returns an iterator to one element past the last element of the memory
      this accessor may access.

For a buffer accessor this is an iterator to one element past the last element
in the underlying buffer, unless this is a <<ranged-accessor>> in which case
it is an iterator to one element past the last element within the accessor's
range.

For [code]#accessor# and [code]#local_accessor#, this function may only be
called from within a <<command>>.

a@
[source]
----
const_iterator cbegin() const noexcept
----
   a@ Returns a const iterator to the first element of the memory this accessor
      may access.

For a buffer accessor this is a const iterator to the first element of the
underlying buffer, unless this is a <<ranged-accessor>> in which case it is a
const iterator to first element within the accessor's range.

For [code]#accessor# and [code]#local_accessor#, this function may only be
called from within a <<command>>.

a@
[source]
----
const_iterator cend() const noexcept
----
   a@ Returns a const iterator to one element past the last element of the
      memory this accessor may access.

For a buffer accessor this is a const iterator to one element past the last
element in the underlying buffer, unless this is a <<ranged-accessor>> in which
case it is a const iterator to one element past the last element within the
accessor's range.

For [code]#accessor# and [code]#local_accessor#, this function may only be
called from within a <<command>>.

a@
[source]
----
reverse_iterator rbegin() const noexcept
----
   a@ Returns an iterator adaptor to the last element of the memory this
      accessor may access.

For a buffer accessor this is an iterator adaptor to the last element of the
underlying buffer, unless this is a <<ranged-accessor>> in which case it is an
iterator adaptor to the last element within the accessor's range.

For [code]#accessor# and [code]#local_accessor#, this function may only be
called from within a <<command>>.

a@
[source]
----
reverse_iterator rend() const noexcept
----
   a@ Returns an iterator adaptor to one element before the first element of
      the memory this accessor may access.

For a buffer accessor this is an iterator adaptor to one element before the
first element in the underlying buffer, unless this is a <<ranged-accessor>> in
which case it is an iterator adaptor to one element before the first element
within the accessor's range.

For [code]#accessor# and [code]#local_accessor#, this function may only be
called from within a <<command>>.

a@
[source]
----
const_reverse_iterator crbegin() const noexcept
----
   a@ Returns a const iterator adaptor to the last element of the memory this
      accessor may access.

For a buffer accessor this is a const iterator adaptor to the last element of
the underlying buffer, unless this is a <<ranged-accessor>> in which case it is
an const iterator adaptor to last element within the accessor's range.

For [code]#accessor# and [code]#local_accessor#, this function may only be
called from within a <<command>>.

a@
[source]
----
const_reverse_iterator crend() const noexcept
----
   a@ Returns a const iterator adaptor to one element before the first element of
      the memory this accessor may access.

For a buffer accessor this is a const iterator adaptor to one element before the
first element in the underlying buffer, unless this is a <<ranged-accessor>> in
which case it is a const iterator adaptor to one element before the first element
within the accessor's range.

For [code]#accessor# and [code]#local_accessor#, this function may only be
called from within a <<command>>.

|====


==== Unsampled image accessors

There are two classes which implement accessors for unsampled images,
[code]#unsampled_image_accessor# and [code]#host_unsampled_image_accessor#.
The former provides access from within a <<sycl-kernel-function>> or from within
a <<host-task>>.
The latter provides access from host code that is outside of a <<host-task>>.

The dimensionality of an unsampled image accessor must match the dimensionality
of the underlying image to which it provides access.
Both unsampled image accessor classes support the [code]#access_mode::read# and
[code]#access_mode::write# access modes.
In addition, the [code]#host_unsampled_image_accessor# class supports
[code]#access_mode::read_write#.

The [code]#AccessTarget# template parameter dictates how the
[code]#unsampled_image_accessor# can be used: [code]#image_target::device# means
the accessor can be used in a <<sycl-kernel-function>> while
[code]#image_target::host_task# means the accessor can be used in a
<<host-task>>.
Programs which specify this template parameter as [code]#image_target::device#
and then use the [code]#unsampled_image_accessor# from a <<host-task>> are ill
formed.
Likewise, programs which specify this template parameter as
[code]#image_target::host_task# and then use the
[code]#unsampled_image_accessor# from a <<sycl-kernel-function>> are ill formed.


===== Interface for unsampled image accessors

A synopsis of the two unsampled image accessor classes is provided below.
Both classes have member types with the same name, which are described in
<<table.accessors.unsampled.image.types>>.
The constructors for the two classes are described in
<<table.accessors.unsampled.image.constructors>> and
<<table.accessors.host.unsampled.image.constructors>>.
Both classes also have member functions with the same name, which are described
in <<table.accessors.unsampled.image.members>>.

The additional common special member functions and common member functions are
listed in <<sec:reference-semantics>> in
<<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>>, respectively.
For valid implicit conversions between unsampled accessor types refer to
<<sec:accessor.unsampled.image.conversions>>.

Two [code]#unsampled_image_accessor# objects of the same type must be equality
comparable in both the host code and in SYCL kernel functions.
Two [code]#host_unsampled_image_accessor# objects of the same type must be
equality comparable in the host code.

[source,,linenums]
----
include::{header_dir}/accessorUnsampledImage.h[lines=4..-1]
----


[[table.accessors.unsampled.image.types]]
.Member types of the unsampled image classes
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member types @ Description
a@
[source]
----
value_type
----
   a@ If the accessor is read-only, equal to [code]#const DataT#, otherwise
      equal to [code]#DataT#.

See <<sec:accessor.unsampled.image.conversions>> for which accessors are
considered read-only.

a@
[source]
----
reference
----
   a@ Equal to [code]#value_type&#.

a@
[source]
----
const_reference
----
   a@ Equal to [code]#const DataT&#.

|====


[[table.accessors.unsampled.image.constructors]]
.Constructors of the [code]#unsampled_image_accessor# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
template <typename AllocatorT>
unsampled_image_accessor(unsampled_image<Dimensions, AllocatorT>& imageRef,
                         handler& commandGroupHandlerRef,
                         const property_list& propList = {})
----
   a@ Constructs an [code]#unsampled_image_accessor# for accessing an
      [code]#unsampled_image# within a <<command>> on the [code]#queue#
      associated with [code]#commandGroupHandlerRef#.  The optional
      [code]#property_list# provides properties for the constructed object.

If [code]#AccessTarget# is [code]#image_target::device#, throws an
[code]#exception# with the [code]#errc::feature_not_supported# error code if
the device associated with [code]#commandGroupHandlerRef# does not have
[code]#aspect::image#.

|====


[[table.accessors.host.unsampled.image.constructors]]
.Constructors of the [code]#host_unsampled_image_accessor# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
template <typename AllocatorT>
host_unsampled_image_accessor(unsampled_image<Dimensions, AllocatorT>& imageRef,
                              const property_list& propList = {})
----
   a@ Constructs a [code]#host_unsampled_image_accessor# for accessing an
      [code]#unsampled_image# immediately on the host.  The optional
      [code]#property_list# provides properties for the constructed object.

|====


[[table.accessors.unsampled.image.members]]
.Member functions of the unsampled image classes
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
size_t size() const noexcept
----
   a@ Returns the number of elements of the underlying [code]#unsampled_image#
      that this accessor is accessing.

a@
[source]
----
template <typename CoordT> DataT read(const CoordT& coords) const
----
   a@ Available only when [code]#(AccessMode == access_mode::read ||
      AccessMode == access_mode::read_write)#.

Reads and returns an element of the [code]#unsampled_image# at the coordinates
specified by [code]#coords#.  Permitted types for [code]#CoordT# are
[code]#int# when [code]#Dimensions == 1#, [code]#int2# when
[code]#Dimensions == 2# and [code]#int4# when [code]#Dimensions == 3#.

For [code]#unsampled_image_accessor#, this function may only be called from
within a <<command>>.

a@
[source]
----
template <typename CoordT>
void write(const CoordT& coords, const DataT& color) const
----
   a@ Available only when [code]#(AccessMode == access_mode::write ||
      AccessMode == access_mode::read_write)#.

Writes the value specified by [code]#color# to the element of the image at the
coordinates specified by [code]#coords#.  Permitted types for [code]#CoordT#
are [code]#int# when [code]#Dimensions == 1#, [code]#int2# when
[code]#Dimensions == 2# and [code]#int4# when [code]#Dimensions == 3#.

For [code]#unsampled_image_accessor#, this function may only be called from
within a <<command>>.

|====


[[sec:accessor.unsampled.image.conversions]]
===== Read only unsampled image accessors and implicit conversions

All specializations of unsampled image accessors with [code]#access_mode::read#
are read-only regardless of whether [code]#DataT# is [code]#const# qualified.
There is an implicit conversion between the [code]#const# qualified and
non-[code]#const# qualified specializations, provided that all other template
parameters are the same.


==== Sampled image accessors

There are two classes which implement accessors for sampled images,
[code]#sampled_image_accessor# and [code]#host_sampled_image_accessor#.
The former provides access from within a <<sycl-kernel-function>> or from within
a <<host-task>>.
The latter provides access from host code that is outside of a <<host-task>>.

The dimensionality of a sampled image accessor must match the dimensionality of
the underlying image to which it provides access.
Sampled image accessors are always read-only.

The [code]#AccessTarget# template parameter dictates how the
[code]#sampled_image_accessor# can be used: [code]#image_target::device# means
the accessor can be used in a <<sycl-kernel-function>> while
[code]#image_target::host_task# means the accessor can be used in a
<<host-task>>.
Programs which specify this template parameter as [code]#image_target::device#
and then use the [code]#sampled_image_accessor# from a <<host-task>> are ill
formed.
Likewise, programs which specify this template parameter as
[code]#image_target::host_task# and then use the [code]#sampled_image_accessor#
from a <<sycl-kernel-function>> are ill formed.



===== Interface for sampled image accessors

A synopsis of the two sampled image accessor classes is provided below.
Both classes have member types with the same name, which are described in
<<table.accessors.sampled.image.types>>.
The constructors for the two classes are described in
<<table.accessors.sampled.image.constructors>> and
<<table.accessors.host.sampled.image.constructors>>.
Both classes also have member functions with the same name, which are described
in <<table.accessors.sampled.image.members>>.

The additional common special member functions and common member functions are
listed in <<sec:reference-semantics>> in
<<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>>, respectively.
For valid implicit conversions between sampled accessor types refer to
<<sec:accessor.sampled.image.conversions>>.

Two [code]#sampled_image_accessor# objects of the same type must be equality
comparable in both the host code and in SYCL kernel functions.
Two [code]#host_sampled_image_accessor# objects of the same type must be
equality comparable in the host code.

[source,,linenums]
----
include::{header_dir}/accessorSampledImage.h[lines=4..-1]
----


[[table.accessors.sampled.image.types]]
.Member types of the sampled image classes
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member types @ Description
a@
[source]
----
value_type
----
   a@ Equal to [code]#const DataT#.

a@
[source]
----
reference
----
   a@ Equal to [code]#const DataT&#.

a@
[source]
----
const_reference
----
   a@ Equal to [code]#const DataT&#.

|====


[[table.accessors.sampled.image.constructors]]
.Constructors of the [code]#sampled_image_accessor# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
template <typename AllocatorT>
sampled_image_accessor(sampled_image<Dimensions, AllocatorT>& imageRef,
                       handler& commandGroupHandlerRef,
                       const property_list& propList = {})
----
   a@ Constructs a [code]#sampled_image_accessor# for accessing a
      [code]#sampled_image# within a <<command>> on the [code]#queue#
      associated with [code]#commandGroupHandlerRef#.  The optional
      [code]#property_list# provides properties for the constructed object.

If [code]#AccessTarget# is [code]#image_target::device#, throws an
[code]#exception# with the [code]#errc::feature_not_supported# error code if
the device associated with [code]#commandGroupHandlerRef# does not have
[code]#aspect::image#.

|====


[[table.accessors.host.sampled.image.constructors]]
.Constructors of the [code]#host_sampled_image_accessor# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
template <typename AllocatorT>
host_sampled_image_accessor(sampled_image<Dimensions, AllocatorT>& imageRef,
                            const property_list& propList = {})
----
   a@ Constructs a [code]#host_sampled_image_accessor# for accessing a
      [code]#sampled_image# immediately on the host.  The optional
      [code]#property_list# provides properties for the constructed object.

|====


[[table.accessors.sampled.image.members]]
.Member functions of the sampled image classes
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
size_t size() const noexcept
----
   a@ Returns the number of elements of the underlying [code]#sampled_image#
      that this accessor is accessing.

a@
[source]
----
template <typename CoordT> DataT read(const CoordT& coords) const
----
   a@ Reads and returns a sampled element of the [code]#sampled_image# at the
      coordinates specified by [code]#coords#.  Permitted types for
      [code]#CoordT# are [code]#float# when [code]#Dimensions == 1#,
      [code]#float2# when [code]#Dimensions == 2# and [code]#float4# when
      [code]#Dimensions == 3#.

For [code]#sampled_image_accessor#, this function may only be called from
within a <<command>>.

|====


[[sec:accessor.sampled.image.conversions]]
===== Read only sampled image accessors and implicit conversions

All specializations of sampled image accessors are read-only regardless of
whether [code]#DataT# is [code]#const# qualified.
There is an implicit conversion between the [code]#const# qualified and
non-[code]#const# qualified specializations, provided that all other template
parameters are the same.


// %%%%%%%%%%%%%%%%%%%%%%%%%%%% end accessors %%%%%%%%%%%%%%%%%%%%%%%%%%%%


=== Address space classes

In SYCL, there are five different address spaces: global, local, constant,
private and generic.
In a SYCL generic implementation, types are not affected by the address spaces.
However, there are situations where users need to explicitly carry address
spaces in the type.
For example:

  * For performance tuning and genericness.
    Even if the platform supports the representation of the generic address
    space, this may come at some performance sacrifice.
    In order to help the target compiler, it can be useful to track specifically
    which address space a pointer is addressing.
  * When linking SYCL kernels with <<backend>>-specific functions.
    In this case, it might be necessary to specify the address space for any
    pointer parameters.

Direct declaration of pointers with address spaces is discouraged as the
definition is implementation-defined.
Users must rely on the [code]#multi_ptr# class to handle address space
boundaries and interoperability.


[[sec:multiptr]]
==== Multi-pointer class

The multi-pointer class is the common interface for the explicit pointer
classes, defined in <<sec:pointerclasses>>.

There are situations where a user may want to make their type address space
dependent.
This allows performing generic programming that depends on the address space
associated with their data.
An example might be wrapping a pointer inside a class, where a user may need to
template the class according to the address space of the pointer the class is
initialized with.
In this case, the [code]#multi_ptr# class enables users to do this in a portable
and stable way.

The [code]#multi_ptr# class exposes 3 flavors of the same interface.
If the value of [code]#access::decorated# is [code]#access::decorated::no#, the
interface exposes pointers and references type that are not decorated by an
address space.
If the value of [code]#access::decorated# is [code]#access::decorated::yes#, the
interface exposes pointers and references type that are decorated by an address
space.
The decoration is implementation dependent and relies on device compiler
extensions.
The decorated type may be distinct from the non-decorated one.
For interoperability with the <<backend>>, users should rely on types exposed by
the decorated version.
If the value of [code]#access::decorated# is [code]#access::decorated::legacy#,
the 1.2.1 interface is exposed.

The template traits [code]#remove_decoration# and type alias
[code]#remove_decoration_t# retrieve the non-decorated pointer or reference from
a decorated one.
Using this template trait with a non-decorated type is safe and returns the same
type.


It is possible to use the [code]#void# type for the [code]#multi_ptr# class, but
in that case some functionality is disabled.
[code]#multi_ptr<void># does not provide the [code]#reference# or
[code]#const_reference# types, the access operators ([code]#operator*()#,
[code]#+operator->()+#), the arithmetic operators or [code]#prefetch# member
function.
Conversions from [code]#multi_ptr# to [code]#multi_ptr<void># of the same
address space are allowed, and will occur implicitly.
Conversions from [code]#multi_ptr<void># to any other [code]#multi_ptr# type of
the same address space are allowed, but must be explicit.
The same rules apply to [code]#multi_ptr<const void>#.

An overview of the interface provided for the [code]#multi_ptr# class follows.

[source,,linenums]
----
include::{header_dir}/multipointer.h[lines=4..-1]
----


[[table.constructors.multiptr]]
.Constructors of the SYCL [code]#multi_ptr# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
multi_ptr()
----
   a@ Default constructor.

a@
[source]
----
multi_ptr(const multi_ptr&)
----
   a@ Copy constructor.

a@
[source]
----
multi_ptr(multi_ptr&&)
----
   a@ Move constructor.

a@
[source]
----
explicit
multi_ptr(multi_ptr<ElementType, Space,
                    access::decorated::yes>::pointer)
----
   a@ Constructor that takes as an argument a decorated pointer.

a@
[source]
----
multi_ptr(std::nullptr_t)
----
   a@ Constructor from a [code]#nullptr#.

a@
[source]
----
template <typename AccDataT, int Dimensions,
          access_mode Mode,
          access::placeholder IsPlaceholder>
multi_ptr(accessor<AccDataT, Dimensions, Mode,
                   target::device, IsPlaceholder>)
----
   a@ Available only when:
      [code]#(Space == access::address_space::global_space || Space == access::address_space::generic_space) &&
      (std::is_void_v<ElementType> || std::is_same_v<std::remove_const_t<ElementType>, std::remove_const_t<AccDataT>>) &&
      (std::is_const_v<ElementType> ||
      !std::is_const_v<accessor<AccDataT, Dimensions, Mode, target::device, IsPlaceholder>::value_type>)#.

Constructs a [code]#multi_ptr# from an accessor of
[code]#target::device#.

This constructor may only be called from within a <<command>>.

a@
[source]
----
template <typename AccDataT, int Dimensions>
multi_ptr(local_accessor<AccDataT, Dimensions>)
----
   a@ Available only when:
      [code]#(Space == access::address_space::local_space || Space == access::address_space::generic_space) &&
      (std::is_void_v<ElementType> || std::is_same_v<std::remove_const_t<ElementType>, std::remove_const_t<AccDataT>>) &&
      (std::is_const_v<ElementType> || !std::is_const_v<AccDataT>)#.

Constructs a [code]#multi_ptr# from a [code]#local_accessor#.

This constructor may only be called from within a <<command>>.

a@
[source]
----
template <typename AccDataT, int Dimensions,
          access_mode Mode,
          access::placeholder IsPlaceholder>
multi_ptr(accessor<AccDataT, Dimensions, Mode,
                   target::local, IsPlaceholder>)
----
   a@ Deprecated in SYCL 2020.  Use the overload with
      [code]#local_accessor# instead.

Available only when:
[code]#(Space == access::address_space::local_space || Space == access::address_space::generic_space) &&
(std::is_void_v<ElementType> || std::is_same_v<std::remove_const_t<ElementType>, std::remove_const_t<AccDataT>>) &&
(std::is_const_v<ElementType> || !std::is_const_v<AccDataT>)#.

Constructs a [code]#multi_ptr# from an accessor of [code]#target::local#.

This constructor may only be called from within a <<command>>.

a@
[source]
----
template <typename ElementType,
          access::address_space Space,
          access::decorated DecorateAddress>
multi_ptr<ElementType, Space, DecorateAddress>
make_ptr(ElementType* pointer)
----
   a@ Deprecated in SYCL 2020.  Use [code]#address_space_cast# instead.

Global function to create a [code]#multi_ptr# instance depending
on the address space of the [code]#pointer# argument.
An implementation must return [code]#nullptr# if the run-time value of
[code]#pointer# is not compatible with [code]#Space#, and must issue a
compile-time diagnostic if the deduced address space is not compatible
with [code]#Space#.

a@
[source]
----
template <access::address_space Space,
          access::decorated DecorateAddress,
          typename ElementType>
multi_ptr<ElementType, Space, DecorateAddress>
address_space_cast(ElementType* pointer)
----
   a@ Global function to create a [code]#multi_ptr# instance from
      [code]#pointer#, using the address space and decoration specified
      via the [code]#Space# and [code]#DecorateAddress# template arguments.

An implementation must return [code]#nullptr# if the run-time value of
[code]#pointer# is not compatible with [code]#Space#, and must issue a
compile-time diagnostic if the deduced address space for [code]#pointer#
is not compatible with [code]#Space#.

|====



[[table.multiptr.operators]]
.Operators of [code]#multi_ptr# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Operators @ Description
a@
[source]
----
multi_ptr& operator=(const multi_ptr&)
----
   a@ Copy assignment operator.

a@
[source]
----
multi_ptr& operator=(multi_ptr&&)
----
   a@ Move assignment operator.

a@
[source]
----
multi_ptr& operator=(std::nullptr_t)
----
   a@ Assigns [code]#nullptr# to the [code]#multi_ptr#.

a@
[source]
----
template <access::address_space AS,
          access::decorated IsDecorated>
multi_ptr&
operator=(const multi_ptr<value_type, AS, IsDecorated>&)
----
   a@ Available only when: [code]#(Space == access::address_space::generic_space && AS != access::address_space::constant_space)#.

Assigns the value of the right hand side [code]#multi_ptr# into the [code]#generic_ptr#.

a@
[source]
----
template<access::address_space AS,
         access::decorated IsDecorated>
multi_ptr&
operator=(multi_ptr<value_type, AS, IsDecorated>&&)
----
   a@ Available only when:
      [code]#(Space == access::address_space::generic_space && AS != access::address_space::constant_space)#.

Move the value of the right hand side [code]#multi_ptr# into the [code]#generic_ptr#.

a@
[source]
----
reference operator[](std::ptrdiff_t i) const
----
   a@ Available only when: [code]#(!std::is_void_v<value_type>)#.

Returns a reference to the i-th pointed value. The value i can be negative.

a@
[source]
----
pointer operator->() const
----
   a@ Available only when: [code]#(!std::is_void_v<value_type>)#.

Returns the underlying pointer.

a@
[source]
----
reference operator*() const
----
   a@ Available only when: [code]#(!std::is_void_v<value_type>)#.

Returns a reference to the pointed value.

a@
[source]
----
operator pointer() const
----
   a@ Implicit conversion to the underlying pointer type.
      *Deprecated:* The member function [code]#get# should be used instead

a@
[source]
----
template <access::decorated IsDecorated>
explicit
operator multi_ptr<value_type,
                   access::address_space::private_space,
                   IsDecorated>() const
----
   a@ Available only when:
      [code]#(Space == access::address_space::generic_space)#.

Conversion from [code]#generic_ptr# to [code]#private_ptr#.
The result is undefined if the pointer does not address the private
address space.

a@
[source]
----
template <access::decorated IsDecorated>
explicit
operator multi_ptr<const value_type,
                   access::address_space::private_space,
                   IsDecorated>() const
----
   a@ Available only when:
      [code]#(Space == access::address_space::generic_space)#.

Conversion from [code]#generic_ptr# to [code]#private_ptr# of const data.
The result is undefined if the pointer does not address the private
address space.

a@
[source]
----
template <access::decorated IsDecorated>
explicit
operator multi_ptr<value_type,
                   access::address_space::global_space,
                   IsDecorated>() const
----
   a@ Available only when:
      [code]#(Space == access::address_space::generic_space)#.

Conversion from [code]#generic_ptr# to [code]#global_ptr#.
The result is undefined if the pointer does not address the global
address space.

a@
[source]
----
template <access::decorated IsDecorated>
explicit
operator multi_ptr<const value_type,
                   access::address_space::global_space,
                   IsDecorated>() const
----
   a@ Available only when:
      [code]#(Space == access::address_space::generic_space)#.

Conversion from [code]#generic_ptr# to [code]#global_ptr# of const data.
The result is undefined if the pointer does not address the global
address space.

a@
[source]
----
template <access::decorated IsDecorated>
explicit
operator multi_ptr<value_type,
                   access::address_space::local_space,
                   IsDecorated>() const
----
   a@ Available only when:
      [code]#(Space == access::address_space::generic_space)#.

Conversion from [code]#generic_ptr# to [code]#local_ptr#.
The result is undefined if the pointer does not address the local
address space.

a@
[source]
----
template <access::decorated IsDecorated>
explicit
operator multi_ptr<const value_type,
                   access::address_space::local_space,
                   IsDecorated>() const
----
   a@ Available only when:
      [code]#(Space == access::address_space::generic_space)#.

Conversion from [code]#generic_ptr# to [code]#local_ptr# of const data.
The result is undefined if the pointer does not address the local
address space.

a@
[source]
----
template <access::decorated IsDecorated>
operator multi_ptr<void, Space, IsDecorated>() const
----
   a@ Available only when:
      [code]#(!std::is_void_v<value_type> && !std::is_const_v<value_type>)#.

Implicit conversion to a [code]#multi_ptr# of type [code]#void#.

a@
[source]
----
template <access::decorated IsDecorated>
operator multi_ptr<const void, Space, IsDecorated>() const
----
   a@ Available only when:
      [code]#(!std::is_void_v<value_type> && std::is_const_v<value_type>)#.

Implicit conversion to a [code]#multi_ptr# of type [code]#const void#.

a@
[source]
----
template <access::decorated IsDecorated>
operator multi_ptr<const value_type, Space,
                   IsDecorated>() const
----
   a@ Implicit conversion to a [code]#multi_ptr#
      of type [code]#const value_type#.

a@
[source]
----
operator multi_ptr<value_type, Space,
                   access::decorated::no>() const
----
   a@ Available only when:
      [code]#(is_decorated == true)#.

Implicit conversion to the equivalent [code]#multi_ptr# object that does not expose
decorated pointers or references.

a@
[source]
----
operator multi_ptr<value_type, Space,
                   access::decorated::yes>() const
----
   a@ Available only when:
      [code]#(is_decorated == false)#.

Implicit conversion to the equivalent [code]#multi_ptr# object that exposes
decorated pointers and references.

|====



[[table.multiptr.members]]
.Member functions of [code]#multi_ptr# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
pointer get() const
----
   a@ Returns the underlying pointer.
      Whether the pointer is decorated depends on the value of [code]#DecorateAddress#.

a@
[source]
----
__unspecified__* get_decorated() const
----
   a@ Returns the underlying pointer decorated by the address space that it addresses.
      Note that the support involves implementation-defined device compiler extensions.

a@
[source]
----
std::add_pointer_t<value_type> get_raw() const
----
   a@ Returns the underlying pointer, always undecorated.

a@
[source]
----
void prefetch(size_t numElements) const
----
   a@ Available only when: [code]#Space == access::address_space::global_space#.

Prefetches a number of elements specified by [code]#numElements# into
the <<global-memory>> cache. This operation is an implementation-defined
optimization and does not effect the functional  behavior of the SYCL
kernel function.

|====



[[table.multipointer.hiddenfriendfunctions]]
.Hidden friend functions of the [code]#multi_ptr# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Hidden friend function @ Description
a@
[source]
----
reference operator*(const multi_ptr& mp)
----
   a@ Available only when: [code]#(!std::is_void_v<ElementType>)#.

Operator that returns a reference to the [code]#value_type#
of [code]#mp#.

a@
[source]
----
multi_ptr& operator++(multi_ptr& mp)
----
   a@ Available only when: [code]#(!std::is_void_v<ElementType>)#.

Increments [code]#mp# by [code]#1# and returns  [code]#mp#.

a@
[source]
----
multi_ptr operator++(multi_ptr& mp, int)
----
   a@ Available only when: [code]#(!std::is_void_v<ElementType>)#.

Increments [code]#mp# by [code]#1# and returns a new [code]#multi_ptr#
with the value of the original [code]#mp#.

a@
[source]
----
multi_ptr& operator--(multi_ptr& mp)
----
   a@ Available only when: [code]#(!std::is_void_v<ElementType>)#.

Decrements [code]#mp# by [code]#1# and returns [code]#mp#.

a@
[source]
----
multi_ptr operator--(multi_ptr& mp, int)
----
   a@ Available only when: [code]#(!std::is_void_v<ElementType>)#.

Decrements [code]#mp# by [code]#1# and returns a new [code]#multi_ptr#
with the value of the original [code]#mp#.

a@
[source]
----
multi_ptr& operator+=(multi_ptr& lhs, difference_type r)
----
   a@ Available only when: [code]#(!std::is_void_v<ElementType>)#.

Moves [code]#mp# forward by [code]#r# and returns  [code]#lhs#.

a@
[source]
----
multi_ptr& operator-=(multi_ptr& lhs, difference_type r)
----
   a@ Available only when: [code]#(!std::is_void_v<ElementType>)#.

Moves [code]#mp# backward by [code]#r# and returns  [code]#lhs#.

a@
[source]
----
multi_ptr operator+(const multi_ptr& lhs, difference_type r)
----
   a@ Available only when: [code]#(!std::is_void_v<ElementType>)#.

Creates a new [code]#multi_ptr# that points [code]#r# forward
compared to [code]#lhs#.

a@
[source]
----
multi_ptr operator-(const multi_ptr& lhs, difference_type r)
----
   a@ Available only when: [code]#(!std::is_void_v<ElementType>)#.

Creates a new [code]#multi_ptr# that points [code]#r# backward
compared to [code]#lhs#.

a@
[source]
----
bool operator==(const multi_ptr& lhs, const multi_ptr& rhs)
----
   a@ Comparison operator [code]#==# for [code]#multi_ptr# class.

a@
[source]
----
bool operator!=(const multi_ptr& lhs, const multi_ptr& rhs)
----
   a@ Comparison operator [code]#!=# for [code]#multi_ptr# class.

a@
[source]
----
bool operator<(const multi_ptr& lhs, const multi_ptr& rhs)
----
   a@ Comparison operator [code]#<# for [code]#multi_ptr# class.

a@
[source]
----
bool operator>(const multi_ptr& lhs, const multi_ptr& rhs)
----
   a@ Comparison operator [code]#># for [code]#multi_ptr# class.

a@
[source]
----
bool operator<=(const multi_ptr& lhs, const multi_ptr& rhs)
----
   a@ Comparison operator [code]#+<=+# for [code]#multi_ptr# class.

a@
[source]
----
bool operator>=(const multi_ptr& lhs, const multi_ptr& rhs)
----
   a@ Comparison operator [code]#>=# for [code]#multi_ptr# class.

a@
[source]
----
bool operator==(const multi_ptr& lhs, std::nullptr_t)
----
   a@ Comparison operator [code]#==# for [code]#multi_ptr# class with a
      [code]#std::nullptr_t#.

a@
[source]
----
bool operator!=(const multi_ptr& lhs, std::nullptr_t)
----
   a@ Comparison operator [code]#!=# for [code]#multi_ptr# class with a
      [code]#std::nullptr_t#.

a@
[source]
----
bool operator<(const multi_ptr& lhs, std::nullptr_t)
----
   a@ Comparison operator [code]#<# for [code]#multi_ptr# class with a
      [code]#std::nullptr_t#.

a@
[source]
----
bool operator>(const multi_ptr& lhs, std::nullptr_t)
----
   a@ Comparison operator [code]#># for [code]#multi_ptr# class with a
      [code]#std::nullptr_t#.

a@
[source]
----
bool operator<=(const multi_ptr& lhs, std::nullptr_t)
----
   a@ Comparison operator [code]#+<=+# for [code]#multi_ptr# class with a
      [code]#std::nullptr_t#.

a@
[source]
----
bool operator>=(const multi_ptr& lhs, std::nullptr_t)
----
   a@ Comparison operator [code]#>=# for [code]#multi_ptr# class with a
      [code]#std::nullptr_t#.

a@
[source]
----
bool operator==(std::nullptr_t, const multi_ptr& rhs)
----
   a@ Comparison operator [code]#==# for [code]#multi_ptr# class with a
      [code]#std::nullptr_t#.

a@
[source]
----
bool operator!=(std::nullptr_t, const multi_ptr& rhs)
----
   a@ Comparison operator [code]#!=# for [code]#multi_ptr# class with a
      [code]#std::nullptr_t#.

a@
[source]
----
bool operator<(std::nullptr_t, const multi_ptr& rhs)
----
   a@ Comparison operator [code]#<# for [code]#multi_ptr# class with a
      [code]#std::nullptr_t#.

a@
[source]
----
bool operator>(std::nullptr_t, const multi_ptr& rhs)
----
   a@ Comparison operator [code]#># for [code]#multi_ptr# class with a
      [code]#std::nullptr_t#.

a@
[source]
----
bool operator<=(std::nullptr_t, const multi_ptr& rhs)
----
   a@ Comparison operator [code]#+<=+# for [code]#multi_ptr# class with a
      [code]#std::nullptr_t#.

a@
[source]
----
bool operator>=(std::nullptr_t, const multi_ptr& rhs)
----
   a@ Comparison operator [code]#>=# for [code]#multi_ptr# class with a
      [code]#std::nullptr_t#.

|====


The following is the overview of the legacy interface from 1.2.1 provided for
the [code]#multi_ptr# class.

[source,,linenums]
----
include::{header_dir}/multipointerlegacy.h[lines=4..-1]
----


[[sec:pointerclasses]]
==== Explicit pointer aliases

SYCL provides aliases to the [code]#multi_ptr# class template (see
<<sec:multiptr>>) for each specialization of [code]#access::address_space#.

A synopsis of the SYCL [code]#multi_ptr# class template aliases is provided
below.

// Interface of the explicit pointer classes
[source,,linenums]
----
include::{header_dir}/pointer.h[lines=4..-1]
----


[[subsec:samplers]]
=== Image samplers

The SYCL [code]#image_sampler# struct contains a configuration for sampling a
[code]#sampled_image#.
The members of this struct are defined by the following tables.

// Interface of the sampler class
[source,,linenums]
----
include::{header_dir}/imageSampler.h[lines=4..-1]
----


[[table.addressing.mode.sampler]]
.Addressing modes description
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ addressing_mode @ Description
a@
[source]
----
mirrored_repeat
----
   a@ Out of range coordinates will be flipped at every integer junction. This addressing mode
      can only be used with normalized coordinates. If normalized coordinates are not used, this
      addressing mode may generate image coordinates that are undefined.

a@
[source]
----
repeat
----
   a@ Out of range image coordinates are wrapped to the valid range. This addressing mode can only
      be used with normalized coordinates. If normalized coordinates are not used, this
      addressing mode may generate image coordinates that are undefined.

a@
[source]
----
clamp_to_edge
----
   a@ Out of range image coordinates are clamped to the extent.

a@
[source]
----
clamp
----
   a@ Out of range image coordinates will return a border color.

a@
[source]
----
none
----
   a@ For this addressing mode the programmer guarantees that the image coordinates used to
      sample elements of the image refer to a location inside the image; otherwise the results are
      undefined.

|====



[[table.filtering.mode.sampler]]
.Filtering modes description
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ filtering_mode @ Description
a@
[source]
----
nearest
----
   a@ Chooses a color of nearest pixel.

a@
[source]
----
linear
----
   a@ Performs a linear sampling of adjacent pixels.

|====



[[table.normalization.mode.sampler]]
.Coordinate normalization modes description
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ coordinate_normalization_mode @ Description
a@
[source]
----
normalized
----
   a@ Normalizes image coordinates.

a@
[source]
----
unnormalized
----
   a@ Does not normalize image coordinates.

|====


// \input{usm}

// %%%%%%%%%%%%%%%%%%%%%%%%%%%% begin usm %%%%%%%%%%%%%%%%%%%%%%%%%%%%

[[sec:usm]]
== Unified shared memory (USM)

This section describes properties and routines for pointer-based memory
management interfaces in SYCL.
These routines augment, rather than replace, the buffer-based interfaces in
SYCL.

Unified Shared Memory (<<usm>>) provides a pointer-based alternative to the
buffer programming model.
USM enables:

  * Easier integration into existing code bases by representing allocations as
    pointers rather than buffers, with full support for pointer arithmetic into
    allocations.
  * Fine-grain control over ownership and accessibility of allocations, to
    optimally choose between performance and programmer convenience.
  * A simpler programming model, by automatically migrating some allocations
    between SYCL devices and the host.

To show the differences with the example from <<sec:anatomy>>, the following
source code example shows how shared memory can be used between host and device:

[source,,linenums]
----
include::{code_dir}/usm_shared.cpp[lines=4..-1]
----

By comparison, the following source code example uses less capable device
memory, which requires an explicit copy between the device and the host:
[source,,linenums]
----
include::{code_dir}/usm_device.cpp[lines=4..-1]
----


=== Unified addressing

Unified Addressing guarantees that all devices will use a unified address space.
Pointer values in the unified address space will always refer to the same
location in memory.
The unified address space encompasses the host and one or more devices.
Note that this does not require addresses in the unified address space to be
accessible on all devices, just that pointer values will be consistent.


=== Kinds of unified shared memory

<<usm>> is a capability that, when available, provides the ability to create
allocations that are visible to both host and device(s).
USM builds upon Unified Addressing to define a shared address space where
pointer values in this space always refer to the same location in memory.
USM defines three types of memory allocations described in
<<table.USM.allocation>>.

[[table.USM.allocation]]
.Type of USM allocations
[width="100%",options="header",cols="20%,80%"]
|====
| USM allocation type | Description
| [code]#host#
    | Allocations in host memory that are accessible by a device
| [code]#device#
    | Allocations in device memory that are *not* accessible by the host
| [code]#shared#
    | Allocations in shared memory that are accessible by both host and
      device
|====

The following [code]#enum# is used to refer to the different types of
allocations inside of a SYCL program:

[source,,linenums]
----
namespace sycl {
namespace usm {

enum class alloc : /* unspecified */ {
  host,
  device,
  shared,
  unknown
};

}
}
----

USM is an optional feature which may not be supported by all devices, and
devices that support USM may not support all types of USM allocation.
A SYCL application can use the [code]#device::has()# function to determine the
level of USM support for a device.
See <<sec:device-aspects>> for more details.

The characteristics of USM allocations are summarized in
<<table.USM.allocation.characteristics>>.

[[table.USM.allocation.characteristics]]
.Characteristics of the different kinds of USM allocation
[width="100%",options="header",cols="16%,16%,16%,16%,16%,16%"]
|====
| Allocation Type | Initial Location | Accessible By | | Migratable To |
.3+| [code]#device# .3+| [code]#device# | [code]#host#      | No            | [code]#host#          | No
|                                         [code]#device#    | Yes           | [code]#device#        | N/A
|                                 Another [code]#device#    | Optional (P2P)| Another [code]#device#| No

.2+| [code]#host#    .2+| [code]#host#  | [code]#host#      | Yes           | [code]#host#          | N/A
|                                     Any [code]#device#    | Yes           | [code]#device#        | No

.3+| [code]#shared#  .3+| Unspecified   | [code]#host#      | Yes           | [code]#host#          | Yes
|                                         [code]#device#    | Yes           | [code]#device#        | Yes
|                                 Another [code]#device#    | Optional  | Another [code]#device#| Optional
|====

Each USM allocation has an associated SYCL <<context>>, and any access to that
memory must use the same context.
Specifically, any <<sycl-kernel-function>> that dereferences a pointer to a USM
allocation must be submitted to a <<queue>> that was constructed with the same
context that was used to allocate that memory.
The explicit memory operation <<command, commands>> that take USM pointers have
a similar restriction.
(See <<subsec:explicitmemory>> for details.)
Violations of these requirements result in undefined behavior.

[NOTE]
====
There are no similar restrictions for dereferencing a USM pointer in a
<<host-task>>.
This is legal regardless of which <<queue>> the host task was submitted to so
long as the USM pointer is accessible on the host.
====

Each type of USM allocation has different rules for where that memory is
accessible.
Attempting to dereference a USM pointer on the host or on a device in violation
of these rules results in undefined behavior.
Passing a USM pointer to one of the explicit memory functions where the pointer
is not accessible to the device generally results in undefined behavior.
See <<subsec:explicitmemory>> for the exact rules.

Device allocations are used for explicitly managing device memory.
Programmers directly allocate device memory and explicitly copy data between
host memory and a device allocation.
Device allocations are obtained through SYCL device USM allocation routines
instead of system allocation routines like [code]#std::malloc# or {cpp}
[code]#new#.
Device allocations are not accessible on the host, but the pointer values remain
consistent on account of Unified Addressing.
The size of device allocations will be limited by the amount of memory in a
device.
Support for device allocations on a specific device can be queried through
[code]#aspect::usm_device_allocations#.

Device allocations must be explicitly copied between the host and a device.
The member functions to copy and initialize data are found in
<<sec:queue-shortcuts>> and <<table.members.handler.copy>>, and these functions
may be used on device allocations if a device supports
[code]#aspect::usm_device_allocations#.

Host allocations allow devices to directly read and write host memory inside of
a kernel.
This can be useful for several reasons, such as when the overhead of moving a
small amount of data is not worth paying over the cost of a remote access or
when the size of a data set exceeds the size of a device's memory.
Host allocations must also be obtained using SYCL routines instead of system
allocation routines.
While a device may remotely read and write a host allocation, the allocation
does not migrate to the device -
it remains in host memory.
Users should take care to properly synchronize access to host allocations
between host execution and kernels.
The total size of host allocations will be limited by the amount of
pinnable-memory on the host on most systems.
Support for host allocations on a specific device can be queried through
[code]#aspect::usm_host_allocations#.
Support for atomic modification of host allocations on a specific device can be
queried through [code]#aspect::usm_atomic_host_allocations#.

Shared allocations implicitly share data between the host and devices.
Data may move to where it is being used without the programmer explicitly
informing the runtime.
It is up to the runtime and backends to make sure that a shared allocation is
available where it is used.
Shared allocations must also be obtained using SYCL allocation routines instead
of the system allocator.
The maximum size of a shared allocation on a specific device, and the total size
of all shared allocations in a context, are implementation-defined.
Support for shared allocations on a specific device can be queried through
[code]#aspect::usm_shared_allocations#.

Not all devices may support concurrent access of a shared allocation with the
host.
If a device does not support this, host execution and device code must take
turns accessing the allocation, so the host must not access a shared allocation
while a kernel is executing.
Host access to a shared allocation which is also accessed by an executing kernel
on a device that does not support concurrent access results in undefined
behavior.
If a device does support concurrent access, both the host and and the device may
atomically modify the same data inside an allocation.
Allocations, or pieces of allocations, are now free to migrate to different
devices in the same context that also support this capability.
Additionally, many devices that support concurrent access may support a working
set of shared allocations larger than device memory.
Users may query whether a device supports concurrent access with atomic
modification of shared allocations through the aspect
[code]#aspect::usm_atomic_shared_allocations#.
See <<sec:device-aspects>> for more details.

Performance hints for shared allocations may be specified by the user by
enqueuing [code]#prefetch# operations on a device.
These operations inform the SYCL runtime that the specified shared allocation is
likely to be accessed on the device in the future, and that it is free to
migrate the allocation to the device.
More about [code]#prefetch# is found in <<sec:queue-shortcuts>> and
<<table.members.handler.copy>>.
If a device supports concurrent access to shared allocations, then
[code]#prefetch# operations may be overlapped with kernel execution.

Additionally, users may use the [code]#mem_advise# member function to annotate
shared allocations with [code]#advice#.
Valid [code]#advice# is defined by the device and its associated backend.
See <<sec:queue-shortcuts>> and <<table.members.handler.copy>> for more
information.

In the most capable systems, users do not need to use SYCL USM allocation
functions to create shared allocations.
The system allocator ([code]#malloc#/[code]#new#) may instead be used.
Likewise, [code]#std::free# and [code]#delete# are used instead of
[code]#sycl::free#.
Note that host and device allocations are unaffected by this change and must
still be allocated using their respective USM functions in order to guarantee
their behavior.
Users may query the device to determine if system allocations are supported for
use on the device, through [code]#aspect::usm_system_allocations#.


=== USM allocations

USM provides several allocation functions.
These functions accept a [code]#property_list# parameter, which is provided for
future extensibility.
The <<core-spec>> does not yet define any USM allocation properties.

Some of the allocation functions take an explicit alignment parameter.
Like [code]#std::aligned_alloc#, these functions return [code]#nullptr# if the
alignment is not supported by the implementation.
Some of the allocation functions are templated on the allocated type [code]#T#
and some are not.
The following table specifies the alignment guarantees for each category.

[[table.usm.alignment]]
.Alignment guarantees of USM allocation functions
[width="100%",options="header",separator="@",cols="45%,55%"]
|====
@ Category @ Alignment guarantee
a@ No alignment parameter +
   Not templated on allocation type
a@ Pointer is suitably aligned for any object with fundamental alignment whose
   size is less than or equal to the requested allocation size.

a@ No alignment parameter +
   Templated on allocation type [code]#T#
a@ Pointer is suitably aligned for an object of type [code]#T#.

a@ Alignment parameter [code]#alignment# specified +
   Not templated on allocation type
a@ Pointer is suitably aligned for any object with fundamental alignment whose
   size is less than or equal to the requested allocation size or it is aligned
   to the specified [code]#alignment#, whichever is greater.

a@ Alignment parameter [code]#alignment# specified +
   Templated on allocation type [code]#T#
a@ Pointer is suitably aligned for an object of type [code]#T# or it is aligned
   to the specified [code]#alignment#, whichever is greater.
|====

==== {cpp} allocator interface

SYCL defines an allocator class named [code]#usm_allocator# that satisfies the
{cpp} named requirement [code]#Allocator#.
The [code]#AllocKind# template parameter can be either [code]#usm::alloc::host#
or [code]#usm::alloc::shared#, causing the allocator to make either host USM
allocations or shared USM allocations.

[NOTE]
====
There is no specialization for [code]#usm::alloc::device# because an
[code]#Allocator# is required to allocate memory that is accessible on the host.
====

The [code]#usm_allocator# class has a template argument [code]#Alignment#, which
specifies the minimum alignment for memory that it allocates.
This alignment is used even if the allocator is rebound to a different type.
Memory allocated by this allocator is suitably aligned for objects of its
underlying [code]#value_type# or at the alignment specified by
[code]#Alignment#, whichever is greater.

A synopsis of the [code]#usm_allocator# class is provided below.
The constructors are listed in <<table.constructors.usm-allocator>>.

[source,,linenums]
----
template <typename T, usm::alloc AllocKind, size_t Alignment = 0>
class usm_allocator {
public:
  using value_type = T;
  using propagate_on_container_copy_assignment = std::true_type;
  using propagate_on_container_move_assignment = std::true_type;
  using propagate_on_container_swap = std::true_type;

public:
  template <typename U> struct rebind {
    typedef usm_allocator<U, AllocKind, Alignment> other;
  };

  usm_allocator() = delete;
  usm_allocator(const context& syclContext,
                const device& syclDevice,
                const property_list& propList = {});
  usm_allocator(const queue& syclQueue,
                const property_list& propList = {});
  usm_allocator(const usm_allocator& other);
  usm_allocator(usm_allocator&&) noexcept;
  usm_allocator& operator=(const usm_allocator&);
  usm_allocator& operator=(usm_allocator&&);

  template <class U>
  usm_allocator(usm_allocator<U, AllocKind, Alignment> const&) noexcept;

  /// Allocate memory
  T* allocate(size_t count);

  /// Deallocate memory
  void deallocate(T* Ptr, size_t count);

  /// Equality Comparison
  ///
  /// Allocators only compare equal if they are of the same USM kind, alignment,
  /// context, and device
  template <class U, usm::alloc AllocKindU, size_t AlignmentU>
  friend bool operator==(const usm_allocator<T, AllocKind, Alignment>&,
                         const usm_allocator<U, AllocKindU, AlignmentU>&);

  /// Inequality Comparison
  /// Allocators only compare unequal if they are not of the same USM kind, alignment,
  /// context, or device
  template <class U, usm::alloc AllocKindU, size_t AlignmentU>
  friend bool operator!=(const usm_allocator<T, AllocKind, Alignment>&,
                         const usm_allocator<U, AllocKindU, AlignmentU>&);
};
----

[[table.constructors.usm-allocator]]
.Constructors of the [code]#usm_allocator# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
usm_allocator(const context& syclContext, const device& syclDevice,
              const property_list& propList = {})
----
a@ Constructs a [code]#usm_allocator# instance that allocates USM for the
provided context and device.

If [code]#AllocKind# is [code]#usm::alloc::host#, this constructor throws a
synchronous [code]#exception# with the [code]#errc::feature_not_supported#
error code if no device in [code]#syclContext# has
[code]#aspect::usm_host_allocations#.  The [code]#syclDevice# is ignored for
this allocation kind.

If [code]#AllocKind# is [code]#usm::alloc::shared#, this constructor throws a
synchronous [code]#exception# with the [code]#errc::feature_not_supported#
error code if the [code]#syclDevice# does not have
[code]#aspect::usm_shared_allocations#.  The [code]#syclDevice# must either be
contained by [code]#syclContext# or it must be a <<descendent-device>> of some
device that is contained by that context, otherwise this constructor throws a
synchronous [code]#exception# with the [code]#errc::invalid# error code.

a@
[source]
----
usm_allocator(const queue& syclQueue, const property_list& propList = {})
----
a@ Simplified constructor form where [code]#syclQueue# provides the
[code]#device# and [code]#context#.

|====

==== Device allocation functions

The functions in <<table.usm.device.allocs>> allocate device USM.
On success, these functions return a pointer to the newly allocated memory,
which must eventually be deallocated with [code]#sycl::free# in order to avoid a
memory leak.
If there are not enough resources to allocate the requested memory, these
functions return [code]#nullptr#.

When the allocation size is zero bytes ([code]#numBytes# or [code]#count# is
zero), these functions behave in a manner consistent with {cpp}
[code]#std::malloc#.
The value returned is unspecified in this case, and the returned pointer may not
be used to access storage.
If this pointer is not null, it must be passed to [code]#sycl::free# to avoid a
memory leak.

[[table.usm.device.allocs]]
.Device USM Allocation Functions
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Function @ Description
a@
[source]
----
void* sycl::malloc_device(size_t numBytes, const device& syclDevice,
                          const context& syclContext,
                          const property_list& propList = {})
----
a@ Returns a pointer to the newly allocated memory, which is allocated on
[code]#syclDevice#.  The allocation size is specified in bytes.  Throws a
synchronous [code]#exception# with the [code]#errc::feature_not_supported#
error code if the [code]#syclDevice# does not have
[code]#aspect::usm_device_allocations#.  The [code]#syclDevice# must either be
contained by [code]#syclContext# or it must be a <<descendent-device>> of some
device that is contained by that context, otherwise this function throws a
synchronous [code]#exception# with the [code]#errc::invalid# error code.

a@
[source]
----
template <typename T>
T* sycl::malloc_device(size_t count, const device& syclDevice,
                       const context& syclContext,
                       const property_list& propList = {})
----
a@  Returns a pointer to the newly allocated memory, which is allocated on
[code]#syclDevice#.  The allocation size is specified in number of elements of
type [code]#T#.  Throws a synchronous [code]#exception# with the
[code]#errc::feature_not_supported# error code if the [code]#syclDevice#
does not have [code]#aspect::usm_device_allocations#.  The [code]#syclDevice#
must either be contained by [code]#syclContext# or it must be a
<<descendent-device>> of some device that is contained by that context,
otherwise this function throws a synchronous [code]#exception# with the
[code]#errc::invalid# error code.

a@
[source]
----
void* sycl::malloc_device(size_t numBytes, const queue& syclQueue,
                          const property_list& propList = {})
----
a@ Simplified form where [code]#syclQueue# provides the [code]#device# and
[code]#context#.

a@
[source]
----
template <typename T>
T* sycl::malloc_device(size_t count, const queue& syclQueue,
                       const property_list& propList = {})
----
a@ Simplified form where [code]#syclQueue# provides the [code]#device# and
[code]#context#.

a@
[source]
----
void* sycl::aligned_alloc_device(size_t alignment, size_t numBytes,
                                 const device& syclDevice,
                                 const context& syclContext,
                                 const property_list& propList = {})
----
a@ Returns a pointer to the newly allocated memory, which is allocated on
[code]#syclDevice#.  The allocation is specified in bytes and aligned according
to [code]#alignment#.  Throws a synchronous [code]#exception# with the
[code]#errc::feature_not_supported# error code if the [code]#syclDevice# does
not have [code]#aspect::usm_device_allocations#.  The [code]#syclDevice# must
either be contained by [code]#syclContext# or it must be a
<<descendent-device>> of some device that is contained by that context,
otherwise this function throws a synchronous [code]#exception# with the
[code]#errc::invalid# error code.

a@
[source]
----
template <typename T>
T* sycl::aligned_alloc_device(size_t alignment, size_t count,
                              const device& syclDevice,
                              const context& syclContext,
                              const property_list& propList = {})
----
a@ Returns a pointer to the newly allocated memory, which is allocated on
[code]#syclDevice#.  The allocation is specified in number of elements of type
[code]#T# and aligned according to [code]#alignment#.  Throws a synchronous
[code]#exception# with the [code]#errc::feature_not_supported# error code if
the [code]#syclDevice# does not have [code]#aspect::usm_device_allocations#.
The [code]#syclDevice# must either be contained by [code]#syclContext# or it
must be a <<descendent-device>> of some device that is contained by that
context, otherwise this function throws a synchronous [code]#exception# with
the [code]#errc::invalid# error code.

a@
[source]
----
void* sycl::aligned_alloc_device(size_t alignment, size_t numBytes,
                                 const queue& syclQueue,
                                 const property_list& propList = {})
----
a@ Simplified form where [code]#syclQueue# provides the [code]#device# and
[code]#context#.

a@
[source]
----
template <typename T>
T* sycl::aligned_alloc_device(size_t alignment, size_t count,
                              const queue& syclQueue,
                              const property_list& propList = {})
----
a@ Simplified form where [code]#syclQueue# provides the [code]#device# and
[code]#context#.

|====

==== Host allocation functions

The functions in <<table.usm.host.allocs>> allocate host USM.
On success, these functions return a pointer to the newly allocated memory,
which must eventually be deallocated with [code]#sycl::free# in order to avoid a
memory leak.
If there are not enough resources to allocate the requested memory, these
functions return [code]#nullptr#.

When the allocation size is zero bytes ([code]#numBytes# or [code]#count# is
zero), these functions behave in a manner consistent with {cpp}
[code]#std::malloc#.
The value returned is unspecified in this case, and the returned pointer may not
be used to access storage.
If this pointer is not null, it must be passed to [code]#sycl::free# to avoid a
memory leak.

[[table.usm.host.allocs]]
.Host USM Allocation Functions
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Function @ Description
a@
[source]
----
void* sycl::malloc_host(size_t numBytes, const context& syclContext,
                        const property_list& propList = {})
----
a@ Returns a pointer to the newly allocated memory.  This allocation is
specified in bytes.  Throws a synchronous [code]#exception# with the
[code]#errc::feature_not_supported# error code if no device in
[code]#syclContext# has [code]#aspect::usm_host_allocations#.

a@
[source]
----
template <typename T>
T* sycl::malloc_host(size_t count, const context& syclContext,
                     const property_list& propList = {})
----
a@ Returns a pointer to the newly allocated memory.  This allocation is
specified in number of elements of type [code]#T#.  Throws a synchronous
[code]#exception# with the [code]#errc::feature_not_supported# error code if no
device in [code]#syclContext# has [code]#aspect::usm_host_allocations#.

a@
[source]
----
void* sycl::malloc_host(size_t numBytes, const queue& syclQueue,
                        const property_list& propList = {})
----
a@ Simplified form where [code]#syclQueue# provides the [code]#context#.

a@
[source]
----
template <typename T>
T* sycl::malloc_host(size_t count, const queue& syclQueue,
                     const property_list& propList = {})
----
a@ Simplified form where [code]#syclQueue# provides the [code]#context#.

a@
[source]
----
void* sycl::aligned_alloc_host(size_t alignment, size_t numBytes,
                               const context& syclContext,
                               const property_list& propList = {})
----
a@ Returns a pointer to the newly allocated memory.  This allocation is
specified in bytes and aligned according to [code]#alignment#.  Throws a
synchronous [code]#exception# with the [code]#errc::feature_not_supported#
error code if no device in [code]#syclContext# has
[code]#aspect::usm_host_allocations#.

a@
[source]
----
template <typename T>
T* sycl::aligned_alloc_host(size_t alignment, size_t count,
                            const context& syclContext,
                            const property_list& propList = {})
----
a@ Returns a pointer to the newly allocated memory.  This allocation is
specified in elements of type [code]#T# and aligned according to
[code]#alignment#.  Throws a synchronous [code]#exception# with the
[code]#errc::feature_not_supported# error code if no device in
[code]#syclContext# has [code]#aspect::usm_host_allocations#.

a@
[source]
----
void* sycl::aligned_alloc_host(size_t alignment, size_t numBytes,
                               const queue& syclQueue,
                               const property_list& propList = {})
----
a@ Simplified form where [code]#syclQueue# provides the [code]#context#.

a@
[source]
----
template <typename T>
T* sycl::aligned_alloc_host(size_t alignment, size_t count,
                               const queue& syclQueue,
                               const property_list& propList = {})
----
a@ Simplified form where [code]#syclQueue# provides the [code]#context#.

|====

==== Shared allocation functions

The functions in <<table.usm.shared.allocs>> allocate shared USM.
On success, these functions return a pointer to the newly allocated memory,
which must eventually be deallocated with [code]#sycl::free# in order to avoid a
memory leak.
If there are not enough resources to allocate the requested memory, these
functions return [code]#nullptr#.

When the allocation size is zero bytes ([code]#numBytes# or [code]#count# is
zero), these functions behave in a manner consistent with {cpp}
[code]#std::malloc#.
The value returned is unspecified in this case, and the returned pointer may not
be used to access storage.
If this pointer is not null, it must be passed to [code]#sycl::free# to avoid a
memory leak.

[[table.usm.shared.allocs]]
.Shared USM Allocation Functions
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Function @ Description
a@
[source]
----
void* sycl::malloc_shared(size_t numBytes, const device& syclDevice,
                          const context& syclContext,
                          const property_list& propList = {})
----
a@ Returns a pointer to the newly allocated memory, which is associated with
[code]#syclDevice#.  This allocation is specified in bytes.  Throws a
synchronous [code]#exception# with the [code]#errc::feature_not_supported#
error code if the [code]#syclDevice# does not have
[code]#aspect::usm_shared_allocations#.  The [code]#syclDevice# must either be
contained by [code]#syclContext# or it must be a <<descendent-device>> of some
device that is contained by that context, otherwise this function throws a
synchronous [code]#exception# with the [code]#errc::invalid# error code.

a@
[source]
----
template <typename T>
T* sycl::malloc_shared(size_t count, const device& syclDevice,
                       const context& syclContext,
                       const property_list& propList = {})
----
a@ Returns a pointer to the newly allocated memory, which is associated with
[code]#syclDevice#.  This allocation is specified in number of elements of
type [code]#T#.  Throws a synchronous [code]#exception# with the
[code]#errc::feature_not_supported# error code if the [code]#syclDevice# does
not have [code]#aspect::usm_shared_allocations#.  The [code]#syclDevice# must
either be contained by [code]#syclContext# or it must be a
<<descendent-device>> of some device that is contained by that context,
otherwise this function throws a synchronous [code]#exception# with the
[code]#errc::invalid# error code.

a@
[source]
----
void* sycl::malloc_shared(size_t numBytes, const queue& syclQueue,
                          const property_list& propList = {})
----
a@ Simplified form where [code]#syclQueue# provides the [code]#device# and
[code]#context#.

a@
[source]
----
template <typename T>
T* sycl::malloc_shared(size_t count, const queue& syclQueue,
                       const property_list& propList = {})
----
a@ Simplified form where [code]#syclQueue# provides the [code]#device# and
[code]#context#.

a@
[source]
----
void* sycl::aligned_alloc_shared(size_t alignment, size_t numBytes,
                                 const device& syclDevice,
                                 const context& syclContext,
                                 const property_list& propList = {})
----
a@ Returns a pointer to the newly allocated memory, which is associated with
[code]#syclDevice#.  This allocation is specified in bytes and aligned
according to [code]#alignment#.  Throws a synchronous [code]#exception# with
the [code]#errc::feature_not_supported# error code if the [code]#syclDevice#
does not have [code]#aspect::usm_shared_allocations#.  The [code]#syclDevice#
must either be contained by [code]#syclContext# or it must be a
<<descendent-device>> of some device that is contained by that context,
otherwise this function throws a synchronous [code]#exception# with the
[code]#errc::invalid# error code.

a@
[source]
----
template <typename T>
T* sycl::aligned_alloc_shared(size_t alignment, size_t count,
                              const device& syclDevice,
                              const context& syclContext,
                              const property_list& propList = {})
----
a@ Returns a pointer to the newly allocated memory, which is associated with
[code]#syclDevice#.  This allocation is specified in number of elements of
type [code]#T# and aligned aligned according to [code]#alignment#.  Throws a
synchronous [code]#exception# with the [code]#errc::feature_not_supported#
error code if the [code]#syclDevice# does not have
[code]#aspect::usm_shared_allocations#.  The [code]#syclDevice# must either be
contained by [code]#syclContext# or it must be a <<descendent-device>> of some
device that is contained by that context, otherwise this function throws a
synchronous [code]#exception# with the [code]#errc::invalid# error code.

a@
[source]
----
void* sycl::aligned_alloc_shared(size_t alignment, size_t numBytes,
                                 const queue& syclQueue,
                                 const property_list& propList = {})
----
a@ Simplified form where [code]#syclQueue# provides the [code]#device# and
[code]#context#.

a@
[source]
----
template <typename T>
T* sycl::aligned_alloc_shared(size_t alignment, size_t count,
                              const queue& syclQueue,
                              const property_list& propList = {})
----
a@ Simplified form where [code]#syclQueue# provides the [code]#device# and
[code]#context#.

|====

==== Parameterized allocation functions

The functions in <<table.usm.param.allocs>> take a [code]#kind# parameter that
specifies the type of USM to allocate.
When [code]#kind# is [code]#usm::alloc::device#, then the allocation device must
have [code]#aspect::usm_device_allocations#.
When [code]#kind# is [code]#usm::alloc::host#, at least one device in the
allocation context must have [code]#aspect::usm_host_allocations#.
When [code]#kind# is [code]#usm::alloc::shared#, the allocation device must have
[code]#aspect::usm_shared_allocations#.
If these requirements are violated, the allocation function throws a synchronous
[code]#exception# with the [code]#errc::feature_not_supported# error code.

On success, these functions return a pointer to the newly allocated memory,
which must eventually be deallocated with [code]#sycl::free# in order to avoid a
memory leak.
If there are not enough resources to allocate the requested memory, these
functions return [code]#nullptr#.

When the allocation size is zero bytes ([code]#numBytes# or [code]#count# is
zero), these functions behave in a manner consistent with {cpp}
[code]#std::malloc#.
The value returned is unspecified in this case, and the returned pointer may not
be used to access storage.
If this pointer is not null, it must be passed to [code]#sycl::free# to avoid a
memory leak.

[[table.usm.param.allocs]]
.Parameterized USM Allocation Functions
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Function @ Description
a@
[source]
----
void* sycl::malloc(size_t numBytes, const device& syclDevice,
                   const context& syclContext, usm::alloc kind,
                   const property_list& propList = {})
----
a@ Returns a pointer to the newly allocated memory of type [code]#kind#.  This
allocation size is specified in bytes.  The [code]#syclDevice# parameter is
ignored if [code]#kind# is [code]#usm::alloc::host#.  If [code]#kind# is not
[code]#usm::alloc::host#, [code]#syclDevice# must either be contained by
[code]#syclContext# or it must be a <<descendent-device>> of some device that
is contained by that context, otherwise this function throws a synchronous
[code]#exception# with the [code]#errc::invalid# error code.

a@
[source]
----
template <typename T>
T* sycl::malloc(size_t count, const device& syclDevice,
                const context& syclContext, usm::alloc kind,
                const property_list& propList = {})
----
a@ Returns a pointer to the newly allocated memory of type [code]#kind#.  This
allocation size is specified in number of elements of type [code]#T#.  The
[code]#syclDevice# parameter is ignored if [code]#kind# is
[code]#usm::alloc::host#.  If [code]#kind# is not [code]#usm::alloc::host#,
[code]#syclDevice# must either be contained by [code]#syclContext# or it must
be a <<descendent-device>> of some device that is contained by that context,
otherwise this function throws a synchronous [code]#exception# with the
[code]#errc::invalid# error code.

a@
[source]
----
void* sycl::malloc(size_t numBytes, const queue& syclQueue, usm::alloc kind,
                   const property_list& propList = {})
----
a@ Simplified form where [code]#syclQueue# provides the [code]#context# and any
necessary [code]#device#.

a@
[source]
----
template <typename T>
T* sycl::malloc(size_t count, const queue& syclQueue, usm::alloc kind,
                const property_list& propList = {})
----
a@ Simplified form where [code]#syclQueue# provides the [code]#context# and any
necessary [code]#device#.

a@
[source]
----
void* sycl::aligned_alloc(size_t alignment, size_t numBytes,
                          const device& syclDevice, const context& syclContext,
                          usm::alloc kind, const property_list& propList = {})
----
a@ Returns a pointer to the newly allocated memory of type [code]#kind#.  This
allocation is specified in bytes and is aligned according to [code]#alignment#.
The [code]#syclDevice# parameter is ignored if [code]#kind# is
[code]#usm::alloc::host#.  If [code]#kind# is not [code]#usm::alloc::host#,
[code]#syclDevice# must either be contained by [code]#syclContext# or it must
be a <<descendent-device>> of some device that is contained by that context,
otherwise this function throws a synchronous [code]#exception# with the
[code]#errc::invalid# error code.

a@
[source]
----
template <typename T>
T* sycl::aligned_alloc(size_t alignment, size_t count, const device& syclDevice,
                       const context& syclContext, usm::alloc kind,
                       const property_list& propList = {})
----
a@ Returns a pointer to the newly allocated memory of type [code]#kind#.  This
allocation is specified in number of elements of type [code]#T# and is aligned
according to [code]#alignment#.  The [code]#syclDevice# parameter is ignored if
[code]#kind# is [code]#usm::alloc::host#.  If [code]#kind# is not
[code]#usm::alloc::host#, [code]#syclDevice# must either be contained by
[code]#syclContext# or it must be a <<descendent-device>> of some device that
is contained by that context, otherwise this function throws a synchronous
[code]#exception# with the [code]#errc::invalid# error code.

a@
[source]
----
void* sycl::aligned_alloc(size_t alignment, size_t numBytes,
                          const queue& syclQueue, usm::alloc kind,
                          const property_list& propList = {})
----
a@ Simplified form where [code]#syclQueue# provides the [code]#context# and any
necessary [code]#device#.

a@
[source]
----
template <typename T>
T* sycl::aligned_alloc(size_t alignment, size_t count, const queue& syclQueue,
                       usm::alloc kind, const property_list& propList = {})
----
a@ Simplified form where [code]#syclQueue# provides the [code]#context# and any
necessary [code]#device#.

|====


==== Memory deallocation functions

.[apidef]#free#
[source,role=synopsis,id=api:free]
----
void free(void* ptr, const context& ctxt); (1)
void free(void* ptr, const queue& q);      (2)
----

*Overload (1):*

_Preconditions_:

* [code]#ptr# points to memory allocated against [code]#ctxt# using one of the
  USM allocation routines, or is a null pointer;

* [code]#ptr# has not previously been deallocated; and

* There are no in-progress or enqueued <<command, commands>> using the memory
  pointed to by [code]#ptr#.

_Effects_: Causes the memory pointed to by [code]#ptr# to be deallocated.

{note}Whether [code]#free# is blocking or non-blocking is unspecified.
Applications should not rely on [code]#free# for synchronization, nor assume
that [code]#free# cannot cause deadlocks.{endnote}

_Remarks_: If [code]#ptr# is null, this function has no effect.

*Overload (2):*

_Effects_: Equivalent to [code]#return free(ptr, q.get_context());#.

{note}Although this overload accepts a [code]#queue# argument, it does not
submit a "free" <<command>> to the device; the [code]#queue# argument is only
used to determine the [code]#context# associated with [code]#ptr#.{endnote}

=== Unified shared memory pointer queries

Since USM pointers look like raw {cpp} pointers, users cannot deduce what kind
of USM allocation a given pointer may be from examining its type.
However, two functions are defined that let users query the type of a USM
allocation and, if applicable, the [code]#device# on which it was allocated.
These query functions are only supported on the host.

[[table.usm.ptr.query]]
.USM Pointer Query Functions
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Function @ Description
a@
[source]
----
usm::alloc get_pointer_type(const void* ptr, const context& syclContext)
----
a@ Returns the USM allocation type for [code]#ptr# if [code]#ptr# falls inside
a valid USM allocation for the context [code]#syclContext#.  Returns
[code]#usm::alloc::unknown# if [code]#ptr# does not point within a valid USM
allocation from [code]#syclContext#.

a@
[source]
----
device get_pointer_device(const void* ptr, const context& syclContext)
----
a@ Returns the [code]#device# associated with the USM allocation.  If
[code]#ptr# points within a device USM allocation or a shared USM allocation
for the context [code]#syclContext#, returns the same device that was passed
when allocating the memory.  If [code]#ptr# points within a host USM allocation
for the context [code]#syclContext#, returns the first device in
[code]#syclContext#.  Throws a synchronous [code]#exception# with the
[code]#errc::invalid# error code if [code]#ptr# does not point within a valid
USM allocation from [code]#syclContext#.

|====

// %%%%%%%%%%%%%%%%%%%%%%%%%%%% begin expressingParallelism %%%%%%%%%%%%%%%%%%%%%%%%%%%%

[[sec:expr-parall-thro]]
== Expressing parallelism through kernels


[[ranges-identifiers]]
=== Ranges and index space identifiers

The data parallelism of the SYCL kernel execution model requires instantiation
of a parallel execution over a range of iteration space coordinates.
To achieve this, SYCL exposes types to define the range of execution and to
identify a given execution instance's point in the iteration space.

The following types are defined: [code]#range#, [code]#nd_range#, [code]#id#,
[code]#item#, [code]#h_item#, [code]#nd_item# and [code]#group#.

When constructing multi-dimensional ids or ranges from integers, the elements
are written such that the right-most element varies fastest in a linearization
of the multi-dimensional space (see <<sec:multi-dim-linearization>>).


[[table.id.summary]]
.Summary of types used to identify points in an index space, and ranges over which those points can vary
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Type @ Description
a@
[source]
----
id
----
   a@ A point within a range

a@
[source]
----
range
----
   a@ Bounds over which an [code]#id# may vary

a@
[source]
----
item
----
   a@ Pairing of an [code]#id# (specific point) and the
      [code]#range# that it is bounded by

a@
[source]
----
nd_range
----
   a@ Encapsulates both global and local (work-group size)
      [code]#ranges# over which work-item [code]#ids# will
      vary

a@
[source]
----
nd_item
----
   a@ Encapsulates two [code]#items#, one for global
      [code]#id# and [code]#range#, and one for local [code]#id#
      and [code]#range#

a@
[source]
----
h_item
----
   a@ Index point queries within hierarchical parallelism
      ([code]#parallel_for_work_item)#. Encapsulates physical global and
      local [code]#ids# and [code]#ranges#, as well as a
      logical local [code]#id# and [code]#range# defined by hierarchical
      parallelism

a@
[source]
----
group
----
   a@ Work-group queries within hierarchical parallelism
      ([code]#parallel_for_work_group)#, and exposes the
      [code]#parallel_for_work_item# construct that identifies code to be
      executed by each work-item. Encapsulates work-group [code]#ids#
      and [code]#ranges#

|====



[[range-class]]
==== [code]#range# class

[code]#range<int _Dimensions_># is a 1D, 2D or 3D vector that defines the
iteration domain of either a single work-group in a parallel dispatch, or the
overall Dimensions of the dispatch.
It can be constructed from integers.

The SYCL [code]#range# class template provides the common by-value semantics
(see <<sec:byval-semantics>>).

A synopsis of the SYCL [code]#range# class is provided below.
The constructors, member functions and non-member functions of the SYCL
[code]#range# class are listed in <<table.constructors.range>>,
<<table.members.range>> and <<table.functions.range>> respectively.
The additional common special member functions and common member functions are
listed in <<sec:byval-semantics>> in <<table.specialmembers.common.byval>> and
<<table.hiddenfriends.common.byval>> respectively.

[source,,linenums]
----
include::{header_dir}/range.h[lines=4..-1]
----


[[table.constructors.range]]
.Constructors of the [code]#range# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
range()
----
   a@ Construct a SYCL [code]#range# with the value [code]#0# for each dimension.

a@
[source]
----
range(size_t dim0)
----
   a@ Construct a 1D range with value dim0.
      Only valid when the template parameter [code]#Dimensions# is equal
      to 1.

a@
[source]
----
range(size_t dim0, size_t dim1)
----
   a@ Construct a 2D range with values dim0 and dim1.
      Only valid when the template parameter [code]#Dimensions# is equal
      to 2.

a@
[source]
----
range(size_t dim0, size_t dim1, size_t dim2)
----
   a@ Construct a 3D range with values dim0, dim1 and dim2.
      Only valid when the template parameter [code]#Dimensions# is equal
      to 3.

|====



[[table.members.range]]
.Member functions of the [code]#range# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
size_t get(int dimension) const
----
   a@ Return the value of the specified dimension of the
      [code]#range#.

a@
[source]
----
size_t& operator[](int dimension)
----
   a@ Return the l-value of the specified dimension of the
      [code]#range#.

a@
[source]
----
size_t operator[](int dimension) const
----
   a@ Return the value of the specified dimension of the
      [code]#range#.

a@
[source]
----
size_t size() const
----
   a@ Return the size of the range computed as dimension0*...*dimensionN.

|====



[[table.functions.range]]
.Hidden friend functions of the SYCL [code]#range# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Hidden friend function @ Description
a@
[source]
----
range operatorOP(const range& lhs, const range& rhs)
----
   a@ Where [code]#OP# is: [code]#pass:[+]#, [code]#-#, [code]#*#,
      [code]#/#, [code]#%#, [code]#<<#, [code]#>>#,
      [code]#&#, [code]#|#, [code]#^#,
      [code]#&&#, [code]#||#,
      [code]#<#, [code]#>#, [code]#+<=+#,
      [code]#>=#.

Constructs and returns a new instance of the SYCL [code]#range# class
template with the same dimensionality as [code]#lhs# [code]#range#,
where each element of the new SYCL [code]#range# instance is the
result of an element-wise [code]#OP# operator between each element of
[code]#lhs# [code]#range# and each element of the [code]#rhs#
[code]#range#. If the operator returns a [code]#bool#, the result
is the cast to [code]#size_t#.

a@
[source]
----
range operatorOP(const range& lhs, const size_t& rhs)
----
   a@ Where [code]#OP# is: [code]#pass:[+]#, [code]#-#, [code]#*#,
      [code]#/#, [code]#%#, [code]#<<#, [code]#>>#,
      [code]#&#, [code]#|#, [code]#^#,
      [code]#&&#, [code]#||#,
      [code]#<#, [code]#>#, [code]#+<=+#,
      [code]#>=#.

Constructs and returns a new instance of the SYCL [code]#range# class
template with the same dimensionality as [code]#lhs# [code]#range#,
where each element of the new SYCL [code]#range# instance is the result
of an element-wise [code]#OP# operator between each element of this
SYCL [code]#range# and the [code]#rhs# [code]#size_t#. If
the operator returns a [code]#bool#, the result is the cast to
[code]#size_t#.

a@
[source]
----
range& operatorOP(range& lhs, const range& rhs)
----
   a@ Where [code]#OP# is: [code]#pass:[+=]#, [code]#-=#,[code]#*=#, [code]#/=#, [code]#%=#, [code]#+<<=+#, [code]#>>=#, [code]#&=#, [code]#|=#, [code]#^=#.

Assigns each element of [code]#lhs# [code]#range# instance with the
result of an element-wise [code]#OP# operator between each element
of [code]#lhs# [code]#range# and each element of the [code]#rhs#
[code]#range# and returns [code]#lhs# [code]#range#. If the operator returns a [code]#bool#, the result is the cast
to [code]#size_t#.

a@
[source]
----
range& operatorOP(range& lhs, const size_t& rhs)
----
   a@ Where [code]#OP# is: [code]#pass:[+=]#, [code]#-=#,[code]#*=#, [code]#/=#, [code]#%=#, [code]#+<<=+#, [code]#>>=#, [code]#&=#, [code]#|=#, [code]#^=#.

Assigns each element of [code]#lhs# [code]#range# instance with the
result of an element-wise [code]#OP# operator between each element
of [code]#lhs# [code]#range# and the [code]#rhs# [code]#size_t# and returns [code]#lhs# [code]#range#. If the
operator returns a [code]#bool#, the result is the cast to
[code]#size_t#.

a@
[source]
----
range operatorOP(const size_t& lhs, const range& rhs)
----
   a@ Where [code]#OP# is: [code]#pass:[+]#, [code]#-#, [code]#*#,
      [code]#/#, [code]#%#, [code]#<<#, [code]#>>#,
      [code]#&#, [code]#|#, [code]#^#,
      [code]#&&#, [code]#||#,
      [code]#<#, [code]#>#, [code]#+<=+#,
      [code]#>=#.

Constructs and returns a new instance of the SYCL [code]#range# class
template with the same dimensionality as the [code]#rhs# SYCL
[code]#range#, where each element of the new SYCL [code]#range#
instance is the result of an element-wise [code]#OP# operator between
the [code]#lhs# [code]#size_t# and each element of the
[code]#rhs# SYCL [code]#range#. If the operator returns a
[code]#bool#, the result is the cast to [code]#size_t#.

a@
[source]
----
range operatorOP(const range& rhs)
----
   a@ Where [code]#OP# is: unary [code]#pass:[+]#, unary [code]#-#.

Constructs and returns a new instance of the SYCL [code]#range# class
template with the same dimensionality as the [code]#rhs# SYCL
[code]#range#, where each element of the new SYCL [code]#range#
instance is the result of an element-wise [code]#OP# operator on
the [code]#rhs# SYCL [code]#range#.

a@
[source]
----
range& operatorOP(range& rhs)
----
   a@ Where [code]#OP# is: prefix [code]#pass:[++]#, prefix [code]#--#.

Assigns each element of the [code]#rhs# [code]#range# instance with the result
of an element-wise [code]#OP# operator on each element of the [code]#rhs#
[code]#range# and returns this [code]#range#.

a@
[source]
----
range operatorOP(range& lhs, int)
----
   a@ Where [code]#OP# is: postfix [code]#pass:[++]#, postfix [code]#--#.

Make a copy of the [code]#lhs# [code]#range#.
Assigns each element of the [code]#lhs# [code]#range# instance with the result
of an element-wise [code]#OP# operator on each element of the [code]#lhs#
[code]#range#.
Then return the initial copy of the [code]#range#.

|====




[[subsubsec:nd-range-class]]
==== [code]#nd_range# class

// Interface for class: nd_range
[source,,linenums]
----
include::{header_dir}/ndRange.h[lines=4..-1]
----

[code]#nd_range<int _Dimensions_># defines the iteration domain of both the
work-groups and the overall dispatch.
To define this the [code]#nd_range# comprises two ranges: the whole range over
which the kernel is to be executed, and the range of each work group.

The SYCL [code]#nd_range# class template provides the common by-value semantics
(see <<sec:byval-semantics>>).

A synopsis of the SYCL [code]#nd_range# class is provided below.
The constructors and member functions of the SYCL [code]#nd_range# class are
listed in <<table.constructors.ndrange>> and <<table.members.ndrange>>
respectively.
The additional common special member functions and common member functions are
listed in <<sec:byval-semantics>> in <<table.specialmembers.common.byval>> and
<<table.hiddenfriends.common.byval>> respectively.


[[table.constructors.ndrange]]
.Constructors of the [code]#nd_range# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
nd_range<Dimensions>(
range<Dimensions> globalSize,
    range<Dimensions> localSize,
    id<Dimensions> offset = id<Dimensions>())
----
   a@ Construct an [code]#nd_range# from the local and global
      constituent ranges. Supplying the option offset is
      deprecated in SYCL 2020.
      If the offset is not provided it will default to no offset.

|====



[[table.members.ndrange]]
.Member functions for the [code]#nd_range# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
range<Dimensions> get_global_range() const
----
   a@ Return the constituent global range.

a@
[source]
----
range<Dimensions> get_local_range() const
----
   a@ Return the constituent local range.

a@
[source]
----
range<Dimensions> get_group_range() const
----
   a@ Return a range representing the number of groups in each
      dimension.  This range would result from
      [code]#globalSize/localSize# as provided on construction.

a@
[source]
----
id<Dimensions> get_offset() const
    // Deprecated in SYCL 2020.
----
   a@ Deprecated in SYCL 2020.
   Return the constituent offset.

|====



[[id-class]]
==== [code]#id# class

[code]#id<int Dimensions># is a vector of Dimensions that is used to represent
an <<id>> into a global or local [code]#range#.
It can be used as an index in an accessor of the same rank.
The subscript operator ([code]#operator[](n)#) returns the component [code]#n#
as a [code]#size_t#.

The SYCL [code]#id# class template provides the common by-value semantics (see
<<sec:byval-semantics>>).

A synopsis of the SYCL [code]#id# class is provided below.
The constructors, member functions and non-member functions of the SYCL
[code]#id# class are listed in <<table.constructors.id>>, <<table.members.id>>
and <<table.functions.id>> respectively.
The additional common special member functions and common member functions are
listed in <<sec:byval-semantics>> in <<table.specialmembers.common.byval>> and
<<table.hiddenfriends.common.byval>> respectively.

[source,,linenums]
----
include::{header_dir}/id.h[lines=4..-1]
----


[[table.constructors.id]]
.Constructors of the [code]#id# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
id()
----
   a@ Construct a SYCL [code]#id# with the value [code]#0# for each dimension.

a@
[source]
----
id(size_t dim0)
----
   a@ Construct a 1D [code]#id# with value dim0.
      Only valid when the template parameter [code]#Dimensions# is equal
      to 1.

a@
[source]
----
id(size_t dim0, size_t dim1)
----
   a@ Construct a 2D [code]#id# with values dim0, dim1.
      Only valid when the template parameter [code]#Dimensions# is equal
      to 2.

a@
[source]
----
id(size_t dim0, size_t dim1, size_t dim2)
----
   a@ Construct a 3D [code]#id# with values dim0, dim1, dim2.
      Only valid when the template parameter [code]#Dimensions# is equal
      to 3.

a@
[source]
----
id(const range<Dimensions>& range)
----
   a@ Construct an [code]#id# from the dimensions of [code]#range#.

a@
[source]
----
id(const item<Dimensions>& item)
----
   a@ Construct an [code]#id# from [code]#item.get_id()#.

|====



[[table.members.id]]
.Member functions of the [code]#id# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
size_t get(int dimension) const
----
   a@ Return the value of the [code]#id# for dimension
      [code]#Dimension#.

a@
[source]
----
size_t& operator[](int dimension)
----
   a@ Return a reference to the requested dimension of the [code]#id#
      object.

a@
[source]
----
size_t operator[](int dimension) const
----
   a@ Return the value of the requested dimension of the [code]#id#
      object.

a@
[source]
----
operator size_t() const
----
   a@ Available only when: [code]#Dimensions == 1#

Returns the same value as [code]#get(0)#.

|====

[[table.functions.id]]
.Hidden friend functions of the [code]#id# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Hidden friend function @ Description
a@
[source]
----
id operatorOP(const id& lhs, const id& rhs)
----
   a@ Where [code]#OP# is: [code]#pass:[+]#, [code]#-#, [code]#*#, [code]#/#, [code]#%#, [code]#<<#, [code]#>>#,
      [code]#&#, [code]#|#, [code]#^#, [code]#&&#, [code]#||#, [code]#<#, [code]#>#, [code]#+<=+#, [code]#>=#.

Constructs and returns a new instance of the SYCL [code]#id# class
template with the same dimensionality as [code]#lhs# [code]#id#, where
each element of the new SYCL [code]#id# instance is the result of an
element-wise [code]#OP# operator between each element of [code]#lhs#
[code]#id# and each element of the [code]#rhs# [code]#id#.
If the operator returns a [code]#bool# the result is the cast to
[code]#size_t#.

a@
[source]
----
id operatorOP(const id& lhs, const size_t& rhs)
----
   a@ Where [code]#OP# is: [code]#pass:[+]#, [code]#-#, [code]#*#, [code]#/#, [code]#%#, [code]#<<#, [code]#>>#,
      [code]#&#, [code]#|#, [code]#^#, [code]#&&#, [code]#||#, [code]#<#, [code]#>#, [code]#+<=+#, [code]#>=#.

Constructs and returns a new instance of the SYCL [code]#id# class
template with the same dimensionality as [code]#lhs# [code]#id#, where
each element of the new SYCL [code]#id# instance is the result of an
element-wise [code]#OP# operator between each element of [code]#lhs#
[code]#id# and the [code]#rhs# [code]#size_t#. If the
operator returns a [code]#bool# the result is the cast to
[code]#size_t#.

a@
[source]
----
id& operatorOP(id& lhs, const id& rhs)
----
   a@ Where [code]#OP# is: [code]#pass:[+=]#, [code]#-=#,[code]#*=#, [code]#/=#, [code]#%=#,
      [code]#+<<=+#, [code]#>>=#, [code]#&=#, [code]#|=#, [code]#^=#.

Assigns each element of [code]#lhs# [code]#id# instance with the
result of an element-wise [code]#OP# operator between each element
of [code]#lhs# [code]#id# and each element of the [code]#rhs#
[code]#id# and returns [code]#lhs# [code]#id#. If
the operator returns a [code]#bool# the result is the cast to
[code]#size_t#.

a@
[source]
----
id& operatorOP(id& lhs, const size_t& rhs)
----
   a@ Where [code]#OP# is: [code]#pass:[+=]#, [code]#-=#,[code]#*=#, [code]#/=#, [code]#%=#,
      [code]#+<<=+#, [code]#>>=#, [code]#&=#, [code]#|=#, [code]#^=#.

Assigns each element of [code]#lhs# [code]#id# instance with the
result of an element-wise [code]#OP# operator between each element
of [code]#lhs# [code]#id# and the [code]#rhs# [code]#size_t#
and returns [code]#lhs# [code]#id#. If the operator
returns a [code]#bool# the result is the cast to [code]#size_t#.

a@
[source]
----
id operatorOP(const size_t& lhs, const id& rhs)
----
   a@ Where [code]#OP# is: [code]#pass:[+]#, [code]#-#, [code]#*#, [code]#/#, [code]#%#, [code]#<<#, [code]#>>#,
      [code]#&#, [code]#|#, [code]#^#, [code]#&&#, [code]#||#, [code]#<#, [code]#>#, [code]#+<=+#, [code]#>=#.

Constructs and returns a new instance of the SYCL [code]#id# class
template with the same dimensionality as the [code]#rhs# SYCL
[code]#id#, where each element of the new SYCL [code]#id#
instance is the result of an element-wise [code]#OP# operator between
the [code]#lhs# [code]#size_t# and each element of the
[code]#rhs# SYCL [code]#id#. If the operator returns a
[code]#bool# the result is the cast to [code]#size_t#.

a@
[source]
----
id operatorOP(const id& rhs)
----
   a@ Where [code]#OP# is: unary [code]#pass:[+]#, unary [code]#-#.

Constructs and returns a new instance of the SYCL [code]#id# class
template with the same dimensionality as the [code]#rhs# SYCL
[code]#id#, where each element of the new SYCL [code]#id#
instance is the result of an element-wise [code]#OP# operator on
the [code]#rhs# SYCL [code]#id#.

a@
[source]
----
id& operatorOP(id& rhs)
----
   a@ Where [code]#OP# is: prefix [code]#pass:[++]#, prefix [code]#--#.

Assigns each element of the [code]#rhs# [code]#id# instance with the result
of an element-wise [code]#OP# operator on each element of the [code]#rhs#
[code]#id# and returns this [code]#id#.

a@
[source]
----
id operatorOP(id& lhs, int)
----
   a@ Where [code]#OP# is: postfix [code]#pass:[++]#, postfix [code]#--#.

Make a copy of the [code]#lhs# [code]#id#.
Assigns each element of the [code]#lhs# [code]#id# instance with the result
of an element-wise [code]#OP# operator on each element of the [code]#lhs#
[code]#id#.
Then return the initial copy of the [code]#id#.

|====



[[subsec:item.class]]
==== [code]#item# class

<<item>> identifies an instance of the function object executing at each point
in a [code]#range#.
It is passed to a [code]#parallel_for# call or returned by member functions of
[code]#h_item#.
It encapsulates enough information to identify the work-item's range of possible
values and its ID in that range.
It can optionally carry the offset of the range if provided to the
[code]#parallel_for#; note this is deprecated in SYCL 2020.
Instances of the [code]#item# class are not user-constructible and are passed by
the runtime to each instance of the function object.

The SYCL [code]#item# class template provides the common by-value semantics (see
<<sec:byval-semantics>>).

A synopsis of the SYCL [code]#item# class is provided below.
The member functions of the SYCL [code]#item# class are listed in
<<table.members.id>>.
The additional common special member functions and common member functions are
listed in <<sec:byval-semantics>> in <<table.specialmembers.common.byval>> and
<<table.hiddenfriends.common.byval>> respectively.

// Interface for class: item
[source,,linenums]
----
include::{header_dir}/item.h[lines=4..-1]
----


[[table.members.item]]
.Member functions for the [code]#item# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
id<Dimensions> get_id() const
----
   a@ Return the constituent [code]#id#
      representing the work-item's position in the iteration space.

a@
[source]
----
size_t get_id(int dimension) const
----
   a@ Return the same value as [code]#get_id()[dimension]#.

a@
[source]
----
size_t operator[](int dimension) const
----
   a@ Return the same value as [code]#get_id(dimension)#.

a@
[source]
----
range<Dimensions> get_range() const
----
   a@ Returns a [code]#range# representing the dimensions of the
      range of possible values of the [code]#item#.

a@
[source]
----
size_t get_range(int dimension) const
----
   a@ Return the same value as [code]#get_range().get(dimension)#.

a@
[source]
----
id<Dimensions> get_offset() const
    // Deprecated in SYCL 2020.
----
   a@ Deprecated in SYCL 2020.
      Returns an [code]#id# representing the _n_-dimensional offset
      provided to the [code]#parallel_for# and that is added by
      the runtime to the global-ID of each work-item, if this item
      represents a global range. For an item converted from an item with
      no offset this will always return an [code]#id# of all 0 values.

This member function is only available if [code]#WithOffset# is [code]#true#.

a@
[source]
----
operator item<Dimensions, true>() const
    // Deprecated in SYCL 2020.
----
   a@ Deprecated in SYCL 2020.

Available only when: [code]#WithOffset == false#

Returns an [code]#item# representing the same information as the object holds
but also includes the offset set to 0. This conversion allow users to seamlessly
write code that assumes an offset and still provides an offset-less [code]#item#.

a@
[source]
----
operator size_t() const
----
   a@ Available only when: [code]#Dimensions == 1#

Returns the same value as [code]#get_id(0)#.

a@
[source]
----
size_t get_linear_id() const
----
   a@ Return the id as a linear index value. Calculating a linear
      address from the multi-dimensional index follows
      <<sec:multi-dim-linearization>>.

|====



[[nditem-class]]
==== [code]#nd_item# class

[code]#nd_item<int Dimensions># identifies an instance of the function object
executing at each point in an [code]#nd_range<int Dimensions># passed to a
[code]#parallel_for# call.
It encapsulates enough information to identify the <<work-item>>'s local and
global <<id,ids>>, the <<work-group-id>> and also provides access to the
[code]#group# and [code]#sub_group# classes.
Instances of the [code]#nd_item<int Dimensions># class are not
user-constructible and are passed by the runtime to each instance of the
function object.

The SYCL [code]#nd_item# class template provides the common by-value semantics
(see <<sec:byval-semantics>>).

A synopsis of the SYCL [code]#nd_item# class is provided below.
The member functions of the SYCL [code]#nd_item# class are listed in
<<table.members.nditem>>.
The additional common special member functions and common member functions are
listed in <<sec:byval-semantics>> in <<table.specialmembers.common.byval>> and
<<table.hiddenfriends.common.byval>> respectively.

// interface for nd_item class
[source,,linenums]
----
include::{header_dir}/nditem.h[lines=4..-1]
----


[[table.members.nditem]]
.Member functions for the [code]#nd_item# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
id<Dimensions> get_global_id() const
----
   a@ Return the constituent <<global-id>> representing the
      work-item's position in the global iteration space.

a@
[source]
----
size_t get_global_id(int dimension) const
----
   a@ Return the constituent element of the <<global-id>>
      representing the work-item's position in the <<nd-range>>
      in the given [code]#Dimension#.

a@
[source]
----
size_t get_global_linear_id() const
----
   a@ Return the constituent <<global-id>> as a linear index value, representing the work-item's
   position in the global iteration space.  The linear address is calculated from the
   multi-dimensional index by first subtracting the offset and then following
   <<sec:multi-dim-linearization>>.

a@
[source]
----
id<Dimensions> get_local_id() const
----
   a@ Return the constituent <<local-id>> representing the
      work-item's position within the current <<work-group>>.

a@
[source]
----
size_t get_local_id(int dimension) const
----
   a@ Return the constituent element of the <<local-id>> representing the
      work-item's position within the current <<work-group>> in the given
      [code]#Dimension#.

a@
[source]
----
size_t get_local_linear_id() const
----
   a@ Return the constituent <<local-id>> as a linear index value, representing the work-item's
   position within the current <<work-group>>.  The linear address is calculated from the
   multi-dimensional index following <<sec:multi-dim-linearization>>.

a@
[source]
----
group<Dimensions> get_group() const
----
   a@ Return the constituent <<work-group>>, [code]#group#
      representing the <<work-group>>'s position within the overall
      <<nd-range>>.

a@
[source]
----
sub_group get_sub_group() const
----
   a@ Return a [code]#sub_group# representing the <<sub-group>> to which the work-item belongs.

a@
[source]
----
size_t get_group(int dimension) const
----
   a@ Return the constituent element of the group [code]#id# representing
      the work-group's position within the overall [code]#nd_range# in the
      given [code]#Dimension#.

a@
[source]
----
size_t get_group_linear_id() const
----
   a@ Return the group id as a linear index value. Calculating a linear address
      from a multi-dimensional index follows <<sec:multi-dim-linearization>>.

a@
[source]
----
range<Dimensions> get_group_range() const
----
   a@ Returns the number of <<work-group,work-groups>> in the iteration space.

a@
[source]
----
size_t get_group_range(int dimension) const
----
   a@ Return the number of <<work-group,work-groups>> for [code]#Dimension# in the
      iteration space.

a@
[source]
----
range<Dimensions> get_global_range() const
----
   a@ Returns a [code]#range# representing the dimensions of the
      global iteration space.

a@
[source]
----
size_t get_global_range(int dimension) const
----
   a@ Return the same value as [code]#get_global_range().get(dimension)#.

a@
[source]
----
range<Dimensions> get_local_range() const
----
   a@ Returns a [code]#range# representing the dimensions of the current
      work-group.

a@
[source]
----
size_t get_local_range(int dimension) const
----
   a@ Return the same value as [code]#get_local_range().get(dimension)#.

a@
[source]
----
id<Dimensions> get_offset() const
    // Deprecated in SYCL 2020.
----
   a@ Deprecated in SYCL 2020.
      Returns an <<id>> representing the n-dimensional offset
      provided to the constructor of the [code]#nd_range# and that
      is added by the runtime to the <<global-id>> of each <<work-item>>.

a@
[source]
----
nd_range<Dimensions> get_nd_range() const
----
   a@ Returns the [code]#nd_range# of the current execution.

a@
[source]
----
template <typename DataT>
device_event async_work_group_copy(local_ptr<DataT> dest,
                                   global_ptr<DataT> src,
                                   size_t numElements) const
----
   a@ Deprecated in SYCL 2020.
      Has the same effect as the overload taking [code]#decorated_local_ptr#
      and [code]#decorated_global_ptr# except that the dest and src parameters
      are [code]#multi_ptr# with [code]#access::decorated::legacy#.

a@
[source]
----
template <typename DataT>
device_event async_work_group_copy(global_ptr<DataT> dest,
                                   local_ptr<DataT> src,
                                   size_t numElements) const
----
   a@ Deprecated in SYCL 2020.
      Has the same effect as the overload taking [code]#decorated_local_ptr#
      and [code]#decorated_global_ptr# except that the dest and src parameters
      are [code]#multi_ptr# with [code]#access::decorated::legacy#.

a@
[source]
----
template <typename DataT>
device_event async_work_group_copy(local_ptr<DataT> dest,
                                   global_ptr<DataT> src,
                                   size_t numElements, size_t srcStride) const
----
   a@ Deprecated in SYCL 2020.
      Has the same effect as the overload taking [code]#decorated_local_ptr#
      and [code]#decorated_global_ptr# except that the dest and src parameters
      are [code]#multi_ptr# with [code]#access::decorated::legacy#.

a@
[source]
----
template <typename DataT>
device_event async_work_group_copy(global_ptr<DataT> dest,
                                   local_ptr<DataT> src,
                                   size_t numElements, size_t destStride) const
----
    a@ Deprecated in SYCL 2020.
      Has the same effect as the overload taking [code]#decorated_local_ptr#
      and [code]#decorated_global_ptr# except that the dest and src parameters
      are [code]#multi_ptr# with [code]#access::decorated::legacy#.

a@
[source]
----
template <typename DestDataT, typename SrcDataT>
device_event async_work_group_copy(decorated_local_ptr<DestDataT> dest,
                                   decorated_global_ptr<SrcDataT> src,
                                   size_t numElements) const
----
   a@ Available only when: (std::is_same_v<DestDataT,
        std::remove_const_t<SrcDataT>> == true)

Permitted types for [code]#DataT# are all scalar and vector types.
Asynchronously copies a number of elements specified by [code]#numElements#
from the source pointer [code]#src# to destination pointer [code]#dest# and
returns a SYCL [code]#device_event# which can be used to wait on the completion
of the copy.

a@
[source]
----
template <typename DestDataT, typename SrcDataT>
device_event async_work_group_copy(decorated_global_ptr<DestDataT> dest,
                                   decorated_local_ptr<SrcDataT> src,
                                   size_t numElements) const
----
   a@ Available only when: (std::is_same_v<DestDataT,
        std::remove_const_t<SrcDataT>> == true)

Permitted types for [code]#DataT# are all scalar and vector types.
Asynchronously copies a number of elements specified by [code]#numElements#
from the source pointer [code]#src# to destination pointer [code]#dest# and
returns a SYCL [code]#device_event# which can be used to wait on the
completion of the copy.

a@
[source]
----
template <typename DestDataT, typename SrcDataT>
device_event async_work_group_copy(decorated_local_ptr<DestDataT> dest,
                                   decorated_global_ptr<SrcDataT> src,
                                   size_t numElements, size_t srcStride) const
----
   a@ Available only when: (std::is_same_v<DestDataT,
        std::remove_const_t<SrcDataT>> == true)

Permitted types for [code]#DataT# are all scalar and vector types.
Asynchronously copies a number of elements specified by [code]#numElements#
from the source pointer [code]#src# to destination pointer [code]#dest# with a
source stride specified by [code]#srcStride# and returns a SYCL
[code]#device_event# which can be used to wait on the completion of the copy.

a@
[source]
----
template <typename DestDataT, SrcDataT>
device_event async_work_group_copy(decorated_global_ptr<DestDataT> dest,
                                   decorated_local_ptr<SrcDataT> src,
                                   size_t numElements, size_t destStride) const
----
    a@ Available only when: (std::is_same_v<DestDataT,
        std::remove_const_t<SrcDataT>> == true)

Permitted types for [code]#DataT# are all scalar and vector types.
Asynchronously copies a number of elements specified by [code]#numElements#
from the source pointer [code]#src# to destination pointer [code]#dest# with a
destination stride specified by [code]#destStride# and returns a SYCL
[code]#device_event# which can be used to wait on the completion of the copy.

a@
[source]
----
template <typename... EventTN> void wait_for(EventTN... events) const
----
   a@ Permitted type for [code]#EventTN# is [code]#device_event#.
      Waits for the asynchronous operations associated with each [code]#device_event# to complete.

|====



[[hitem-class]]
==== [code]#h_item# class (deprecated)

The [code]#h_item# class is deprecated in SYCL 2020.

[code]#h_item<int Dimensions># identifies an instance of a
[code]#group::parallel_for_work_item# function object executing at each point in
a local [code]#range<int Dimensions># passed to a [code]#parallel_for_work_item#
call or to the corresponding [code]#parallel_for_work_group# call if no
[code]#range# is passed to the [code]#parallel_for_work_item# call.
It encapsulates enough information to identify the <<work-item>>'s local and
global <<item,items>> according to the information given to
[code]#parallel_for_work_group# (physical ids) as well as the <<work-item>>'s
logical local <<item,items>> in the logical local range.
All returned <<item,items>> objects are offset-less.
Instances of the [code]#h_item<int Dimensions># class are not user-constructible
and are passed by the runtime to each instance of the function object.

The SYCL [code]#h_item# class template provides the common by-value semantics
(see <<sec:byval-semantics>>).

A synopsis of the SYCL [code]#h_item# class is provided below.
The member functions of the SYCL [code]#h_item# class are listed in
<<table.members.hitem>>.
The additional common special member functions and common member functions are
listed in <<sec:byval-semantics>> in <<table.specialmembers.common.byval>> and
<<table.hiddenfriends.common.byval>> respectively.

[source,,linenums]
----
include::{header_dir}/hitem.h[lines=4..-1]
----


[[table.members.hitem]]
.Member functions for the [code]#h_item# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
item<Dimensions, false> get_global() const
----
   a@ Return the constituent global <<item>> representing the
      work-item's position in the global iteration space as provided upon kernel invocation.

a@
[source]
----
item<Dimensions, false> get_local() const
----
   a@ Return the same value as [code]#get_logical_local()#.

a@
[source]
----
item<Dimensions, false> get_logical_local() const
----
   a@ Return the constituent element of the logical local <<item>>
      work-item's position in the local iteration space as provided upon the invocation of the
      [code]#group::parallel_for_work_item#.

If the [code]#group::parallel_for_work_item# was called without any logical local range
then the member function returns the physical local <<item>>.

A physical id can be computed from a logical id by getting the remainder of the integer division
of the logical id and the physical range:
[code]#get_logical_local().get() % get_physical_local.get_range() == get_physical_local().get()#.

a@
[source]
----
item<Dimensions, false> get_physical_local() const
----
   a@ Return the constituent element of the physical local <<item>>
      work-item's position in the local iteration space as provided (by the user or the runtime)
      upon the kernel invocation.

a@
[source]
----
range<Dimensions> get_global_range() const
----
   a@ Return the same value as [code]#get_global().get_range()#

a@
[source]
----
size_t get_global_range(int dimension) const
----
   a@ Return the same value as [code]#get_global().get_range(dimension)#

a@
[source]
----
id<Dimensions> get_global_id() const
----
   a@ Return the same value as [code]#get_global().get_id()#

a@
[source]
----
size_t get_global_id(int dimension) const
----
   a@ Return the same value as [code]#get_global().get_id(dimension)#

a@
[source]
----
range<Dimensions> get_local_range() const
----
   a@ Return the same value as [code]#get_local().get_range()#

a@
[source]
----
size_t get_local_range(int dimension) const
----
   a@ Return the same value as [code]#get_local().get_range(dimension)#

a@
[source]
----
id<Dimensions> get_local_id() const
----
   a@ Return the same value as [code]#get_local().get_id()#

a@
[source]
----
size_t get_local_id(int dimension) const
----
   a@ Return the same value as [code]#get_local().get_id(dimension)#

a@
[source]
----
range<Dimensions> get_logical_local_range() const
----
   a@ Return the same value as [code]#get_logical_local().get_range()#

a@
[source]
----
size_t get_logical_local_range(int dimension) const
----
   a@ Return the same value as [code]#get_logical_local().get_range(dimension)#

a@
[source]
----
id<Dimensions> get_logical_local_id() const
----
   a@ Return the same value as [code]#get_logical_local().get_id()#

a@
[source]
----
size_t get_logical_local_id(int dimension) const
----
   a@ Return the same value as [code]#get_logical_local().get_id(dimension)#

a@
[source]
----
range<Dimensions> get_physical_local_range() const
----
   a@ Return the same value as [code]#get_physical_local().get_range()#

a@
[source]
----
size_t get_physical_local_range(int dimension) const
----
   a@ Return the same value as [code]#get_physical_local().get_range(dimension)#

a@
[source]
----
id<Dimensions> get_physical_local_id() const
----
   a@ Return the same value as [code]#get_physical_local().get_id()#

a@
[source]
----
size_t get_physical_local_id(int dimension) const
----
   a@ Return the same value as [code]#get_physical_local().get_id(dimension)#

|====



[[group-class]]
==== [code]#group# class

The [code]#group<int Dimensions># encapsulates all functionality required to
represent a particular <<work-group>> within a parallel execution.
It is not user-constructible.

The local range stored in the group class is provided either by the programmer,
when it is passed as an optional parameter to [code]#parallel_for_work_group#,
or by the runtime system when it selects the optimal work-group size.
This allows the developer to always know how many work-items are in each
executing work-group, even through the abstracted iteration range of the
[code]#parallel_for_work_item# loops.

The SYCL [code]#group# class template provides the common by-value semantics
(see <<sec:byval-semantics>>).

A synopsis of the SYCL [code]#group# class is provided below.
The member functions of the SYCL [code]#group# class are listed in
<<table.members.group>>.
The additional common special member functions and common member functions are
listed in <<sec:byval-semantics>> in <<table.specialmembers.common.byval>> and
<<table.hiddenfriends.common.byval>> respectively.

// Interface for class: group
[source,,linenums]
----
include::{header_dir}/group.h[lines=4..-1]
----

[[table.members.group]]
.Member functions for the [code]#group# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
id<Dimensions> get_group_id() const
----
   a@ Return an <<id>> representing the index of the work-group within the
      global <<nd-range>> for every dimension.  Since the work-items in a
      work-group have a defined position within the global nd-range, the
      returned group id can be used along with the local id to uniquely
      identify the work-item in the global nd-range.

a@
[source]
----
size_t get_group_id(int dimension) const
----
   a@ Return the same value as [code]#get_group_id()[dimension]#.

a@
[source]
----
id<Dimensions> get_local_id() const
----
   a@ Return a SYCL [code]#id# representing the calling work-item's position
      within the <<work-group>>.

It is undefined behavior for this member function to be invoked from within
a [code]#parallel_for_work_item# context.

a@
[source]
----
size_t get_local_id(int dimension) const
----
   a@ Return the same value as [code]#get_local_id()[dimension]#.

It is undefined behavior for this member function to be invoked from within
a [code]#parallel_for_work_item# context.

a@
[source]
----
range<Dimensions> get_local_range() const
----
   a@ Return a SYCL [code]#range# representing all dimensions of the local range.
      This local range may have been provided by the programmer, or chosen by the <<sycl-runtime>>.

a@
[source]
----
size_t get_local_range(int dimension) const
----
   a@ Return the same value as [code]#get_local_range()[dimension]#.

a@
[source]
----
range<Dimensions> get_group_range() const
----
   a@ Return a [code]#range# representing the number of <<work-group,work-groups>> in the [code]#nd_range#.

a@
[source]
----
size_t get_group_range(int dimension) const
----
   a@ Return the same value as [code]#get_group_range()[dimension]#.

a@
[source]
----
size_t operator[](int dimension) const
----
   a@ Return the same value as [code]#get_group_id(dimension)#.

a@
[source]
----
range<Dimensions> get_max_local_range() const
----
   a@ Return a [code]#range# representing the maximum number of work-items in any <<work-group>>
      in the [code]#nd_range#.

a@
[source]
----
size_t get_group_linear_id() const
----
   a@ Get a linearized version of the <<work-group-id>>.
      Calculating a linear <<work-group-id>>
      from a multi-dimensional index follows <<sec:multi-dim-linearization>>.

a@
[source]
----
size_t get_group_linear_range() const
----
   a@ Return the total number of <<work-group,work-groups>> in the [code]#nd_range#.

a@
[source]
----
size_t get_local_linear_id() const
----
   a@ Get a linearized version of the calling work-item's <<local-id>>.
      Calculating a linear <<local-id>>
      from a multi-dimensional index follows <<sec:multi-dim-linearization>>.

It is undefined behavior for this member function to be invoked from within
a [code]#parallel_for_work_item# context.

a@
[source]
----
size_t get_local_linear_range() const
----
   a@ Return the total number of work-items in the <<work-group>>.

a@
[source]
----
bool leader() const
----
   a@ Return true for exactly one work-item in the <<work-group>>, if the
      calling work-item is the leader of the work-group, and false for all
      other work-items in the work-group.

The leader of the work-group is determined during construction of the
work-group, and is invariant for the lifetime of the work-group.  The
leader of the work-group is guaranteed to be the work-item with a
local id of 0.

a@
[source]
----
template <typename WorkItemFunctionT>
void parallel_for_work_item(const WorkItemFunctionT& func) const
----
   a@ Deprecated in SYCL 2020.
      Launch the work-items for this work-group.

[code]#func# is a function object type with a public member function
[code]#void F::operator()(h_item<Dimensions>)#
representing the work-item computation.

This member function can only be invoked within a
[code]#parallel_for_work_group# context.  It is
undefined behavior for this member function to be invoked
from within the [code]#parallel_for_work_group# form that
does not define work-group size, because then the number of
work-items that should execute the code is not defined.  It is
expected that this form of [code]#parallel_for_work_item#
is invoked within the [code]#parallel_for_work_group# form
that specifies the size of a work-group.

a@
[source]
----
template <typename WorkItemFunctionT>
void parallel_for_work_item(range<Dimensions> logicalRange,
                            const WorkItemFunctionT& func) const
----
   a@ Deprecated in SYCL 2020.
      Launch the work-items for this work-group using a logical local range.
      The function object [code]#func# is executed as if the kernel were
      invoked with [code]#logicalRange# as the local range. This new local
      range is emulated and may not map one-to-one with the physical range.

[code]#logicalRange# is the new local range to be used.
This range can be smaller or larger than the one used to invoke the kernel.
[code]#func# is a function object type with a public member function
[code]#void F::operator()(h_item<Dimensions>)#
representing the work-item computation.

Note that the logical range does not need to be uniform
across all work-groups in a kernel.  For example the logical range may depend on
a work-group varying query (e.g. [code]#group::get_linear_id)#,
such that different work-groups in the same kernel invocation execute
different logical range sizes.

This member function can only be invoked within a
[code]#parallel_for_work_group# context.

a@
[source]
----
template <typename DataT>
device_event async_work_group_copy(local_ptr<DataT> dest,
                                   global_ptr<DataT> src,
                                   size_t numElements) const
----
   a@ Deprecated in SYCL 2020.
      Has the same effect as the overload taking [code]#decorated_local_ptr#
      and [code]#decorated_global_ptr# except that the dest and src parameters
      are [code]#multi_ptr# with [code]#access::decorated::legacy#.

a@
[source]
----
template <typename DataT>
device_event async_work_group_copy(global_ptr<DataT> dest,
                                   local_ptr<DataT> src,
                                   size_t numElements) const
----
   a@ Deprecated in SYCL 2020.
      Has the same effect as the overload taking [code]#decorated_local_ptr#
      and [code]#decorated_global_ptr# except that the dest and src parameters
      are [code]#multi_ptr# with [code]#access::decorated::legacy#.

a@
[source]
----
template <typename DataT>
device_event async_work_group_copy(local_ptr<DataT> dest,
                                   global_ptr<DataT> src,
                                   size_t numElements, size_t srcStride) const
----
   a@ Deprecated in SYCL 2020.
      Has the same effect as the overload taking [code]#decorated_local_ptr#
      and [code]#decorated_global_ptr# except that the dest and src parameters
      are [code]#multi_ptr# with [code]#access::decorated::legacy#.

a@
[source]
----
template <typename DataT>
device_event async_work_group_copy(global_ptr<DataT> dest,
                                   local_ptr<DataT> src,
                                   size_t numElements, size_t destStride) const
----
    a@ Deprecated in SYCL 2020.
      Has the same effect as the overload taking [code]#decorated_local_ptr#
      and [code]#decorated_global_ptr# except that the dest and src parameters
      are [code]#multi_ptr# with [code]#access::decorated::legacy#.

a@
[source]
----
template <typename DestDataT, typename SrcDataT>
device_event async_work_group_copy(decorated_global_ptr<DestDataT> dest,
                                   decorated_local_ptr<SrcDataT> src,
                                   size_t numElements) const
----
   a@ Available only when: (std::is_same_v<DestDataT,
        std::remove_const_t<SrcDataT>> == true)

Permitted types for [code]#DataT# are all scalar and vector types.
Asynchronously copies a number of elements specified by [code]#numElements#
from the source pointer [code]#src# to destination pointer [code]#dest# and
returns a SYCL [code]#device_event# which can be used to wait on the
completion of the copy.

a@
[source]
----
template <typename DestDataT, typename SrcDataT>
device_event async_work_group_copy(decorated_local_ptr<DestDataT> dest,
                                   decorated_global_ptr<SrcDataT> src,
                                   size_t numElements, size_t srcStride) const
----
   a@ Available only when: (std::is_same_v<DestDataT,
        std::remove_const_t<SrcDataT>> == true)

Permitted types for [code]#DataT# are all scalar and vector types.
Asynchronously copies a number of elements specified by [code]#numElements#
from the source pointer [code]#src# to destination pointer [code]#dest# with a
source stride specified by [code]#srcStride# and returns a SYCL
[code]#device_event# which can be used to wait on the completion of the copy.

a@
[source]
----
template <typename DestDataT, SrcDataT>
device_event async_work_group_copy(decorated_global_ptr<DestDataT> dest,
                                   decorated_local_ptr<SrcDataT> src,
                                   size_t numElements, size_t destStride) const
----
    a@ Available only when: (std::is_same_v<DestDataT,
        std::remove_const_t<SrcDataT>> == true)

Permitted types for [code]#DataT# are all scalar and vector types.
Asynchronously copies a number of elements specified by [code]#numElements#
from the source pointer [code]#src# to destination pointer [code]#dest# with a
destination stride specified by [code]#destStride# and returns a SYCL
[code]#device_event# which can be used to wait on the completion of the copy.

a@
[source]
----
template <typename... EventTN> void wait_for(EventTN... events) const
----
   a@ Permitted type for [code]#EventTN# is [code]#device_event#.
      Waits for the asynchronous operations associated with each [code]#device_event# to complete.

|====



[[sub-group-class]]
==== [code]#sub_group# class

The [code]#sub_group# class encapsulates all functionality required to represent
a particular <<sub-group>> within a parallel execution.
It is not user-constructible.

The SYCL [code]#sub_group# class provides the common by-value semantics (see
<<sec:byval-semantics>>).

A synopsis of the SYCL [code]#sub_group# class is provided below.
The member functions of the SYCL [code]#sub_group# class are listed in
<<table.members.subgroup>>.
The additional common special member functions and common member functions are
listed in <<sec:byval-semantics>> in <<table.specialmembers.common.byval>> and
<<table.hiddenfriends.common.byval>> respectively.

// Interface for class: subgroup
[source,,linenums]
----
include::{header_dir}/subgroup.h[lines=4..-1]
----


[[table.members.subgroup]]
.Member functions for the [code]#sub_group# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
id<1> get_group_id() const
----
   a@ Return an <<id>> representing the index of the sub-group within the
      <<work-group>>.  Since the work-items that compose a sub-group are chosen
      in an implementation defined way, the returned sub-group id cannot be
      used to identify a particular work-item in the global nd-range.  Rather,
      the returned sub-group id is merely an abstract identifier of the
      sub-group containing this work-item.

a@
[source]
----
id<1> get_local_id() const
----
   a@ Return a SYCL [code]#id# representing the calling work-item's position
      within the <<sub-group>>.

a@
[source]
----
range<1> get_local_range() const
----
   a@ Return a [code]#range# representing the size of the <<sub-group>>.
      This size may be less than the value returned by
      [code]#get_max_local_range()#, depending on the position of the
      sub-group within its parent <<work-group>> and the manner in which
      sub-groups are constructed by the implementation.

a@
[source]
----
range<1> get_group_range() const
----
   a@ Return a [code]#range# representing the number of
      <<sub-group,sub-groups>> in the <<work-group>>.

a@
[source]
----
range<1> get_max_local_range() const
----
   a@ Return a [code]#range# representing the maximum number of work-items
      permitted in a <<sub-group>> for the executing kernel.  This value may
      have been chosen by the programmer via an attribute, or chosen by the
      <<device-compiler>>.

a@
[source]
----
uint32_t get_group_linear_id() const
----
   a@ Return the same value as [code]#get_group_id()[0]#.

a@
[source]
----
uint32_t get_group_linear_range() const
----
   a@ Return the same value as [code]#get_group_range()[0]#.

a@
[source]
----
uint32_t get_local_linear_id() const
----
   a@ Return the same value as [code]#get_local_id()[0]#.

a@
[source]
----
uint32_t get_local_linear_range() const
----
   a@ Return the same value as [code]#get_local_range()[0]#.

a@
[source]
----
bool leader() const
----
   a@ Return true for exactly one work-item in the <<sub-group>>, if the
      calling work-item is the leader of the sub-group, and false for all
      other work-items in the sub-group.

The leader of the sub-group is determined during construction of the
sub-group, and is invariant for the lifetime of the sub-group.  The
leader of the sub-group is guaranteed to be the work-item with a
local id of 0.

|====


[[sec:reduction]]
=== Reduction variables

All functionality related to <<reduction,reductions>> is captured by the
[code]#reducer# class and the [code]#reduction# function.

The example below demonstrates how to write a <<reduction>> kernel that performs
two reductions simultaneously on the same input values, computing both the sum
of all values in a buffer and the maximum value in the buffer.
For each reduction variable passed to [code]#parallel_for#, a reference to a
[code]#reducer# object is passed as a parameter to the kernel function in the
same order.

[source,,linenums]
----
include::{code_dir}/reduction.cpp[lines=4..-1]
----

Reductions are supported for all trivially copyable types (as defined by the
{cpp} core language).
If the reduction operator is non-associative or non-commutative, the behavior of
a reduction may be non-deterministic.
If multiple reductions reference the same reduction variable, or a reduction
variable is accessed directly during the lifetime of a reduction (e.g. via an
[code]#accessor# or USM pointer), the behavior is undefined.

Some of the overloads for the [code]#reduction# function take an identity value
and some do not.
An implementation is required to compute a correct reduction even when the
application does not specify an identity value.
However, the implementation may be more efficient when the identity value is
either provided by the application or is known by the implementation.
For reductions using standard binary operators and fundamental types (e.g.
[code]#plus# and arithmetic types), an implementation can determine the correct
identity value automatically in order to avoid performance penalties.

If an implementation can identify an identity value for a given combination of
accumulator type and function object type, the value is defined as a member of
the [code]#known_identity# trait class and can be retrieved using the
[code]#known_identity_v# variable template.
Whether this member value exists can be tested using the
[code]#has_known_identity# trait class or the [code]#has_known_identity_v#
variable template.

[source,,linenums]
----
include::{header_dir}/identity.h[lines=4..-1]
----

For each of the partial specializations listed in <<table.identities>>,
[code]#known_identity# exists and has the value shown.

[[table.identities]]
.Known identities.
[width="100%",options="header",separator="@",cols="25%,55%,20%"]
|====
@ Operator @ Available Only When @ Identity

a@
[source]
----
sycl::plus
----
a@
[source]
----
std::is_arithmetic_v<AccumulatorT> ||
    std::is_same_v<std::remove_cv_t<AccumulatorT>, sycl::half>
----
a@
----
AccumulatorT{}
----

a@
[source]
----
sycl::multiplies
----
a@
[source]
----
std::is_arithmetic_v<AccumulatorT> ||
    std::is_same_v<std::remove_cv_t<AccumulatorT>, sycl::half>
----
a@
----
AccumulatorT{1}
----

a@
[source]
----
sycl::bit_and
----
a@
[source]
----
std::is_integral_v<AccumulatorT>
----
a@
----
~AccumulatorT{}
----

a@
[source]
----
sycl::bit_or
----
a@
[source]
----
std::is_integral_v<AccumulatorT>
----
a@
----
AccumulatorT{}
----

a@
[source]
----
sycl::bit_xor
----
a@
[source]
----
std::is_integral_v<AccumulatorT>
----
a@
----
AccumulatorT{}
----

a@
[source]
----
sycl::logical_and
----
a@
[source]
----
std::is_same_v<std::remove_cv_t<AccumulatorT>, bool>
----
a@
----
true
----

a@
[source]
----
sycl::logical_or
----
a@
[source]
----
std::is_same_v<std::remove_cv_t<AccumulatorT>, bool>
----
a@
----
false
----

a@
[source]
----
sycl::minimum
----
a@
[source]
----
std::is_integral_v<AccumulatorT>
----
a@
----
std::numeric_limits<AccumulatorT>::max()
----

a@
[source]
----
sycl::minimum
----
a@
[source]
----
std::is_floating_point_v<AccumulatorT> ||
    std::is_same_v<std::remove_cv_t<AccumulatorT>, sycl::half>
----
a@
----
std::numeric_limits<AccumulatorT>::infinity()
----

a@
[source]
----
sycl::maximum
----
a@
[source]
----
std::is_integral_v<AccumulatorT>
----
a@
----
std::numeric_limits<AccumulatorT>::lowest()
----

a@
[source]
----
sycl::maximum
----
a@
[source]
----
std::is_floating_point_v<AccumulatorT> ||
    std::is_same_v<std::remove_cv_t<AccumulatorT>, sycl::half>
----
a@
----
-std::numeric_limits<AccumulatorT>::infinity()
----

|====

The reduction interface is limited to reduction variables whose size can be
determined at compile-time.
As such, [code]#buffer# and USM pointer arguments are interpreted by the
reduction interface as describing a single variable.
A reduction operation associated with a [code]#span# represents an array
reduction.
An array reduction of size _N_ is functionally equivalent to specifying _N_
independent scalar reductions.
The combination operations performed by an array reduction are limited to the
extent of a USM allocation described by a [code]#span#, and access to elements
outside of these regions results in undefined behavior.

[NOTE]
====
Since a [code]#span# is one-dimensional, there is currently no way to describe
an array reduction with more than one dimension.
This is expected to change in a future version of the SYCL specification, but
depends on the introduction of a multi-dimensional [code]#span#.
====

[[reduction-interface]]
==== [code]#reduction# interface

The [code]#reduction# interface is used to attach <<reduction>> semantics to a
variable, by specifying: the reduction variable, the reduction operator and an
optional identity value associated with the operator.
The overloads of the interface are described in <<table.reduction>>.
The return value of the [code]#reduction# interface is an implementation-defined
object of unspecified type, which is interpreted by [code]#parallel_for# to
construct an appropriate [code]#reducer# type as detailed in <<reducer-class>>.

An implementation may use an unspecified number of temporary variables inside of
any [code]#reducer# objects it creates.
If an identity value is supplied to a reduction, an implementation will use that
value to initialize any such temporary variables.

[NOTE]
====
Since the number of temporary variables is unspecified, supplying an identity
value different to the identity value associated with the reduction operator may
lead to unexpected results.
====

The initial value of the reduction variable is included in the reduction
operation, unless the [code]#property::reduction::initialize_to_identity#
property was specified when the [code]#reduction# interface was invoked.

The reduction variable is updated so as to contain the result of the reduction
when the kernel finishes execution.

[source,,linenums]
----
include::{header_dir}/reduction.h[lines=4..-1]
----


[[table.reduction]]
.Overloads of the [code]#reduction# interface
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Function @ Description
a@
[source]
----
reduction<BufferT, BinaryOperation>(BufferT vars, handler& cgh,
                                    BinaryOperation combiner,
                                    const property_list& propList = {})
----
   a@ Construct an unspecified object representing a reduction
      of the variable(s) described by [code]#vars# using the combination
      operation specified by [code]#combiner#. Zero or more properties can be
      provided via an instance of [code]#property_list#.
      Throws an [code]#exception# with the [code]#errc::invalid#
      error code if the range of the [code]#vars# buffer is not 1.

a@
[source]
----
reduction<T, BinaryOperation>(T* var, BinaryOperation combiner,
                              const property_list& propList = {})
----
   a@ Construct an unspecified object representing a reduction
      of the variable described by [code]#var# using the combination
      operation specified by [code]#combiner#. Zero or more properties
      can be provided via an instance of [code]#property_list#.

a@
[source]
----
reduction<T, BinaryOperation>(span<T, Extent> vars, BinaryOperation combiner,
                              const property_list& propList = {})
----
   a@ Available only when [code]#Extent != sycl::dynamic_extent#.
      Construct an unspecified object representing a reduction
      of the variable(s) described by [code]#vars# using the combination
      operation specified by [code]#combiner#. Zero or more properties
      can be provided via an instance of [code]#property_list#.

a@
[source]
----
reduction<BufferT, BinaryOperation>(BufferT vars, handler& cgh,
                                    const BufferT::value_type& identity,
                                    BinaryOperation combiner,
                                    const property_list& propList = {})
----
   a@ Construct an unspecified object representing a reduction
      of the variable(s) described by [code]#vars# using the combination
      operation specified by [code]#combiner#. The value of
      [code]#identity# may be used by the implementation to initialize
      an unspecified number of temporary accumulation variables.  Zero or more
      properties can be provided via an instance of [code]#property_list#.
      Throws an [code]#exception# with the [code]#errc::invalid#
      error code if the range of the [code]#vars# buffer is not 1.

a@
[source]
----
reduction<T, BinaryOperation>(T* var, const T& identity,
                              BinaryOperation combiner,
                              const property_list& propList = {})
----
   a@ Construct an unspecified object representing a reduction
      of the variable described by [code]#var# using the combination
      operation specified by [code]#combiner#. The value of
      [code]#identity# may be used by the implementation to initialize
      an unspecified number of temporary accumulation variables.  Zero or more
      properties can be provided via an instance of [code]#property_list#.

a@
[source]
----
reduction<T, BinaryOperation>(span<T, Extent> vars, const T& identity,
                              BinaryOperation combiner,
                              const property_list& propList = {})
----
   a@ Available only when [code]#Extent != sycl::dynamic_extent#.
      Construct an unspecified object representing a reduction
      of the variable(s) described by [code]#vars# using the combination
      operation specified by [code]#combiner#. The value of
      [code]#identity# may be used by the implementation to initialize
      an unspecified number of temporary accumulation variables.  Zero or more
      properties can be provided via an instance of [code]#property_list#.

|====

[[sec:reduction-properties]]
==== Reduction properties

The properties that can be provided when using the [code]#reduction# interface
are described in <<table.properties.reduction>>.


[[table.properties.reduction]]
.Properties supported by the [code]#reduction# interface
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Property @ Description
a@
[source]
----
property::reduction::initialize_to_identity
----
   a@ The [code]#initialize_to_identity# property adds the requirement that the
      <<sycl-runtime>> must initialize the [code]#reduction# variable to the
      identity value passed to the reduction interface, or to the identity
      value determined by the [code]#known_identity# trait if no identity value
      was specified. If no identity value was specified and an identity value
      cannot be determined by the [code]#known_identity# trait, the
      implementation must throw an [code]#exception# with the
      [code]#errc::invalid# error code. When this property is set, the original
      value of the reduction variable is not included in the reduction.

|====


The constructors of the reduction property classes are listed in
<<table.constructors.properties.reduction>>.

[[table.constructors.properties.reduction]]
.Constructors of the [code]#reduction# [code]#property# classes
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
property::reduction::initialize_to_identity::initialize_to_identity()
----
   a@ Constructs an [code]#initialize_to_identity# property instance.

|====


[[reducer-class]]
==== [code]#reducer# class

The [code]#reducer# class defines the interface between a work-item and a
reduction variable during the execution of a SYCL kernel, restricting access to
the underlying reduction variable.
The intermediate values of a reduction variable cannot be inspected during
kernel execution, and the variable cannot be updated using anything other than
the reduction's specified combination operation.
The combination order of different reducers is unspecified, as are when and how
the value of each reducer is combined with the original reduction variable.

To enable compile-time specialization of reduction algorithms, the
implementation of the [code]#reducer# class is unspecified, except for the
functions and operators defined in <<table.members.reducer>> and
<<table.operators.reducer>>.
As such, developers should not specify the template arguments of a
[code]#reducer# directly, and should instead employ generic programming
techniques that allow kernel functions to accept a reference to a variable of
any [code]#reducer# type.
Kernels written as lambdas should employ [code]#auto&# or [code]#+auto&...+#,
and kernels written as function objects should employ template parameters or
template parameter packs.

An implementation must guarantee that it is safe for multiple work-items in a
kernel to call the combine function of a [code]#reducer# concurrently.
An implementation is free to re-use reducer variables (e.g. across work-groups
scheduled to the same compute unit) if it can guarantee that it is safe to do
so.

The type aliases and constant static members of the [code]#reducer# class are
listed in <<table.types.reducer>> and its member functions are listed in
<<table.members.reducer>>.
Additional shorthand operators may be made available for certain combinations of
reduction variable type and combination operation, as described in
<<table.operators.reducer>>.

[source,,linenums]
----
include::{header_dir}/reducer.h[lines=4..-1]
----

[[table.types.reducer]]
.Member types and constants of the [code]#reducer# class
[width="100%",options="header",separator="@",cols="50%,50%"]
|====
@ Member @ Description
a@
[source]
----
value_type
----
   a@ The data type of the reduction variable.  If this reducer object was
      created from a buffer type [code]#BufferT#, this type is
      [code]#BufferT::value_type#.  If this reducer object was created from a
      USM pointer [code]#T*# or a span [code]#span<T, Extent>#, this type is
      [code]#T#.

a@
[source]
----
binary_operation
----
   a@ The type of the combiner operator [code]#BinaryOperation# that was
      passed to the reduction function that created this reducer object.

a@
[source]
----
static constexpr int dimensions
----
   a@ The number of dimensions of the reduction variable.  If this reducer
      object was created from a buffer or a USM pointer, the number of
      dimensions is [code]#0#.  If this reducer object was created from a span,
      the number of dimensions is [code]#1#.
|====

[[table.members.reducer]]
.Member functions of the [code]#reducer# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
reducer& combine(const T& partial)
----
   a@ Available only when: [code]#Dimensions == 0#.
      Combine the value of [code]#partial# with the reduction variable
      associated with this [code]#reducer#.
      Returns [code]#*this#.

a@
[source]
----
__unspecified__ operator[](size_t index)
----
   a@ Available only when: [code]#Dimensions > 0#.
      Returns an instance of an undefined intermediate type representing
      a [code]#reducer# of the same type as this [code]#reducer#,
      with the dimensionality [code]#Dimensions-1# and containing an
      implicit SYCL [code]#id# with index [code]#Dimensions# set
      to [code]#index#.  The intermediate type returned must provide
      all member functions and operators defined by the [code]#reducer#
      class that are appropriate for the type it represents (including this
      subscript operator).

a@
[source]
----
T identity() const
----
   a@ Return the identity value of the combination operation associated with
      this [code]#reducer#.  Only available if the identity value is known
      to the implementation.
|====

[[table.operators.reducer]]
.Hidden friend operators of the [code]#reducer# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Operator @ Description
a@
[source]
----
reducer& operator+=(reducer& accum, const T& partial)
----
   a@ Equivalent to calling [code]#accum.combine(partial)#.
      Available only when: [code]#Dimensions == 0 &&
      (std::is_same_v<BinaryOperation, plus<>> || std::is_same_v<BinaryOperation, plus<T>>)#.

a@
[source]
----
reducer& operator*=(reducer& accum, const T& partial)
----
   a@ Equivalent to calling [code]#accum.combine(partial)#.
      Available only when: [code]#Dimensions == 0 &&
      (std::is_same_v<BinaryOperation, multiplies<>> || std::is_same_v<BinaryOperation, multiplies<T>>)#.

a@
[source]
----
reducer& operator&=(reducer& accum, const T& partial)
----
   a@ Equivalent to calling [code]#accum.combine(partial)#.
      Available only when: [code]#Dimensions == 0 && is_integral_v<T> &&
      (std::is_same_v<BinaryOperation, bit_and<>> || std::is_same_v<BinaryOperation, bit_and<T>>)#.

a@
[source]
----
reducer& operator|=(reducer& accum, const T& partial)
----
   a@ Equivalent to calling [code]#accum.combine(partial)#.
      Available only when: [code]#Dimensions == 0 && is_integral_v<T> &&
      (std::is_same_v<BinaryOperation, bit_or<>> || std::is_same_v<BinaryOperation, bit_or<T>>)#.

a@
[source]
----
reducer& operator^=(reducer& accum, const T& partial)
----
   a@ Equivalent to calling [code]#accum.combine(partial)#.
      Available only when: [code]#Dimensions == 0 && is_integral_v<T> &&
      (std::is_same_v<BinaryOperation, bit_xor<>> || std::is_same_v<BinaryOperation, bit_xor<T>>)#.

a@
[source]
----
reducer& operator++(reducer& accum)
----
   a@ Equivalent to calling [code]#accum.combine(1)#.
      Available only when: [code]#Dimensions == 0 && std::is_integral_v<T> && !std::is_same_v<T, bool> &&
      (std::is_same_v<BinaryOperation, plus<>> || std::is_same_v<BinaryOperation, plus<T>>)#.

|====


[[sec:command.group.scope]]
=== Command group scope

A <<command-group-scope>>, as defined in <<sec:executionmodel>>, may execute a
single <<command>> such as invoking a kernel, copying memory, or executing a
host task.
It is legal for a <<command-group-scope>> to statically contain more than one
call to a <<command>> function, but any single execution of the
<<command-group-function-object>> may execute no more than one <<command>>.
If an application fails to do this, the function that submits the
<<command-group-function-object>> (i.e., [code]#queue::submit#) must throw a
synchronous [code]#exception# with the [code]#errc::invalid# error code.
The statements that call <<command, commands>> together with the statements that
define the requirements for a kernel form the <<command-group-function-object>>.
The command group function object takes as a parameter an instance of the
<<handler>> class which encapsulates all the member functions executed in the
command group scope.
The member functions and objects defined in this scope will define the
requirements for the kernel execution or explicit memory operation, and will be
used by the <<sycl-runtime>> to evaluate if the operation is ready for
execution.
Host code within a <<command-group-function-object>> (typically setting up
requirements) is executed once, before the command group submit call returns.
This abstraction of the kernel execution unifies the data with its processing,
and consequently allows more abstraction and flexibility in the parallel
programming models that can be implemented on top of SYCL.

The <<command-group-function-object>> and the [code]#handler# class serve as an
interface for the encapsulation of <<command-group-scope>>.
A <<sycl-kernel-function>> is defined as a function object.
All the device data accesses are defined inside this group and any transfers are
managed by the <<sycl-runtime>>.
The rules for the data transfers regarding device and host data accesses are
better described in <<sec:data.access.and.storage>>, where buffers
(<<subsec:buffers>>) and accessor (<<subsec:accessors>>) classes are described.
The overall memory model of the SYCL application is described in
<<sub.section.memmodel.app>>.

It is possible for a <<command-group-function-object>> to fail to enqueue to a
queue, or for it to fail to execute correctly.
A user can therefore supply a secondary queue when submitting a command group to
the primary queue.
If the <<sycl-runtime>> fails to enqueue or execute a command group on a primary
queue, it can attempt to run the command group on the secondary queue.
The circumstances in which it is, or is not, possible for a <<sycl-runtime>> to
fall-back from primary to secondary queue are unspecified in the specification.
Even if a command group is run on the secondary queue, the requirement that host
code within the command group is executed exactly once remains, regardless of
whether the fallback queue is used for execution.
The fallback queue feature is deprecated in SYCL {SYCL_VERSION}.

The command group [code]#handler# class provides the interface for all of the
member functions that are able to be executed inside the command group scope,
and it is also provided as a scoped object to all of the data access requests.
The <<handler>> class provides the interface in which every command in the
command group scope will be submitted to a queue.


[[sec:handlerClass]]
=== Command group [code]#handler# class

A <<handler>> object can only be constructed by the SYCL runtime.
All of the accessors defined in <<command-group-scope>> take as a parameter an
instance of the <<handler>>, and all the kernel invocation functions are member
functions of this class.

The constructors of the SYCL [code]#handler# class are described in
<<table.constructors.handler>>.

It is disallowed for an instance of the SYCL [code]#handler# class to be moved
or copied.

// Interface for class: handler
[source,,linenums]
----
include::{header_dir}/commandGroupHandler.h[lines=4..-1]
----


[[table.constructors.handler]]
.Constructors of the [code]#handler# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
handler(___unspecified___)
----
   a@ Unspecified implementation-defined constructor.

|====


[[sub.section.requirement]]
==== SYCL functions for adding requirements

When an accessor is created from a <<handler>>, a *requirement* is implicitly
added to the <<command-group>> for the accessor's data.
However, this does not happen when creating a [keyword]#placeholder# accessor.
In order to create a *requirement* for a [keyword]#placeholder# accessor, code
must call the [code]#handler::require()# member function.

Note that the default constructed [code]#accessor# is not a placeholder, so it
may be passed to a <<sycl-kernel-function>> without calling
[code]#handler::require()#.
However, this accessor also has no underlying memory object, so such an accessor
does not create any *requirement* for the command group, and attempting to
access data elements from it produces undefined behavior.

SYCL events may also be used to create requirements for a <<command-group>>.
Such requirements state that the actions represented by the events must complete
before the <<command-group>> may execute.
Such requirements are added when code calls the [code]#handler::depends_on()#
member function.

[[table.members.handler.requirements]]
.Member functions of the [code]#handler# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
template <typename DataT, int Dimensions, access_mode AccessMode,
          target AccessTarget, access::placeholder IsPlaceholder>
void require(
    accessor<DataT, Dimensions, AccessMode, AccessTarget, IsPlaceholder> acc)
----
   a@ Calling this function has no effect unless [code]#acc# is a placeholder
      accessor.  When [code]#acc# is a placeholder accessor, this function
      adds a *requirement* to the handler's <<command-group>> for the memory
      object represented by [code]#acc#.  If the accessor has already been
      registered with the <<command-group>>, calling this function has no
      effect.

a@
[source]
----
void depends_on(event depEvent)
----
a@ The <<command-group>> now has a *requirement* that the action represented
by [code]#depEvent# must complete before executing this
<<command-group, command-group's>> action.

a@
[source]
----
void depends_on(const std::vector<event>& depEvents)
----
a@ The <<command-group>> now has a *requirement* that the actions represented
by each event in [code]#depEvents# must complete before executing this
<<command-group, command-group's>> action.

|====


[[subsec:invokingkernels]]
==== SYCL functions for invoking kernels

<<kernel,Kernels>> can be invoked as [keyword]#single tasks#, basic
[keyword]#data-parallel# <<kernel,kernels>>, <<nd-range>> in
<<work-group,work-groups>>, or [keyword]#hierarchical parallelism#.

Each function takes an optional kernel name template parameter.
The user may optionally provide a <<kernel-name>>, otherwise an
implementation-defined name will be generated for the kernel.

All the functions for invoking kernels are member functions of the command group
[code]#handler# class (<<sec:handlerClass>>), which is used to encapsulate all
the member functions provided in a command group scope.
<<table.members.handler.kernel>> lists all the members of the [code]#handler#
class related to the kernel invocation.


[[table.members.handler.kernel]]
.Member functions of the [code]#handler# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
template <typename T> void set_arg(int argIndex, T&& arg)
----
   a@ This function must only be used to set arguments for a kernel that
      was constructed using a backend specific interoperability function
      or for a device built-in kernel.  Attempting to use this function to set
      arguments for other kernels results in undefined behavior.  The precise
      semantics of this function are defined by each SYCL backend
      specification.

a@
[source]
----
template <typename... Ts> void set_args(Ts&&... args)
----
   a@ Set all arguments for a given kernel, as if each argument in
      [code]#args# was passed to [code]#set_arg# in the same order and
      with an increasing index starting at 0.

a@
[source]
----
template <typename KernelName, typename KernelType>
void single_task(const KernelType& kernelFunc)
----
   a@ Defines and invokes a <<sycl-kernel-function>> as a lambda expression
      or a named function object type.
      Specification of a <<kernel-name>> ([code]#typename KernelName#), as
      described in <<subsec:invokingkernels>>, is optional.
      The callable
      [code]#KernelType# can optionally take a [code]#kernel_handler#
      in which case the <<sycl-runtime>> will construct an instance of
      [code]#kernel_handler# and pass it to [code]#KernelType#.

a@
[source]
----
template <typename KernelName, int Dimensions, typename... Rest>
void parallel_for(range<Dimensions> numWorkItems, Rest&&... rest)
----
   a@ Defines and invokes a <<sycl-kernel-function>> as a lambda expression
      or a named function object type,
      for the specified range and given an item or integral type (e.g [code]#int#,
      [code]#size_t)#, if range is 1-dimensional, for indexing in the indexing
      space defined by range. Generic kernel functions are permitted,
      in that case the argument type is an [code]#item#.
      Specification of a <<kernel-name>> ([code]#typename KernelName#), as
      described in <<subsec:invokingkernels>>, is optional.
      The [code]#rest# parameter pack consists of 0 or more objects created by
      the [code]#reduction# function, followed by a callable.  For each
      object in [code]#rest#, the kernel function must take an additional
      reference parameter corresponding to that object's [code]#reducer# type,
      in the same order.
      The callable can optionally take a [code]#kernel_handler#
      as its last parameter, in which case the <<sycl-runtime>> will
      construct an instance of [code]#kernel_handler# and pass it to
      the callable.

a@
[source]
----
template <typename KernelName, int Dimensions, typename... Rest>
void parallel_for(range<Dimensions> numWorkItems, id<Dimensions> workItemOffset,
                  const KernelType& kernelFunc)
    // Deprecated in SYCL 2020.
----
   a@ Deprecated in SYCL 2020.
      Defines and invokes a <<sycl-kernel-function>> as a lambda expression
      or a named function object type,
      for the specified range and offset and given an item or integral type
      (e.g [code]#int#, [code]#size_t)#, if range is 1-dimensional,
      for indexing in the indexing space defined by range. Generic kernel functions
      are permitted, in that case the argument type is an [code]#item#.
      Specification of a <<kernel-name>> ([code]#typename KernelName#), as
      described in <<subsec:invokingkernels>>, is optional.
      The [code]#rest# parameter pack consists of 0 or more objects created by
      the [code]#reduction# function, followed by a callable.  For each
      object in [code]#rest#, the kernel function must take an additional
      reference parameter corresponding to that object's [code]#reducer# type,
      in the same order.
      The callable can optionally take a [code]#kernel_handler#
      as its last parameter, in which case the <<sycl-runtime>> will
      construct an instance of [code]#kernel_handler# and pass it to
      the callable.
a@
[source]
----
template <typename KernelName, int Dimensions, typename... Rest>
void parallel_for(nd_range<Dimensions> executionRange, Rest&&... rest)
----
   a@ Defines and invokes a <<sycl-kernel-function>> as a lambda expression
      or a named function object type,
      for the specified <<nd-range>> and given an <<nd-item>>
      for indexing in the indexing space defined by the <<nd-range>>.
      Generic kernel functions are permitted, in that case the argument type is
      an <<nd-item>>.
      Specification of a <<kernel-name>> ([code]#typename KernelName#), as
      described in <<subsec:invokingkernels>>, is optional.
      The [code]#rest# parameter pack consists of 0 or more objects created by
      the [code]#reduction# function, followed by a callable.  For each
      object in [code]#rest#, the kernel function must take an additional
      reference parameter corresponding to that object's [code]#reducer# type,
      in the same order.
      The callable can optionally take a [code]#kernel_handler#
      as its last parameter, in which case the <<sycl-runtime>> will
      construct an instance of [code]#kernel_handler# and pass it to
      the callable.

Throws an [code]#exception# with the [code]#errc::nd_range# error code if the
global size defined in the associated [code]#executionRange# defines a non-zero
index space which is not evenly divisible by the local size in each dimension.

a@
[source]
----
template <typename KernelName, typename WorkgroupFunctionType, int Dimensions>
void parallel_for_work_group(range<Dimensions> numWorkGroups,
                             const WorkgroupFunctionType& kernelFunc)
----
   a@ Deprecated in SYCL 2020.
      Defines and invokes a hierarchical kernel as a lambda expression
      or a named function object type,
      encoding the body of each work-group to launch. Generic kernel
      functions are permitted, in that case the argument type is a [code]#group#. May
      contain multiple calls to [code]#parallel_for_work_item(..)# member functions
      representing the execution on each work-item. Launches
      [code]#num_work_groups# work-groups of runtime-defined
      size. Described in detail in <<subsec:invokingkernels>>. The callable
      [code]#WorkgroupFunctionType# can optionally take a
      [code]#kernel_handler# as its last parameter, in which case the
      <<sycl-runtime>> will construct an instance of
      [code]#kernel_handler# and pass it to [code]#WorkgroupFunctionType#.

a@
[source]
----
template <typename KernelName, typename WorkgroupFunctionType, int Dimensions>
void parallel_for_work_group(range<Dimensions> numWorkGroups,
                             range<Dimensions> workGroupSize,
                             const WorkgroupFunctionType& kernelFunc)
----
   a@ Deprecated in SYCL 2020.
      Defines and invokes a hierarchical kernel as a lambda expression
      or a named function object type,
      encoding the body of each work-group to launch. Generic kernel
      functions are permitted, in that case the argument type is a [code]#group#.
      May contain multiple calls to [code]#parallel_for_work_item# member functions
      representing the execution on each work-item. Launches
      [code]#num_work_groups# work-groups of
      [code]#work_group_size# work-items each. Described in
      detail in <<subsec:invokingkernels>>. The callable
      [code]#WorkgroupFunctionType# can optionally take a
      [code]#kernel_handler# as its last parameter, in which case the
      <<sycl-runtime>> will construct an instance of [code]#kernel_handler#
      and pass it to [code]#WorkgroupFunctionType#.

a@
[source]
----
void single_task(const kernel& kernelObject)
----
   a@ This function must only be used to invoke a kernel that was constructed
      using a backend specific interoperability function or to invoke a device
      built-in kernel.  Attempting to use this function to invoke other kernels
      throws a synchronous [code]#exception# with the [code]#errc::invalid#
      error code.  The precise semantics of this function are defined by each
      SYCL backend specification, but the intent is that the kernel should
      execute exactly once.

This invocation function ignores any [code]#kernel_bundle# that was bound to
this command group handler via [code]#handler::use_kernel_bundle()# and instead
implicitly uses the kernel bundle that contains the [code]#kernelObject#.
Throws an [code]#exception# with the [code]#errc::kernel_not_supported# error
code if the [code]#kernelObject# is not compatible with either the device
associated with the primary queue of the <<command-group>> or with the device
associated with the secondary queue (if specified).

a@
[source]
----
template <int Dimensions>
void parallel_for(range<Dimensions> numWorkItems, const kernel& kernelObject)
----
   a@ This function must only be used to invoke a kernel that was constructed
      using a backend specific interoperability function or to invoke a device
      built-in kernel.  Attempting to use this function to invoke other kernels
      throws a synchronous [code]#exception# with the [code]#errc::invalid#
      error code.  The precise semantics of this function are defined by each
      SYCL backend specification, but the intent is that the kernel should be
      invoked for the specified range of index values.

This invocation function ignores any [code]#kernel_bundle# that was bound to
this command group handler via [code]#handler::use_kernel_bundle()# and instead
implicitly uses the kernel bundle that contains the [code]#kernelObject#.
Throws an [code]#exception# with the [code]#errc::kernel_not_supported# error
code if the [code]#kernelObject# is not compatible with either the device
associated with the primary queue of the <<command-group>> or with the device
associated with the secondary queue (if specified).

a@
[source]
----
template <int Dimensions>
void parallel_for(nd_range<Dimensions> executionRange,
                  const kernel& kernelObject)
----
   a@ This function must only be used to invoke a kernel that was constructed
      using a backend specific interoperability function or to invoke a device
      built-in kernel.  Attempting to use this function to invoke other kernels
      throws a synchronous [code]#exception# with the [code]#errc::invalid#
      error code.  The precise semantics of this function are defined by each
      SYCL backend specification, but the intent is that the kernel should be
      invoked for the specified [code]#executionRange#.

Throws an [code]#exception# with the [code]#errc::nd_range# error code if the
global size defined in the associated [code]#executionRange# defines a non-zero
index space which is not evenly divisible by the local size in each dimension.

This invocation function ignores any [code]#kernel_bundle# that was bound to
this command group handler via [code]#handler::use_kernel_bundle()# and instead
implicitly uses the kernel bundle that contains the [code]#kernelObject#.
Throws an [code]#exception# with the [code]#errc::kernel_not_supported# error
code if the [code]#kernelObject# is not compatible with either the device
associated with the primary queue of the <<command-group>> or with the device
associated with the secondary queue (if specified).

|====


// Interface for apis
// include headers/parallelFor.h ?


===== [code]#single_task# invoke

SYCL provides a simple interface to enqueue a kernel that will be sequentially
executed on a device.
Only one instance of the kernel will be executed.
This interface is useful as a primitive for more complicated parallel
algorithms, as it can easily create a chain of sequential tasks on a SYCL device
with each of them managing its own data transfers.

This function can only be called inside a command group using the
[code]#handler# object created by the runtime.
Any accessors that are used in a kernel should be defined inside the same
command group.

Local accessors are disallowed for single task invocations.

[source,,linenums]
----
include::{code_dir}/singletask.cpp[lines=4..-1]
----

For single tasks, the kernel member function takes no parameters, as there is no
need for <<index-space-classes>> in a unary index space.

A [code]#kernel_handler# can optionally be passed as a parameter to the
<<sycl-kernel-function>> that is invoked by [code]#single_task# for the purpose
explained in <<sec:spec-constants.device-code>>.

[source,,linenums]
----
include::{code_dir}/singleTaskWithKernelHandler.cpp[lines=4..-1]
----


===== [code]#parallel_for# invoke

The [code]#parallel_for# member function of the SYCL [code]#handler# class
provides an interface to define and invoke a SYCL kernel function in a command
group, to execute in parallel execution over a 3 dimensional index space.
There are three overloads of the [code]#parallel_for# member function which
provide variations of this interface, each with a different level of complexity
and providing a different set of features.

For the simplest case, users need only provide the global range (the total
number of work-items in the index space) via a SYCL [code]#range# parameter.
In this case the function object that represents the SYCL kernel function must
take one of: 1) a single SYCL [code]#item# parameter, 2) a single generic
parameter ([code]#template# parameter or [code]#auto#) that will be treated as
an [code]#item# parameter, 3) any other type implicitly converted from SYCL
[code]#item#, representing the currently executing work-item within the range
specified by the [code]#range# parameter.

[NOTE]
====
Case 3) above allows the kernel function to take an argument of type [code]#id#
because [code]#item# is implicitly convertible to [code]#id#.
It also allows a 1-D kernel function to take an integral argument (e.g.
[code]#int# or [code]#size_t#) because a 1-D [code]#item# is implicitly
convertible to these types.
Finally, it allows the kernel function to take a user-defined argument type that
can be constructed from [code]#item#, enabling users to layer their own
abstractions on top of SYCL.
====

The execution of the kernel function is the same whether the parameter to the
SYCL kernel function is a SYCL [code]#id# or a SYCL [code]#item#.
What differs is the functionality that is available to the SYCL kernel function
via the respective interfaces.

Below is an example of invoking a SYCL kernel function with [code]#parallel_for#
using a lambda expression, and passing a SYCL [code]#id# parameter.
In this case, only the global id is available.
This variant of [code]#parallel_for# is designed for when it is not necessary to
query the global range of the index space being executed across.

[source,,linenums]
----
include::{code_dir}/basicparallelfor.cpp[lines=4..-1]
----

Below is an example of invoking a SYCL kernel function with [code]#parallel_for#
using a lambda expression and passing a SYCL [code]#item# parameter.
In this case, both the global id and global range are queryable.
This variant of [code]#parallel_for# is designed for when it is necessary to
query the global range of the index space being executed across.

[source,,linenums]
----
include::{code_dir}/basicParallelForItem.cpp[lines=4..-1]
----

Below is an example of invoking a SYCL kernel function with [code]#parallel_for#
using a lambda expression and passing [code]#auto# parameter, treated as
[code]#item#.
In this case, both the global id and global range are queryable.
The same effect can be achieved using class with templatized [code]#operator()#.
This variant of [code]#parallel_for# is designed for when it is necessary to
query the global range within which the global id will vary.

[source,,linenums]
----
include::{code_dir}/basicParallelForGeneric.cpp[lines=4..-1]
----

Below is an example of invoking a SYCL kernel function with [code]#parallel_for#
using a lambda expression and passing an integral type parameter.
This example is only valid when calling [code]#parallel_for# with
[code]#range<1>#.
In this case only the global id is available.
This variant of [code]#parallel_for# is designed for when it is not necessary to
query the global range of the index space being executed across.

[source,,linenums]
----
include::{code_dir}/basicParallelForIntegral.cpp[lines=4..-1]
----

The [code]#parallel_for# overload without an offset can be called with either a
number or a [code]#braced-init-list# with 1-3 elements.
In that case the following calls are equivalent:

  * [code]#parallel_for(N, some_kernel)# has same effect as
    [code]#parallel_for(range<1>(N), some_kernel)#
  * [code]#parallel_for({N}, some_kernel)# has same effect as
    [code]#parallel_for(range<1>(N), some_kernel)#
  * [code]#parallel_for({N1, N2}, some_kernel)# has same effect as
    [code]#parallel_for(range<2>(N1, N2), some_kernel)#
  * [code]#parallel_for({N1, N2, N3}, some_kernel)# has same effect as
    [code]#parallel_for(range<3>(N1, N2, N3), some_kernel)#

Below is an example of invoking [code]#parallel_for# with a number instead of an
explicit [code]#range# object.

[source,,linenums]
----
include::{code_dir}/basicParallelForNumber.cpp[lines=4..-1]
----

For SYCL kernel functions invoked via the above described overload of the
[code]#parallel_for# member function, it is disallowed to use local accessors or
to use a <<work-group-barrier>>.

The following two examples show how a kernel function object can be launched
over a 3D grid, with 3 elements in each dimension.
In the first case work-item ids range from 0 to 2 inclusive, and in the second
case work-item ids run from 1 to 3.

[source,,linenums]
----
include::{code_dir}/parallelfor.cpp[lines=4..-1]
----

The last case of a [code]#parallel_for# invocation enables low-level
functionality of work-items and work-groups.
This becomes valuable when an execution requires groups of work-items to
coordinate with one another.
These are exposed in SYCL through [code]#+parallel_for (nd_range,...)+# and the
[code]#nd_item# class.
In this case, the developer needs to define the [code]#nd_range# that the kernel
will execute on in order to have fine grained control of the enqueuing of the
kernel.
This variation of parallel_for expects an [code]#nd_range#, specifying both
local and global ranges, defining the global number of work-items and the number
in each cooperating work-group.
The function object that represents the SYCL kernel function must take one of:
1) a single SYCL [code]#nd_item# parameter, 2) a single generic parameter
([code]#template# parameter or [code]#auto#) that will be treated as an
[code]#nd_item# parameter, 3) any other type converted from SYCL
[code]#nd_item#, representing the currently executing work-item within the range
specified by the [code]#nd_range# parameter.
The [code]#nd_item# parameter makes all information about the work-item and its
position in the range available, and provides access to functions enabling the
use of a <<work-group-barrier>>.

[NOTE]
====
Case 3) above includes user-defined types that can be constructed from
[code]#nd_item#, enabling users to layer their own abstractions on top of SYCL.
====

The following example shows how sixty-four work-items may be launched in a
three-dimensional grid with four in each dimension, and divided into eight
work-groups.
Each group of work-items uses a <<work-group-barrier>> for coordination.

[source,,linenums]
----
include::{code_dir}/parallelforbarrier.cpp[lines=4..-1]
----

In all of these cases the underlying <<nd-range>> will be created and the kernel
defined as a function object will be created and enqueued as part of the command
group scope.

Some forms of [code]#parallel_for# accept an offset parameter of type
[code]#id<Dimensions>#, where the number of dimensions of the [code]#id# is the
same as the number of dimensions of the [code]#range# that determines the
iteration space.
These forms of [code]#parallel_for# execute the same number of iterations as the
form with no offset.
The difference is that the [code]#id# or [code]#item# parameter passed to the
kernel function has the value of [code]#offset# implicitly added.
This offset parameter is deprecated in SYCL 2020.

An offset can also be passed to the forms of [code]#parallel_for# that accept an
[code]#nd_range# via the third parameter to the [code]#nd_range# constructor.
These forms of [code]#parallel_for# also execute the same number of iterations
as if no offset was specified.
The difference is that the [code]#nd_item# parameter passed to the kernel
function has the value of the offset implicitly added to the constituent
<<global-id>>.
This offset parameter is deprecated in SYCL 2020.


A [code]#kernel_handler# can optionally be passed as a parameter to the
<<sycl-kernel-function>> that is invoked by both variants of
[code]#parallel_for#.

[source,,linenums]
----
include::{code_dir}/parallelForWithKernelHandler.cpp[lines=4..-1]
----


[[sec:parallel-for-hierarchical]]
===== Parallel for hierarchical invoke (deprecated)

The behavior in this section and the [code]#private_memory# class are deprecated
in SYCL 2020.

The hierarchical parallel kernel execution interface provides the same
functionality as is available from the <<nd-range>> interface, but exposed
differently.
To execute the same sixty-four work-items in eight work-groups that we saw in a
previous example, we execute an outer [code]#parallel_for_work_group# call to
create the groups.
The member function [code]#handler::parallel_for_work_group# is parameterized by
the number of work-groups, such that the size of each group is chosen by the
runtime, or by the number of work-groups and number of work-items for users who
need more control.

The body of the outer [code]#parallel_for_work_group# call consists of a lambda
expression or function object.
The body of this function object contains code that is executed only once for
the entire work-group.
If the code has no side-effects and the compiler heuristic suggests that it is
more efficient to do so, this code will be executed for each work-item.

Within this region any variable declared will have the semantics of
<<local-memory>>, shared between all <<work-item,work-items>> in the
<<work-group>>.
If the device compiler can prove that an array of such variables is accessed
only by a single work-item throughout the lifetime of the work-group, for
example if access is derived from the id of the work-item with no
transformation, then it can allocate the data in private memory or registers
instead.

To guarantee use of private per-work-item memory, the [code]#private_memory#
class can be used to wrap the data.
This class simply constructs private data for a given group across the entire
group.
The id of the current work-item is passed to any access to grab the correct
data.

The [code]#private_memory# class has the following interface:

[source,,linenums]
----
include::{header_dir}/priv.h[lines=4..-1]
----

[[table.constructors.private.memory]]
.Constructor of the [code]#private_memory# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
private_memory(const group<Dimensions>&)
----
   a@ Place an object of type [code]#T# in the underlying private memory of each <<work-item,work-items>>.
      The type [code]#T# must be default constructible.
      The underlying constructor will be called for each <<work-item>>.

|====

[[table.members.private.memory]]
.Member functions of the [code]#private_memory# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member functions @ Description
a@
[source]
----
T& operator()(const h_item<Dimensions>& id)
----
   a@ Retrieve a reference to the object for the <<work-item,work-items>>.

|====

<<private-memory,Private memory>> is allocated per underlying <<work-item>>, not
per iteration of the [code]#parallel_for_work_item# loop.
The number of instances of a private memory object is only under direct control
if a work-group size is passed to the [code]#parallel_for_work_group# call.
If the underlying work-group size is chosen by the runtime, the number of
private memory instances is opaque to the program.
Explicit private memory declarations should therefore be used with care and with
a full understanding of which instances of a [code]#parallel_for_work_item# loop
will share the same underlying variable.

Also within the lambda body can be a sequence of calls to
[code]#parallel_for_work_item#.
No work-item can begin executing a [code]#parallel_for_work_item# until all
work-items in the group have completed executing the previous
[code]#parallel_for_work_item#.
As a result the pair of [code]#parallel_for_work_item# calls in the code below
is equivalent to the parallel execution with a <<work-group-barrier>> in the
earlier example.

[source,,linenums]
----
include::{code_dir}/parallelforworkgroup.cpp[lines=4..-1]
----

It is valid to use more flexible dimensions of the work-item loops.
In the following example we issue 8 work-groups but let the runtime choose their
size, by not passing a work-group size to the [code]#parallel_for_work_group#
call.
The [code]#parallel_for_work_item# loops may also vary in size, with their
execution ranges unrelated to the dimensions of the work-group, and the compiler
generating an appropriate iteration space to fill the gap.
In this case, the [code]#h_item# provides access to local ids and ranges that
reflect both kernel and [code]#parallel_for_work_item# invocation ranges.

[source,,linenums]
----
include::{code_dir}/parallelforworkgroup2.cpp[lines=4..-1]
----

This interface offers a more intuitive way for tiling parallel programming
paradigms.
In summary, the hierarchical model allows a developer to distinguish the
execution at work-group level and at work-item level using the
[code]#parallel_for_work_group# and the nested [code]#parallel_for_work_item#
functions.
It also provides this visibility to the compiler without the need for difficult
loop fission such that host execution may be more efficient.

A [code]#kernel_handler# can optionally be passed as a parameter to the
<<sycl-kernel-function>> that is invoked by any variant of
[code]#parallel_for_work_group#.

[source,,linenums]
----
include::{code_dir}/parallelForWorkGroupWithKernelHandler.cpp[lines=4..-1]
----

// \input{sycl_explicit_memory}

// %%%%%%%%%%%%%%%%%%%%%%%%%%%% begin sycl_explicit_memory %%%%%%%%%%%%%%%%%%%%%%%%%%%%

[[subsec:explicitmemory]]
==== SYCL functions for explicit memory operations

In addition to <<kernel,kernels>>, <<command-group>> objects can also be used to
perform manual operations on host and device memory by using the [keyword]#copy#
API of the <<handler>>.
Manual copy operations can be seen as specialized kernels executing on the
device, except that typically this operations will be implemented using a host
API that exists as part of a backend (e.g, OpenCL enqueue copy operations).

These explicit copy operations have a source and a destination.
When an accessor is the _source_ of the operation, the destination can be a host
pointer or another accessor.
The _source_ accessor must have either [code]#access_mode::read# or
[code]#access_mode::read_write# access mode.
When an accessor is the _destination_ of the explicit copy operation, the source
can be a host pointer or another accessor.
The _destination_ accessor must have either [code]#access_mode::write#,
[code]#access_mode::read_write#, [code]#access_mode::discard_write# or
[code]#access_mode::discard_read_write# access mode.

When an accessor is used as a parameter to one of these explicit copy
operations, the target must be either [code]#target::device# or
[code]#target::constant_buffer#.

When accessors are both the source and the destination, the operation is
executed on objects controlled by the SYCL runtime.
The SYCL runtime is allowed to not perform an explicit in-copy operation if a
different path to update the data is available according to the SYCL application
memory model.

The most recent copy of the memory object may reside on any context controlled
by the SYCL runtime, or on the host in a pointer controlled by the SYCL runtime.
The SYCL runtime will ensure that data is copied to the destination once the
<<command-group>> has completed execution.

Whenever a host pointer is used as either the source or the destination of these
explicit memory operations, it is the responsibility of the user for that
pointer to have at least as much memory allocated as the accessor is giving
access to, e.g: if an accessor accesses a range of 10 elements of [code]#int#
type, the host pointer must at least have [code]#10 * sizeof(int)# bytes of
memory allocated.

A special case is the [code]#update_host# member function.
This member function only requires an accessor, and instructs the runtime to
update the internal copy of the data in the host, if any.
This is particularly useful when used in conjunction with the [code]#buffer#
constructor overloads which accept mutex objects.

<<table.members.handler.copy>> describes the interface for the explicit copy
operations.


[[table.members.handler.copy]]
.Member functions of the [code]#handler# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
template <typename SrcT, int SrcDims, access_mode SrcMode, target SrcTgt,
          typename DestT, access::placeholder IsPlaceholder>
void copy(accessor<SrcT, SrcDims, SrcMode, SrcTgt, IsPlaceholder> src,
          std::shared_ptr<DestT> dest)
----
a@ Copies the contents of the memory object accessed by
[code]#src# into the memory pointed to by [code]#dest#.
[code]#dest# must be a host pointer and must have at least
as many bytes as the range accessed by [code]#src#.  The
type [code]#DestT# must be <<device-copyable>>.

a@
[source]
----
template <typename SrcT, typename DestT, int DestDims, access_mode DestMode,
          target DestTgt, access::placeholder IsPlaceholder>
void copy(std::shared_ptr<SrcT> src,
          accessor<DestT, DestDims, DestMode, DestTgt, IsPlaceholder> dest)
----
a@ Copies the contents of the memory pointed to by [code]#src#
into the memory object accessed by [code]#dest#.
[code]#src# must be a host pointer and must have at least
as many bytes as the range accessed by [code]#dest#.  The type
[code]#SrcT# must be <<device-copyable>>.

a@
[source]
----
template <typename SrcT, int SrcDims, access_mode SrcMode, target SrcTgt,
          typename DestT, access::placeholder IsPlaceholder>
void copy(accessor<SrcT, SrcDims, SrcMode, SrcTgt, IsPlaceholder> src,
          DestT* dest)
----
a@ Copies the contents of the memory object accessed by
[code]#src# into the memory pointed to by [code]#dest#.
[code]#dest# must be a host pointer and must have at least
as many bytes as the range accessed by [code]#src#.  The type
[code]#DestT# must be <<device-copyable>>.

a@
[source]
----
template <typename SrcT, typename DestT, int DestDims, access_mode DestMode,
          target DestTgt, access::placeholder IsPlaceholder>
void copy(const SrcT* src,
          accessor<DestT, DestDims, DestMode, DestTgt, IsPlaceholder> dest)
----
a@ Copies the contents of the memory pointed to by [code]#src#
into the memory object accessed by [code]#dest#.
[code]#src# must be a host pointer and must have at least
as many bytes as the range accessed by [code]#dest#.  The type
[code]#SrcT# must be <<device-copyable>>.

a@
[source]
----
template <typename SrcT, int SrcDims, access_mode SrcMode, target SrcTgt,
          access::placeholder IsSrcPlaceholder, typename DestT, int DestDims,
          access_mode DestMode, target DestTgt,
          access::placeholder IsDestPlaceholder>
void copy(accessor<SrcT, SrcDims, SrcMode, SrcTgt, IsSrcPlaceholder> src,
          accessor<DestT, DestDims, DestMode, DestTgt, IsDestPlaceholder> dest)
----
a@ Copies the contents of the memory object accessed by [code]#src#
into the memory object accessed by [code]#dest#.  The size of the [code]#src#
accessor determines the number of bytes that are copied, and [code]#dest# must
have at least this many bytes.  If the size of [code]#dest# is too small, the
implementation throws a synchronous [code]#exception# with the
[code]#errc::invalid# error code.

a@
[source]
----
template <typename T, int Dims, access_mode Mode, target Tgt,
          access::placeholder IsPlaceholder>
void update_host(accessor<T, Dims, Mode, Tgt, IsPlaceholder> acc)
----
a@ The contents of the memory object accessed via [code]#acc#
on the host are guaranteed to be up-to-date after this
<<command-group>> object execution is complete.

a@
[source]
----
template <typename T, int Dims, access_mode Mode, target Tgt,
          access::placeholder IsPlaceholder>
void fill(accessor<T, Dims, Mode, Tgt, IsPlaceholder> dest, const T& src)
----
a@ Replicates the value of [code]#src# into the
memory object accessed by [code]#dest#.

a@
[source]
----
void memcpy(void* dest, const void* src, size_t numBytes)
----
a@ Copies [code]#numBytes# of data from the pointer [code]#src# to the pointer
[code]#dest#.  The [code]#dest# and [code]#src# parameters must each either be
a host pointer or a pointer within a USM allocation that is accessible on the
handler's device.  If a pointer is to a USM allocation, that allocation must
have been created from the same context as the handler's queue.  For more
detail on USM, please see <<sec:usm>>.

a@
[source]
----
template <typename T> void copy(const T* src, T* dest, size_t count)
----
a@ Copies [code]#count# elements of type [code]#T# from the pointer [code]#src#
to the pointer [code]#dest#.  The [code]#dest# and [code]#src# parameters must
each either be a host pointer or a pointer within a USM allocation that is
accessible on the handler's device.  If a pointer is to a USM allocation, that
allocation must have been created from the same context as the handler's queue.
For more detail on USM, please see <<sec:usm>>.

The type [code]#T# must be <<device-copyable>>.

a@
[source]
----
void memset(void* ptr, int value, size_t numBytes)
----
a@ Fills [code]#numBytes# bytes of memory beginning at address [code]#ptr#
with [code]#value#.  The [code]#ptr# must point within a USM allocation from
the same context as the handler's queue, and the pointer must be accessible
from the queue's device.  Note that [code]#value# is interpreted as an
[code]#unsigned char#.  For more detail on USM, please see <<sec:usm>>.

a@
[source]
----
template <typename T> void fill(void* ptr, const T& pattern, size_t count)
----
a@ Replicates the provided [code]#pattern# into the memory at address
[code]#ptr#.  The [code]#ptr# must point within a USM allocation from the same
context as the handler's queue, and the pointer must be accessible from the
queue's device.  The [code]#pattern# is filled [code]#count# times.  For more
detail on USM, please see <<sec:usm>>.

The type [code]#T# must be <<device-copyable>>.

a@
[source]
----
void prefetch(void* ptr, size_t numBytes)
----
a@ Enqueues a prefetch of [code]#num_bytes# of data starting at address
[code]#ptr#.  The [code]#ptr# must point within a USM allocation from the same
context as the handler's queue, and the pointer must be accessible from the
queue's device.  For more detail on USM, please see <<sec:usm>>.

a@
[source]
----
void mem_advise(void* ptr, size_t numBytes, int advice)
----
a@ Enqueues a command that provides information to the implementation about a
region of USM starting at [code]#ptr# and extending for [code]#numBytes# bytes.
The [code]#ptr# must point within a USM allocation from the same context as the
handler's queue, and the pointer must be accessible from the queue's device.
The values for [code]#advice# are vendor- or backend-specific, with the
exception of the value [code]#0# which reverts the advice for [code]#ptr# to
the default behavior.  For more detail on USM, please see <<sec:usm>>.

|====


The listing below illustrates how to use explicit copy operations in SYCL.
The example copies half of the contents of a [code]#std::vector# into the
device, leaving the rest of the contents of the buffer on the device unchanged.

[source,,linenums]
----
include::{code_dir}/explicitcopy.cpp[lines=4..-1]
----


// %%%%%%%%%%%%%%%%%%%%%%%%%%%% end sycl_explicit_memory %%%%%%%%%%%%%%%%%%%%%%%%%%%%


[[sec:handler.usekernelbundle]]
==== Functions for using a kernel bundle

[source,,linenums]
----
include::{header_dir}/handler/useKernelBundle.h[lines=4..-1]
----

_Effects:_ The <<command-group>> associated with the [code]#handler# will use
<<device-image,device images>> of the [code]#kernel_bundle# [code]#execBundle#
in any of its <<kernel-invocation-command,kernel invocation commands>>.
If the [code]#kernel_bundle# contains multiple <<device-image,device images>>
that are compatible with the <<device>> to which the kernel is submitted, then
the <<device-image>> chosen is implementation-defined.

If the <<command-group>> attempts to invoke a kernel that is not contained by a
compatible device image in [code]#execBundle#, the <<kernel-invocation-command>>
throws a synchronous [code]#exception# with the
[code]#errc::kernel_not_supported# error code.
If the <<command-group>> has a secondary queue, then the [code]#execBundle# must
contain a kernel that is compatible with both the primary queue's device and the
secondary queue's device, otherwise the <<kernel-invocation-command>> throws
this exception.

Since the handler method for setting specialization constants is incompatible
with the kernel bundle method, applications should not call this function if
[code]#handler::set_specialization_constant()# has been previously called for
this same <<command-group>>.

_Throws:_

  * An [code]#exception# with the [code]#errc::invalid# error code if the
    <<context>> associated with the <<handler>> via its associated primary
    <<queue>> or the <<context>> associated with the secondary <<queue>> (if
    provided) is different from the <<context>> associated with the
    <<kernel-bundle>> specified by [code]#execBundle#.

  * An [code]#exception# with the [code]#errc::invalid# error code if
    [code]#handler::set_specialization_constant()# has been called for this
    <<command-group>>.


=== Specialization constants

Device code can make use of <<specialization-constant,specialization constants>>
which represent constants whose values can be set dynamically during execution
of the <<sycl-application>>.
The values of these constants are fixed when a <<sycl-kernel-function>> is
invoked, and they do not change during the execution of the kernel.
However, the application is able to set a new value for a specialization
constant each time a kernel is invoked, so the values can be tuned differently
for each invocation.

There are two methods for an application to use specialization constants, one
method requires creating a [code]#kernel_bundle# object and the other does not.
The syntax for both methods is mostly the same.
Both methods declare specialization constants in the same way, and kernels read
their values in the same way.
The main difference is whether their values are set via
[code]#handler::set_specialization_constant()# or via
[code]#kernel_bundle::set_specialization_constant()#.
These two methods are incompatible with one another, so they may not both be
used by the same <<command-group>>.

[NOTE]
====
Implementations that support online compilation of kernel bundles will likely
implement both methods of specialization constants using kernel bundles.
Therefore, applications should expect that there is some overhead associated
with invoking a kernel with new values for its specialization constants.
A typical implementation records the values of specialization constants set via
[code]#handler::set_specialization_constant()# and remembers these values until
a kernel is invoked (e.g. via [code]#parallel_for()#).
At this point, the implementation determines the bundle that contains the
invoked kernel.
If that bundle has already been compiled for the handler's device and compiled
with the correct values for the specialization constants, the kernel is
scheduled for invocation.
Otherwise, the implementation compiles the bundle before scheduling the kernel
for invocation.
Therefore, applications that frequently change the values of specialization
constants may see an overhead associated with recompilation of the kernel's
bundle.
====


==== Declaring a specialization constant

Specialization constants must be declared using the [code]#specialization_id#
class with the following restrictions:

* the template parameter [code]#T# must be a <<device-copyable>> type;
* the [code]#specialization_id# variable must be declared as [code]#constexpr#;
* the [code]#specialization_id# variable must be declared in either namespace
  scope or in class scope;
* if the [code]#specialization_id# variable is declared in class scope, it must
  have public accessibility when referenced from namespace scope;
* the [code]#specialization_id# variable may not be shadowed by another
  identifier [code]#X# which has the same name and is declared in an
  [code]#inline# namespace, such that the [code]#specialization_id# variable is
  no longer accessible after the declaration of [code]#X#;
* if the [code]#specialization_id# variable is declared in a namespace, none of
  the enclosing namespace names [code]#N# may be shadowed by another identifier
  [code]#X# which has the same name as [code]#N# and is declared in an
  [code]#inline# namespace, such that [code]#N# is no longer accessible after
  the declaration of [code]#X#.

[NOTE]
====
The expectation is that some implementations may conceptually insert code at the
end of a translation unit which references each `specialization_id` variable
that is declared in that translation unit.
The restrictions listed above make this possible by ensuring that these
variables are accessible at the end of the translation unit.
====

The following example illustrates some of these restrictions:

[source,,linenums]
----
include::{code_dir}/specialization_id.cpp[lines=4..-1]
----

A synopsis of this class is shown below.

[source,,linenums]
----
include::{header_dir}/expressingParallelism/classSpecializationId.h[lines=4..-1]
----

===== Constructors

[source]
----
template <class... Args> explicit constexpr specialization_id(Args&&... args);
----

_Constraints:_ Available only when [code]#+std::is_constructible_v<T, Args...>+#
evaluates to [code]#true#.

_Effects:_ Constructs a [code]#specialization_id# containing an instance of
[code]#T# initialized with [code]#+args...+#, which represents the
specialization constant's default value.

===== Special member functions

[source]
----
specialization_id(const specialization_id& rhs) = delete;            // (1)
specialization_id(specialization_id&& rhs) = delete;                 // (2)
specialization_id& operator=(const specialization_id& rhs) = delete; // (3)
specialization_id& operator=(specialization_id&& rhs) = delete;      // (4)
----

  . Deleted copy constructor.
  . Deleted move constructor.
  . Deleted copy assignment operator.
  . Deleted move assignment operator.


==== Setting and getting the value of a specialization constant

If the application uses specialization constants without creating a
[code]#kernel_bundle# object, it can set and get their values from
<<command-group-scope>> by calling member functions of the [code]#handler#
class.
These member functions have a template parameter [code]#SpecName# whose value
must be a reference to a variable of type [code]#specialization_id#, which
defines the type and default value of the specialization constant.

When not using a kernel bundle, the value of a specialization constant that is
used in a kernel invoked from a <<command-group>> is affected by calls to set
its value from that same <<command-group>>, but it is not affected by calls from
other <<command-group,command groups>> even if those calls are from another
invocation of the same <<command-group-function-object>>.

[source]
----
template <auto& SpecName>
void set_specialization_constant(
    typename std::remove_reference_t<decltype(SpecName)>::value_type value);
----

_Effects:_ Sets the value of the specialization constant whose address is
[code]#SpecName# for this handler's <<command-group>>.
If the specialization constant's value was previously set in this same
<<command-group>>, the value is overwritten.

This function may be called even if the specialization constant [code]#SpecName#
isn't used by the kernel that is invoked by this handler's <<command-group>>.
Doing so has no effect on the invoked kernel.

_Throws:_

  * An [code]#exception# with the [code]#errc::invalid# error code if a kernel
    bundle has been bound to the [code]#handler# via
    [code]#use_kernel_bundle()#.

[source]
----
template <auto& SpecName>
typename std::remove_reference_t<decltype(SpecName)>::value_type
get_specialization_constant();
----

_Returns:_ The value of the specialization constant whose address is
[code]#SpecName# for this handler's <<command-group>>.
If the value was previously set in this handler's <<command-group>>, that value
is returned.
Otherwise, the specialization constant's default value is returned.

_Throws:_

  * An [code]#exception# with the [code]#errc::invalid# error code if a kernel
    bundle has been bound to the [code]#handler# via
    [code]#use_kernel_bundle()#.


[[sec:spec-constants.device-code]]
==== Reading the value of a specialization constant from device code

In order to read the value of a specialization constant from device code, the
<<sycl-kernel-function>> must be declared to take an object of type
[code]#kernel_handler# as its last parameter.
The <<sycl-runtime>> constructs this object, which has a member function for
reading the specialization constant's value.
A synopsis of this class is shown below.

[source,,linenums]
----
include::{header_dir}/expressingParallelism/classKernelHandler.h[lines=4..-1]
----


===== Member functions

[source,,linenums]
----
template<auto& SpecName>
typename std::remove_reference_t<decltype(SpecName)>::value_type
get_specialization_constant();
----

_Returns:_ The value of the <<specialization-constant>> whose address is
[code]#SpecName#.
For a kernel invoked from a <<command-group>> that was not bound to a kernel
bundle, the value is the same as what would have been returned if
[code]#handler::get_specialization_constant()# was called immediately before
invoking the kernel.
For a kernel invoked from a <<command-group>> that was bound to a kernel bundle,
the value is the same as what would be returned if
[code]#kernel_bundle::get_specialization_constant()# was called on the bound
bundle.


==== Example usage

The following example performs a convolution and uses
<<specialization-constant,specialization constants>> to set the values of the
coefficients.

[source,,linenums]
----
include::{code_dir}/usingSpecConstants.cpp[lines=4..-1]
----


[[subsec:interfaces.hosttasks]]
== Host tasks


[[sec:interfaces.hosttasks.overview]]
=== Overview

A <<host-task>> is a native {cpp} callable which is scheduled by the
<<sycl-runtime>>.
A <<host-task>> is submitted to a <<queue>> via a <<command-group>> by a
<<host-task-command>>.

When a <<host-task-command>> is submitted to a <<queue>> it is scheduled based
on its data dependencies with other <<command,commands>> including
<<kernel-invocation-command,kernel invocation commands>> and asynchronous
copies, resolving any requisites created by <<accessor,accessors>> attached to
the <<command-group>> as defined in <<sub.section.memmodel.app>>.

Since a <<host-task>> is invoked directly by the <<sycl-runtime>> rather than
being compiled as a <<sycl-kernel-function>>, it does not have the same
restrictions as a <<sycl-kernel-function>>, and can therefore contain any
arbitrary {cpp} code.

Capturing <<accessor,accessors>> in a <<host-task>> is allowed, however,
capturing or using any other SYCL class that has reference semantics (see
<<sec:reference-semantics>>) is undefined behavior.

A <<host-task>> can be enqueued on any <<queue>> and the callable will be
invoked directly by the SYCL runtime, regardless of which <<device>> the
<<queue>> is associated with.

A <<host-task>> is enqueued on a <<queue>> via the [code]#host_task# member
function of the [code]#handler# class.
The <<event>> returned by the submission of the associated <<command-group>>
enters the completed state (corresponding to a status of
[code]#info::event_command_status::complete#) once the invocation of the
provided {cpp} callable has returned.
Any uncaught exception thrown during the execution of a <<host-task>> will be
turned into an <<async-error>> that can be handled as described in
<<subsubsec:exception.async>>.

A <<host-task>> can optionally be used to interoperate with the
<<native-backend-object,native backend objects>> associated with the <<queue>>
executing the <<host-task>>, the <<context>> that the <<queue>> is associated
with, the <<device>> that the <<queue>> is associated with and the
<<accessor,accessors>> that have been captured in the callable, via an optional
[code]#interop_handle# parameter.

This allows <<host-task,host tasks>> to be used for two purposes: either as a
task which can perform arbitrary {cpp} code within the scheduling of the
<<sycl-runtime>> or as a task which can perform interoperability at a point
within the scheduling of the <<sycl-runtime>>.

For the former use case, construct a buffer accessor with
[code]#target::host_task# or an image accessor with
[code]#image_target::host_task#.
This makes the buffer or image available on the host during execution of the
<<host-task>>.

For the latter case, construct a buffer accessor with [code]#target::device# or
[code]#target::constant_buffer#, or construct an image accessor with
[code]#image_target::device#.
This makes the buffer or image available on the device that is associated with
the queue used to submit the <<host-task>>, so that it can be accessed via
interoperability member functions provided by the [code]#interop_handle# class.

Local <<accessor,accessors>> cannot be used within a <<host-task>>.

[NOTE]
====
If a C++ lambda is passed to a <<host-task>>, the lambda may capture by
reference or by value.
Since the <<host-task>> callable executes asynchronously, care must be taken to
ensure that lifetimes of objects captured by reference by a <<host-task>> lambda
last at least until the <<host-task>> completes.
====

// TODO: access mode/target resolution rules

[source,,linenums]
----
include::{header_dir}/hostTask/hostTaskSynopsis.h[lines=4..-1]
----


[[subsec:interfaces.hosttasks.interophandle]]
=== Class [code]#interop_handle#

The [code]#interop_handle# class is an abstraction over the <<queue>> which is
being used to invoke the <<host-task>> and its associated <<device>> and
<<context>>.
It also represents the state of the <<sycl-runtime>> dependency model at the
point the <<host-task>> is invoked.

The [code]#interop_handle# class provides access to the
<<native-backend-object>> associated with the <<queue>>, <<device>>, <<context>>
and any <<buffer,buffers>> or <<image,images>> that are captured in the callable
being invoked in order to allow a <<host-task>> to be used for interoperability
purposes.

An [code]#interop_handle# cannot be constructed by user-code, only by the
<<sycl-runtime>>.

[source,,linenums]
----
include::{header_dir}/hostTask/classInteropHandle.h[lines=4..-1]
----


[[subsec:interfaces.hosttask.interophandle.ctrs]]
==== Constructors

[source,,linenums]
----
include::{header_dir}/hostTask/classInteropHandle/constructors.h[lines=4..-1]
----

  . Private implementation-defined constructor with unspecified arguments so
    that the <<sycl-runtime>> can construct a [code]#interop_handle#.
  . Explicitly deleted default constructor.

[[subsec:interfaces.hosttask.interophandle.getbackend]]
==== Member functions

[source,,linenums]
----
include::{header_dir}/hostTask/classInteropHandle/getbackend.h[lines=4..-1]
----

  . _Returns:_ Returns a [code]#backend# identifying the <<backend>> associated
      with the <<queue>> associated with this [code]#interop_handle#.

[[subsec:interfaces.hosttask.interophandle.getnative]]
==== Template member functions [code]#get_native_*#

[source,,linenums]
----
include::{header_dir}/hostTask/classInteropHandle/getnativeX.h[lines=4..-1]
----

  . _Constraints:_ Available only if the optional interoperability function
    [code]#get_native# taking a [code]#buffer# is available and if
    [code]#accTarget# is [code]#target::device#.
+
--
_Returns:_ The <<native-backend-object>> associated with the underlying
<<buffer>> of <<accessor>> [code]#bufferAcc#.
The <<native-backend-object>> returned must be in a state where it represents
the memory in its current state within the <<sycl-runtime>> dependency model and
is capable of being used in a way appropriate for the associated <<backend>>.
It is undefined behavior to use the <<native-backend-object>> outside of the
scope of the <<host-task>>.

_Throws:_ An [code]#exception# with the [code]#errc::invalid# error code if the
<<accessor>> [code]#bufferAcc# was not registered with the <<command-group>>
which contained the <<host-task>>.
Must throw an [code]#exception# with the [code]#errc::backend_mismatch# error
code if [code]#Backend != get_backend()#.
--
  . _Constraints:_ Available only if the optional interoperability function
    [code]#get_native# taking an [code]#unsampled_image# is available.
+
--
_Returns:_ The <<native-backend-object>> associated with with the underlying
[code]#unsampled_image# of <<accessor>> [code]#imageAcc#.
The <<native-backend-object>> returned must be in a state where it represents
the memory in its current state within the <<sycl-runtime>> dependency model and
is capable of being used in a way appropriate for the associated <<backend>>.
It is undefined behavior to use the <<native-backend-object>> outside of the
scope of the <<host-task>>.

_Throws:_ An [code]#exception# with the [code]#errc::invalid# error code if the
<<accessor>> [code]#imageAcc# was not registered with the <<command-group>>
which contained the <<host-task>>.
--
  . _Constraints:_ Available only if the optional interoperability function
    [code]#get_native# taking an [code]#sampled_image# is available.
+
--
_Returns:_ The <<native-backend-object>> associated with with the underlying
[code]#sampled_image# of <<accessor>> [code]#imageAcc#.
The <<native-backend-object>> returned must be in a state where it represents
the memory in its current state within the <<sycl-runtime>> dependency model and
is capable of being used in a way appropriate for the associated <<backend>>.
It is undefined behavior to use the <<native-backend-object>> outside of the
scope of the <<host-task>>.

_Throws:_ An [code]#exception# with the [code]#errc::invalid# error code if the
<<accessor>> [code]#imageAcc# was not registered with the <<command-group>>
which contained the <<host-task>>.
Must throw an [code]#exception# with the [code]#errc::backend_mismatch# error
code if [code]#Backend != get_backend()#.
--
  . _Constraints:_ Available only if the optional interoperability function
    [code]#get_native# taking a [code]#queue# is available.
+
--
_Returns:_ The <<native-backend-object>> associated with the <<queue>> that the
<<host-task>> was submitted to.
If the <<command-group>> was submitted with a secondary <<queue>> and the
fall-back was triggered, the <<queue>> that is associated with the
[code]#interop_handle# must be the fall-back <<queue>>.
The <<native-backend-object>> returned must be in a state where it is capable of
being used in a way appropriate for the associated <<backend>>.
It is undefined behavior to use the <<native-backend-object>> outside of the
scope of the <<host-task>>.

_Throws:_ Must throw an [code]#exception# with the
[code]#errc::backend_mismatch# error code if [code]#Backend != get_backend()#.
--
  . _Constraints:_ Available only if the optional interoperability function
    [code]#get_native# taking a [code]#device# is available.
+
--
_Returns:_ The <<native-backend-object>> associated with the <<device>> that is
associated with the <<queue>> that the <<host-task>> was submitted to.
The <<native-backend-object>> returned must be in a state where it is capable of
being used in a way appropriate for the associated <<backend>>.
It is undefined behavior to use the <<native-backend-object>> outside of the
scope of the <<host-task>>.

_Throws:_ Must throw an [code]#exception# with the
[code]#errc::backend_mismatch# error code if [code]#Backend != get_backend()#.
--
  . _Constraints:_ Available only if the optional interoperability function
    [code]#get_native# taking a [code]#context# is available.
+
--
_Returns:_ The <<native-backend-object>> associated with the <<context>> that is
associated with the <<queue>> that the <<host-task>> was submitted to.
The <<native-backend-object>> returned must be in a state where it is capable of
being used in a way appropriate for the associated <<backend>>.
It is undefined behavior to use the <<native-backend-object>> outside of the
scope of the <<host-task>>.

_Throws:_ Must throw an [code]#exception# with the
[code]#errc::backend_mismatch# error code if [code]#Backend != get_backend()#.
--


[[subsec:interfaces.hosttask.handler]]
=== Additions to the [code]#handler# class

This section describes member functions in the <<handler>> class that are used
with host tasks.

[source,,linenums]
----
include::{header_dir}/hostTask/classHandler/hostTask.h[lines=4..-1]
----

  . _Effects:_ Enqueues an implementation-defined command to the
    <<sycl-runtime>> to invoke [code]#hostTaskCallable# exactly once.
    The scheduling of the invocation of [code]#hostTaskCallable# in relation to
    other <<command,commands>> enqueued to the <<sycl-runtime>> must be in
    accordance with the dependency model described in
    <<sub.section.memmodel.app>>.
    Initializes an [code]#interop_handle# object and passes it to
    [code]#hostTaskCallable# when it is invoked if [code]#std::is_invocable_v<T,
    interop_handle># evaluates to [code]#true#, otherwise invokes
    [code]#hostTaskCallable# as a nullary function.


[[sec:interfaces.bundles]]
== Kernel bundles

Kernel bundles provide several features to a <<sycl-application>>.
For implementations that support an online compiler, they provide fine grained
control over the online compilation of device code.
For example, an application can use a kernel bundle to compile its
<<kernel,kernels>> at a specific time during the application's execution (such
as during its initialization), rather than relying on the implementation's
default behavior (which may not compile kernels until they are submitted).

Kernel bundles also provide a way for the application to set the values of
specialization constants in many kernels before any of them are submitted to a
device, which could potentially be more efficient in some cases.

Kernel bundles provide a way for the application to introspect its kernels.
For example, an application can use a bundle to query a kernel's work-group size
when it is run on a specific device.

Finally, kernel bundles provide an extension point to interoperate with backend
and device specific features.
Some examples of this include invocation of device specific built-in kernels,
online compilation of kernel code with vendor specific options, or
interoperation with kernels created with backend APIs.


=== Overview

A kernel bundle is a high-level abstraction which represents a set of
<<kernel,kernels>> that are associated with a <<context>> and can be executed on
a number of <<device,devices>>, where each device is associated with that same
context.
Depending on how a bundle is obtained, it could represent all of the
<<sycl-kernel-function,SYCL kernel functions>> in the <<sycl-application>>, or a
certain subset of them.

A kernel bundle is composed of one or more <<device-image,device images>>, where
each device image is an indivisible unit of compilation and/or linking.
When the <<sycl-runtime>> compiles or links one of the kernels represented by
the device image, it must also compile or link any other kernels the device
image represents.
Once a device image is compiled and linked, any of the other kernels which that
device image represents may be invoked without further compilation or linking.

Each <<sycl-kernel-function>> a bundle represents must reside in at least one of
the bundle's device images.
However, it is not necessary for each device image to contain all of the kernel
functions that the bundle represents.
The granularity in which kernel functions are grouped into device images is an
implementation detail.

[NOTE]
====
To illustrate the intent of device images, a hypothetical implementation could
represent an application's kernel functions in both the SPIR-V format and also
in a native device code format.
The implementation's ahead-of-time compiler in this example produces device
images with native code for certain devices and also produces SPIR-V device
images for use with other devices.
Note that in such an implementation, a particular kernel function could be
represented in more than one device image.

An implementation could choose to have all kernel functions from all translation
units grouped together in a single device image, to have each kernel function
represented in its own device image, or to group kernel functions in some other
way.
====

Each device associated with a kernel bundle must have at least one compatible
device image, meaning that the implementation can either invoke the image's
kernel functions directly on the device or that the implementation can translate
the device image into a format that allows it to invoke the kernel functions.

An outcome of this definition is that each kernel function in a bundle must be
invocable on at least one of the devices associated with the bundle.
However, it is not necessary for every kernel function in the bundle to be
invocable on every associated device.

[NOTE]
====
One common reason why a kernel function might not be invocable on every device
associated with a bundle is if the kernel uses optional device features.
It's possible that these features are available to only some devices in the
bundle.

The use of optional device features could affect how the implementation groups
kernels into device images, depending on how these features are represented.
For example, consider an implementation where the optional feature is
represented in SPIR-V but translation of that SPIR-V into native code will fail
if the target device does not support the feature.
In such an implementation, kernels that use optional features should not be
grouped into the same device image as kernels that do not use these features.
Since a device image is an indivisible unit of compilation, doing so would cause
a compilation failure if a kernel K1 is invoked on a device D1 if K1 happened to
reside in the same device image as another kernel K2 that used a feature which
is not supported on device D1.

See <<sec:optional-kernel-features>> for more about optional device features.
====

A <<sycl-application>> can obtain a kernel bundle by calling one of the
overloads of the [code]#get_kernel_bundle()# free function.
Certain backends may provide additional mechanisms for obtaining bundles with
other representations.
If this is supported, the backend specification document will describe the
details.

Once a kernel bundle has been obtained there are a number of free functions for
performing compilation, linking and joining.
Once a bundle is compiled and linked, the application can invoke kernels from
the bundle by calling [code]#handler::use_kernel_bundle()# as described in
<<sec:handler.usekernelbundle>>.


[[sec:interfaces.bundles.overview.synopsis]]
=== Synopsis

[source,,linenums]
----
include::{header_dir}/bundle/freeFunctions.h[lines=4..-1]
----


=== Fixed-function built-in kernels

SYCL allows a <<backend>> to expose fixed functionality as non-programmable
built-in kernels.
The availability and behavior of these built-in kernels are backend specific and
are not required to follow the SYCL execution and memory models.
However, the basic interface is common to all backends.


[[sec:interfaces.bundles.bundlestate]]
=== Bundle states

A <<kernel-bundle>> can be in one of three different <<bundle-state,bundle
states>> which are represented by an enum class called [code]#bundle_state#.
<<table.bundles.states>> describes the semantics of these three states.

The states form a progression.
A bundle in [code]#bundle_state::input# can be translated into
[code]#bundle_state::object# by online compilation of the bundle.
A bundle in [code]#bundle_state::object# can be translated into
[code]#bundle_state::executable# by online linking.

[NOTE]
====
Each implementation is free to define the "online compilation" and "online
linking" operations as it sees fit, so long as this progression of bundle states
is preserved and so long as the bundles in each state behave as specified.
====

There is no requirement that an implementation must expose kernels in
[code]#bundle_state::input# or [code]#bundle_state::object#.
In fact, an implementation could expose some kernels in these states but not
others.
For example, this behavior could be controlled by implementation specific
options to the ahead-of-time compiler.
Kernels that are not exposed in these states cannot be online compiled or online
linked by the application.

All kernels defined in the <<sycl-application>>, however, must be exposed in
[code]#bundle_state::executable# because this is the only state that allows a
kernel to be invoked on a device.
Device built-in kernels are also exposed in [code]#bundle_state::executable#.

If an application exposes a bundle in [code]#bundle_state::input# for a device
D, then the implementation must also provide an online compiler for device D.
Therefore, an application need not explicitly test for
[code]#aspect::online_compiler# if it successfully obtains a bundle in
[code]#bundle_state::input# for that device.
Likewise, an implementation must provide an online linker for device D if it
exposes a bundle in [code]#bundle_state::object# for device D.

[[table.bundles.states]]
.Enumeration of possible bundle states
[width="100%",options="header",separator="@",cols="35%,65%"]
|====
@ Bundle State @ Description
a@
[source]
----
bundle_state::input
----
   a@ The <<device-image,device images>> in the kernel bundle have a format
      that must be compiled and linked before their kernels can be invoked.
      For example, an implementation could use this state for device images
      that are stored in an intermediate language format or for device images
      that are stored as source code strings.

a@
[source]
----
bundle_state::object
----
   a@ The <<device-image,device images>> in the kernel bundle have a format
      that must be linked before their kernels can be invoked.

a@
[source]
----
bundle_state::executable
----
   a@ The <<device-image,device images>> in the kernel bundle are in a format
      that allows them to be invoked on a device.  For example, an
      implementation could use this state for device images that have been
      compiled into the device's native code.

|====


=== Kernel identifiers

Some of the functions related to kernel bundles take an input parameter of type
[code]#kernel_id# which identifies a kernel.
A synopsis of the [code]#kernel_id# class is shown below along with a
description of its member functions.
Additionally, this class provides the common special member functions and common
member functions that are listed in <<sec:reference-semantics>> in
<<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>>, respectively.

As with all SYCL objects that have the common reference semantics, kernel
identifiers are equality comparable.
Two [code]#kernel_id# objects compare equal if and only if they refer to the
same application kernel or to the same device built-in kernel.

There is no public default constructor for this class.

[source,,linenums]
----
include::{header_dir}/bundle/kernelIdClass.h[lines=4..-1]
----

[source]
----
const char* get_name() const noexcept;
----

_Returns:_ An implementation-defined null-terminated string containing the name
of the kernel.
There is no guarantee that this name is unique amongst all the kernels, nor is
there a guarantee that the name is stable from one run of the application to
another.
The lifetime of the memory containing the name is unspecified.

[NOTE]
====
In practice, the lifetime of the memory containing the name will typically
extend until the application terminates, unless the kernel associated with the
name comes from a dynamic library.
In this case, the lifetime of the memory may end if the dynamic library is
unloaded.
====


=== Obtaining a kernel identifier

An application can obtain an identifier for a kernel that is defined in the
application by calling one of the following free functions, or it may obtain an
identifier for a device's built-in kernels by querying the device with
[code]#info::device::built_in_kernel_ids#.

[source]
----
template <typename KernelName> kernel_id get_kernel_id();
----

_Preconditions:_ The template parameter [code]#KernelName# must be the
<<type-kernel-name>> of a kernel that is defined in the <<sycl-application>>.
Since lambda expressions have no standard type name, kernels defined as lambda
expressions must specify a [code]#KernelName# in their
<<kernel-invocation-command>> in order to obtain their identifier via this
function.
Applications which call [code]#get_kernel_id()# for a [code]#KernelName# that is
not defined are ill formed, and the implementation must issue a diagnostic in
this case.

_Returns:_ The identifier of the kernel associated with [code]#KernelName#.

[source]
----
std::vector<kernel_id> get_kernel_ids();
----

_Returns:_ A vector with the identifiers for all kernels defined in the
<<sycl-application>>.
This does not include identifiers for any device built-in kernels.


=== Obtaining a kernel bundle

A <<sycl-application>> can obtain a kernel bundle by calling one of the
overloads of the free function [code]#get_kernel_bundle()#.
The implementation may return a bundle that consists of device images that were
created by the ahead-of-time compiler, or it may call the online compiler or
linker to create the bundle's device images in the requested state.
A bundle may also contain device images that represent a device's built-in
kernels.

When [code]#get_kernel_bundle()# is used to obtain a kernel bundle in
[code]#bundle_state::object# or [code]#bundle_state::executable#, any
specialization constants in the bundle will have their default values.

[source]
----
template <bundle_state State>
kernel_bundle<State> get_kernel_bundle(const context& ctxt,
                                       const std::vector<device>& devs);
----

_Returns:_ A kernel bundle in state [code]#State# which contains all of the
<<kernel,kernels>> in the application which are compatible with at least one of
the devices in [code]#devs#.
This does not include any device built-in kernels.
The bundle's set of associated devices is [code]#devs# (with any duplicate
devices removed).

Since the implementation may not represent all kernels in
[code]#bundle_state::input# or [code]#bundle_state::object#, calling this
function with one of those states may return a bundle that is missing some of
the application's kernels.

_Throws:_

  * An [code]#exception# with the [code]#errc::invalid# error code if any of the
    devices in [code]#devs# is not one of devices contained by the context
    [code]#ctxt# or is not a <<descendent-device>> of some device in
    [code]#ctxt#.
  * An [code]#exception# with the [code]#errc::invalid# error code if the
    [code]#devs# vector is empty.
  * An [code]#exception# with the [code]#errc::invalid# error code if
    [code]#State# is [code]#bundle_state::input# and any device in [code]#devs#
    does not have [code]#aspect::online_compiler#.
  * An [code]#exception# with the [code]#errc::invalid# error code if
    [code]#State# is [code]#bundle_state::object# and any device in [code]#devs#
    does not have [code]#aspect::online_linker#.
  * An [code]#exception# with the [code]#errc::build# error code if
    [code]#State# is [code]#bundle_state::object# or
    [code]#bundle_state::executable#, if the implementation needs to perform an
    online compile or link, and if the online compile or link fails.

[source]
----
template <bundle_state State>
kernel_bundle<State> get_kernel_bundle(const context& ctxt,
                                       const std::vector<device>& devs,
                                       const std::vector<kernel_id>& kernelIds);
----

_Returns:_ A kernel bundle in state [code]#State# which contains all of the
device images that are compatible with at least one of the devices in
[code]#devs#, further filtered to contain only those device images that contain
at least one of the kernels with the given identifiers.
These identifiers may represent kernels that are defined in the application,
device built-in kernels, or a mixture of the two.
Since the device images may group many kernels together, the returned bundle may
contain additional kernels beyond those that are requested in [code]#kernelIds#.
The bundle's set of associated devices is [code]#devs# (with duplicate devices
removed).

Since the implementation may not represent all kernels in
[code]#bundle_state::input# or [code]#bundle_state::object#, calling this
function with one of those states may return a bundle that is missing some of
the kernels in [code]#kernelIds#.
The application can test for this via [code]#kernel_bundle::has_kernel()#.

_Throws:_

  * An [code]#exception# with the [code]#errc::invalid# error code if any of the
    kernels identified by [code]#kernelIds# are incompatible with all devices in
    [code]#devs#.
  * An [code]#exception# with the [code]#errc::invalid# error code if any of the
    devices in [code]#devs# is not one of devices contained by the context
    [code]#ctxt# or is not a <<descendent-device>> of some device in
    [code]#ctxt#.
  * An [code]#exception# with the [code]#errc::invalid# error code if the
    [code]#devs# vector is empty.
  * An [code]#exception# with the [code]#errc::invalid# error code if
    [code]#State# is [code]#bundle_state::input# and any device in [code]#devs#
    does not have [code]#aspect::online_compiler#.
  * An [code]#exception# with the [code]#errc::invalid# error code if
    [code]#State# is [code]#bundle_state::object# and any device in [code]#devs#
    does not have [code]#aspect::online_linker#.
  * An [code]#exception# with the [code]#errc::build# error code if
    [code]#State# is [code]#bundle_state::object# or
    [code]#bundle_state::executable#, if the implementation needs to perform an
    online compile or link, and if the online compile or link fails.

[source]
----
template <bundle_state State, typename Selector>
kernel_bundle<State> get_kernel_bundle(const context& ctxt,
                                       const std::vector<device>& devs,
                                       Selector selector);
----

_Preconditions:_ The [code]#selector# must be a unary predicate whose return
value is convertible to [code]#bool# and whose parameter is [code]#const
device_image<State>&#.

_Effects:_ The predicate function [code]#selector# is called once for every
device image in the application of state [code]#State# which is compatible with
at least one of the devices in [code]#devs#.
The function's return value determines whether a device image is included in the
new kernel bundle.
The [code]#selector# is called only for device images that contain kernels
defined in the application, not for device images that contain device built-in
kernels.

_Returns:_ A kernel bundle in state [code]#State# which contains all of the
device images for which the [code]#selector# returns [code]#true#.
The bundle's set of associated devices is [code]#devs# (with duplicate devices
removed).

_Throws:_

  * An [code]#exception# with the [code]#errc::invalid# error code if any of the
    devices in [code]#devs# is not one of devices contained by the context
    [code]#ctxt# or is not a <<descendent-device>> of some device in
    [code]#ctxt#.
  * An [code]#exception# with the [code]#errc::invalid# error code if the
    [code]#devs# vector is empty.
  * An [code]#exception# with the [code]#errc::invalid# error code if
    [code]#State# is [code]#bundle_state::input# and any device in [code]#devs#
    does not have [code]#aspect::online_compiler#.
  * An [code]#exception# with the [code]#errc::invalid# error code if
    [code]#State# is [code]#bundle_state::object# and any device in [code]#devs#
    does not have [code]#aspect::online_linker#.

[NOTE]
====
This function is intended to be used in conjunction with backend specific APIs
that allow the application to choose device images based on backend specific
criteria.

This function does not call the online compiler or linker to translate device
images into state [code]#State#.
If the application wants to select specific device images and also compile or
link them into the desired state, it can do this by calling [code]#compile()# or
[code]#link()# and then optionally joining several bundles together with
[code]#join()#.
====

[source]
----
template <bundle_state State> // (1)
kernel_bundle<State> get_kernel_bundle(const context& ctxt);

template <bundle_state State> // (2)
kernel_bundle<State> get_kernel_bundle(const context& ctxt,
                                       const std::vector<kernel_id>& kernelIds);

template <bundle_state State, typename Selector> // (3)
kernel_bundle<State> get_kernel_bundle(const context& ctxt, Selector selector);
----

  . Equivalent to [code]#get_kernel_bundle<State>(ctxt, ctxt.get_devices())#.
  . Equivalent to [code]#get_kernel_bundle<State>(ctxt, ctxt.get_devices(),
    kernelIds)#.
  . Equivalent to [code]#get_kernel_bundle<State>(ctxt, ctxt.get_devices(),
    selector)#.

[source]
----
template <typename KernelName, bundle_state State> // (1)
kernel_bundle<State> get_kernel_bundle(const context& ctxt);

template <typename KernelName, bundle_state State> // (2)
kernel_bundle<State> get_kernel_bundle(const context& ctxt,
                                       const std::vector<device>& devs);
----

_Preconditions:_ The template parameter [code]#KernelName# must be the
<<type-kernel-name>> of a kernel that is defined in the <<sycl-application>>.
Since lambda expressions have no standard type name, kernels defined as lambda
expressions must specify a [code]#KernelName# in their
<<kernel-invocation-command>> in order to use these functions.
Applications which call these functions for a [code]#KernelName# that is not
defined are ill formed, and the implementation must issue a diagnostic in this
case.

  . Equivalent to [code]#get_kernel_bundle<State>(ctxt, ctxt.get_devices(),
    {get_kernel_id<KernelName>()})#.
  . Equivalent to [code]#get_kernel_bundle<State>(ctxt, devs,
    {get_kernel_id<KernelName>()})#.


=== Querying if a kernel bundle exists

Most overloads of [code]#get_kernel_bundle()# have a matching overload of the
free function [code]#has_kernel_bundle()# which checks to see if a kernel bundle
with the requested characteristics exists.

[source]
----
template <bundle_state State>
bool has_kernel_bundle(const context& ctxt, const std::vector<device>& devs);
----

_Returns:_ [code]#true# only if all of the following are true:

  * The application defines at least one <<kernel>> that is compatible with at
    least one of the devices in [code]#devs#, and that kernel can be represented
    in a device image of state [code]#State#.
  * If [code]#State# is [code]#bundle_state::input#, all devices in [code]#devs#
    have [code]#aspect::online_compiler#.
  * If [code]#State# is [code]#bundle_state::object#, all devices in
    [code]#devs# have [code]#aspect::online_linker#.

_Throws:_

  * An [code]#exception# with the [code]#errc::invalid# error code if any of the
    devices in [code]#devs# is not one of devices contained by the context
    [code]#ctxt# or is not a <<descendent-device>> of some device in
    [code]#ctxt#.
  * An [code]#exception# with the [code]#errc::invalid# error code if the
    [code]#devs# vector is empty.

[source]
----
template <bundle_state State>
bool has_kernel_bundle(const context& ctxt, const std::vector<device>& devs,
                       const std::vector<kernel_id>& kernelIds);
----

_Returns:_ [code]#true# only if all of the following are true:

  * Each of the kernels in [code]#kernelIds# can be represented in a device
    image of state [code]#State#.
  * Each of the kernels in [code]#kernelIds# is compatible with at least one of
    the devices in [code]#devs#.
  * If [code]#State# is [code]#bundle_state::input#, all devices in [code]#devs#
    have [code]#aspect::online_compiler#.
  * If [code]#State# is [code]#bundle_state::object#, all devices in
    [code]#devs# have [code]#aspect::online_linker#.

_Throws:_

  * An [code]#exception# with the [code]#errc::invalid# error code if any of the
    devices in [code]#devs# is not one of devices contained by the context
    [code]#ctxt# or is not a <<descendent-device>> of some device in
    [code]#ctxt#.
  * An [code]#exception# with the [code]#errc::invalid# error code if the
    [code]#devs# vector is empty.

[source]
----
template <bundle_state State> // (1)
bool has_kernel_bundle(const context& ctxt);

template <bundle_state State> // (2)
bool has_kernel_bundle(const context& ctxt,
                       const std::vector<kernel_id>& kernelIds);
----

  . Equivalent to [code]#has_kernel_bundle(ctxt, ctxt.get_devices())#.
  . Equivalent to [code]#has_kernel_bundle<State>(ctxt, ctxt.get_devices(),
    kernelIds)#.

[source]
----
template <typename KernelName, bundle_state State> // (1)
bool has_kernel_bundle(const context& ctxt);

template <typename KernelName, bundle_state State> // (2)
bool has_kernel_bundle(const context& ctxt, const std::vector<device>& devs);
----

_Preconditions:_ The template parameter [code]#KernelName# must be the
<<type-kernel-name>> of a kernel that is defined in the <<sycl-application>>.
Since lambda expressions have no standard type name, kernels defined as lambda
expressions must specify a [code]#KernelName# in their
<<kernel-invocation-command>> in order to use these functions.
Applications which call these functions for a [code]#KernelName# that is not
defined are ill formed, and the implementation must issue a diagnostic in this
case.

  . Equivalent to [code]#has_kernel_bundle<State>(ctxt,
    {get_kernel_id<KernelName>()})#.
  . Equivalent to [code]#has_kernel_bundle<State>(ctxt, devs,
    {get_kernel_id<KernelName>()})#.


=== Querying if a kernel is compatible with a device

The following free functions allow an application to test whether a particular
kernel is compatible with a device.
A kernel that is defined in the application is compatible with a device unless:

* It uses optional features which are not supported on the device, as described
  in <<sec:optional-kernel-features>>; or
* It is decorated with a [code]#[[sycl::device_has()]]# {cpp} attribute that
  lists an aspect that is not supported by the device, as described in
  <<sec:kernel.attributes>>; or
* The translation unit containing the kernel was compiled in a compilation
  environment that does not support the device.
  Each implementation defines the specific criteria for which devices are
  supported in its compilation environment.
  For example, this might be dependent on options passed to the compiler.

A device built-in kernel is only compatible with the device for which it is
built-in.

[source]
----
bool is_compatible(const std::vector<kernel_id>& kernelIds, const device& dev);
----

_Returns:_ [code]#true# if all of the kernels identified by [code]#kernelIds#
are compatible with the device [code]#dev#.

[source]
----
template <typename KernelName> bool is_compatible(const device& dev);
----

_Preconditions:_ The template parameter [code]#KernelName# must be the
<<type-kernel-name>> of a kernel that is defined in the <<sycl-application>>.
Since lambda expressions have no standard type name, kernels defined as lambda
expressions must specify a [code]#KernelName# in their
<<kernel-invocation-command>> in order to use this function.
Applications which call this function for a [code]#KernelName# that is not
defined are ill formed, and the implementation must issue a diagnostic in this
case.

Equivalent to [code]#is_compatible<State>({get_kernel_id<KernelName>()}, dev)#.


=== Joining kernel bundles

Two or more kernel bundles of the same state may be joined together into a
single composite bundle.
Joining bundles together is not the same as online compiling or linking because
it produces a new bundle in the same state as its inputs.
Rather, joining creates the union of all the devices images from the input
bundles, eliminates duplicate copies of the same device image, and creates a new
bundle from the result.

[source]
----
template <bundle_state State>
kernel_bundle<State> join(const std::vector<kernel_bundle<State>>& bundles);
----

_Returns:_ A new kernel bundle that contains a copy of all the device images in
the input [code]#bundles# with duplicates removed.
The new bundle has the same associated context and the same set of associated
devices as those in [code]#bundles#.

_Throws:_

  * An [code]#exception# with the [code]#errc::invalid# error code if the
    bundles in [code]#bundles# do not all have the same associated context or do
    not all have the same set of associated devices.


[[sec:bundles.compile-link]]
=== Online compiling and linking

If the implementation provides an online compiler or linker, a
<<sycl-application>> can use the free functions defined in this section to
transform a kernel bundle from [code]#bundle_state::input# into a bundle of
state [code]#bundle_state::object# or to transform a bundle from
[code]#bundle_state::object# into a bundle of state
[code]#bundle_state::executable#.

An application can query whether the implementation provides an online compiler
or linker by querying a device for [code]#aspect::online_compiler# or
[code]#aspect::online_linker#.

All of the functions in this section accept a [code]#property_list# parameter,
which can affect the semantics of the compilation or linking operation.
The <<core-spec>> does not currently define any such properties, but vendors may
specify these properties as an extension.

[source]
----
kernel_bundle<bundle_state::object>
compile(const kernel_bundle<bundle_state::input>& inputBundle,
        const std::vector<device>& devs, const property_list& propList = {});
----

_Effects:_ The device images from [code]#inputBundle# are translated into one or
more new device images of state [code]#bundle_state::object#, and a new kernel
bundle is created to contain these new device images.
The new bundle represents all of the <<kernel,kernels>> in [code]#inputBundles#
that are compatible with at least one of the devices in [code]#devs#.
Any remaining kernels (those that are not compatible with any of the devices
[code]#devs#) are not compiled and not represented in the new kernel bundle.

The new bundle has the same associated context as [code]#inputBundle#, and the
new bundle's set of associated devices is [code]#devs# (with duplicate devices
removed).

_Returns:_ The new kernel bundle.

_Throws:_

  * An [code]#exception# with the [code]#errc::invalid# error code if any of the
    devices in [code]#devs# are not in the set of associated devices for
    [code]#inputBundle# (as defined by [code]#kernel_bundle::get_devices()#) or
    if the [code]#devs# vector is empty.
  * An [code]#exception# with the [code]#errc::build# error code if the online
    compile operation fails.

[source]
----
kernel_bundle<bundle_state::executable>
link(const std::vector<kernel_bundle<bundle_state::object>>& objectBundles,
     const std::vector<device>& devs, const property_list& propList = {});
----

_Effects:_ Duplicate device images from [code]#objectBundles# are eliminated as
though they were joined via [code]#join()#, then the remaining device images are
translated into one or more new device images of state
[code]#bundle_state::executable#, and a new kernel bundle is created to contain
these new device images.
The new bundle represents all of the <<kernel,kernels>> in [code]#objectBundles#
that are compatible with at least one of the devices in [code]#devs#.
Any remaining kernels (those that are not compatible with any of the devices in
[code]#devs#) are not linked and not represented in the new bundle.

The new bundle has the same associated context as those in
[code]#objectBundles#, and the new bundle's set of associated devices is
[code]#devs# (with duplicate devices removed).

_Returns:_ The new kernel bundle.

_Throws:_

  * An [code]#exception# with the [code]#errc::invalid# error code if the
    bundles in [code]#objectBundles# do not all have the same associated
    context.
  * An [code]#exception# with the [code]#errc::invalid# error code if any of the
    devices in [code]#devs# are not in the set of associated devices for any of
    the bundles in [code]#objectBundles# (as defined by
    [code]#kernel_bundle::get_devices()#) or if the [code]#devs# vector is
    empty.
  * An [code]#exception# with the [code]#errc::build# error code if the online
    link operation fails.

[source]
----
kernel_bundle<bundle_state::executable>
build(const kernel_bundle<bundle_state::input>& inputBundle,
      const std::vector<device>& devs, const property_list& propList = {});
----

_Effects:_ This function performs both an online compile and link operation,
translating a kernel bundle of state [code]#bundle_state::input# into a bundle
of state [code]#bundle_state::executable#.
The device images from [code]#inputBundle# are translated into one or more new
device images of state [code]#bundle_state::executable#, and a new bundle is
created to contain these new device images.
The new bundle represents all of the <<kernel,kernels>> in [code]#inputBundle#
that are compatible with at least one of the devices in [code]#devs#.
Any remaining kernels (those that are not compatible with any of the devices
[code]#devs#) are not compiled or linked and are not represented in the new
bundle.

The new bundle has the same associated context as [code]#inputBundle#, and the
new bundle's set of associated devices is [code]#devs# (with duplicate devices
removed).

_Returns:_ The new kernel bundle.

_Throws:_

  * An [code]#exception# with the [code]#errc::invalid# error code if any of the
    devices in [code]#devs# are not in the set of associated devices for
    [code]#inputBundle# (as defined by [code]#kernel_bundle::get_devices()#) or
    if the [code]#devs# vector is empty.
  * An [code]#exception# with the [code]#errc::build# error code if the online
    compile or link operations fail.

[source]
----
kernel_bundle<bundle_state::object> // (1)
compile(const kernel_bundle<bundle_state::input>& inputBundle,
        const property_list& propList = {});

kernel_bundle<bundle_state::executable> // (2)
link(const kernel_bundle<bundle_state::object>& objectBundle,
     const std::vector<device>& devs, const property_list& propList = {});

kernel_bundle<bundle_state::executable> // (3)
link(const std::vector<kernel_bundle<bundle_state::object>>& objectBundles,
     const property_list& propList = {});

kernel_bundle<bundle_state::executable> // (4)
link(const kernel_bundle<bundle_state::object>& objectBundle,
     const property_list& propList = {});

kernel_bundle<bundle_state::executable> // (5)
build(const kernel_bundle<bundle_state::input>& inputBundle,
      const property_list& propList = {});
----

  . Equivalent to [code]#compile(inputBundle, inputBundle.get_devices(),
    propList)#.

  . Equivalent to [code]#link({objectBundle}, devs, propList)#.

  . Equivalent to [code]#link(objectBundles, devs, propList)#, where
    [code]#devs# is the intersection of associated devices in common for all
    bundles in [code]#objectBundles#.

  . Equivalent to [code]#link({objectBundle}, objectBundle.get_devices(),
    propList)#.

  . Equivalent to [code]#build(inputBundle, inputBundle.get_devices(),
    propList)#.


=== The [code]#kernel_bundle# class

A synopsis of the [code]#kernel_bundle# class is shown below.
Additionally, this class provides the common special member functions and common
member functions that are listed in <<sec:reference-semantics>> in
<<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>>, respectively.

As with all SYCL objects that have the common reference semantics, kernel
bundles are equality comparable.
Two bundles of the same <<bundle-state>> are considered to be equal if they are
associated with the same context, have the same set of associated devices, and
contain the same set of device images.

There is no public default constructor for this class.

[source,,linenums]
----
include::{header_dir}/bundle/kernelBundleClass.h[lines=4..-1]
----

[[sec:bundles.query]]
==== Queries

The following member functions provide various queries for a <<kernel-bundle>>.

[source]
----
bool empty() const noexcept;
----

_Returns:_ [code]#true# only if the kernel bundle contains no device images.

[source]
----
backend get_backend() const noexcept;
----

_Returns:_ The backend that is associated with the kernel bundle.

[source]
----
context get_context() const noexcept;
----

_Returns:_ The context that is associated with the kernel bundle.

[source]
----
std::vector<device> get_devices() const noexcept;
----

_Returns:_ The set of devices that is associated with the kernel bundle.

[source]
----
bool has_kernel(const kernel_id& kernelId) const noexcept; // (1)
bool has_kernel(const kernel_id& kernelId,
                const device& dev) const noexcept; // (2)
----

  . _Returns:_ [code]#true# only if the kernel bundle contains the kernel
    identified by [code]#kernelId#.
  . _Returns:_ [code]#true# only if the kernel bundle contains the kernel
    identified by [code]#kernelId# and if that kernel is compatible with the
    device [code]#dev#.

[source]
----
template <typename KernelName> bool has_kernel() const noexcept; // (1)

template <typename KernelName>
bool has_kernel(const device& dev) const noexcept; // (2)
----

_Preconditions:_ The template parameter [code]#KernelName# must be the
<<type-kernel-name>> of a kernel that is defined in the <<sycl-application>>.
Since lambda expressions have no standard type name, kernels defined as lambda
expressions must specify a [code]#KernelName# in their
<<kernel-invocation-command>> in order to use these functions.
Applications which call these functions for a [code]#KernelName# that is not
defined are ill formed, and the implementation must issue a diagnostic in this
case.

  . _Returns:_ [code]#true# only if the kernel bundle contains the kernel
    identified by [code]#KernelName#.
  . _Returns:_ [code]#true# only if the kernel bundle contains the kernel
    identified by [code]#KernelName# and if that kernel is compatible with the
    device [code]#dev#.

[source]
----
std::vector<kernel_id> get_kernel_ids() const;
----

_Returns:_ A vector of the identifiers for all kernels that are contained in the
kernel bundle.

[source]
----
kernel get_kernel(const kernel_id& kernelId) const;
----

_Preconditions:_ This member function is only available if the kernel bundle's
state is [code]#bundle_state::executable#.

_Returns:_ A [code]#kernel# object representing the kernel identified by
[code]#kernelId#, which resides in the bundle.

_Throws:_

  * An [code]#exception# with the [code]#errc::invalid# error code if the kernel
    bundle does not contain the kernel identified by [code]#kernelId#.

[source]
----
template <typename KernelName> kernel get_kernel() const;
----

_Preconditions:_ This member function is only available if the kernel bundle's
state is [code]#bundle_state::executable#.
The template parameter [code]#KernelName# must be the <<type-kernel-name>> of a
kernel that is defined in the <<sycl-application>>.
Since lambda expressions have no standard type name, kernels defined as lambda
expressions must specify a [code]#KernelName# in their
<<kernel-invocation-command>> in order to use this function.
Applications which call this function for a [code]#KernelName# that is not
defined are ill formed, and the implementation must issue a diagnostic in this
case.

_Returns:_ A [code]#kernel# object representing the kernel identified by
[code]#KernelName#, which resides in the bundle.

_Throws:_

  * An [code]#exception# with the [code]#errc::invalid# error code if the kernel
    bundle does not contain the kernel identified by [code]#KernelName#.

==== Specialization constant support

The following member functions allow an application to manipulate
<<specialization-constant,specialization constants>> that are used in the device
images of a <<kernel-bundle>>.
Applications can set the value of specialization constants in a kernel bundle
whose state is [code]#bundle_state::input# and then online compile that bundle
into [code]#bundle_state::object# or [code]#bundle_state::executable#.
The value of the specialization constants then become fixed in the compiled
bundle and cannot be changed.
Specialization constants that have not had their values set by the time the
bundle is compiled take their default values.

[NOTE]
====
It is expected that many implementations will use an intermediate language
representation for a bundle in state [code]#bundle_state::input# such as SPIR-V,
and the intermediate language will have native support for specialization
constants.
However, implementations that do not have such native support must still support
specialization constants in some other way.
====

[source]
----
bool contains_specialization_constants() const noexcept;
----

_Returns:_ [code]#true# only if the kernel bundle contains at least one device
image which uses a specialization constant.

[source]
----
bool native_specialization_constant() const noexcept;
----

_Returns:_ [code]#true# only if the kernel bundle contains at least one device
image which uses a specialization constant and all specialization constants used
in all of the bundle's device images are <<native-specialization-constant,native
specialization constants>>.

[source]
----
template <auto& SpecName> bool has_specialization_constant() const noexcept;
----

_Returns:_ [code]#true# if any device image in the kernel bundle uses the
specialization constant whose address is [code]#SpecName#.

[source]
----
template <auto& SpecName>
void set_specialization_constant(
    typename std::remove_reference_t<decltype(SpecName)>::value_type value);
----

_Preconditions:_ This member function is only available if the kernel bundle's
state is [code]#bundle_state::input#.

_Effects:_ Sets the value of the <<specialization-constant>> whose address is
[code]#SpecName# for this bundle.
If the specialization constant's value was previously set in this bundle, the
value is overwritten.

The new value applies to all device images in the bundle.
It is allowed to set the value of a specialization constant even if no device
image in the bundle uses it; doing so has no effect on the execution of kernels
from that bundle.

[source]
----
template <auto& SpecName>
typename std::remove_reference_t<decltype(SpecName)>::value_type
get_specialization_constant() const;
----

_Returns:_ The value of the <<specialization-constant>> whose address is
[code]#SpecName# for this kernel bundle.
The value returned is as follows:

* If the value of this specialization constant was previously set in this
  bundle, that value is returned.
  Otherwise,

* If this bundle is the result of compiling, linking or joining another bundle
  and this specialization constant was set in that other bundle prior to
  compiling, linking or joining; then that value is returned.
  Otherwise,

* The specialization constant's default value is returned.

==== Device image support

The following member type and functions allow iteration over the
<<device-image,device images>> contained by the kernel bundle.

[source]
----
using device_image_iterator = __unspecified__;
----

An iterator type that satisfies the {cpp} requirements of
[code]#LegacyForwardIterator#.
The iterator's referenced type is [code]#const device_image<State>#, where
[code]#State# is the same state as the containing [code]#kernel_bundle#.

[source]
----
device_image_iterator begin() const; // (1)
device_image_iterator end() const;   // (2)
----

  . _Returns:_ An iterator to the first <<device-image>> contained by the kernel
     bundle.
  . _Returns:_ An iterator to one past the last <<device-image>> contained by
     the kernel bundle.


=== The [code]#kernel# class

A synopsis of the [code]#kernel# class is shown below.
Additionally, this class provides the common special member functions and common
member functions that are listed in <<sec:reference-semantics>> in
<<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>>, respectively.

There is no public default constructor for this class.

[source,,linenums]
----
include::{header_dir}/bundle/kernelClass.h[lines=4..-1]
----

[[sec:kernel.query]]
==== Queries

The following member functions provide various queries for a <<kernel>>.

[source]
----
backend get_backend() const noexcept;
----

_Returns:_ The backend associated with this kernel.

[source]
----
context get_context() const;
----

_Returns:_ The context associated with this kernel.

[source]
----
kernel_bundle<bundle_state::executable> get_kernel_bundle() const;
----

_Returns:_ The kernel bundle that contains this kernel.

[source]
----
template <typename Param> typename Param::return_type get_info() const;
----

_Preconditions:_ The [code]#Param# must be one of the [code]#info::kernel#
descriptors defined in <<table.kernel.info>>, and the type alias
[code]#Param::return_type# must be defined in accordance with that table.

_Returns:_ Information about the kernel that is not specific to the device on
which it is invoked.

[source]
----
template <typename Param>
typename Param::return_type get_info(const device& dev) const;
----

_Preconditions:_ The [code]#Param# must be one of the
[code]#info::kernel_device_specific# descriptors defined in
<<table.kernel.devicespecificinfo>>, and the type alias
[code]#Param::return_type# must be defined in accordance with that table.

_Returns:_ Information about the kernel that applies when the kernel is invoked
on the device [code]#dev#.

_Throws:_

  * An [code]#exception# with the [code]#errc::invalid# error code if the kernel
    is not compatible with device [code]#dev# (as defined by
    [code]#is_compatible()#).

[source]
----
template <typename Param> typename Param::return_type get_backend_info() const;
----

_Preconditions:_ The [code]#Param# must be one of a descriptor defined by a
<<backend>> specification.

_Returns:_ Backend specific information about the kernel that is not specific to
the device on which it is invoked.

_Throws:_

  * An [code]#exception# with the [code]#errc::backend_mismatch# error code if
    the <<backend>> that corresponds with [code]#Param# is different from the
    <<backend>> that is associated with this kernel bundle.

==== Kernel information descriptors

A <<kernel>> can be queried for information using the [code]#get_info()# member
function, specifying one of the info parameters in [code]#info::kernel#.
All info parameters in [code]#info::kernel# are specified in
<<table.kernel.info>> and the synopsis for [code]#info::kernel# is described in
<<appendix.kernel.descriptors>>.

[[table.kernel.info]]
.Kernel class information descriptors
[width="100%",options="header",separator="@",cols="37%,19%,44%"]
|====
@ Kernel Descriptors @ Return type @ Description
a@
[source]
----
info::kernel::num_args
----

    @ [code]#uint32_t#
   a@ This descriptor may only be used to query a kernel that resides in a
      kernel bundle that was constructed using a backend specific
      interoperability function or to query a device built-in kernel, and the
      semantics of this descriptor are defined by each SYCL backend
      specification.

Attempting to use this descriptor for other kernels throws an [code]#exception#
with the [code]#errc::invalid# error code.

a@
[source]
----
info::kernel::attributes
----

    @ [code]#std::string#
   a@ Return any attributes specified on a kernel function (as defined in
      <<sec:device.attributes>>).

|====

A <<kernel>> can also be queried for device specific information using the
[code]#get_info()# member function, specifying one of the info parameters in
[code]#info::kernel_device_specific#.
All info parameters in [code]#info::kernel_device_specific# are specified in
<<table.kernel.devicespecificinfo>>.
The synopsis for [code]#info::kernel_device_specific# is described in
<<appendix.kernel.descriptors>>.

[[table.kernel.devicespecificinfo]]
.Device-specific kernel information descriptors
[width="100%",options="header",separator="@",cols="37%,19%,44%"]
|====
@ Device-specific Kernel Information Descriptors @ Return type @ Description
a@
[source]
----
info::kernel_device_specific::global_work_size
----

    @ [code]#range<3>#
   a@ This descriptor may only be used if the device type is
      [code]#device_type::custom# or if the kernel is a built-in kernel.  The
      exact semantics of this descriptor are defined by each SYCL backend
      specification, but the intent is to return the kernel's maximum global
      work size.

Attempting to use this descriptor for other devices or kernels throws an
[code]#exception# with the [code]#errc::invalid# error code.

a@
[source]
----
info::kernel_device_specific::work_group_size
----

    @ [code]#size_t#
   a@ Returns the maximum number of work-items in a work-group that can be used
      to execute this kernel on the given device.
      This value will always be less than or equal to the value returned from
      [code]#info::device::max_work_group_size#.

a@
[source]
----
info::kernel_device_specific::compile_work_group_size
----

    @ [code]#range<3>#
   a@ Returns the work-group size specified by the device compiler if applicable,
      otherwise returns [code]#{0,0,0}#.

a@
[source]
----
info::kernel_device_specific::preferred_work_group_size_multiple
----

    @ [code]#size_t#
   a@ Returns a value, of which work-group size is preferred to be a multiple,
      for executing a kernel on a particular device.  This is a performance
      hint.  The value must be less than or equal to that returned by
      [code]#info::kernel_device_specific::work_group_size#.

a@
[source]
----
info::kernel_device_specific::private_mem_size
----

    @ [code]#size_t#
   a@ Returns the minimum amount of private memory, in bytes, used by each work-item
      in the kernel.  This value may include any private memory needed by an
      implementation to execute the kernel, including that used by the language
      built-ins and variables declared inside the kernel in the private address
      space.

a@
[source]
----
info::kernel_device_specific::max_num_sub_groups
----

    @ [code]#uint32_t#
   a@ Returns the maximum number of sub-groups for this kernel.

a@
[source]
----
info::kernel_device_specific::compile_num_sub_groups
----

    @ [code]#uint32_t#
   a@ Returns the number of sub-groups specified by the kernel, or 0 (if not specified).

a@
[source]
----
info::kernel_device_specific::max_sub_group_size
----

    @ [code]#uint32_t#
   a@ Returns the maximum sub-group size for this kernel.

a@
[source]
----
info::kernel_device_specific::compile_sub_group_size
----

    @ [code]#uint32_t#
   a@ Returns the required sub-group size specified by the kernel, or 0 (if not specified).

|====


=== The [code]#device_image# class

A synopsis of the [code]#device_image# class is shown below.
Additionally, this class provides the common special member functions and common
member functions that are listed in <<sec:reference-semantics>> in
<<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>>, respectively.

[source,,linenums]
----
include::{header_dir}/bundle/deviceImageClass.h[lines=4..-1]
----

There is no public constructor for this class.

[source]
----
bool has_kernel(const kernel_id& kernelId) const noexcept; // (1)
bool has_kernel(const kernel_id& kernelId,
                const device& dev) const noexcept; // (2)
----

  . _Returns:_ [code]#true# only if the device image contains the kernel
    identified by [code]#kernelId#.
  . _Returns:_ [code]#true# only if the device image contains the kernel
    identified by [code]#kernelId# and if that kernel is compatible with the
    device [code]#dev#.


=== Example usage

This section provides some examples showing typical use cases for kernel
bundles.
These examples are intended to clarify the definition of the kernel bundle
interfaces, but the content of this section is non-normative.

==== Controlling the timing of online compilation

In some cases an application may want to pre-compile its kernels before
submitting them to a device.
This gives the application control over when the overhead of online compilation
happens, rather than relying on the default behavior (which may cause the online
compilation to happen at the point when the kernel is submitted to a device).
The following example shows how this can be achieved.

[source,,linenums]
----
include::{code_dir}/bundle-pre-compile.cpp[lines=4..-1]
----

==== Specialization constants

An application can use a kernel bundle to set the values of specialization
constants in several kernels before any of them are submitted for execution.

[source,,linenums]
----
include::{code_dir}/bundle-spec-constants.cpp[lines=4..-1]
----

==== Kernel introspection

Applications can use kernel bundles to introspect its kernels and use that
information to tune the arguments passed when invoking it.

[source,,linenums]
----
include::{code_dir}/bundle-kernel-introspection.cpp[lines=4..-1]
----

==== Invoking a device built-in kernel

An application can use kernel bundles to invoke a device's built-in kernels.

[source,,linenums]
----
include::{code_dir}/bundle-builtin-kernel.cpp[lines=4..-1]
----


== Defining kernels

In SYCL, functions that are executed on a SYCL device are referred to as
<<sycl-kernel-function,SYCL kernel functions>>.
A <<kernel>> containing such a <<sycl-kernel-function>> is enqueued on a device
queue in order to be executed on that particular device.

The return type of the <<sycl-kernel-function>> is [code]#void#, and all memory
accesses between host and device are through <<accessor,accessors>> or through
<<sec:usm, USM pointers>>.

There are two ways of defining kernels: as named function objects or as lambda
expressions.
A backend may also provide interoperability interfaces for defining kernels.


[[sec:interfaces.kernels.as.function-objects]]
=== Defining kernels as named function objects

A kernel can be defined as a named function object type.
These function objects provide the same functionality as any {cpp} function
object, with the restriction that they need to follow SYCL rules to be
<<device-copyable>>.
The kernel function can be templated via templating the kernel function object
type.
For details on restrictions for kernel naming, please refer to
<<sec:naming.kernels>>.

The [code]#operator()# member function must be const-qualified, and it may take
different parameters depending on the data accesses defined for the specific
kernel.
If the [code]#operator()# function writes to any of the member variables, the
behavior is undefined.

The following example defines a <<sycl-kernel-function>>, _RandomFiller_, which
initializes all elements of a buffer with the same random number.
The random number is generated during the construction of the function object
while processing the command group.
The [code]#operator()# member function of the function object receives an
[code]#item# object.
This member function will be called for each work-item of the execution range.
The value of the random number will be assigned to each element of the buffer.
In this case, the accessor and the scalar random number are members of the
function object and therefore will be arguments to the device kernel.
Usual restrictions of passing arguments to kernels apply.

[source,,linenums]
----
include::{code_dir}/myfunctor.cpp[lines=4..-1]
----


[[sec:interfaces.kernels.as.lambdas]]
=== Defining kernels as lambda expressions

In {cpp}, function objects can be defined using lambda expressions.
Kernels may be defined as lambda expressions in SYCL.
The name of a lambda expression in SYCL may optionally be specified by passing
it as a template parameter to the invoking member function, and in that case,
the lambda name is a [keyword]#{cpp} typename# which must be forward declarable
at namespace scope.
If the lambda expression relies on template arguments, then if specified, the
name of the lambda expression must contain those template arguments which must
also be forward declarable at namespace scope.
The class used for the name of a lambda expression is only used for naming
purposes and is not required to be defined.
For details on restrictions for kernel naming, please refer to
<<sec:naming.kernels>>.

The kernel function for the lambda expression is the lambda expression itself.
The kernel lambda must use copy for all of its captures (i.e. [code]#[=]#), and
the lambda must not use the [code]#mutable# specifier.

[source,,linenums]
----
include::{code_dir}/mykernel.cpp[lines=4..-1]
----

Explicit lambda naming is shown in the following code example, including an
illegal case that uses a class within the kernel name which is not forward
declarable ([code]#std::complex#).

[source,,linenums]
----
include::{code_dir}/lambdaNameExamples.cpp[lines=4..-1]
----

=== [code]#is_device_copyable# type trait

....
namespace sycl {
    template<typename T>
    struct is_device_copyable;

    template<typename T>
    inline constexpr bool is_device_copyable_v = is_device_copyable<T>::value;
};
....

[code]#is_device_copyable# is a user specializable class template to indicate
that a type [code]#T# is <<device-copyable>>.

  * [code]#is_device_copyable# must meet the Cpp17UnaryTrait requirements.
  * If [code]#is_device_copyable# is specialized such that
    [code]#is_device_copyable_v<T> == true# on a [code]#T# that does not satisfy
    all the requirements of a device copyable type, the results are unspecified.

If the application defines a type [code]#UDT# that satisfies the requirements of
a <<device-copyable>> type (as defined in <<sec::device.copyable>>) but the type
is not implicitly device copyable as defined in that section, then the
application must provide a specialization of [code]#is_device_copyable# that
derives from [code]#std:true_type# in order to use that type in a context that
requires a device copyable type.
Such a specialization can be declared like this:

....
template<>
struct sycl::is_device_copyable<UDT> : std::true_type {};
....

It is legal to provide this specialization even if the implementation does not
define [code]#SYCL_DEVICE_COPYABLE# to [code]#1#, but the type cannot be used as
a device copyable type in that case and the specialization is ignored.


[[sec:kernel.parameter.passing]]
=== Rules for parameter passing to kernels

A SYCL application passes parameters to a kernel in different ways depending on
whether the kernel is a named function object or a lambda expression.
If the kernel is a named function object, the [code]#operator()# member function
(or other member functions that it calls) may reference member variables inside
the same named function object.
Any such member variables become parameters to the kernel.
If the kernel is a lambda expression, any variables captured by the lambda
become parameters to the kernel.

Regardless of how the parameter is passed, the following rules define the
allowable types for a kernel parameter:

* Any <<device-copyable>> type is a legal parameter type.

* The following SYCL types are legal parameter types:
  - [code]#accessor# when templated with [code]#target::device#;
  - [code]#accessor# when templated with any of the deprecated parameters:
    [code]#target::global_buffer#, [code]#target::constant_buffer#, or
    [code]#target::local#;
  - [code]#local_accessor#;
  - [code]#unsampled_image_accessor# when templated with
    [code]#image_target::device#;
  - [code]#sampled_image_accessor# when templated with
    [code]#image_target::device#;
  - [code]#stream#;
  - [code]#id#;
  - [code]#range#;
  - [code]#marray<T, NumElements># when [code]#T# is <<device-copyable>>;
  - [code]#vec<T, NumElements>#.

* An array of element types [code]#T# is a legal parameter type if [code]#T# is
  a legal parameter type.

* A class type [code]#S# with a non-static member variable of type [code]#T# is
  a legal parameter type if [code]#T# is a legal parameter type and if [code]#S#
  would otherwise be a legal parameter type aside from this member variable.

* A class type [code]#S# with a non-virtual base class of type [code]#T# is a
  legal parameter type if [code]#T# is a legal parameter type and if [code]#S#
  would otherwise be a legal parameter type aside from this base class.

[NOTE]
====
Pointer types are trivially copyable, so they may be passed as kernel
parameters.
However, only the pointer value itself is passed to the kernel.
Dereferencing the pointer on the kernel results in undefined behavior unless the
pointer points to an address within a <<usm>> memory region that is accessible
on the device.

Reference types are not trivially copyable, so they may not be passed as kernel
parameters.
====

[NOTE]
====
The [code]#reducer# class is a special type of kernel parameter which is passed
to a kernel in a different way.
<<sec:reduction>> describes how this parameter type is used.
====

// %%%%%%%%%%%%%%%%%%%%%%%%%%%% end expressingParallelism %%%%%%%%%%%%%%%%%%%%%%%%%%%%


[[error-handling]]
== Error handling

=== Error handling rules

Error handling in a SYCL application (host code) uses {cpp} exceptions.
If an error occurs, it will be thrown by the API function call and may be caught
by the user through standard {cpp} exception handling mechanisms.

SYCL applications are asynchronous in the sense that host and device code
executions are decoupled from one another except at specific points.
For example, device code executions often begin when dependencies in the SYCL
task graph are satisfied, which occurs asynchronously from host code execution.
As a result of this the errors that occur on a device cannot be thrown directly
from a host API call, because the call enqueuing a device action has typically
already returned by the time that the error occurs.
Such errors are not detected until the error-causing task executes or tries to
execute, and we refer to these as <<async-error,asynchronous errors>>.


[[subsubsec:exception.async]]
==== Asynchronous error handler

The queue and context classes can optionally take an asynchronous handler object
<<async-handler>> on construction, which is a callable such as a function class
or lambda, with an [code]#exception_list# as a parameter.
Invocation of an <<async-handler>> may be triggered by the queue member
functions [code]#queue::wait_and_throw()# or
[code]#queue::throw_asynchronous()#, by the event member function
[code]#event::wait_and_throw()#, or automatically on destruction of a queue or
context that contains unconsumed asynchronous errors.
When invoked, an <<async-handler>> is called and receives an
[code]#exception_list# argument containing a list of exception objects
representing any unconsumed <<async-error,asynchronous errors>> associated with
the queue or context.

When an <<async-error>> instance has been passed to an <<async-handler>>, then
that instance of the error has been consumed for handling and is not reported on
any subsequent invocations of the <<async-handler>>.

The <<async-handler>> may be a named function object type, a lambda expression
or a [code]#std::function#.
The [code]#exception_list# object passed to the <<async-handler>> is constructed
by the <<sycl-runtime>>.


[[subsubsec:exception.nohandler]]
==== Behavior without an async handler

If an asynchronous error occurs in a queue or context that has no user-supplied
asynchronous error handler object <<async-handler>>, then an
implementation-defined default <<async-handler>> is called to handle the error
in the same situations that a user-supplied <<async-handler>> would be, as
defined in <<subsubsec:exception.async>>.
The default <<async-handler>> must in some way report all errors passed to it,
when possible, and must then invoke [code]#std::terminate# or equivalent.

[[subsubsec:async.handler.priorities]]
==== Priorities of async handlers

If the SYCL runtime can associate an <<async-error>> with a specific queue,
then:

  * If the queue was constructed with an <<async-handler>>, that handler is
    invoked to handle the error.
  * Otherwise if the context enclosed by the queue was constructed with an
    <<async-handler>>, that handler is invoked to handle the error.
  * Otherwise when no handler was passed to either queue or context on
    construction, then a default handler is invoked to handle the error, as
    described by <<subsubsec:exception.nohandler>>.
  * All handler invocations in this list occur at times as defined by
    <<subsubsec:exception.async>>.

If the SYCL runtime cannot associate an <<async-error>> with a specific queue,
then:

  * If the context in which the error occurred was constructed with an
    <<async-handler>>, then that handler is invoked to handle the error.
  * Otherwise when no handler was passed to the associated context on
    construction, then a default handler is invoked to handle the error, as
    described by <<subsubsec:exception.nohandler>>.
  * All handler invocations in this list occur at times as defined by
    <<subsubsec:exception.async>>.


==== Asynchronous errors with a secondary queue

If an <<async-error>> occurs when running or enqueuing a command group which has
a secondary queue specified, then the command group may be enqueued to the
secondary queue instead of the primary queue.
The error handling in this case is also configured using the <<async-handler>>
provided for both queues.
If there is no <<async-handler>> given on any of the queues, then the
asynchronous error handling proceeds through the contexts associated with the
queues, and if they were also constructed without <<async-handler>>s, then the
default handler will be used.
If the primary queue fails and there is an <<async-handler>> given at this
queue's construction, which populates the [code]#exception_list# parameter, then
any errors will be added and can be thrown whenever the user chooses to handle
those exceptions.
Since there were errors on the primary queue and a secondary queue was given,
then the execution of the kernel is re-scheduled to the secondary queue and any
error reporting for the kernel execution on that queue is done through that
queue, in the same way as described above.
The secondary queue may fail as well, and the errors will be thrown if there is
an <<async-handler>> and either [code]#wait_and_throw()# or [code]#throw()# are
called on that queue.
If no <<async-handler>> was specified, then the one associated with the queue's
context will be used and if the context was also constructed without an
<<async-handler>>, then the default handler will be used.
The <<command-group-function-object>> event returned by that function will be
relevant to the queue where the kernel has been enqueued.

The secondary queue feature is deprecated in SYCL {SYCL_VERSION}.

Below is an example of catching a SYCL [code]#exception# and printing out the
error message.

[source,,linenums]
----
include::{code_dir}/handlingException.cpp[lines=4..-1]
----

Below is an example of catching a SYCL [code]#exception# with the
[code]#errc::invalid# error code and printing out the error message.

[source,,linenums]
----
include::{code_dir}/handlingErrorCode.cpp[lines=4..-1]
----


[[subsec:exception.class]]
=== Exception class interface

[source,,linenums]
----
include::{header_dir}/exception.h[lines=4..-1]
----

The SYCL [code]#exception_list# class is also available in order to provide a
list of synchronous and asynchronous exceptions.

Errors can occur both in the SYCL library and SYCL host side, or may come
directly from a <<backend>>.
The member functions on these exceptions provide the corresponding information.
<<backend, SYCL backends>> can provide additional exception class objects as
long as they derive from [code]#sycl::exception# object, or any of its derived
classes.

A specialization of [code]#std::is_error_code_enum# must be defined for
[code]#sycl::errc# that inherits from [code]#std::true_type#.


[[table.members.exception]]
.Member functions of the SYCL [code]#exception# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
exception(std::error_code ec, const std::string& what_arg)
----
   a@ Constructs an [code]#exception#. The string returned by [code]#what()# is guaranteed to contain [code]#what_arg# as a substring.

a@
[source]
----
exception(std::error_code ec, const char* what_arg)
----
   a@ Constructs an [code]#exception#. The string returned by [code]#what()# is guaranteed to contain [code]#what_arg# as a substring.

a@
[source]
----
exception(std::error_code ec)
----
   a@ Constructs an [code]#exception#.

a@
[source]
----
exception(int ev, const std::error_category& ecat, const std::string& what_arg)
----
   a@ Constructs an [code]#exception# with the error code ev and the underlying error category [code]#ecat#. The string returned by [code]#what()# is guaranteed to contain [code]#what_arg# as a substring.

a@
[source]
----
exception(int ev, const std::error_category& ecat, const char* what_arg)
----
   a@ Constructs an [code]#exception# with the error code ev and the underlying error category [code]#ecat#. The string returned by [code]#what()# is guaranteed to contain [code]#what_arg# as a substring.

a@
[source]
----
exception(int ev, const std::error_category& ecat)
----
   a@ Constructs an [code]#exception# with the error code ev and the underlying error category [code]#ecat#.

a@
[source]
----
exception(context ctx, std::error_code ec, const std::string& what_arg)
----
   a@ Constructs an [code]#exception# with an associated SYCL context [code]#ctx#. The string returned by [code]#what()# is guaranteed to contain [code]#what_arg# as a substring.

a@
[source]
----
exception(context ctx, std::error_code ec, const char* what_arg)
----
   a@ Constructs an [code]#exception# with an associated SYCL context [code]#ctx#. The string returned by [code]#what()# is guaranteed to contain [code]#what_arg# as a substring.

a@
[source]
----
exception(context ctx, std::error_code ec)
----
   a@ Constructs an [code]#exception# with an associated SYCL context [code]#ctx#.

a@
[source]
----
exception(context ctx, int ev, const std::error_category& ecat,
          const std::string& what_arg)
----
   a@ Constructs an [code]#exception# with an associated SYCL context [code]#ctx#, the error code ev and the underlying error category [code]#ecat#. The string returned by [code]#what()# is guaranteed to contain [code]#what_arg# as a substring.

a@
[source]
----
exception(context ctx, int ev, const std::error_category& ecat,
          const char* what_arg)
----
   a@ Constructs an [code]#exception# with an associated SYCL context [code]#ctx#, the error code ev and the underlying error category [code]#ecat#. The string returned by [code]#what()# is guaranteed to contain [code]#what_arg# as a substring.

a@
[source]
----
exception(context ctx, int ev, const std::error_category& ecat)
----
   a@ Constructs an [code]#exception# with an associated SYCL context [code]#ctx#, the error code ev and the underlying error category [code]#ecat#.

a@
[source]
----
const std::error_code& code() const noexcept
----
   a@ Returns the error code stored inside the exception.

a@
[source]
----
const std::error_category& category() const noexcept
----
   a@ Returns the error category of the error code stored inside the exception.

a@
[source]
----
const char* what() const
----
   a@ Returns an implementation-defined non-null constant C-style string that describes the error that triggered the exception.

a@
[source]
----
bool has_context() const noexcept
----
   a@ Returns [code]#true# if this SYCL [code]#exception# has an associated SYCL [code]#context# and [code]#false# if it does not.

a@
[source]
----
context get_context() const
----
   a@ Returns the SYCL [code]#context# that is associated with this SYCL [code]#exception# if one is available. Must throw an [code]#exception# with the [code]#errc::invalid# error code if this SYCL [code]#exception# does not have a SYCL [code]#context#.

|====



[[table.members.exceptionlist]]
.Member functions of the [code]#exception_list#
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
size_t size() const
----
   a@ Returns the size of the list

a@
[source]
----
iterator begin() const
----
   a@ Returns an iterator to the beginning of the list of asynchronous exceptions.

a@
[source]
----
iterator end() const
----
   a@ Returns an iterator to the end of the list of asynchronous exceptions.

|====



[[table.errc.values]]
.Values of the SYCL [code]#errc# enum
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Standard SYCL Error Codes @ Description
a@
[source]
----
success
----
   a@ The implementation never throws an exception with this error code, but it
      is defined to ensure that no other error code has the value zero.  An
      application can construct an [code]#std::error_code# with this code to
      indicate "not an error".

a@
[source]
----
runtime
----
   a@ Generic runtime error.

a@
[source]
----
kernel
----
   a@ Error that occurred before or while enqueuing the SYCL kernel.

a@
[source]
----
nd_range
----
   a@ Error regarding the SYCL [code]#nd_range# specified for the SYCL kernel

a@
[source]
----
accessor
----
   a@ Error regarding the SYCL <<accessor>> objects defined.

a@
[source]
----
event
----
   a@ Error regarding associated SYCL [code]#event# objects.

a@
[source]
----
kernel_argument
----
   a@ The application has passed an invalid argument to a
      <<sycl-kernel-function>>.  This includes captured variables if the
      <<sycl-kernel-function>> is a lambda expression.

a@
[source]
----
build
----
   a@ Error from an online compile or link operation when compiling, linking,
      or building a kernel bundle for a device.

a@
[source]
----
invalid
----
   a@ A catchall error which is used when the application passes an invalid
      value as a parameter to a SYCL API function or calls a SYCL API function
      in some invalid way.

a@
[source]
----
memory_allocation
----
   a@ Error on memory allocation on the SYCL device for a SYCL kernel.

a@
[source]
----
platform
----
   a@ The SYCL platform will trigger this exception on error.

a@
[source]
----
profiling
----
   a@ The <<sycl-runtime>> will trigger this error if there is an error when profiling info
      is enabled.

a@
[source]
----
feature_not_supported
----
   a@ Exception thrown when host code uses an optional feature that is not
      supported by a device.

a@
[source]
----
kernel_not_supported
----
   a@ Exception thrown when a kernel uses an optional feature that is not
      supported on the device to which it is enqueued.  This exception is also
      thrown if a <<command-group>> is bound to a <<kernel-bundle>>, and the
      bundle does not contain the kernel invoked by the command group.

a@
[source]
----
backend_mismatch
----
   a@ The application has called a backend interoperability function with
      mismatched backend information.  For example, requesting information
      specific to backend A from a SYCL object that comes from backend B causes
      this error.

|====

[[table.error.helpers]]
.SYCL error code helper functions
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ SYCL Error Code Helpers @ Description
a@
[source]
----
const std::error_category& sycl_category() noexcept;
----
   a@ Obtains a reference to the static error category object for SYCL errors.
      This object overrides the virtual function [code]#error_category::name()#
      to return a pointer to the string [code]#"sycl"#.  When the
      implementation throws an [code]#sycl::exception# object [code]#ex# with
      this category, the error code value contained by the exception
      ([code]#ex.code().value()#) is one of the enumerated values in
      [code]#sycl::errc#.

a@
[source]
----
std::error_code make_error_code(errc e) noexcept;
----
   a@ Constructs an error code using [code]#e# and [code]#sycl_category()#.

|====



== Data types

SYCL as a {cpp} programming model supports the {cpp} core language data types,
and it also provides the ability for all SYCL applications to be executed on
SYCL compatible devices.
The scalar and vector data types that are supported by the SYCL system are
defined below.
More details about the SYCL device compiler support for fundamental and backend
interoperability types are found in <<subsec:scalartypes>>.


=== Scalar data types

The fundamental {cpp} data types which are supported in SYCL are described in
<<table.types.fundamental>>.
Note these types are fundamental and therefore do not exist within the
[code]#sycl# namespace.

Additional scalar data types which are supported by SYCL within the [code]#sycl#
namespace are described in <<table.types.additional>>.


[[table.types.additional]]
.Additional scalar data types supported by SYCL
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Scalar data type @ Description
a@
[source]
----
byte
----
   a@ An alias to [code]#std::uint8_t#.  This is deprecated in SYCL 2020 since
      {cpp17} [code]#std::byte# can be used instead.

a@
[source]
----
half
----
   a@ A 16-bit floating-point. The half data type must conform to the IEEE
      754-2008 half precision storage format. This type is only supported
      on devices that have [code]#aspect::fp16#. [code]#std::numeric_limits#
      must be specialized for the half data type.

|====


// \input{vec_class}

// %%%%%%%%%%%%%%%%%%%%%%%%%%%% begin vec_class %%%%%%%%%%%%%%%%%%%%%%%%%%%%

[[sec:vector.type]]
=== Vector types

SYCL provides a cross-platform class template that works efficiently on SYCL
devices as well as in host {cpp} code.
This type allows sharing of vectors between the host and its SYCL devices.
The vector supports member functions that allow construction of a new vector
from a swizzled set of component elements.

The [code]#vec# class is templated on its number of elements and its element
type.
The number of elements parameter, [code]#NumElements#, must be one of: 1, 2, 3,
4, 8 or 16.
Any other value shall produce a compilation failure.
The element type parameter, [code]#DataT#, must be the cv-unqualified version of
one of the following: one of the built-in scalar data types listed in
<<subsec:scalartypes>>, [code]#half#, or [code]#sycl::byte#.

An instance of the SYCL [code]#vec# class template can be implicitly converted
to an instance of the data type when the number of elements is [code]#1# in
order to allow single element vectors and scalars to be convertible with each
other.

==== Vec interface

The constructors, member functions and non-member functions of the SYCL
[code]#vec# class template are listed in <<table.constructors.vec>>,
<<table.members.vec>> and <<table.functions.vec>> respectively.

// Interface for class: vec
[source,,linenums]
----
include::{header_dir}/vec.h[lines=4..-1]
----


[[table.constructors.vec]]
.Constructors of the SYCL [code]#vec# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
vec()
----
   a@ Default construct a vector with element type [code]#DataT# and
      with [code]#NumElements# dimensions by default construction of
      each of its elements.

a@
[source]
----
explicit constexpr vec(const DataT& arg)
----
a@ _Constraints:_ [code]#NumElements# is greater than 1.

Constructs a [code]#vec# object by assigning each element to [code]#arg#.

a@
[source]
----
constexpr vec(const DataT& arg)
----
a@ _Constraints:_ [code]#NumElements# is equal to 1.

Constructs a 1-element [code]#vec# object by assigning the element to
[code]#arg#.

a@
[source]
----
template <typename... ArgTN> constexpr vec(const ArgTN&... args)
----
a@ _Constraints:_

* The total number of elements from all parameters is greater than 1 and sums to
[code]#NumElements#, and

* Each type [code]#ArgTN# is one of the following:
** A type that is implicitly convertible to [code]#DataT#, or
** A [code]#vec# type whose element type is [code]#DataT#, or
** A [code]#+__writeable_swizzle__+# type whose element type is [code]#DataT#, or
** A [code]#+__const_swizzle__+# type whose element type is [code]#DataT#.

Constructs a [code]#vec# object from a combination of scalar and vector
parameters.

a@
[source]
----
constexpr vec(const vec<DataT, NumElements>& rhs)
----
   a@ Construct a vector of element type [code]#DataT# and number of elements [code]#NumElements# by copy from another similar vector.

|====



[[table.members.vec]]
.Member functions for the SYCL [code]#vec# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
operator DataT() const
----
   a@ Available only when: [code]#NumElements == 1#.

Converts this SYCL [code]#vec# instance to an instance of [code]#DataT# with
the value of the single element in this SYCL [code]#vec# instance.

The SYCL [code]#vec# instance shall be implicitly convertible to the same data types,
to which [code]#DataT# is implicitly convertible.
Note that conversion operator shall not be templated
to allow standard conversion sequence for implicit conversion.

a@
[source]
----
template<typename T>
explicit operator T() const
----
a@ _Constraints:_

* [code]#NumElements# is equal to 1, and
* [code]#DataT# can be explicitly converted to [code]#T# via
  [code]#static_cast<T>#, and
* [code]#T# is not [code]#DataT#.

Returns the value of the vector's element converted to [code]#T#.

a@
[source]
----
static constexpr size_t size() noexcept
----
   a@ Returns the number of elements of this SYCL [code]#vec#.
a@
[source]
----
size_t get_count() const
----
   a@ Returns the same value as [code]#size()#. Deprecated.
a@
[source]
----
static constexpr size_t byte_size() noexcept
----
   a@ Returns the size of this SYCL [code]#vec# in bytes.

3-element vector size matches 4-element vector size to provide
interoperability with OpenCL vector types. The same rule applies to vector
alignment as described in <<memory-layout-and-alignment>>.
a@
[source]
----
size_t get_size() const
----
   a@ Returns the same value as [code]#byte_size()#. Deprecated.
a@
[source]
----
template <typename ConvertT,
          rounding_mode RoundingMode = rounding_mode::automatic>
vec<ConvertT, NumElements> convert() const
----
   a@ Converts this SYCL [code]#vec# to a SYCL [code]#vec# of a different element type specified by [code]#ConvertT# using the rounding mode specified by [code]#RoundingMode#. The new SYCL [code]#vec# type must have the same number of elements as this SYCL [code]#vec#. The different rounding modes are described in <<table.vec.roundingmodes>>.

a@
[source]
----
template <typename AsT> AsT as() const
----
   a@ Equivalent to [code]#sycl::bit_cast<AsT>(*this)#.

[NOTE]
====
Since the object representation of a [code]#vec<T, 3># contains padding bits
(see <<memory-layout-and-alignment>>), using [code]#as# or [code]#bit_cast# to
create a [code]#vec# with a different number of elements can lead to undefined
behavior.
====

a@
[source]
----
template <int... swizzleIndexes> __writeable_swizzle__ swizzle()
template <int... swizzleIndexes> __const_swizzle__ swizzle() const
----
   a@ Available only when: The number of [code]#swizzleIndexes# template
      parameters is 1, 2, 3, 4, 8, or 16.
      Available only when: Each of the [code]#swizzleIndexes# template
      parameters is greater or equal to 0 and less than [code]#NumElements#.

Return an instance of the implementation-defined [code]#+__writeable_swizzle__+#
or [code]#+__const_swizzle__+# class representing a swizzled view of the vector
as described in <<swizzled-vec-class>>.
The [code]#swizzleIndexes# argument pack specifies the elements in the swizzle.

a@
[source]
----
DataT& XYZW_ACCESS()
const DataT& XYZW_ACCESS() const
----
   a@ Available only when: [code]#+NumElements <= 4+#.

Return a reference to the element identified by [code]#XYZW_ACCESS#.

Where [code]#XYZW_ACCESS# is: [code]#x# for [code]#NumElements == 1#,
[code]#x, y# for
[code]#NumElements == 2#,
[code]#x, y, z# for
[code]#NumElements == 3# and
[code]#x, y, z, w# for
[code]#NumElements == 4#.

a@
[source]
----
DataT& RGBA_ACCESS()
const DataT& RGBA_ACCESS() const
----
   a@ Available only when: [code]#NumElements == 4#.

Return a reference to the element identified by [code]#RGBA_ACCESS#.

Where [code]#RGBA_ACCESS# is: [code]#r, g, b, a#.

a@
[source]
----
DataT& INDEX_ACCESS()
const DataT& INDEX_ACCESS() const
----
a@ Return a reference to the element identified by [code]#INDEX_ACCESS#.

Where [code]#INDEX_ACCESS# is: [code]#s0# for [code]#NumElements == 1#,
[code]#s0, s1# for
[code]#NumElements == 2#,
[code]#s0, s1, s2# for
[code]#NumElements == 3#,
[code]#s0, s1, s2, s3# for
[code]#NumElements == 4#,
[code]#s0, s1, s2, s3, s4, s5, s6, s7, s8# for
[code]#NumElements == 8# and
[code]#s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, sA, sB, sC, sD, sE, sF# for
[code]#NumElements == 16#.

a@
[source]
----
__writeable_swizzle__ XYZW_SWIZZLE()
__const_swizzle__ XYZW_SWIZZLE() const
----
   a@ Available only when: [code]#+NumElements <= 4+#, and when the macro [code]#SYCL_SIMPLE_SWIZZLES# is defined before including [code]#<sycl/sycl.hpp>#.

Return an instance of the implementation-defined [code]#+__writeable_swizzle__+#
or [code]#+__const_swizzle__+# class representing a swizzled view of the vector
as described in <<swizzled-vec-class>>.

Where XYZW_SWIZZLE is all permutations with repetition, of any subset with length greater than [code]#1#, of [code]#x, y# for
[code]#NumElements == 2#,
[code]#x, y, z# for
[code]#NumElements == 3# and
[code]#x, y, z, w# for
[code]#NumElements == 4#. For example a four element [code]#vec# provides permutations including [code]#xzyw#, [code]#xyyy# and [code]#xz#.

a@
[source]
----
__writeable_swizzle__ RGBA_SWIZZLE()
__const_swizzle__ RGBA_SWIZZLE() const
----
   a@ Available only when: [code]#NumElements == 4#, and when the macro [code]#SYCL_SIMPLE_SWIZZLES# is defined before including [code]#<sycl/sycl.hpp>#.

Return an instance of the implementation-defined [code]#+__writeable_swizzle__+#
or [code]#+__const_swizzle__+# class representing a swizzled view of the vector
as described in <<swizzled-vec-class>>.

Where RGBA_SWIZZLE is all permutations with repetition, of any subset with length greater than [code]#1#, of [code]#r, g, b, a#.
For example a four element [code]#vec# provides permutations including [code]#rbga#, [code]#rggg# and [code]#rb#.

a@
[source]
----
__writeable_swizzle__ lo()
__const_swizzle__ lo() const
----
   a@ Available only when: [code]#NumElements > 1#.

Return an instance of the implementation-defined [code]#+__writeable_swizzle__+#
or [code]#+__const_swizzle__+# class representing a swizzled view of the vector
as described in <<swizzled-vec-class>>.
The swizzle consists of the lower half of the elements in the vector.
When [code]#NumElements == 3#, the vector is treated as though
[code]#NumElements == 4# with the fourth element undefined.

a@
[source]
----
__writeable_swizzle__ hi()
__const_swizzle__ hi() const
----
   a@ Available only when: [code]#NumElements > 1#.

Return an instance of the implementation-defined [code]#+__writeable_swizzle__+#
or [code]#+__const_swizzle__+# class representing a swizzled view of the vector
as described in <<swizzled-vec-class>>.
The swizzle consists of the upper half of the elements in the vector.
When [code]#NumElements == 3#, the vector is treated as though
[code]#NumElements == 4# with the fourth element undefined.

a@
[source]
----
__writeable_swizzle__ odd()
__const_swizzle__ odd() const
----
   a@ Available only when: [code]#NumElements > 1#.

Return an instance of the implementation-defined [code]#+__writeable_swizzle__+#
or [code]#+__const_swizzle__+# class representing a swizzled view of the vector
as described in <<swizzled-vec-class>>.
The swizzle consists of the elements in the vector with an odd numbered index.
When [code]#NumElements == 3#, the vector is treated as though
[code]#NumElements == 4# with the fourth element undefined.


a@
[source]
----
__writeable_swizzle__ even()
__const_swizzle__ even() const
----
   a@ Available only when: [code]#NumElements > 1#.

Return an instance of the implementation-defined [code]#+__writeable_swizzle__+#
or [code]#+__const_swizzle__+# class representing a swizzled view of the vector
as described in <<swizzled-vec-class>>.
The swizzle consists of the elements in the vector with an even numbered index.
When [code]#NumElements == 3#, the vector is treated as though
[code]#NumElements == 4# with the fourth element undefined.

a@
[source]
----
template <access::address_space AddressSpace,
          access::decorated IsDecorated>
void load(
  size_t offset,
  multi_ptr<const DataT, AddressSpace, IsDecorated> ptr)

void load(size_t offset, const DataT* ptr)
----
   a@ Loads [code]#NumElements# elements into the components of this SYCL [code]#vec#. These elements are loaded from consecutive addresses, where the starting address is computed by adding [code]#offset * NumElements * sizeof(DataT)# bytes to the address specified by the [code]#ptr#. The [code]#ptr# must be aligned to [code]#alignof(DataT)#.

a@
[source]
----
template <access::address_space AddressSpace,
          access::decorated IsDecorated>
void store(
  size_t offset,
  multi_ptr<DataT, AddressSpace, IsDecorated> ptr) const

void store(size_t offset, DataT* ptr) const
----
   a@ Stores [code]#NumElements# components of this SYCL [code]#vec# into consecutive addresses, with the starting address determined by adding [code]#offset * NumElements * sizeof(DataT)# to the address specified by the [code]#ptr#. The [code]#ptr# must be aligned to [code]#alignof(DataT)#.

a@
[source]
----
DataT& operator[](int index)
----
   a@ Returns a reference to the element stored within this SYCL [code]#vec# at the index specified by [code]#index#.

a@
[source]
----
const DataT& operator[](int index) const
----
   a@ Returns a const reference to the element stored within this SYCL [code]#vec# at the index specified by [code]#index#.

a@
[source]
----
vec& operator=(const vec& rhs)
----
   a@ Assign each element of the [code]#rhs# SYCL [code]#vec# to each element of this SYCL [code]#vec# and return a reference to this SYCL [code]#vec#.

a@
[source]
----
template<typename T>
vec& operator=(const T& rhs)
----
a@ _Constraints:_ [code]#T# is implicitly convertible to [code]#DataT#.

Assign the [code]#rhs# scalar to each element of this SYCL [code]#vec# and return a reference to this SYCL [code]#vec#.

|====



[[table.functions.vec]]
.Hidden friend functions of the [code]#vec# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Hidden friend function @ Description
a@
[source]
----
vec operatorOP(const vec& lhs, const vec& rhs)
----
   a@ If [code]#OP# is [code]#%#, available only when: [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#vec# class template with the same template parameters as [code]#lhs# [code]#vec# with each element of the new SYCL [code]#vec# instance the result of an element-wise [code]#OP# arithmetic operation between each element of [code]#lhs# [code]#vec# and each element of the [code]#rhs# SYCL [code]#vec#.

Where [code]#OP# is: [code]#pass:[+]#, [code]#-#, [code]#*#, [code]#/#, [code]#%#.

a@
[source]
----
template<typename T>
vec operatorOP(const vec& lhs, const T& rhs)
----
a@ _Constraints:_

* [code]#T# is implicitly convertible to [code]#DataT#, and
* If [code]#OP# is [code]#%#, [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#vec# class template with the same template parameters as [code]#lhs# [code]#vec# with each element of the new SYCL [code]#vec# instance the result of an element-wise [code]#OP# arithmetic operation between each element of [code]#lhs# [code]#vec# and the [code]#rhs# scalar.

Where [code]#OP# is: [code]#pass:[+]#, [code]#-#, [code]#*#, [code]#/#, [code]#%#.

a@
[source]
----
template<typename T>
vec operatorOP(const T& lhs, const vec& rhs)
----
a@ _Constraints:_

* [code]#T# is implicitly convertible to [code]#DataT#, and
* If [code]#OP# is [code]#%#, [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#vec# class template with
the same template parameters as the [code]#rhs# SYCL [code]#vec#
with each element of the new SYCL [code]#vec# instance the result of
an element-wise [code]#OP# arithmetic operation between the
[code]#lhs# scalar and each element of the [code]#rhs# SYCL
[code]#vec#.

Where [code]#OP# is: [code]#pass:[+]#, [code]#-#, [code]#*#,
[code]#/#, [code]#%#.

a@
[source]
----
vec& operatorOP(vec& lhs, const vec& rhs)
----
   a@ If [code]#OP# is [code]#%=#, available only when: [code]#DataT != float && DataT != double && DataT != half#.

Perform an in-place element-wise [code]#OP# arithmetic operation between each element of [code]#lhs# [code]#vec# and each element of the [code]#rhs# SYCL [code]#vec# and return [code]#lhs# [code]#vec#.

Where [code]#OP# is: [code]#pass:[+=]#, [code]#-=#, [code]#*=#, [code]#/=#, [code]#%=#.

a@
[source]
----
template<typename T>
vec& operatorOP(vec& lhs, const T& rhs)
----
a@ _Constraints:_

* [code]#T# is implicitly convertible to [code]#DataT#, and
* If [code]#OP# is [code]#%=#, [code]#DataT != float && DataT != double && DataT != half#.

Perform an in-place element-wise [code]#OP# arithmetic operation between each element of [code]#lhs# [code]#vec# and [code]#rhs# scalar and return [code]#lhs# [code]#vec#.

Where [code]#OP# is: [code]#pass:[+=]#, [code]#-=#, [code]#*=#, [code]#/=#, [code]#%=#.

a@
[source]
----
vec& operatorOP(vec& v)
----
   a@ Available only when: [code]#DataT != bool#.

Perform an in-place element-wise [code]#OP# prefix arithmetic operation on each element of [code]#v# and return [code]#v#.

Where [code]#OP# is: [code]#pass:[++]#, [code]#--#.

a@
[source]
----
vec operatorOP(vec& v, int)
----
   a@ Available only when: [code]#DataT != bool#.

Perform an in-place element-wise [code]#OP# postfix arithmetic operation on each element of [code]#v# and return a copy of [code]#v# before the operation is performed.

Where [code]#OP# is: [code]#pass:[++]#, [code]#--#.

a@
[source]
----
vec operatorOP(const vec& v)
----
   a@ Construct a new instance of the SYCL [code]#vec# class template with the same template parameters as this SYCL [code]#vec# with each element of the new SYCL [code]#vec# instance the result of an element-wise [code]#OP# unary arithmetic operation on each element of this SYCL [code]#vec#.

Where [code]#OP# is: [code]#pass:[+]#, [code]#-#.

a@
[source]
----
vec operatorOP(const vec& lhs, const vec& rhs)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#vec# class template with the same template parameters as [code]#lhs# [code]#vec# with each element of the new SYCL [code]#vec# instance the result of an element-wise [code]#OP# bitwise operation between each element of [code]#lhs# [code]#vec# and each element of the [code]#rhs# SYCL [code]#vec#.

Where [code]#OP# is: [code]#&#, [code]#|#, [code]#^#.

a@
[source]
----
template<typename T>
vec operatorOP(const vec& lhs, const T& rhs)
----
a@ _Constraints:_

* [code]#T# is implicitly convertible to [code]#DataT#, and
* [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#vec# class template with the same template parameters as [code]#lhs# [code]#vec# with each element of the new SYCL [code]#vec# instance the result of an element-wise [code]#OP# bitwise operation between each element of [code]#lhs# [code]#vec# and the [code]#rhs# scalar.

Where [code]#OP# is: [code]#&#, [code]#|#, [code]#^#.

a@
[source]
----
template<typename T>
vec operatorOP(const T& lhs, const vec& rhs)
----
a@ _Constraints:_

* [code]#T# is implicitly convertible to [code]#DataT#, and
* [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#vec# class template with
the same template parameters as the [code]#rhs# SYCL [code]#vec#
with each element of the new SYCL [code]#vec# instance the result of
an element-wise [code]#OP# bitwise operation between the [code]#lhs# scalar and each element of the [code]#rhs# SYCL [code]#vec#.

Where [code]#OP# is: [code]#&#, [code]#|#, [code]#^#.

a@
[source]
----
vec& operatorOP(vec& lhs, const vec& rhs)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Perform an in-place element-wise [code]#OP# bitwise operation between each element of [code]#lhs# [code]#vec# and the [code]#rhs# SYCL [code]#vec# and return [code]#lhs# [code]#vec#.

Where [code]#OP# is: [code]#&=#, [code]#|=#, [code]#^=#.

a@
[source]
----
template<typename T>
vec& operatorOP(vec& lhs, const T& rhs)
----
a@ _Constraints:_

* [code]#T# is implicitly convertible to [code]#DataT#, and
* [code]#DataT != float && DataT != double && DataT != half#.

Perform an in-place element-wise [code]#OP# bitwise operation between each element of [code]#lhs# [code]#vec# and the [code]#rhs# scalar and return a [code]#lhs# [code]#vec#.

Where [code]#OP# is: [code]#&=#, [code]#|=#, [code]#^=#.

a@
[source]
----
vec operatorOP(const vec& lhs, const vec& rhs)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#vec# class template with the same template parameters as [code]#lhs# [code]#vec# with each element of the new SYCL [code]#vec# instance the result of an element-wise [code]#OP# bitshift operation between each element of [code]#lhs# [code]#vec# and each element of the [code]#rhs# SYCL [code]#vec#. If [code]#OP# is [code]#>>#, [code]#DataT# is a signed type and [code]#lhs# [code]#vec# has a negative value any vacated bits viewed as an unsigned integer must be assigned the value [code]#1#, otherwise any vacated bits viewed as an unsigned integer must be assigned the value [code]#0#.

Where [code]#OP# is: [code]#<<#, [code]#>>#.

a@
[source]
----
template<typename T>
vec operatorOP(const vec& lhs, const T& rhs)
----
a@ _Constraints:_

* [code]#T# is implicitly convertible to [code]#DataT#, and
* [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#vec# class template with the same template parameters as [code]#lhs# [code]#vec# with each element of the new SYCL [code]#vec# instance the result of an element-wise [code]#OP# bitshift operation between each element of [code]#lhs# [code]#vec# and the [code]#rhs# scalar. If [code]#OP# is [code]#>>#, [code]#DataT# is a signed type and [code]#lhs# [code]#vec# has a negative value any vacated bits viewed as an unsigned integer must be assigned the value [code]#1#, otherwise any vacated bits viewed as an unsigned integer must be assigned the value [code]#0#.

Where [code]#OP# is: [code]#<<#, [code]#>>#.

a@
[source]
----
template<typename T>
vec operatorOP(const T& lhs, const vec& rhs)
----
a@ _Constraints:_

* [code]#T# is implicitly convertible to [code]#DataT#, and
* [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#vec# class template with
the same template parameters as the [code]#rhs# SYCL [code]#vec#
with each element of the new SYCL [code]#vec# instance the result of
an element-wise [code]#OP# bitshift operation between the [code]#lhs# scalar and each element of the [code]#rhs# SYCL [code]#vec#.
If [code]#OP# is [code]#>>#, [code]#DataT# is a signed type
and this SYCL [code]#vec# has a negative value any vacated bits viewed
as an unsigned integer must be assigned the value [code]#1#, otherwise
any vacated bits viewed as an unsigned integer must be assigned the value
[code]#0#.

Where [code]#OP# is: [code]#<<#, [code]#>>#.

a@
[source]
----
vec& operatorOP(vec& lhs, const vec& rhs)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Perform an in-place element-wise [code]#OP# bitshift operation between each element of [code]#lhs# [code]#vec# and the [code]#rhs# SYCL [code]#vec# and returns [code]#lhs# [code]#vec#. If [code]#OP# is [code]#>>=#, [code]#DataT# is a signed type and [code]#lhs# [code]#vec# has a negative value any vacated bits viewed as an unsigned integer must be assigned the value [code]#1#, otherwise any vacated bits viewed as an unsigned integer must be assigned the value [code]#0#.

Where [code]#OP# is: [code]#+<<=+#, [code]#>>=#.

a@
[source]
----
template<typename T>
vec& operatorOP(vec& lhs, const T& rhs)
----
a@ _Constraints:_

* [code]#T# is implicitly convertible to [code]#DataT#, and
* [code]#DataT != float && DataT != double && DataT != half#.

Perform an in-place element-wise [code]#OP# bitshift operation between each element of [code]#lhs# [code]#vec# and the [code]#rhs# scalar and returns a reference to this SYCL [code]#vec#. If [code]#OP# is [code]#>>=#, [code]#DataT# is a signed type and [code]#lhs# [code]#vec# has a negative value any vacated bits viewed as an unsigned integer must be assigned the value [code]#1#, otherwise any vacated bits viewed as an unsigned integer must be assigned the value [code]#0#.

Where [code]#OP# is: [code]#+<<=+#, [code]#>>=#.

a@
[source]
----
vec<RET, NumElements> operatorOP(const vec& lhs, const vec& rhs)
----
   a@ Construct a new instance of the SYCL [code]#vec# class template with the same template parameters as [code]#lhs# [code]#vec# with each element of the new SYCL [code]#vec# instance the result of an element-wise [code]#OP# logical operation between each element of [code]#lhs# [code]#vec# and each element of the [code]#rhs# SYCL [code]#vec#.

The element type of the returned [code]#vec#, [code]#RET#, varies depending on
the size of the [code]#DataT# template parameter of the input [code]#vec#.
If [code]#sizeof(DataT)# is 1, [code]#RET# is [code]#int8_t#.
If [code]#sizeof(DataT)# is 2, [code]#RET# is [code]#int16_t#.
If [code]#sizeof(DataT)# is 4, [code]#RET# is [code]#int32_t#.
If [code]#sizeof(DataT)# is 8, [code]#RET# is [code]#int64_t#.
If [code]#sizeof(DataT)# is any other value, [code]#RET# is an implementation
defined integer type.

Where [code]#OP# is: [code]#&&#, [code]#||#.

a@
[source]
----
template<typename T>
vec<RET, NumElements> operatorOP(const vec& lhs, const T& rhs)
----
a@ _Constraints:_ [code]#T# is implicitly convertible to [code]#DataT#.

Construct a new instance of the SYCL [code]#vec# class template with the same template parameters as this SYCL [code]#vec# with each element of the new SYCL [code]#vec# instance the result of an element-wise [code]#OP# logical operation between each element of [code]#lhs# [code]#vec# and the [code]#rhs# scalar.

The element type of the returned [code]#vec#, [code]#RET#, varies depending on
the size of the [code]#DataT# template parameter of the input [code]#vec#.
If [code]#sizeof(DataT)# is 1, [code]#RET# is [code]#int8_t#.
If [code]#sizeof(DataT)# is 2, [code]#RET# is [code]#int16_t#.
If [code]#sizeof(DataT)# is 4, [code]#RET# is [code]#int32_t#.
If [code]#sizeof(DataT)# is 8, [code]#RET# is [code]#int64_t#.
If [code]#sizeof(DataT)# is any other value, [code]#RET# is an implementation
defined integer type.

Where [code]#OP# is: [code]#&&#, [code]#||#.

a@
[source]
----
template<typename T>
vec<RET, NumElements> operatorOP(const T& lhs, const vec& rhs)
----
a@ _Constraints:_ [code]#T# is implicitly convertible to [code]#DataT#.

Construct a new instance of the SYCL [code]#vec# class template with
the same template parameters as the [code]#rhs# SYCL [code]#vec#
with each element of the new SYCL [code]#vec# instance the result of
an element-wise [code]#OP# logical operation between the [code]#lhs# scalar and each element of the [code]#rhs# SYCL [code]#vec#.

The element type of the returned [code]#vec#, [code]#RET#, varies depending on
the size of the [code]#DataT# template parameter of the input [code]#vec#.
If [code]#sizeof(DataT)# is 1, [code]#RET# is [code]#int8_t#.
If [code]#sizeof(DataT)# is 2, [code]#RET# is [code]#int16_t#.
If [code]#sizeof(DataT)# is 4, [code]#RET# is [code]#int32_t#.
If [code]#sizeof(DataT)# is 8, [code]#RET# is [code]#int64_t#.
If [code]#sizeof(DataT)# is any other value, [code]#RET# is an implementation
defined integer type.

Where [code]#OP# is: [code]#&&#, [code]#||#.

a@
[source]
----
vec<RET, NumElements> operatorOP(const vec& lhs, const vec& rhs)
----
   a@ Construct a new instance of the SYCL [code]#vec# class template with the element type [code]#RET# with each element of the new SYCL [code]#vec# instance the result of an element-wise [code]#OP# relational operation between each element of [code]#lhs# [code]#vec# and each element of the [code]#rhs# SYCL [code]#vec#. Each element of the SYCL [code]#vec# that is returned must be [code]#-1# if the operation results in [code]#true# and [code]#0# if the operation results in [code]#false#.  The [code]#==#, [code]#<#, [code]#>#, [code]#+<=+# and [code]#>=# operations result in [code]#false# if either the [code]#lhs# element or the [code]#rhs# element is a NaN.  The [code]#!=# operation results in [code]#true# if either the [code]#lhs# element or the [code]#rhs# element is a NaN.

The element type of the returned [code]#vec#, [code]#RET#, varies depending on
the size of the [code]#DataT# template parameter of the input [code]#vec#.
If [code]#sizeof(DataT)# is 1, [code]#RET# is [code]#int8_t#.
If [code]#sizeof(DataT)# is 2, [code]#RET# is [code]#int16_t#.
If [code]#sizeof(DataT)# is 4, [code]#RET# is [code]#int32_t#.
If [code]#sizeof(DataT)# is 8, [code]#RET# is [code]#int64_t#.
If [code]#sizeof(DataT)# is any other value, [code]#RET# is an implementation
defined integer type.

Where [code]#OP# is: [code]#==#, [code]#!=#, [code]#<#, [code]#>#, [code]#+<=+#, [code]#>=#.

a@
[source]
----
template<typename T>
vec<RET, NumElements> operatorOP(const vec& lhs, const T& rhs)
----
a@ _Constraints:_ [code]#T# is implicitly convertible to [code]#DataT#.

Construct a new instance of the SYCL [code]#vec# class template with the [code]#DataT# parameter of [code]#RET# with each element of the new SYCL [code]#vec# instance the result of an element-wise [code]#OP# relational operation between each element of [code]#lhs# [code]#vec# and the [code]#rhs# scalar. Each element of the SYCL [code]#vec# that is returned must be [code]#-1# if the operation results in [code]#true# and [code]#0# if the operation results in [code]#false#.  The [code]#==#, [code]#<#, [code]#>#, [code]#+<=+# and [code]#>=# operations result in [code]#false# if either the [code]#lhs# element or the [code]#rhs# is a NaN.  The [code]#!=# operation results in [code]#true# if either the [code]#lhs# element or the [code]#rhs# is a NaN.

The element type of the returned [code]#vec#, [code]#RET#, varies depending on
the size of the [code]#DataT# template parameter of the input [code]#vec#.
If [code]#sizeof(DataT)# is 1, [code]#RET# is [code]#int8_t#.
If [code]#sizeof(DataT)# is 2, [code]#RET# is [code]#int16_t#.
If [code]#sizeof(DataT)# is 4, [code]#RET# is [code]#int32_t#.
If [code]#sizeof(DataT)# is 8, [code]#RET# is [code]#int64_t#.
If [code]#sizeof(DataT)# is any other value, [code]#RET# is an implementation
defined integer type.

Where [code]#OP# is: [code]#==#, [code]#!=#, [code]#<#, [code]#>#, [code]#+<=+#, [code]#>=#.

a@
[source]
----
template<typename T>
vec<RET, NumElements> operatorOP(const T& lhs, const vec& rhs)
----
a@ _Constraints:_ [code]#T# is implicitly convertible to [code]#DataT#.

Construct a new instance of the SYCL [code]#vec# class template with
the element type [code]#RET# with each element of the new SYCL
[code]#vec# instance the result of an element-wise [code]#OP#
relational operation between the [code]#lhs# scalar and each element
of the [code]#rhs# SYCL [code]#vec#. Each element of the SYCL
[code]#vec# that is returned must be [code]#-1# if the operation
results in [code]#true# and [code]#0# if the operation results
in [code]#false#. The [code]#==#, [code]#<#, [code]#>#, [code]#+<=+#
and [code]#>=# operations result in [code]#false# if either the
[code]#lhs# or the [code]#rhs# element is a NaN. The [code]#!=#
operation results in [code]#true# if either the [code]#lhs# or the
[code]#rhs# element is a NaN.

The element type of the returned [code]#vec#, [code]#RET#, varies depending on
the size of the [code]#DataT# template parameter of the input [code]#vec#.
If [code]#sizeof(DataT)# is 1, [code]#RET# is [code]#int8_t#.
If [code]#sizeof(DataT)# is 2, [code]#RET# is [code]#int16_t#.
If [code]#sizeof(DataT)# is 4, [code]#RET# is [code]#int32_t#.
If [code]#sizeof(DataT)# is 8, [code]#RET# is [code]#int64_t#.
If [code]#sizeof(DataT)# is any other value, [code]#RET# is an implementation
defined integer type.

Where [code]#OP# is: [code]#==#, [code]#!=#, [code]#<#, [code]#>#, [code]#+<=+#, [code]#>=#.

a@
[source]
----
vec operator~(const vec& v)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#vec# class template with the same template parameters as [code]#v# [code]#vec# with each element of the new SYCL [code]#vec# instance the result of an element-wise bitwise NOT operation on each element of [code]#v# [code]#vec#.

a@
[source]
----
vec<RET, NumElements> operator!(const vec& v)
----
   a@ Construct a new instance of the SYCL [code]#vec# class template with the same template parameters as [code]#v# [code]#vec# with each element of the new SYCL [code]#vec# instance the result of an element-wise logical NOT operation on each element of [code]#v# [code]#vec#. Each element of the SYCL [code]#vec# that is returned must be [code]#-1# if the operation results in [code]#true# and [code]#0# if the operation results in [code]#false# or this SYCL [code]#vec# is a NaN.

The element type of the returned [code]#vec#, [code]#RET#, varies depending on
the size of the [code]#DataT# template parameter of the input [code]#vec#.
If [code]#sizeof(DataT)# is 1, [code]#RET# is [code]#int8_t#.
If [code]#sizeof(DataT)# is 2, [code]#RET# is [code]#int16_t#.
If [code]#sizeof(DataT)# is 4, [code]#RET# is [code]#int32_t#.
If [code]#sizeof(DataT)# is 8, [code]#RET# is [code]#int64_t#.
If [code]#sizeof(DataT)# is any other value, [code]#RET# is an implementation
defined integer type.

|====


==== Aliases

The SYCL programming API provides all permutations of the type alias:

[code]#+using <type><elems> = vec<<storage-type>, <elems>>+#

where [code]#<elems># is [code]#2#, [code]#3#, [code]#4#, [code]#8# and
[code]#16#, and pairings of [code]#<type># and [code]#<storage-type># for
integral types are [code]#char# and [code]#int8_t#, [code]#uchar# and
[code]#uint8_t#, [code]#short# and [code]#int16_t#, [code]#ushort# and
[code]#uint16_t#, [code]#int# and [code]#int32_t#, [code]#uint# and
[code]#uint32_t#, [code]#long# and [code]#int64_t#, [code]#ulong# and
[code]#uint64_t#, and for floating point types are both [code]#half#,
[code]#float# and [code]#double#.

For example [code]#uint4# is the alias to [code]#vec<uint32_t, 4># and
[code]#float16# is the alias to [code]#vec<float, 16>#.

==== Swizzles

Swizzle operations can be performed in two ways.
Firstly by calling the [code]#swizzle# member function template, which takes a
variadic number of integer template arguments between [code]#0# and
[code]#NumElements-1#, specifying swizzle indexes.
Secondly by calling one of the simple swizzle member functions defined in
<<table.members.vec>> as [code]#XYZW_SWIZZLE# and [code]#RGBA_SWIZZLE#.
Note that the simple swizzle functions are only available for up to 4 element
vectors and are only available when the macro [code]#SYCL_SIMPLE_SWIZZLES# is
defined before including [code]#<sycl/sycl.hpp>#.

In both cases the return value is an instance of either the
[code]#+__writeable_swizzle__+# or the [code]#+__const_swizzle__+# class
template.
These classes have an implementation-defined name, and they represent a view of
the original [code]#vec# object with the swizzle operation applied.
The [code]#+__writeable_swizzle__+# class represents a writeable view of the
[code]#vec# object, while the [code]#+__const_swizzle__+# class represents a
read-only view.
Since the swizzle operation may result in a different number of elements, these
views may represent a different number of elements than the original [code]#vec#
object.

Both the [code]#swizzle# member function template and the simple swizzle member
functions allow swizzle indexes to be repeated.

A series of static constexpr values are provided within the [code]#elem# struct
to allow specifying named swizzle indexes when calling the [code]#swizzle#
member function template.


[[swizzled-vec-class]]
==== The swizzled vector classes

The [code]#+__writeable_swizzle__+# and [code]#+__const_swizzle__+# classes are
each views over a [code]#vec# object which captures the effects of a swizzle
operation without actually performing that operation.
The tables below define the interfaces to these classes, but in general
[code]#+__writeable_swizzle__+# supports the same interface as [code]#vec#,
while [code]#+__const_swizzle__+# supports only the non-mutating operations of
[code]#vec#.
Member functions and operators that read elements from these views return
elements from the underlying [code]#vec# as translated by the captured swizzle
operation.
Member functions and operators that modify elements of these views modify
corresponding elements of the underlying [code]#vec# as translated by the
captured swizzle operation.
The following example illustrates this behavior:

[source,,linenums]
----
include::{code_dir}/swizzle-example.cpp[lines=4..-1]
----

Synopses of the [code]#+__writeable_swizzle__+# and [code]#+__const_swizzle__+#
classes are shown below.
The member type aliases are described in <<sec:types.swizzled-vec>>, the
constructors are described in <<sec:constructors.swizzled-vec>>, the member
functions are described in <<sec:members.swizzled-vec>>, and the hidden friend
functions are described in <<sec:functions.swizzled-vec>>.

The [code]#+__writeable_swizzle__+# and [code]#+__const_swizzle__+# classes are
not user constructible.

The [code]#+__writeable_swizzle__+# and [code]#+__const_swizzle__+# types are
class templates, but the template parameters are unspecified.
The description below describes the member functions and hidden friend functions
using two exposition-only private members named [code]#DataT# and
[code]#NumElements#.
The type alias [code]#DataT# represents the element type of the underlying
[code]#vec#.
The constant [code]#NumElements# represents the number of elements in the result
of the swizzle operation, which could be different from the number of elements
in the underlying [code]#vec#.

Because the template parameters to the [code]#+__writeable_swizzle__+# and
[code]#+__const_swizzle__+# classes affect the {cpp} argument dependent lookup
(ADL) behavior, implementations do not have complete freedom when choosing these
template parameters.
Implementations must choose template parameters that result in the following ADL
behavior:

* When an argument is the [code]#+__writeable_swizzle__+# type, the ADL search
  set must include only the class template definition for
  [code]#+__writeable_swizzle__+#, the class definition for [code]#DataT# (if it
  is a class), and the namespace that contains [code]#DataT#.

* When an argument is the [code]#+__const_swizzle__+# type, the ADL search set
  must include only the class template definition for
  [code]#+__const_swizzle__+#, the class definition for [code]#DataT# (if it is
  a class), and the namespace that contains [code]#DataT#.

When the string [code]#+__writeable_swizzle__+# or [code]#+__const_swizzle__+#
is used inside the class definition in the synopses below, it refers to the
instantiation with the same set of template parameters as the enclosing class.
This is consistent with {cpp} syntax.
When the string [code]#+__writeable_swizzle__</*unspecified*/>+# or
[code]#+__const_swizzle__</*unspecified*/>+# is used inside the class
definition, it refers to a possibly different instantiation of the
[code]#+__writeable_swizzle__+# or [code]#+__const_swizzle__+# class.

Although the synopses below illustrate [code]#+__writeable_swizzle__+# and
[code]#+__const_swizzle__+# as two separate classes, this is exposition only.
An implementation could instead implement a single combined class with
additional constraints on the member functions.

[source,,linenums]
----
include::{header_dir}/swizzled-vec.h[lines=4..-1]
----

[[sec:types.swizzled-vec]]
===== Member type aliases for the swizzled vector class templates

[frame=all,grid=none,separator="@"]
|====
a@
[source]
----
using element_type = DataT
using value_type = DataT
----
|====
Each of these type aliases tells the type of an element in the underlying
[code]#vec#.

[[sec:constructors.swizzled-vec]]
===== Constructors for the swizzled vector class templates

[frame=all,grid=none,separator="@"]
|====
a@
[source]
----
__writeable_swizzle__() = delete
__writeable_swizzle__(const __writeable_swizzle__&) = delete

__const_swizzle__() = delete
__const_swizzle__(const __const_swizzle__&) = delete
----
|====
The default constructor and copy constructor are deleted.

===== Destructors for the swizzled vector class templates

[frame=all,grid=none,separator="@"]
|====
a@
[source]
----
~__writeable_swizzle__()
~__const_swizzle__()
----
|====
The destructors have no visible effect.

[[sec:members.swizzled-vec]]
===== Member functions for the swizzled vector class templates

[frame=all,grid=none,separator="@"]
|====
a@
[source]
----
operator DataT() const

template<typename T>
explicit operator T() const

static constexpr size_t byte_size() noexcept
static constexpr size_t size() noexcept

size_t get_size() const   // Deprecated
size_t get_count() const  // Deprecated

template <typename ConvertT,
          rounding_mode RoundingMode = rounding_mode::automatic>
vec<ConvertT, NumElements> convert() const

template <typename asT> asT as() const

template <access::address_space AddressSpace, access::decorated IsDecorated>
void store(size_t offset, multi_ptr<DataT, AddressSpace, IsDecorated> ptr) const
----
|====
_Availability:_ These functions are available in both
[code]#+__writeable_swizzle__+# and [code]#+__const_swizzle__+#.

_Constraints:_ These functions have the same constraints as the equivalent
member functions of the [code]#vec# class.

_Effects:_ The effect of these functions is the same as if they were called on a
temporary [code]#vec# object that contains the result of the captured swizzle
operation.

'''

[frame=all,grid=none,separator="@"]
|====
a@
[source]
----
operator vec<DataT, NumElements>() const
----
|====
_Availability:_ These functions are available in both
[code]#+__writeable_swizzle__+# and [code]#+__const_swizzle__+#.

_Returns:_ A new [code]#vec# object that contains the result of the captured
swizzle operation.

'''

[frame=all,grid=none,separator="@"]
|====
a@
[source]
----
DataT& XYZW_ACCESS() const         (1)
DataT& RGBA_ACCESS() const         (2)
DataT& INDEX_ACCESS() const        (3)

const DataT& XYZW_ACCESS() const   (4)
const DataT& RGBA_ACCESS() const   (5)
const DataT& INDEX_ACCESS() const  (6)
----
|====
_Availability:_ Functions (1) - (3) are available only in
[code]#+__writeable_swizzle__+#.
Functions (4) - (6) are available only in [code]#+__const_swizzle__+#.

_Constraints:_ These functions have the same constraints as the equivalent
member functions of the [code]#vec# class.

_Returns:_ A reference to the element of the underlying [code]#vec# object that
corresponds to the position of the swizzle operation identified by
[code]#XYZW_ACCESS#, [code]#RGBA_ACCESS#, or [code]#INDEX_ACCESS#.

'''

[frame=all,grid=none,separator="@"]
|====
a@
[source]
----
template <int... swizzleIndexes> __writeable_swizzle__</*unspecified*/> swizzle() const  (1)

#ifdef SYCL_SIMPLE_SWIZZLES
__writeable_swizzle__</*unspecified*/> XYZW_SWIZZLE() const                              (2)
__writeable_swizzle__</*unspecified*/> RGBA_SWIZZLE() const                              (3)
#endif

__writeable_swizzle__</*unspecified*/> lo() const                                        (4)
__writeable_swizzle__</*unspecified*/> hi() const                                        (5)
__writeable_swizzle__</*unspecified*/> odd() const                                       (6)
__writeable_swizzle__</*unspecified*/> even() const                                      (7)


template <int... swizzleIndexes> __const_swizzle__</*unspecified*/> swizzle() const      (8)

#ifdef SYCL_SIMPLE_SWIZZLES
__const_swizzle__</*unspecified*/> XYZW_SWIZZLE() const                                  (9)
__const_swizzle__</*unspecified*/> RGBA_SWIZZLE() const                                  (10)
#endif

__const_swizzle__</*unspecified*/> lo() const                                            (11)
__const_swizzle__</*unspecified*/> hi() const                                            (12)
__const_swizzle__</*unspecified*/> odd() const                                           (13)
__const_swizzle__</*unspecified*/> even() const                                          (14)
----
|====
_Availability:_ Functions (1) - (7) are available only in
[code]#+__writeable_swizzle__+#.
Functions (8) - (14) are available only in [code]#+__const_swizzle__+#.

_Constraints:_ These functions have the same constraints as the equivalent
member functions of the [code]#vec# class.

_Returns:_ A new view of the underlying [code]#vec# object, where the view
represents the composition of two swizzle operations.
The first is the swizzle operation represented by the
[code]#+__writeable_swizzle__+# or [code]#+__const_swizzle__+# view.
The second is the swizzle operation defined by the member function.
The indices used by the second swizzle are the indices produced by the first
swizzle.
For example, if the second swizzle references the first element, this means the
element of the underlying [code]#vec# that corresponds to the first element
produced by the first swizzle.

'''

[frame=all,grid=none,separator="@"]
|====
a@
[source]
----
template <access::address_space AddressSpace, access::decorated IsDecorated>
void load(size_t offset, multi_ptr<const DataT, AddressSpace, IsDecorated> ptr) const
----
|====
_Availability:_ Available only in [code]#+__writeable_swizzle__+#.

_Constraints:_ Available only when the [code]#+__writeable_swizzle__+# view does
not contain any repeated elements.

_Effects:_ Loads values from memory into elements of the underlying [code]#vec#
object.
A total of [code]#NumElements# values are loaded from memory, starting at the
the address [code]#ptr + offset*sizeof(DataT)#.
The first value from memory is written to the element in [code]#vec# that
corresponds to the first element of the swizzle operation.
The second value from memory is written to the element in [code]#vec# that
corresponds to the second element of the swizzle operation, etc.

'''

[frame=all,grid=none,separator="@"]
|====
a@
[source]
----
DataT& operator[](int index) const        (1)
const DataT& operator[](int index) const  (2)
----
|====
_Availability:_ Functions (1) is available only in
[code]#+__writeable_swizzle__+#.
Functions (2) is available only in [code]#+__const_swizzle__+#.

_Returns:_ A reference to the element of the underlying [code]#vec# object that
corresponds to the position [code]#index# of the swizzle operation.

'''

[frame=all,grid=none,separator="@"]
|====
a@
[source]
----
const __writeable_swizzle__&
operator=(const __writeable_swizzle__& rhs) const
----
|====
_Availability:_ Available only in [code]#+__writeable_swizzle__+#.

_Constraints:_ Available only when the [code]#+__writeable_swizzle__+# view does
not contain any repeated elements.

_Effects:_ Assigns elements from the right hand side
[code]#+__writeable_swizzle__+# view to elements of the left hand side
[code]#+__writeable_swizzle__+# view.
The value corresponding to the first element of the [code]#rhs# swizzle
operation is assigned to the element of the underlying [code]#vec# object that
corresponds to the first element of the left hand side swizzle operation, etc.

_Returns:_ A reference to the left hand side [code]#+__writeable_swizzle__+#
view.

'''

[frame=all,grid=none,separator="@"]
|====
a@
[source]
----
const __const_swizzle__&
operator=(const __const_swizzle__& rhs) const = delete;
----
|====
The copy assignment operator is deleted for the [code]#+__const_swizzle__+#
class.

'''

[frame=all,grid=none,separator="@"]
|====
a@
[source]
----
template</*unspecified*/>
const __writeable_swizzle__&
operator=(const __writeable_swizzle__</*unspecified*/>& rhs) const

template</*unspecified*/>
const __writeable_swizzle__&
operator=(const __const_swizzle__</*unspecified*/>& rhs) const
----
|====
_Availability:_ Available only in [code]#+__writeable_swizzle__+#.

_Constraints:_ Available only when all of the following conditions are met:

* The element data type of [code]#rhs# is the same as [code]#DataT#;
* The number of elements in the [code]#rhs# view is equal to
  [code]#NumElements#; and
* The [code]#+__writeable_swizzle__+# view (i.e. the left hand side of the
  assignment) does not contain any repeated elements.

_Effects:_ Assigns elements from the right hand side
[code]#+__writeable_swizzle__+# or [code]#+__const_swizzle__+# view to elements
of the left hand side [code]#+__writeable_swizzle__+# view.
The value corresponding to the first element of the [code]#rhs# swizzle
operation is assigned to the element of the underlying [code]#vec# object that
corresponds to the first element of the left hand side swizzle operation, etc.

_Returns:_ A reference to the left hand side [code]#+__writeable_swizzle__+#
view.

'''

[frame=all,grid=none,separator="@"]
|====
a@
[source]
----
const __writeable_swizzle__& operator=(const DataT& rhs) const
----
|====
_Availability:_ Available only in [code]#+__writeable_swizzle__+#.

_Constraints:_ Available only when the [code]#+__writeable_swizzle__+# view does
not contain any repeated elements.

_Effects:_ Assigns the value [code]#rhs# to those elements of the underlying
[code]#vec# object that have corresponding elements in the
[code]#+__writeable_swizzle__+# view.
Elements in the underlying [code]#vec# object that do not have elements in the
[code]#+__writeable_swizzle__+# view are not assigned.

_Returns:_ A reference to the [code]#+__writeable_swizzle__+# view.

'''

[frame=all,grid=none,separator="@"]
|====
a@
[source]
----
const __writeable_swizzle__& operator=(const vec<DataT, NumElements>& rhs) const
----
|====
_Availability:_ Available only in [code]#+__writeable_swizzle__+#.

_Constraints:_ Available only when the [code]#+__writeable_swizzle__+# view does
not contain any repeated elements.

_Effects:_ Assigns elements from [code]#rhs# to elements of the [code]#vec#
object that underlies this [code]#+__writeable_swizzle__+# view.
The first element of [code]#rhs# is assigned to the element of the underlying
[code]#vec# object that corresponds to the first element of the swizzle
operation, etc.

_Returns:_ A reference to the [code]#+__writeable_swizzle__+# view.

[[sec:functions.swizzled-vec]]
===== Hidden friend functions of the swizzled vector class templates

[frame=all,grid=none,separator="@"]
|====
a@
[source]
----
template</*unspecified*/>                                                               (1)
friend vec<DataT, NumElements>
operatorOP(const __writeable_swizzle__& lhs,
           const __writeable_swizzle__</*unspecified*/>& rhs)

template</*unspecified*/>                                                               (2)
friend vec<DataT, NumElements>
operatorOP(const __writeable_swizzle__& lhs,
           const __const_swizzle__</*unspecified*/>& rhs)

template</*unspecified*/>                                                               (3)
friend vec<DataT, NumElements>
operatorOP(const __const_swizzle__</*unspecified*/>& lhs,
           const __writeable_swizzle__& rhs)

template</*unspecified*/>                                                               (4)
friend vec<DataT, NumElements>
operatorOP(const __const_swizzle__& lhs, const __const_swizzle__</*unspecified*/>& rhs)

friend vec<DataT, NumElements>                                                          (5)
operatorOP(const vec<DataT, NumElements>& lhs, const __writeable_swizzle__& rhs)

friend vec<DataT, NumElements>                                                          (6)
operatorOP(const vec<DataT, NumElements>& lhs, const __const_swizzle__& rhs)

friend vec<DataT, NumElements>                                                          (7)
operatorOP(const __writeable_swizzle__& lhs, const vec<DataT, NumElements>& rhs)

friend vec<DataT, NumElements>                                                          (8)
operatorOP(const __const_swizzle__& lhs, const vec<DataT, NumElements>& rhs)

template<typename T>
friend vec<DataT, NumElements>                                                          (9)
operatorOP(const __writeable_swizzle__& lhs, const T& rhs)

template<typename T>
friend vec<DataT, NumElements>                                                          (10)
operatorOP(const __const_swizzle__& lhs, const T& rhs)

template<typename T>
friend vec<DataT, NumElements>                                                          (11)
operatorOP(const T& lhs, const __writeable_swizzle__& rhs)

template<typename T>
friend vec<DataT, NumElements>                                                          (12)
operatorOP(const T& lhs, const __const_swizzle__& rhs)
----
|====
Where [code]#OP# is: [code]#pass:[+]#, [code]#-#, [code]#*#, [code]#/#,
[code]#%#, [code]#&#, [code]#|#, [code]#^#, [code]#<<#, [code]#>>#.

_Availability:_ Overloads (1), (2), (3), (5), (7), (9), and (11) are hidden
friends of [code]#+__writeable_swizzle__+#.
Overloads (4), (6), (8), (10), and (12) are hidden friends of
[code]#+__const_swizzle__+#.

_Constraints:_ If [code]#OP# is one of the following: [code]#%#, [code]#&#,
[code]#|#, [code]#^#, [code]#<<#, [code]#>>#; available only when: [code]#DataT
!= float && DataT != double && DataT != half#.

Overloads (1) - (4) are available only when the element data type of [code]#lhs#
is the same as the element data type of [code]#rhs# and when the number of
elements in the [code]#lhs# view is equal to the number of elements in the
[code]#rhs# view.

Overloads (9) - (12) are available only when [code]#T# is implicitly convertible
to [code]#DataT# and when [code]#T# is not one of the swizzled vector class
templates.

_Effects:_ These functions behave as though the swizzle operation represented by
each [code]#+__writeable_swizzle__+# or [code]#+__const_swizzle__+# parameter
was first evaluated into a temporary [code]#vec# object, and then
[code]#operatorOP# was called with the temporary [code]#vec# object.

_Returns:_ A new [code]#vec# object that represents the result of the operation.

'''

[frame=all,grid=none,separator="@"]
|====
a@
[source]
----
template</*unspecified*/>                                                        (1)
friend const __writeable_swizzle__&
operatorOP(const __writeable_swizzle__& lhs,
           const __writeable_swizzle__</*unspecified*/>& rhs)

template</*unspecified*/>                                                        (2)
friend const __writeable_swizzle__&
operatorOP(const __writeable_swizzle__& lhs,
           const __const_swizzle__</*unspecified*/>& rhs)

friend const __writeable_swizzle__&                                              (3)
operatorOP(const __writeable_swizzle__& lhs, const vec<DataT, NumElements>& rhs)

template<typename T>
friend const __writeable_swizzle__&                                              (4)
operatorOP(const __writeable_swizzle__& lhs, const T& rhs)
----
|====
Where [code]#OP# is: [code]#pass:[+=]#, [code]#-=#, [code]#*=#, [code]#/=#,
[code]#%=#, [code]#&=#, [code]#|=#, [code]#^=#, [code]#+<<=+#, [code]#>>=#.

_Availability:_ These are hidden friend functions only in
[code]#+__writeable_swizzle__+#.

_Constraints:_ Available only when the left hand side
[code]#+__writeable_swizzle__+# view does not contain any repeated elements.

If [code]#OP# is one of the following: [code]#%=#, [code]#&=#, [code]#|=#,
[code]#^=#, [code]#+<<=+#, [code]#>>=#; available only when: [code]#DataT !=
float && DataT != double && DataT != half#.

Overloads (1) and (2) are available only when the element data type of
[code]#lhs# is the same as the element data type of [code]#rhs# and when the
number of elements in the [code]#lhs# view is equal to the number of elements in
the [code]#rhs# view.

Overloads (4) is available only when [code]#T# is implicitly convertible to
[code]#DataT# and when [code]#T# is not one of the swizzled vector class
templates.

_Effects:_ These functions operate as follow.

A left hand side value is computed from [code]#lhs# by applying the swizzle
operation on the underlying [code]#vec# object.
If the [code]#rhs# is a [code]#+__writeable_swizzle__+# view, the right hand
side value is computed the same way.
Otherwise, the right hand side value is the same as [code]#rhs#.

The non-assignment part of the operation is performed on these two values,
producing a result.
This result is assigned to [code]#lhs# as follows.

The first element of the result is assigned to the [code]#vec# element that
corresponds to the first element of the left-hand-side swizzle.
The second element of the result is assigned to the [code]#vec# element that
corresponds to the second element of the left-hand-side swizzle, etc.

_Returns:_ A reference to the [code]#lhs#.

'''

[frame=all,grid=none,separator="@"]
|====
a@
[source]
----
friend const __writeable_swizzle__& operatorOP(const __writeable_swizzle__& sv)
----
|====
Where [code]#OP# is: [code]#pass:[++]#, [code]#--#.

_Availability:_ These are hidden friend functions only in
[code]#+__writeable_swizzle__+#.

_Constraints:_ Available only when the [code]#+__writeable_swizzle__+# view does
not contain any repeated elements.
Available only when [code]#DataT# is not [code]#bool#.

_Effects:_ Perform an in-place element-wise [code]#OP# prefix arithmetic
operation on those elements of the [code]#vec# object that have corresponding
elements in the [code]#sv# view.
Elements in the underlying [code]#vec# object that do not have elements in the
[code]#sv# view are not modified.

_Returns:_ A reference to the [code]#sv# view.

'''

[frame=all,grid=none,separator="@"]
|====
a@
[source]
----
friend vec<DataT, NumElements> operatorOP(const __writeable_swizzle__& sv, int)
----
|====
Where [code]#OP# is: [code]#pass:[++]#, [code]#--#.

_Availability:_ These are hidden friend functions only in
[code]#+__writeable_swizzle__+#.

_Constraints:_ Available only when the [code]#+__writeable_swizzle__+# view does
not contain any repeated elements.
Available only when [code]#DataT# is not [code]#bool#.

_Effects:_ Perform an in-place element-wise [code]#OP# postfix arithmetic
operation on those elements of the [code]#vec# object that have corresponding
elements in the [code]#sv# view.
Elements in the underlying [code]#vec# object that do not have elements in the
[code]#sv# view are not modified.

_Returns:_ A new [code]#vec# object that represents the elements of [code]#sv#
after the swizzle operation is applied and before the postfix arithmetic
operation is applied.

'''

[frame=all,grid=none,separator="@"]
|====
a@
[source]
----
friend vec<DataT, NumElements> operatorOP(const __writeable_swizzle__& sv)  (1)
friend vec<DataT, NumElements> operatorOP(const __const_swizzle__& sv)      (2)
----
|====
Where [code]#OP# is: [code]#pass:[+]#, [code]#-#.

_Availability:_ Functions (1) are hidden friends in
[code]#+__writeable_swizzle__+#.
Functions (2) are hidden friends in [code]#+__const_swizzle__+#.

_Effects:_ These functions behave as though the swizzle operation represented by
the [code]#sv# parameter was first evaluated into a temporary [code]#vec#
object, and then [code]#operatorOP# was applied to the temporary [code]#vec#
object.

_Returns:_ A [code]#vec# object that represents the result of the operation.

'''

[frame=all,grid=none,separator="@"]
|====
a@
[source]
----
template</*unspecified*/>                                                               (1)
friend vec<RET, NumElements>
operatorOP(const __writeable_swizzle__& lhs,
           const __writeable_swizzle__</*unspecified*/>& rhs)

template</*unspecified*/>                                                               (2)
friend vec<RET, NumElements>
operatorOP(const __writeable_swizzle__& lhs,
           const __const_swizzle__</*unspecified*/>& rhs)

template</*unspecified*/>                                                               (3)
friend vec<RET, NumElements>
operatorOP(const __const_swizzle__</*unspecified*/>& lhs,
           const __writeable_swizzle__& rhs)

template</*unspecified*/>                                                               (4)
friend vec<RET, NumElements>
operatorOP(const __const_swizzle__& lhs, const __const_swizzle__</*unspecified*/>& rhs)

friend vec<RET, NumElements>                                                            (5)
operatorOP(const vec<DataT, NumElements>& lhs, const __writeable_swizzle__& rhs)

friend vec<RET, NumElements>                                                            (6)
operatorOP(const vec<DataT, NumElements>& lhs, const __const_swizzle__& rhs)

friend vec<RET, NumElements>                                                            (7)
operatorOP(const __writeable_swizzle__& lhs, const vec<DataT, NumElements>& rhs)

friend vec<RET, NumElements>                                                            (8)
operatorOP(const __const_swizzle__& lhs, const vec<DataT, NumElements>& rhs)

template<typename T>
friend vec<RET, NumElements>                                                            (9)
operatorOP(const __writeable_swizzle__& lhs, const T& rhs)

template<typename T>
friend vec<RET, NumElements>                                                            (10)
operatorOP(const __const_swizzle__& lhs, const T& rhs)

template<typename T>
friend vec<RET, NumElements>                                                            (11)
operatorOP(const T& lhs, const __writeable_swizzle__& rhs)

template<typename T>
friend vec<RET, NumElements>                                                            (12)
operatorOP(const T& lhs, const __const_swizzle__& rhs)
----
|====
Where [code]#OP# is: [code]#&&#, [code]#||#, [code]#==#, [code]#!=#, [code]#<#,
[code]#>#, [code]#+<=+#, [code]#>=#.

_Availability:_ Overloads (1), (2), (3), (5), (7), (9), and (11) are hidden
friends of [code]#+__writeable_swizzle__+#.
Overloads (4), (6), (8), (10), and (12) are hidden friends of
[code]#+__const_swizzle__+#.

_Constraints:_ Overloads (1) - (4) are available only when the element data type
of [code]#lhs# is the same as the element data type of [code]#rhs# and when the
number of elements in the [code]#lhs# view is equal to the number of elements in
the [code]#rhs# view.

Overloads (9) - (12) are available only when [code]#T# is implicitly convertible
to [code]#DataT# and when [code]#T# is not one of the swizzled vector class
templates.

_Effects:_ These functions behave as though the swizzle operation represented by
each [code]#+__writeable_swizzle__+# or [code]#+__const_swizzle__+# parameter
was first evaluated into a temporary [code]#vec# object, and then
[code]#operatorOP# was called with the temporary [code]#vec# object.

_Returns:_ A [code]#vec# object that represents the result of the operation.

'''

[frame=all,grid=none,separator="@"]
|====
a@
[source]
----
friend vec<DataT, NumElements> operator~(const __writeable_swizzle__& sv)  (1)
friend vec<DataT, NumElements> operator~(const __const_swizzle__& sv)      (2)

friend vec<RET, NumElements> operator!(const __writeable_swizzle__& sv)    (3)
friend vec<RET, NumElements> operator!(const __const_swizzle__& sv)        (4)
----
|====
_Availability:_ Overloads (1) and (3) are hidden friends of
[code]#+__writeable_swizzle__+#.
Overloads (2) and (4) are hidden friends of [code]#+__const_swizzle__+#.

_Constraints:_ Overloads (1) - (2) are available only when: [code]#DataT !=
float && DataT != double && DataT != half#.

_Effects:_ These functions behave as though the swizzle operation represented by
the [code]#+__writeable_swizzle__+# or [code]#+__const_swizzle__+# parameter was
first evaluated into a temporary [code]#vec# object, and then the bitwise or
logical NOT operation was applied to the temporary [code]#vec# object.

_Returns:_ A [code]#vec# object that represents the result of the operation.


==== Rounding modes

The various rounding modes that can be used in the [code]#convert# member
function template are described in <<table.vec.roundingmodes>>.


[[table.vec.roundingmodes]]
.Rounding modes for the SYCL [code]#vec# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Rounding mode @ Description
a@
[source]
----
automatic
----
   a@ Default rounding mode for the SYCL [code]#vec# class element type. [code]#rtz# (round toward zero) for integer types and [code]#rte# (round to nearest even) for floating-point types.

a@
[source]
----
rte
----
   a@ Round to nearest even.

a@
[source]
----
rtz
----
   a@ Round toward zero.

a@
[source]
----
rtp
----
   a@ Round toward positive infinity.

a@
[source]
----
rtn
----
   a@ Round toward negative infinity.

|====



[[memory-layout-and-alignment]]
==== Memory layout and alignment

The elements of an instance of the SYCL [code]#vec# class template are stored in
memory sequentially and contiguously and are aligned to the size of the element
type in bytes multiplied by the number of elements:

[[vec-memory-alignment]]
[latexmath]
++++
\texttt{sizeof}(\texttt{DataT}) \cdot \texttt{NumElements}
++++

The exception to this is when the number of element is three in which case the
SYCL [code]#vec# is aligned to the size of the element type in bytes multiplied
by four:

[[vec3-memory-alignment]]
[latexmath]
++++
\texttt{sizeof}(\texttt{DataT}) \cdot 4
++++

This is true for both host and device code in order to allow for instances of
the [code]#vec# class template to be passed to SYCL kernel functions.

In no case, however, is the alignment guaranteed to be greater than 64 bytes.

[NOTE]
====
The alignment guarantee is limited to 64 bytes because some host compilers (e.g.
on Microsoft Windows) limit the maximum alignment of function parameters to this
value.
====


==== Performance note

The usage of the subscript [code]#operator[]# may not be efficient on some
devices.

// %%%%%%%%%%%%%%%%%%%%%%%%%%%% end vec_class %%%%%%%%%%%%%%%%%%%%%%%%%%%%

// \input{marray_class}

// %%%%%%%%%%%%%%%%%%%%%%%%%%%% begin marray_class %%%%%%%%%%%%%%%%%%%%%%%%%%%%

[[sec:marray.type]]
=== Math array types

SYCL provides an [code]#marray<typename DataT, std::size_t NumElements># class
template to represent a contiguous fixed-size container.
This type allows sharing of containers between the host and its SYCL devices.

The [code]#marray# class is templated on its element type and number of
elements.
The number of elements parameter, [code]#NumElements#, is a positive value of
the [code]#std::size_t# type.
The element type parameter, [code]#DataT#, must be a _numeric type_ as it is
defined by {cpp} standard.

An instance of the [code]#marray# class template can also be implicitly
converted to an instance of the data type when the number of elements is
[code]#1# in order to allow single element arrays and scalars to be convertible
with each other.

Logical and comparison operators for [code]#marray# class template return
[code]#marray<bool, NumElements>#.


==== Math array interface

The constructors, member functions and non-member functions of the SYCL
[code]#marray# class template are listed in <<table.constructors.marray>>,
<<table.members.marray>> and <<table.functions.marray>> respectively.

// Interface for class: vec
[source,,linenums]
----
include::{header_dir}/marray.h[lines=4..-1]
----


[[table.constructors.marray]]
.Constructors of the SYCL [code]#marray# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
marray()
----
   a@ Default construct an array with element type [code]#DataT# and
      with [code]#NumElements# dimensions by default construction of
      each of its elements.

a@
[source]
----
explicit constexpr marray(const DataT& arg)
----
   a@ Construct an array of element type [code]#DataT# and
      [code]#NumElements# dimensions by setting each value to [code]#arg# by
      assignment.

a@
[source]
----
template <typename... ArgTN> constexpr marray(const ArgTN&... args)
----
   a@ Construct a SYCL [code]#marray# instance from any combination of scalar and SYCL [code]#marray# parameters of the same element type, providing the total number of elements for all parameters sum to [code]#NumElements# of this [code]#marray# specialization.

a@
[source]
----
constexpr marray(const marray<DataT, NumElements>& rhs)
----
   a@ Construct an array of element type [code]#DataT# and number of elements [code]#NumElements# by copy from another similar vector.

a@
[source]
----
constexpr marray(marray<DataT, NumElements>&& rhs)
----
   a@ Construct an array of element type [code]#DataT# and number of elements
      [code]#NumElements# by moving from another similar vector.

|====



[[table.members.marray]]
.Member functions for the SYCL [code]#marray# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
operator DataT() const
----
   a@ Available only when: [code]#NumElements == 1#.

Converts this SYCL [code]#marray# instance to an instance of [code]#DataT# with
the value of the single element in this SYCL [code]#marray# instance.

The SYCL [code]#marray# instance shall be implicitly convertible to the same data types,
to which [code]#DataT# is implicitly convertible.
Note that conversion operator shall not be templated
to allow standard conversion sequence for implicit conversion.

a@
[source]
----
static constexpr std::size_t size() noexcept
----
   a@ Returns the number of elements in this SYCL [code]#marray# (i.e., [code]#NumElements#).

a@
[source]
----
DataT& operator[](std::size_t index)
----
   a@ Returns a reference to the element stored within this SYCL [code]#marray# at the index specified by [code]#index#.

a@
[source]
----
const DataT& operator[](std::size_t index) const
----
   a@ Returns a const reference to the element stored within this SYCL [code]#marray# at the index specified by [code]#index#.

a@
[source]
----
marray& operator=(const marray& rhs)
----
   a@ Assign each element of the [code]#rhs# SYCL [code]#marray# to each element of this SYCL [code]#marray# and return a reference to this SYCL [code]#marray#.

a@
[source]
----
marray& operator=(const DataT& rhs)
----
   a@ Assign each element of the [code]#rhs# scalar to each element of this SYCL [code]#marray# and return a reference to this SYCL [code]#marray#.

a@
[source]
----
iterator begin()
----
   a@ Returns an iterator referring to the first element stored within the [code]#marray#.

a@
[source]
----
const_iterator begin() const
----
   a@ Returns a const iterator referring to the first element stored within the [code]#marray#.

a@
[source]
----
iterator end()
----
   a@ Returns an iterator referring to the one past the last element stored within the [code]#marray#.

a@
[source]
----
const_iterator end() const
----
   a@ Returns a const iterator referring to the one past the last
      element stored within the [code]#marray#.

|====



[[table.functions.marray]]
.Hidden friend functions of the [code]#marray# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Hidden friend function @ Description
a@
[source]
----
marray operatorOP(const marray& lhs, const marray& rhs)
----
   a@ If [code]#OP# is [code]#%#, available only when: [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#marray# class template with the same template parameters as [code]#lhs# [code]#marray# with each element of the new SYCL [code]#marray# instance the result of an element-wise [code]#OP# arithmetic operation between each element of [code]#lhs# [code]#marray# and each element of the [code]#rhs# SYCL [code]#marray#.

Where [code]#OP# is: [code]#pass:[+]#, [code]#-#, [code]#*#, [code]#/#, [code]#%#.

a@
[source]
----
marray operatorOP(const marray& lhs, const DataT& rhs)
----
   a@ If [code]#OP# is [code]#%#, available only when: [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#marray# class template with the same template parameters as [code]#lhs# [code]#marray# with each element of the new SYCL [code]#marray# instance the result of an element-wise [code]#OP# arithmetic operation between each element of [code]#lhs# [code]#marray# and the [code]#rhs# scalar.

Where [code]#OP# is: [code]#pass:[+]#, [code]#-#, [code]#*#, [code]#/#, [code]#%#.

a@
[source]
----
marray& operatorOP(marray& lhs, const marray& rhs)
----
   a@ If [code]#OP# is [code]#%=#, available only when: [code]#DataT != float && DataT != double && DataT != half#.

Perform an in-place element-wise [code]#OP# arithmetic operation between each element of [code]#lhs# [code]#marray# and each element of the [code]#rhs# SYCL [code]#marray# and return [code]#lhs# [code]#marray#.

Where [code]#OP# is: [code]#pass:[+=]#, [code]#-=#, [code]#*=#, [code]#/=#, [code]#%=#.

a@
[source]
----
marray& operatorOP(marray& lhs, const DataT& rhs)
----
   a@ If [code]#OP# is [code]#%=#, available only when: [code]#DataT != float && DataT != double && DataT != half#.

Perform an in-place element-wise [code]#OP# arithmetic operation between each element of [code]#lhs# [code]#marray# and [code]#rhs# scalar and return [code]#lhs# [code]#marray#.

Where [code]#OP# is: [code]#pass:[+=]#, [code]#-=#, [code]#*=#, [code]#/=#, [code]#%=#.

a@
[source]
----
marray& operatorOP(marray& v)
----
   a@ Perform an in-place element-wise [code]#OP# prefix arithmetic operation on each element of [code]#v# [code]#marray#, assigning the result of each element to the corresponding element of [code]#v# [code]#marray# and return [code]#v# [code]#marray#.

Where [code]#OP# is: [code]#pass:[++]#, [code]#--#.

a@
[source]
----
marray operatorOP(marray& v, int)
----
   a@ Perform an in-place element-wise [code]#OP# postfix arithmetic operation on each element of [code]#v# [code]#marray#, assigning the result of each element to the corresponding element of [code]#v# [code]#marray# and returns a copy of [code]#v# [code]#marray# before the operation is performed.

Where [code]#OP# is: [code]#pass:[++]#, [code]#--#.

a@
[source]
----
marray operatorOP(marray& v)
----
   a@ Construct a new instance of the SYCL [code]#marray# class template with the same template parameters as this SYCL [code]#marray# with each element of the new SYCL [code]#marray# instance the result of an element-wise [code]#OP# unary arithmetic operation on each element of this SYCL [code]#marray#.

Where [code]#OP# is: [code]#pass:[+]#, [code]#-#.

a@
[source]
----
marray operatorOP(const marray& lhs, const marray& rhs)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#marray# class template with the same template parameters as [code]#lhs# [code]#marray# with each element of the new SYCL [code]#marray# instance the result of an element-wise [code]#OP# bitwise operation between each element of [code]#lhs# [code]#marray# and each element of the [code]#rhs# SYCL [code]#marray#.

Where [code]#OP# is: [code]#&#, [code]#|#, [code]#^#.

a@
[source]
----
marray operatorOP(const marray& lhs, const DataT& rhs)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#marray# class template with the same template parameters as [code]#lhs# [code]#marray# with each element of the new SYCL [code]#marray# instance the result of an element-wise [code]#OP# bitwise operation between each element of [code]#lhs# [code]#marray# and the [code]#rhs# scalar.

Where [code]#OP# is: [code]#&#, [code]#|#, [code]#^#.

a@
[source]
----
marray& operatorOP(marray& lhs, const marray& rhs)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Perform an in-place element-wise [code]#OP# bitwise operation between each element of [code]#lhs# [code]#marray# and the [code]#rhs# SYCL [code]#marray# and return [code]#lhs# [code]#marray#.

Where [code]#OP# is: [code]#&=#, [code]#|=#, [code]#^=#.

a@
[source]
----
marray& operatorOP(marray& lhs, const DataT& rhs)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Perform an in-place element-wise [code]#OP# bitwise operation between each element of [code]#lhs# [code]#marray# and the [code]#rhs# scalar and return a [code]#lhs# [code]#marray#.

Where [code]#OP# is: [code]#&=#, [code]#|=#, [code]#^=#.

a@
[source]
----
marray<bool, NumElements> operatorOP(const marray& lhs, const marray& rhs)
----
   a@ Construct a new instance of the [code]#marray# class template with [code]#DataT = bool# and same NumElements as [code]#lhs# [code]#marray# with each element of the new [code]#marray# instance the result of an element-wise [code]#OP# logical operation between each element of [code]#lhs# [code]#marray# and each element of the [code]#rhs# [code]#marray#.

Where [code]#OP# is: [code]#&&#, [code]#||#.

a@
[source]
----
marray<bool, NumElements> operatorOP(const marray& lhs, const DataT& rhs)
----
   a@ Construct a new instance of the [code]#marray# class template with [code]#DataT = bool# and same NumElements as [code]#lhs# [code]#marray# with each element of the new [code]#marray# instance the result of an element-wise [code]#OP# logical operation between each element of [code]#lhs# [code]#marray# and the [code]#rhs# scalar.

Where [code]#OP# is: [code]#&&#, [code]#||#.

a@
[source]
----
marray operatorOP(const marray& lhs, const marray& rhs)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#marray# class template with the same template parameters as [code]#lhs# [code]#marray# with each element of the new SYCL [code]#marray# instance the result of an element-wise [code]#OP# bitshift operation between each element of [code]#lhs# [code]#marray# and each element of the [code]#rhs# SYCL [code]#marray#. If [code]#OP# is [code]#>>#, [code]#DataT# is a signed type and [code]#lhs# [code]#marray# has a negative value any vacated bits viewed as an unsigned integer must be assigned the value [code]#1#, otherwise any vacated bits viewed as an unsigned integer must be assigned the value [code]#0#.

Where [code]#OP# is: [code]#<<#, [code]#>>#.

a@
[source]
----
marray operatorOP(const marray& lhs, const DataT& rhs)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#marray# class template with the same template parameters as [code]#lhs# [code]#marray# with each element of the new SYCL [code]#marray# instance the result of an element-wise [code]#OP# bitshift operation between each element of [code]#lhs# [code]#marray# and the [code]#rhs# scalar. If [code]#OP# is [code]#>>#, [code]#DataT# is a signed type and [code]#lhs# [code]#marray# has a negative value any vacated bits viewed as an unsigned integer must be assigned the value [code]#1#, otherwise any vacated bits viewed as an unsigned integer must be assigned the value [code]#0#.

Where [code]#OP# is: [code]#<<#, [code]#>>#.

a@
[source]
----
marray& operatorOP(marray& lhs, const marray& rhs)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Perform an in-place element-wise [code]#OP# bitshift operation between each element of [code]#lhs# [code]#marray# and the [code]#rhs# SYCL [code]#marray# and returns [code]#lhs# [code]#marray#. If [code]#OP# is [code]#>>=#, [code]#DataT# is a signed type and [code]#lhs# [code]#marray# has a negative value any vacated bits viewed as an unsigned integer must be assigned the value [code]#1#, otherwise any vacated bits viewed as an unsigned integer must be assigned the value [code]#0#.

Where [code]#OP# is: [code]#+<<=+#, [code]#>>=#.

a@
[source]
----
marray& operatorOP(marray& lhs, const DataT& rhs)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Perform an in-place element-wise [code]#OP# bitshift operation between each element of [code]#lhs# [code]#marray# and the [code]#rhs# scalar and returns a reference to this SYCL [code]#marray#. If [code]#OP# is [code]#>>=#, [code]#DataT# is a signed type and [code]#lhs# [code]#marray# has a negative value any vacated bits viewed as an unsigned integer must be assigned the value [code]#1#, otherwise any vacated bits viewed as an unsigned integer must be assigned the value [code]#0#.

Where [code]#OP# is: [code]#+<<=+#, [code]#>>=#.

a@
[source]
----
marray<bool, NumElements> operatorOP(const marray& lhs, const marray& rhs)
----
   a@ Construct a new instance of the [code]#marray# class template with [code]#DataT = bool# and same NumElements as [code]#lhs# [code]#marray#
      with each element of the new [code]#marray# instance is the result of an element-wise [code]#OP# relational operation between each element of [code]#lhs# [code]#marray#
      and each element of the [code]#rhs# [code]#marray#.
      The [code]#==#, [code]#<#, [code]#>#, [code]#+<=+# and [code]#>=#
      operations result in [code]#false# if either the [code]#lhs# element or
      the [code]#rhs# element is a NaN.  The [code]#!=# operation results in
      [code]#true# if either the [code]#lhs# element or the [code]#rhs# element
      is a NaN.

Where [code]#OP# is: [code]#==#, [code]#!=#, [code]#<#, [code]#>#, [code]#+<=+#, [code]#>=#.

a@
[source]
----
marray<bool, NumElements> operatorOP(const marray& lhs, const DataT& rhs)
----
   a@ Construct a new instance of the [code]#marray# class template with [code]#DataT = bool# and same NumElements as [code]#lhs# [code]#marray#
      with each element of the new [code]#marray# instance the result of an element-wise [code]#OP# relational operation between each element of [code]#lhs# [code]#marray#
      and the [code]#rhs# scalar.
      The [code]#==#, [code]#<#, [code]#>#, [code]#+<=+# and [code]#>=#
      operations result in [code]#false# if either the [code]#lhs# element or
      the [code]#rhs# is a NaN.  The [code]#!=# operation results in
      [code]#true# if either the [code]#lhs# element or the [code]#rhs# is a
      NaN.

Where [code]#OP# is: [code]#==#, [code]#!=#, [code]#<#, [code]#>#, [code]#+<=+#, [code]#>=#.

a@
[source]
----
marray operatorOP(const DataT& lhs, const marray& rhs)
----
   a@ If [code]#OP# is [code]#%#, available only when: [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#marray# class template with
the same template parameters as the [code]#rhs# SYCL [code]#marray#
with each element of the new SYCL [code]#marray# instance the result of
an element-wise [code]#OP# arithmetic operation between the
[code]#lhs# scalar and each element of the [code]#rhs# SYCL
[code]#marray#.

Where [code]#OP# is: [code]#pass:[+]#, [code]#-#, [code]#*#,
[code]#/#, [code]#%#.

a@
[source]
----
marray operatorOP(const DataT& lhs, const marray& rhs)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#marray# class template with
the same template parameters as the [code]#rhs# SYCL [code]#marray#
with each element of the new SYCL [code]#marray# instance the result of
an element-wise [code]#OP# bitwise operation between the [code]#lhs# scalar and each element of the [code]#rhs# SYCL [code]#marray#.

Where [code]#OP# is: [code]#&#, [code]#|#, [code]#^#.

a@
[source]
----
marray<bool, NumElements> operatorOP(const DataT& lhs, const marray& rhs)
----
   a@ Construct a new instance of the [code]#marray# class template with [code]#DataT = bool# and
same NumElements as [code]#rhs# [code]#marray# with each element of the new [code]#marray# instance
the result of an element-wise [code]#OP# logical operation between the [code]#lhs#
scalar and each element of the [code]#rhs# [code]#marray#.

Where [code]#OP# is: [code]#&&#, [code]#||#.

a@
[source]
----
marray operatorOP(const DataT& lhs, const marray& rhs)
----
   a@ Construct a new instance of the SYCL [code]#marray# class template with
      the same template parameters as the [code]#rhs# SYCL [code]#marray#
      with each element of the new SYCL [code]#marray# instance the result of
      an element-wise [code]#OP# bitshift operation between the [code]#lhs# scalar and each element of the [code]#rhs# SYCL [code]#marray#.
      If [code]#OP# is [code]#>>#, [code]#DataT# is a signed type
      and this SYCL [code]#marray# has a negative value any vacated bits viewed
      as an unsigned integer must be assigned the value [code]#1#, otherwise
      any vacated bits viewed as an unsigned integer must be assigned the value
      [code]#0#.

Where [code]#OP# is: [code]#<<#, [code]#>>#.

a@
[source]
----
marray<bool, NumElements> operatorOP(const DataT& lhs, const marray& rhs)
----
   a@ Construct a new instance of the [code]#marray# class template with
      [code]#DataT = bool# and same NumElements as [code]#rhs# [code]#marray#
      with each element of the new SYCL [code]#marray# instance the result of
      an element-wise [code]#OP# relational operation between the [code]#lhs#
      scalar and each element of the [code]#rhs# [code]#marray#.  The
      [code]#==#, [code]#<#, [code]#>#, [code]#+<=+# and [code]#>=# operations
      result in [code]#false# if either the [code]#lhs# or the [code]#rhs#
      element is a NaN.  The [code]#!=# operation results in [code]#true# if
      either the [code]#lhs# or the [code]#rhs# element is a NaN.

Where [code]#OP# is: [code]#==#, [code]#!=#, [code]#<#, [code]#>#, [code]#+<=+#, [code]#>=#.

a@
[source]
----
marray& operator~(const marray& v)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#marray# class template with the same template parameters as [code]#v# [code]#marray# with each element of the new SYCL [code]#marray# instance the result of an element-wise [code]#OP# bitwise operation on each element of [code]#v# [code]#marray#.

a@
[source]
----
marray<bool, NumElements> operator!(const marray& v)
----
   a@ Construct a new instance of the [code]#marray# class template with [code]#DataT = bool# and same NumElements as [code]#v# [code]#marray#
      with each element of the new [code]#marray# instance the result of an element-wise logical [code]#!# operation on each element of [code]#v# [code]#marray#.

|====



==== Aliases

The SYCL programming API provides all permutations of the type alias:

[code]#+using m<type><elems> = marray<<storage-type>, <elems>>+#

where [code]#<elems># is [code]#2#, [code]#3#, [code]#4#, [code]#8# and
[code]#16#, and pairings of [code]#<type># and [code]#<storage-type># for
integral types are [code]#char# and [code]#int8_t#, [code]#uchar# and
[code]#uint8_t#, [code]#short# and [code]#int16_t#, [code]#ushort# and
[code]#uint16_t#, [code]#int# and [code]#int32_t#, [code]#uint# and
[code]#uint32_t#, [code]#long# and [code]#int64_t#, [code]#ulong# and
[code]#uint64_t#, for floating point types are both [code]#half#, [code]#float#
and [code]#double#, and for boolean type [code]#bool#.

For example [code]#muint4# is the alias to [code]#marray<uint32_t, 4># and
[code]#mfloat16# is the alias to [code]#marray<float, 16>#.


[[memory-layout-and-alignment.marray]]
==== Memory layout and alignment

The elements of an instance of the [code]#marray# class template as if stored in
[code]#std::array<DataT, NumElements>#.

// %%%%%%%%%%%%%%%%%%%%%%%%%%%% end marray_class %%%%%%%%%%%%%%%%%%%%%%%%%%%%


== Synchronization and atomics

The available features are:

  * Accessor classes: Accessor classes specify acquisition and release of buffer
    and image data structures to provide points at which a SYCL runtime must
    guarantee memory consistency.
  * Atomic operations: SYCL devices support a restricted subset of {cpp} atomics
    and SYCL uses the library syntax from the next {cpp} specification to make
    this available.
  * Fences: Fence primitives are made available to order loads and stores.
    They are exposed through the [code]#atomic_fence# function.
    Fences can have acquire semantics, release semantics or both.
  * Barriers: Barrier primitives are made available as a coordination mechanism
    for work-items within individual <<group,groups>>.
    They are exposed through the [code]#group_barrier# function.
  * Hierarchical parallel dispatch: In the hierarchical parallelism model of
    describing computations, work-items within a work-group may coordinate via
    multiple instances of the [code]#parallel_for_work_item# function call,
    rather than through the use of explicit <<work-group-barrier>> operations.
  * Device event: they are used inside SYCL kernel functions to wait for
    asynchronous operations within a SYCL kernel function to complete.


[[sec:barriers-fences]]
=== Barriers and fences

A <<group-barrier>> or <<mem-fence>> provides memory ordering semantics over
both the local address space and global address space.
A <<mem-fence>> provides control over the re-ordering of memory load and store
operations, subject to the associated memory [code]#order# and memory
[code]#scope#, when paired with synchronization through an atomic object.

[source,,linenums]
----
include::{header_dir}/synchronization.h[lines=4..-1]
----

The effects of a call to [code]#atomic_fence# depend on the value of the
[code]#order# parameter:

  * [code]#memory_order::relaxed:# No effect
  * [code]#memory_order::acquire:# Acquire fence
  * [code]#memory_order::release:# Release fence
  * [code]#memory_order::acq_rel:# Both an acquire fence and a release fence
  * [code]#memory_order::seq_cst:# A sequentially consistent acquire and release
    fence

A <<group-barrier>> acts as both an acquire fence and a release fence: all
work-items in the group execute a release fence prior to signaling arrival at
the barrier, and all work-items in the group execute an acquire fence
afterwards.
A <<group-barrier>> provides implicit atomic synchronization as if through an
internal atomic object, such that the acquire and release fences associated with
the barrier synchronize with each other, without an explicit atomic operation
being required on an atomic object to synchronize the fences.


[[device-event-class]]
=== [code]#device_event# class

The SYCL [code]#device_event# class encapsulates a single SYCL device event
which is available only within SYCL kernel functions and can be used to wait for
asynchronous operations within a SYCL kernel function to complete.

All member functions of the [code]#device_event# class must not throw a SYCL
exception.

A synopsis of the SYCL [code]#device_event# class is provided below.
The constructors and member functions of the SYCL [code]#device_event# class are
listed in <<table.constructors.device-event>> and <<table.members.device-event>>
respectively.

// Interface of device event class
[source,,linenums]
----
include::{header_dir}/deviceEvent.h[lines=4..-1]
----

[[table.members.device-event]]
.Member functions of the SYCL [code]#device_event# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
void wait() noexcept
----
   a@ Waits for the asynchronous operation associated with this SYCL
      [code]#device_event# to complete.

|====

[[table.constructors.device-event]]
.Constructors of the [code]#device_event# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
device_event(___unspecified___)
----
   a@ Unspecified implementation-defined constructor.

|====


[[sec:atomic-references]]
=== Atomic references

The [code]#sycl::atomic_ref# class provides the ability to perform atomic
operations in device code with a syntax similar to the {cpp} standard
[code]#std::atomic_ref#.
The [code]#sycl::atomic_ref# class must not be used in host code.

Unlike [code]#std::atomic_ref#, [code]#sycl::atomic_ref# does not provide a
default memory ordering for its operations.
Instead, the application must specify a default ordering via the
[code]#DefaultOrder# template parameter.
This ordering is used as a default for most of the atomic operations, but most
member functions also provide an optional parameter that allows the application
to override this default.
The set of supported orderings is specific to a device, but every device is
guaranteed to support at least [code]#memory_order::relaxed#.
If the default order is set to [code]#memory_order::relaxed#, all memory order
arguments default to [code]#memory_order::relaxed#.
If the default order is set to [code]#memory_order::acq_rel#, memory order
arguments default to [code]#memory_order::acquire# for load operations,
[code]#memory_order::release# for store operations and
[code]#memory_order::acq_rel# for read-modify-write operations.
If the default order is set to [code]#memory_order::seq_cst#, all memory order
arguments default to [code]#memory_order::seq_cst#.

The [code]#sycl::atomic_ref# class has a template parameter
[code]#DefaultScope#, which allows the application to define a default memory
scope for the atomic operations.
Most member functions also provide an optional parameter that allows the
application to override this default.

The [code]#sycl::atomic_ref# class also has a template parameter
[code]#AddressSpace#, which allows the application to make an assertion about
the address space of the object of type [code]#T# that it references.
The default value for this parameter is
[code]#access::address_space::generic_space#, which indicates that the object
could be in either the global or local address spaces.
If the application knows the address space, it can set this template parameter
to either [code]#access::address_space::global_space# or
[code]#access::address_space::local_space# as an assertion to the
implementation.
Specifying the address space via this template parameter may allow the
implementation to perform certain optimizations.
Specifying an address space that does not match the object's actual address
space results in undefined behavior.

The template parameter [code]#T# must be one of the following types:

* [code]#int#,
* [code]#unsigned int#,
* [code]#long#,
* [code]#unsigned long#,
* [code]#long long#,
* [code]#unsigned long long#,
* [code]#float#,
* [code]#double#, or
* Any pointer-to-object type.

In addition, the type [code]#T# must satisfy one of the following conditions:

* [code]#sizeof(T) == 4#, or
* [code]#sizeof(T) == 8# and the code containing this [code]#atomic_ref# was
  submitted to a device that has [code]#aspect::atomic64#.

For floating-point types, the member functions of the [code]#atomic_ref# class
may be emulated, and they may use a different floating-point environment from
those defined by [code]#info::device::single_fp_config# and
[code]#info::device::double_fp_config# (i.e. floating-point atomics may use
different rounding modes and may have different exception behavior).

The atomic types are defined as follows.

[source,,linenums]
----
include::{header_dir}/atomicref.h[lines=4..-1]
----

The constructors and member functions for instances of the SYCL
[code]#atomic_ref# class using any compatible type are listed in
<<table.atomic-refs.constructors>> and <<table.atomic-refs.members.common>>
respectively.
Additional member functions for integral, floating-point and pointer types are
listed in <<table.atomic-refs.members.integral>>,
<<table.atomic-refs.members.floating>> and <<table.atomic-refs.members.pointer>>
respectively.

The static member [code]#required_alignment# describes the minimum required
alignment in bytes of an object that can be referenced by an
[code]#atomic_ref<T>#, which must be at least [code]#alignof(T)#.

The static member [code]#is_always_lock_free# is true if all atomic operations
for type [code]#T# are always lock-free.
A SYCL implementation is not guaranteed to support atomic operations that are
not lock-free.

The static members [code]#default_read_order#, [code]#default_write_order# and
[code]#default_read_modify_write_order# reflect the default memory order values
for each type of atomic operation, consistent with the [code]#DefaultOrder#
template.

The atomic operations and member functions behave as described in the {cpp}
specification, barring the restrictions discussed above.

[NOTE]
====
Care must be taken when using atomics for work-item coordination, because
work-items are not required to provide stronger than weakly parallel forward
progress guarantees.
Operations that block a work-item, such as continuously checking the value of an
atomic variable until some condition holds, or using atomic operations that are
not lock-free, may prevent overall progress.
====

[[table.atomic-refs.constructors]]
.Constructors of the SYCL [code]#atomic_ref# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
atomic_ref(T& ref)
----
   a@ Constructs an instance of SYCL [code]#atomic_ref# which is associated
      with the reference [code]#ref#.

|====



[[table.atomic-refs.members.common]]
.Member functions available on any object of type [code]#atomic_ref<T>#
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
bool is_lock_free() const
----
   a@ Return [code]#true# if the atomic operations provided by this
      [code]#atomic_ref# are lock-free.

a@
[source]
----
void store(T operand, memory_order order = default_write_order,
           memory_scope scope = default_scope) const
----
   a@ Atomically stores [code]#operand# to the object referenced by
      this [code]#atomic_ref#.  The memory order of this atomic operation
      must be [code]#memory_order::relaxed#,
      [code]#memory_order::release# or [code]#memory_order::seq_cst#.
      This function is only supported for 64-bit data types on devices that have
      [code]#aspect::atomic64#.

a@
[source]
----
T operator=(T desired) const
----
   a@ Equivalent to [code]#store(desired)#.  Returns [code]#desired#.

a@
[source]
----
T load(memory_order order = default_read_order, memory_scope scope =
           default_scope) const
----
   a@ Atomically loads the value of the object referenced by this
      [code]#atomic_ref#.  The memory order of this atomic operation must be
      [code]#memory_order::relaxed#, [code]#memory_order::acquire#,
      or [code]#memory_order::seq_cst#.  This function is only supported for
      64-bit data types on devices that have [code]#aspect::atomic64#.

a@
[source]
----
operator T() const
----
   a@ Equivalent to [code]#load()#.

a@
[source]
----
T exchange(T operand, memory_order order = default_read_modify_write_order,
           memory_scope scope = default_scope) const
----
   a@ Atomically replaces the value of the object referenced by this
      [code]#atomic_ref# with value [code]#operand# and
      returns the original value of the referenced object.
      This function is only supported for 64-bit data types on devices that have
      [code]#aspect::atomic64#.

a@
[source]
----
bool compare_exchange_weak(T& expected, T desired, memory_order success,
                           memory_order failure,
                           memory_scope scope = default_scope) const
----
   a@ Atomically compares the value of the object referenced by this [code]#atomic_ref#
      against the value of [code]#expected#. If the values are
      equal, attempts to
      replace the value of the referenced object with the value of
      [code]#desired#;
      otherwise assigns the original value of the referenced object to [code]#expected#.

Returns [code]#true# if the comparison operation and replacement operation were
successful. The [code]#failure# memory order of this atomic operation must be
[code]#memory_order::relaxed#, [code]#memory_order::acquire# or
[code]#memory_order::seq_cst#.

This function is only supported for 64-bit data types on devices that have
[code]#aspect::atomic64#.

a@
[source]
----
bool compare_exchange_weak(T& expected, T desired,
                           memory_order order = default_read_modify_write_order,
                           memory_scope scope = default_scope) const
----
   a@ Equivalent to [code]#compare_exchange_weak(expected, desired, order, order, scope)#.

a@
[source]
----
bool compare_exchange_strong(T& expected, T desired, memory_order success,
                             memory_order failure,
                             memory_scope scope = default_scope) const
----
   a@ Atomically compares the value of the object referenced by this [code]#atomic_ref#
      against the value of [code]#expected#. If the values are equal,
      replaces the value of the referenced object with the value of
      [code]#desired#;
      otherwise assigns the original value of the referenced object to [code]#expected#.

Returns [code]#true# if the comparison operation was
successful. The [code]#failure# memory order of this atomic operation must be
[code]#memory_order::relaxed#, [code]#memory_order::acquire# or
[code]#memory_order::seq_cst#.

This function is only supported for 64-bit data types on devices that have
[code]#aspect::atomic64#.

a@
[source]
----
bool compare_exchange_strong(
    T& expected, T desired,
    memory_order order = default_read_modify_write_order) const
----
   a@ Equivalent to [code]#compare_exchange_strong(expected, desired, order, order, scope)#.

|====



[[table.atomic-refs.members.integral]]
.Additional member functions available on an object of type [code]#atomic_ref<T># for integral [code]#T#
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
T fetch_add(T operand, memory_order order = default_read_modify_write_order,
            memory_scope scope = default_scope) const
----
   a@ Atomically adds [code]#operand# to the value
      of the object referenced by this [code]#atomic_ref# and assigns
      the result to the value of the referenced object.  Returns the original
      value of the referenced object.  This function is only supported for 64-bit
      data types on devices that have [code]#aspect::atomic64#.

a@
[source]
----
T operator+=(T operand) const
----
   a@ Equivalent to [code]#fetch_add(operand) pass:[+] operand#.

a@
[source]
----
T operator++(int) const
----
   a@ Equivalent to [code]#fetch_add(1)#.

a@
[source]
----
T operator++() const
----
   a@ Equivalent to [code]#fetch_add(1) pass:[+] 1#.

a@
[source]
----
T fetch_sub(T operand, memory_order order = default_read_modify_write_order,
            memory_scope scope = default_scope) const
----
   a@ Atomically subtracts [code]#operand# from the value
      of the object referenced by this [code]#atomic_ref# and assigns
      the result to the value of the referenced object.  Returns the original
      value of the referenced object.  This function is only supported for 64-bit
      data types on devices that have [code]#aspect::atomic64#.

a@
[source]
----
T operator-=(T operand) const
----
   a@ Equivalent to [code]#fetch_sub(operand) - operand#.

a@
[source]
----
T operator--(int) const
----
   a@ Equivalent to [code]#fetch_sub(1)#.

a@
[source]
----
T operator--() const
----
   a@ Equivalent to [code]#fetch_sub(1) - 1#.

a@
[source]
----
T fetch_and(T operand, memory_order order = default_read_modify_write_order,
            memory_scope scope = default_scope) const
----
   a@ Atomically performs a bitwise AND between [code]#operand#
      and the value of the object referenced by this [code]#atomic_ref#,
      and assigns the result to the value of the referenced object. Returns the
      original value of the referenced object.  This function is only supported
      for 64-bit data types on devices that have
      [code]#aspect::atomic64#.

a@
[source]
----
T operator&=(T operand) const
----
   a@ Equivalent to [code]#fetch_and(operand) & operand#.

a@
[source]
----
T fetch_or(T operand, memory_order order = default_read_modify_write_order,
           memory_scope scope = default_scope) const
----
   a@ Atomically performs a bitwise OR between [code]#operand#
      and the value of the object referenced by this [code]#atomic_ref#,
      and assigns the result to the value of the referenced object. Returns the
      original value of the referenced object.  This function is only supported
      for 64-bit data types on devices that have
      [code]#aspect::atomic64#.

a@
[source]
----
T operator|=(T operand) const
----
   a@ Equivalent to [code]#fetch_or(operand) | operand#.

a@
[source]
----
T fetch_xor(T operand, memory_order order = default_read_modify_write_order,
            memory_scope scope = default_scope) const
----
   a@ Atomically performs a bitwise XOR between [code]#operand#
      and the value of the object referenced by this [code]#atomic_ref#,
      and assigns the result to the value of the referenced object. Returns the
      original value of the referenced object.  This function is only supported
      for 64-bit data types on devices that have
      [code]#aspect::atomic64#.

a@
[source]
----
T operator^=(T operand) const
----
   a@ Equivalent to [code]#fetch_xor(operand) ^ operand#.

a@
[source]
----
T fetch_min(T operand, memory_order order = default_read_modify_write_order,
            memory_scope scope = default_scope) const
----
   a@ Atomically computes the minimum of [code]#operand#
      and the value of the object referenced by this [code]#atomic_ref#,
      and assigns the result to the value of the referenced object. Returns the
      original value of the referenced object.  This function is only supported
      for 64-bit data types on devices that have
      [code]#aspect::atomic64#.

a@
[source]
----
T fetch_max(T operand, memory_order order = default_read_modify_write_order,
            memory_scope scope = default_scope) const
----
   a@ Atomically computes the maximum of [code]#operand#
      and the value of the object referenced by this [code]#atomic_ref#,
      and assigns the result to the value of the referenced object. Returns the
      original value of the referenced object.  This function is only supported
      for 64-bit data types on devices that have
      [code]#aspect::atomic64#.

|====



[[table.atomic-refs.members.floating]]
.Additional member functions available on an object of type [code]#atomic_ref<T># for floating-point [code]#T#
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
T fetch_add(T operand, memory_order order = default_read_modify_write_order,
            memory_scope scope = default_scope) const
----
   a@ Atomically adds [code]#operand# to the value
      of the object referenced by this [code]#atomic_ref# and assigns
      the result to the value of the referenced object.  Returns the original
      value of the referenced object.  This function is only supported for 64-bit
      data types on devices that have [code]#aspect::atomic64#.

a@
[source]
----
T operator+=(T operand) const
----
   a@ Equivalent to [code]#fetch_add(operand) pass:[+] operand#.

a@
[source]
----
T fetch_sub(T operand, memory_order order = default_read_modify_write_order,
            memory_scope scope = default_scope) const
----
   a@ Atomically subtracts [code]#operand# from the value
      of the object referenced by this [code]#atomic_ref# and assigns
      the result to the value of the referenced object.  Returns the original
      value of the referenced object.  This function is only supported for 64-bit
      data types on devices that have [code]#aspect::atomic64#.

a@
[source]
----
T operator-=(T operand) const
----
   a@ Equivalent to [code]#fetch_sub(operand) - operand#.

a@
[source]
----
T fetch_min(T operand, memory_order order = default_read_modify_write_order,
            memory_scope scope = default_scope) const
----
   a@ Atomically computes the minimum of [code]#operand#
      and the value of the object referenced by this [code]#atomic_ref#,
      and assigns the result to the value of the referenced object. Returns the
      original value of the referenced object.  This function is only supported for
      64-bit data types on devices that have [code]#aspect::atomic64#.

a@
[source]
----
T fetch_max(T operand, memory_order order = default_read_modify_write_order,
            memory_scope scope = default_scope) const
----
   a@ Atomically computes the maximum of [code]#operand#
      and the value of the object referenced by this [code]#atomic_ref#,
      and assigns the result to the value of the referenced object. Returns the
      original value of the referenced object.  This function is only supported for
      64-bit data types on devices that have [code]#aspect::atomic64#.

|====



[[table.atomic-refs.members.pointer]]
.Additional member functions available on an object of type [code]#atomic_ref<T*>#
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
T* fetch_add(ptrdiff_t operand,
             memory_order order = default_read_modify_write_order,
             memory_scope scope = default_scope) const
----
   a@ Atomically adds [code]#operand# to the value
      of the object referenced by this [code]#atomic_ref# and assigns
      the result to the value of the referenced object.  Returns the original
      value of the referenced object.  This function is only supported for 64-bit
      pointers on devices that have [code]#aspect::atomic64#.

a@
[source]
----
T* operator+=(ptrdiff_t operand) const
----
   a@ Equivalent to [code]#fetch_add(operand) pass:[+] operand#.

a@
[source]
----
T* operator++(int) const
----
   a@ Equivalent to [code]#fetch_add(1)#.

a@
[source]
----
T* operator++() const
----
   a@ Equivalent to [code]#fetch_add(1) pass:[+] 1#.

a@
[source]
----
T* fetch_sub(ptrdiff_t operand,
             memory_order order = default_read_modify_write_order,
             memory_scope scope = default_scope) const
----
   a@ Atomically subtracts [code]#operand# from the value
      of the object referenced by this [code]#atomic_ref# and assigns
      the result to the value of the referenced object.  Returns the original
      value of the referenced object.  This function is only supported for 64-bit
      pointers on devices that have [code]#aspect::atomic64#.

a@
[source]
----
T* operator-=(ptrdiff_t operand) const
----
   a@ Equivalent to [code]#fetch_sub(operand) - operand#.

a@
[source]
----
T* operator--(int) const
----
   a@ Equivalent to [code]#fetch_sub(1)#.

a@
[source]
----
T* operator--() const
----
   a@ Equivalent to [code]#fetch_sub(1) - 1#.

|====



[[sec:atom-types-depr]]
=== Atomic types (deprecated)

// Deprecated atomics from SYCL 1.2.1

The atomic types and operations on atomic types provided by SYCL 1.2.1 are
deprecated in SYCL 2020, and will be removed in a future version of SYCL.

The constructors and member functions for the [code]#sycl::atomic# class are
listed in <<table.atomics.constructors>> and <<table.atomics.members>>
respectively.

[source,,linenums]
----
include::{header_dir}/atomic.h[lines=4..-1]
----

The global functions are as follows and described in
<<table.atomics.functions>>.

[source,,linenums]
----
include::{header_dir}/atomicoperations.h[lines=4..-1]
----


[[table.atomics.constructors]]
.Constructors of the [code]#sycl::atomic# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
template <typename pointerT> atomic(multi_ptr<pointerT, AddressSpace> ptr)
----
   a@ Deprecated in SYCL 2020.

Permitted data types for [code]#pointerT# are any valid scalar data
type which is the same size in bytes as [code]#T#. Constructs an
instance of SYCL [code]#atomic# which is associated with the pointer
[code]#ptr#, converted to a pointer of data type [code]#T#.

|====



[[table.atomics.members]]
.Member functions available on an object of type [code]#sycl::atomic<T>#
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
void store(T operand, memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Atomically stores the value [code]#operand# at the address of the
[code]#multi_ptr# associated with this SYCL [code]#atomic#. The
memory order of this atomic operation must be [code]#memory_order::relaxed#. This function is only supported for 64-bit data
types on devices that have [code]#aspect::atomic64#.

a@
[source]
----
T load(memory_order memoryOrder = memory_order::relaxed) const
----
   a@ Deprecated in SYCL 2020.

Atomically loads the value at the address of the [code]#multi_ptr#
associated with this SYCL [code]#atomic#. Returns the value at the
address of the [code]#multi_ptr# associated with this SYCL
[code]#atomic# before the call. The memory order of this atomic
operation must be [code]#memory_order::relaxed#. This function is
only supported for 64-bit data types on devices that have
[code]#aspect::atomic64#.

a@
[source]
----
T exchange(T operand, memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Atomically replaces the value at the address of the [code]#multi_ptr#
associated with this SYCL [code]#atomic# with value [code]#operand# and returns the value at the address of the [code]#multi_ptr# associated with this SYCL [code]#atomic# before the call.
The memory order of this atomic operation must be [code]#memory_order::relaxed#. This function is only supported for 64-bit data
types on devices that have [code]#aspect::atomic64#.

a@
[source]
----
bool compare_exchange_strong(
    T& expected, T desired,
    memory_order successMemoryOrder = memory_order::relaxed,
    memory_order failMemoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Available only when: [code]#T != float#.

Atomically compares the value at the address of the [code]#multi_ptr#
associated with this SYCL [code]#atomic# against the value of
[code]#expected#. If the values are equal, replaces value at address
of the [code]#multi_ptr# associated with this SYCL
[code]#atomic# with the value of [code]#desired#; otherwise assigns the
original value at the address of the [code]#multi_ptr# associated
with this SYCL [code]#atomic# to [code]#expected#. Returns
[code]#true# if the comparison operation was successful. The memory
order of this atomic operation must be [code]#memory_order::relaxed# for both success and fail.  This function is only
supported for 64-bit data types on devices that have
[code]#aspect::atomic64#.

a@
[source]
----
T fetch_add(T operand, memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Available only when: [code]#T != float#.

Atomically adds the value [code]#operand# to the value at the address
of the [code]#multi_ptr# associated with this SYCL [code]#atomic# and assigns the result to the value at the address of the
[code]#multi_ptr# associated with this SYCL [code]#atomic#.
Returns the value at the address of the [code]#multi_ptr# associated
with this SYCL [code]#atomic# before the call. The memory order of
this atomic operation must be [code]#memory_order::relaxed#. This
function is only supported for 64-bit data types on devices that have
[code]#aspect::atomic64#.

a@
[source]
----
T fetch_sub(T operand, memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Available only when: [code]#T != float#.

Atomically subtracts the value [code]#operand# to the value at the
address of the [code]#multi_ptr# associated with this SYCL
[code]#atomic# and assigns the result to the value at the address of
the [code]#multi_ptr# associated with this SYCL [code]#atomic#.
Returns the value at the address of the [code]#multi_ptr# associated
with this SYCL [code]#atomic# before the call. The memory order of
this atomic operation must be [code]#memory_order::relaxed#. This
function is only supported for 64-bit data types on devices that have
[code]#aspect::atomic64#.

a@
[source]
----
T fetch_and(T operand, memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Available only when: [code]#T != float#.

Atomically performs a bitwise AND between the value [code]#operand#
and the value at the address of the [code]#multi_ptr# associated with
this SYCL [code]#atomic# and assigns the result to the value at the
address of the [code]#multi_ptr# associated with this SYCL
[code]#atomic#. Returns the value at the address of the [code]#multi_ptr# associated with this SYCL [code]#atomic# before the call.
The memory order of this atomic operation must be [code]#memory_order::relaxed#. This function is only supported for 64-bit data
types on devices that have [code]#aspect::atomic64#.

a@
[source]
----
T fetch_or(T operand, memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Available only when: [code]#T != float#.

Atomically performs a bitwise OR between the value [code]#operand#
and the value at the address of the [code]#multi_ptr# associated with
this SYCL [code]#atomic# and assigns the result to the value at the
address of the [code]#multi_ptr# associated with this SYCL
[code]#atomic#. Returns the value at the address of the [code]#multi_ptr# associated with this SYCL [code]#atomic# before the call.
The memory order of this atomic operation must be [code]#memory_order::relaxed#. This function is only supported for 64-bit data
types on devices that have [code]#aspect::atomic64#.

a@
[source]
----
T fetch_xor(T operand, memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Available only when: [code]#T != float#.

Atomically performs a bitwise XOR between the value [code]#operand#
and the value at the address of the [code]#multi_ptr# associated with
this SYCL [code]#atomic# and assigns the result to the value at the
address of the [code]#multi_ptr# associated with this SYCL
[code]#atomic#. Returns the value at the address of the [code]#multi_ptr# associated with this SYCL [code]#atomic# before the call.
The memory order of this atomic operation must be [code]#memory_order::relaxed#. This function is only supported for 64-bit data
types on devices that have [code]#aspect::atomic64#.

a@
[source]
----
T fetch_min(T operand, memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Available only when: [code]#T != float#.

Atomically computes the minimum of the value [code]#operand# and the
value at the address of the [code]#multi_ptr# associated with this
SYCL [code]#atomic# and assigns the result to the value at the address
of the [code]#multi_ptr# associated with this SYCL [code]#atomic#. Returns the value at the address of the [code]#multi_ptr#
associated with this SYCL [code]#atomic# before the call. The memory
order of this atomic operation must be [code]#memory_order::relaxed#.
This function is only supported for 64-bit data types on devices that have
[code]#aspect::atomic64#.

a@
[source]
----
T fetch_max(T operand, memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Available only when: [code]#T != float#.

Atomically computes the maximum of the value [code]#operand# and the
value at the address of the [code]#multi_ptr# associated with this
SYCL [code]#atomic# and assigns the result to the value at the address
of the [code]#multi_ptr# associated with this SYCL [code]#atomic#. Returns the value at the address of the [code]#multi_ptr#
associated with this SYCL [code]#atomic# before the call. The memory
order of this atomic operation must be [code]#memory_order::relaxed#.
This function is only supported for 64-bit data types on devices that have
[code]#aspect::atomic64#.

|====



[[table.atomics.functions]]
.Global functions available on atomic types
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Functions @ Description
a@
[source]
----
template <typename T, access::address_space AddressSpace>
T atomic_load(atomic<T, AddressSpace> object,
              memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Equivalent to calling [code]#object.load(memoryOrder)#.

a@
[source]
----
template <typename T, access::address_space AddressSpace>
void atomic_store(atomic<T, AddressSpace> object, T operand,
                  memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Equivalent to calling [code]#object.store(operand, memoryOrder)#.

a@
[source]
----
template <typename T, access::address_space AddressSpace>
T atomic_exchange(atomic<T, AddressSpace> object, T operand,
                  memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Equivalent to calling [code]#object.exchange(operand, memoryOrder)#.

a@
[source]
----
template <typename T, access::address_space AddressSpace>
bool atomic_compare_exchange_strong(
    atomic<T, AddressSpace> object, T& expected, T desired,
    memory_order successMemoryOrder = memory_order::relaxed memory_order
        failMemoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Equivalent to calling [code]#object.compare_exchange_strong(expected, desired, successMemoryOrder, failMemoryOrders)#.

a@
[source]
----
template <typename T, access::address_space AddressSpace>
T atomic_fetch_add(atomic<T, AddressSpace> object, T operand,
                   memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Equivalent to calling [code]#object.fetch_add(operand, memoryOrder)#.

a@
[source]
----
template <typename T, access::address_space AddressSpace>
T atomic_fetch_sub(atomic<T, AddressSpace> object, T operand,
                   memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Equivalent to calling [code]#object.fetch_sub(operand, memoryOrder)#.

a@
[source]
----
template <typename T, access::address_space AddressSpace>
T atomic_fetch_and(atomic<T> operand, T object,
                   memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Equivalent to calling [code]#object.fetch_add(operand, memoryOrder)#.

a@
[source]
----
template <typename T, access::address_space AddressSpace>
T atomic_fetch_or(atomic<T, AddressSpace> object, T operand,
                  memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Equivalent to calling [code]#object.fetch_or(operand, memoryOrder)#.

a@
[source]
----
template <typename T, access::address_space AddressSpace>
T atomic_fetch_xor(atomic<T, AddressSpace> object, T operand,
                   memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Equivalent to calling [code]#object.fetch_xor(operand, memoryOrder)#.

a@
[source]
----
template <typename T, access::address_space AddressSpace>
T atomic_fetch_min(atomic<T, AddressSpace> object, T operand,
                   memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Equivalent to calling [code]#object.fetch_min(operand, memoryOrder)#.

a@
[source]
----
template <typename T, access::address_space AddressSpace>
T atomic_fetch_max(atomic<T, AddressSpace> object, T operand,
                   memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Equivalent to calling [code]#object.fetch_max(operand, memoryOrder)#.

|====


=== Interaction with host code

When a kernel runs on a device that has either
[code]#aspect::usm_atomic_host_allocations# or
[code]#aspect::usm_atomic_shared_allocations#, the device code and the host code
can concurrently access the same memory.
This has a ramification on the atomic operations because it is possible for
device code and host code to perform atomic operations on the same object _M_ in
this shared memory.
It also has a ramification on the fence operations because the {cpp} core
language defines the semantics of these fence operations in relation to atomic
operations on some shared object _M_.
The following paragraphs specify the guarantees that the SYCL implementation
provides when the application performs atomic or fence operations in device code
using the memory scope [code]#memory_scope::system#.

Atomic operations in device code using [code]#sycl::atomic_ref# on an object _M_
are guaranteed to be atomic with respect to atomic operations in host code using
[code]#std::atomic_ref# on that same object _M_.

Fence operations in device code using [code]#sycl::atomic_fence# synchronize
with fence operations in host code using [code]#std::atomic_thread_fence# if the
fence operations shared the same atomic object _M_ and follow the rules for
fence synchronization defined in the {cpp} core language.

Fence operations in device code using [code]#sycl::atomic_fence# synchronize
with atomic operations in host code using [code]#std::atomic_ref# if the
operations share the same atomic object _M_ and follow the rules for fence
synchronization defined in the {cpp} core language.

Atomic operations in device code using [code]#sycl::atomic_ref# synchronize with
fence operations in host code using [code]#std::atomic_thread_fence# if the
operations share the same atomic object _M_ and follow the rules for fence
synchronization defined in the {cpp} core language.


[[subsec:stream]]
== Stream class

The SYCL [code]#stream# class is a buffered output stream that allows outputting
the values of built-in, vector and SYCL types to the console.
The implementation of how values are streamed to the console is left as an
implementation detail.

The way in which values are output by an instance of the SYCL [code]#stream#
class can also be altered using a range of manipulators.

There are two limits that are relevant for the [code]#stream# class.
The [code]#totalBufferSize# limit specifies the maximum size of the overall
character stream that can be output during a kernel invocation, and the
[code]#workItemBufferSize# limit specifies the maximum size of the character
stream that can be output within a work-item before a flush must be performed.
Both of these limits are specified in bytes.
The [code]#totalBufferSize# limit must be sufficient to contain the characters
output by all stream statements during execution of a kernel invocation (the
aggregate of outputs from all work-items), and the [code]#workItemBufferSize#
limit must be sufficient to contain the characters output within a work-item
between stream flush operations.

If the [code]#totalBufferSize# or [code]#workItemBufferSize# limits are
exceeded, it is implementation-defined whether the streamed characters exceeding
the limit are output, or silently ignored/discarded, and if output it is
implementation-defined whether those extra characters exceeding the
[code]#workItemBufferSize# limit count toward the [code]#totalBufferSize# limit.
Regardless of this implementation defined behavior of output exceeding the
limits, no undefined or erroneous behavior is permitted of an implementation
when the limits are exceeded.
Unused characters within [code]#workItemBufferSize# (any portion of the
[code]#workItemBufferSize# capacity that has not been used at the time of a
stream flush) do not count toward the [code]#totalBufferSize# limit, in that
only characters flushed count toward the [code]#totalBufferSize# limit.

The SYCL [code]#stream# class provides the common reference semantics (see
<<sec:reference-semantics>>).


=== Stream class interface

The constructors and member functions of the SYCL [code]#stream# class are
listed in <<table.constructors.stream>>, <<table.members.stream>>, and
<<table.globals.stream>> respectively.
The additional common special member functions and common member functions are
listed in <<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>>, respectively.

The operand types that are supported by the SYCL [code]#stream# class
[code]#operator<<()# operator are listed in <<table.operands.stream>>.

The manipulators that are supported by the SYCL [code]#stream# class
[code]#operator<<()# operator are listed in <<table.manipulators.stream>>.

// Interface of the device class
[source,,linenums]
----
include::{header_dir}/stream.h[lines=4..-1]
----


[[table.operands.stream]]
.Operand types supported by the [code]#stream# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Stream operand type @ Description
a@
[source]
----
bool, char, signed char, unsigned char, int, unsigned int, short, unsigned short,
long int, unsigned long int, long long int, unsigned long long int
----
   a@ Outputs the value as a stream of characters.

a@
[source]
----
float, double, half
----
   a@ Outputs the value according to the precision of the current statement as a stream of characters.

a@
[source]
----
char*, const char*
----
   a@ Outputs the string.

a@
[source]
----
T*, const T*, multi_ptr
----
   a@ Outputs the address of the pointer as a stream of characters.

a@
[source]
----
vec
----
   a@ Outputs the value of each component of the vector as a stream of characters.

a@
[source]
----
id, range, item, nd_item, group, nd_range, h_item
----
   a@ Outputs the value of each component of each id or range as a stream of characters.

|====



[[table.manipulators.stream]]
.Manipulators supported by the [code]#stream# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Stream manipulator @ Description
a@
[source]
----
flush
----
   a@ Triggers a flush operation, which copies the contents of the work-item
      stream buffer to the global stream buffer, and then empties the work-item
      stream buffer. After a flush, the full [code]#workItemBufferSize# is
      available again for subsequent streaming within the work-item.

a@
[source]
----
endl
----
   a@ Outputs a new-line character and then triggers a flush operation.

a@
[source]
----
dec
----
   a@ Outputs any subsequent values in the current statement in decimal base.

a@
[source]
----
hex
----
   a@ Outputs any subsequent values in the current statement in hexadecimal base.

a@
[source]
----
oct
----
   a@ Outputs any subsequent values in the current statement in octal base.

a@
[source]
----
noshowbase
----
   a@ Outputs any subsequent values without the base prefix.

a@
[source]
----
showbase
----
   a@ Outputs any subsequent values with the base prefix.

a@
[source]
----
noshowpos
----
   a@ Outputs any subsequent values without a plus sign if the value is positive.

a@
[source]
----
showpos
----
   a@ Outputs any subsequent values with a plus sign if the value is positive.

a@
[source]
----
setw(int)
----
   a@ Sets the field width of any subsequent values in the current statement.

a@
[source]
----
setprecision(int)
----
   a@ Sets the precision of any subsequent values in the current statement.

a@
[source]
----
fixed
----
   a@ Outputs any subsequent floating-point values in the current statement in fixed notation.

a@
[source]
----
scientific
----
   a@ Outputs any subsequent floating-point values in the current statement in scientific notation.

a@
[source]
----
hexfloat
----
   a@ Outputs any subsequent floating-point values in the current statement in hexadecimal notation.

a@
[source]
----
defaultfloat
----
   a@ Outputs any subsequent floating-point values in the current statement in the default notation.

|====



[[table.constructors.stream]]
.Constructors of the [code]#stream# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
stream(size_t totalBufferSize, size_t workItemBufferSize, handler& cgh,
       const property_list& propList = {})
----
   a@ Constructs a SYCL [code]#stream# instance associated with the command group
      specified by [code]#cgh#, with a maximum buffer size in bytes per kernel
      invocation specified by the parameter [code]#totalBufferSize#, and a maximum
      stream size that can be buffered by a work-item between stream flushes
      specified by the parameter [code]#workItemBufferSize#.
      Zero or more properties can be provided to the constructed SYCL
      [code]#stream# via an instance of [code]#property_list#.

|====



[[table.members.stream]]
.Member functions of the [code]#stream# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
size_t size() const noexcept
----
   a@ Returns the total buffer size, in bytes.
a@
[source]
----
size_t get_size() const
----
   a@ Returns the same value as [code]#size()#. Deprecated.
a@
[source]
----
size_t get_work_item_buffer_size() const
----
   a@ Returns the buffer size per work-item, in bytes.

a@
[source]
----
size_t get_max_statement_size() const
----
   a@ Deprecated query with same functionality as [code]#get_work_item_buffer_size()#.

|====



[[table.globals.stream]]
.Global functions of the [code]#stream# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Global function @ Description
a@
[source]
----
template <typename T> const stream& operator<<(const stream& os, const T& rhs)
----
   a@ Outputs any valid values (see <<table.operands.stream>>) as a stream of characters and applies any valid manipulator (see <<table.manipulators.stream>>) to the current stream.

|====



=== Output

An instance of the SYCL [code]#stream# class is required to output everything
that is streamed to it via the [code]#operator<<()# operator before a flush
operation (that doesn't exceed the [code]#workItemBufferSize# or
[code]#totalBufferSize# limits) within a SYCL kernel function by the time that
the event associated with a command group submission enters the completed state.
The point at which the flush operation is performed is implementation-defined.

The SYCL [code]#stream# class is required to output the content of each stream,
between flushes (up to [code]#workItemBufferSize)#, without mixing with content
from the same stream in other work-items.
There are no other output order guarantees between work-items or between
streams.
The stream flush operation therefore delimits the unit of output that is
guaranteed to be displayed without mixing with other work-items, with respect to
a single stream.


=== Implicit flush

There is guaranteed to be an implicit flush of each stream used by a kernel, at
the end of kernel execution, from the perspective of each work-item.
There is also an implicit flush when the endl stream manipulator is executed.
No other implicit flushes are permitted in an implementation.


=== Performance note

The usage of the [code]#stream# class is designed for debugging purposes and is
therefore not recommended for performance critical applications.

// \input{builtin_functions}

// %%%%%%%%%%%%%%%%%%%%%%%%%%%% begin builtin_functions %%%%%%%%%%%%%%%%%%%%%%%%%%%%


[[sycl:builtins]]
== SYCL built-in functions for SYCL host and device

// Intentional OpenCL reference
SYCL kernels may execute on any SYCL device, which requires the functions used
in the kernels to be compiled and linked for both device and host.
In the SYCL programming model, the built-ins are available for the entire SYCL
application within the [code]#sycl# namespace, although their semantics may be
different.
This section follows the OpenCL 1.2 specification document <<opencl12, ch.
6.12>> - except that for SYCL, all functions are located within the [code]#sycl#
namespace - and describes the behavior of these functions for SYCL host and
device.
The expected precision and any other semantic requirements are defined in the
backend specification.

The SYCL built-in functions are available throughout the SYCL application, and
depending on where they execute, they are either implemented using their host
implementation or the device implementation.
The SYCL system guarantees that all of the built-in functions fulfill the same
requirements for both host and device.


[[sec:function-objects]]
=== Function objects

SYCL provides a number of function objects in the [code]#sycl# namespace on host
and device.
All function objects obey {cpp} conversion and promotion rules.
Each function object is additionally specialized for [code]#void# as a
_transparent_ function object that deduces its parameter types and return type.

[source,,linenums]
----
include::{header_dir}/functional.h[lines=4..-1]
----

[[table.function.objects.plus]]
.Member functions for the [code]#plus# function object
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
T operator()(const T& x, const T& y) const
----
   a@ Returns the sum of its arguments, equivalent to [code]#pass:[x + y]#.

|====

[[table.function.objects.multiplies]]
.Member functions for the [code]#multiplies# function object
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
T operator()(const T& x, const T& y) const
----
   a@ Returns the product of its arguments, equivalent to [code]#x * y#.

|====

[[table.function.objects.bit-and]]
.Member functions for the [code]#bit_and# function object
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
T operator()(const T& x, const T& y) const
----
   a@ Returns the bitwise AND of its arguments, equivalent to [code]#x & y#.

|====

[[table.function.objects.bit-or]]
.Member functions for the [code]#bit_or# function object
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
T operator()(const T& x, const T& y) const
----
   a@ Returns the bitwise OR of its arguments, equivalent to [code]#x | y#.

|====

[[table.function.objects.bit-xor]]
.Member functions for the [code]#bit_xor# function object
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
T operator()(const T& x, const T& y) const
----
   a@ Returns the bitwise XOR of its arguments, equivalent to [code]#x ^ y#.

|====

[[table.function.objects.logical-and]]
.Member functions for the [code]#logical_and# function object
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
T operator()(const T& x, const T& y) const
----
   a@ Returns the logical AND of its arguments, equivalent to [code]#x && y#.

|====

[[table.function.objects.logical-or]]
.Member functions for the [code]#logical_or# function object
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
T operator()(const T& x, const T& y) const
----
   a@ Returns the logical OR of its arguments, equivalent to [code]#x || y#.

|====

[[table.function.objects.minimum]]
.Member functions for the [code]#minimum# function object
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
T operator()(const T& x, const T& y) const
----
   a@ Returns the smaller value. Returns the first argument when the arguments
      are equivalent.

|====

[[table.function.objects.maximum]]
.Member functions for the [code]#maximum# function object
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
T operator()(const T& x, const T& y) const
----
   a@ Returns the larger value. Returns the first argument when the arguments
      are equivalent.

|====

[[sec:group-functions]]
=== Group functions

SYCL provides a number of functions that expose functionality tied to groups of
work-items (such as <<group-barrier,group barriers>> and collective operations).
These group functions act as _synchronization points_ and must be encountered in
converged <<control-flow>> by all work-items in the group.

The behavior of every group function is as follows:

  * Each work-item in the group arrives at the synchronization point associated
    with the group function, then blocks until any operation(s) specified by the
    group function have completed.

  * Once all work-items in the group have arrived, an unspecified subset of
    those work-items cooperate to execute any operation(s) specified by the
    group function.

  * When the set of cooperating work-items have completed execution of all
    operation(s) specified by the group function, all work-items blocked on the
    synchronization point associated with the group function are unblocked.

The completion of the operation(s) specified by the group function happens
before the returns from all calls that were unblocked.

[NOTE]
====
The behavior of group functions is analogous to the behavior of the C++20
[code]#std::barrier::arrive_and_wait# function, for an implementation-defined
barrier object with an expected count equal to the number of work-items in the
group.
Any operation(s) performed by the group function behave as if they were defined
in the barrier's completion function and were invoked as part of the barrier's
phase completion step.
====

If one work-item in a group calls a group function, then all work-items in that
group must call exactly the same function under the same set of conditions ---
calling the same function under different conditions (e.g. in different
iterations of a loop, or different branches of a conditional statement) results
in undefined behavior.
Additionally, restrictions may be placed on the arguments passed to each
function in order to ensure that all work-items in the group agree on the
operation that is being performed.
Any such restrictions on the arguments passed to a function are defined within
the descriptions of those functions.
Violating these restrictions results in undefined behavior.

All group functions are supported for the fundamental scalar types supported by
SYCL (see <<table.types.fundamental>>) and instances of the SYCL [code]#vec# and
[code]#marray# classes.

Using a group function inside of a kernel may introduce additional limits on the
resources available to user code inside the same kernel.
The behavior of these limits is implementation-defined, but must be reflected by
calls to kernel querying functions (such as [code]#kernel::get_info#) as
described in <<sec:kernel.query>>.

It is undefined behavior for any group function to be invoked within a
[code]#parallel_for_work_group# or [code]#parallel_for_work_item# context.

==== Group type trait

[source,,linenums]
----
include::{header_dir}/algorithms/is_group.h[lines=4..-1]
----

The [code]#is_group# type trait is used to determine which types of groups are
supported by group functions, and to control when group functions participate in
overload resolution.

[code]#is_group<T># inherits from [code]#std::true_type# if [code]#T# is the
type of a standard SYCL group ([code]#group# or [code]#sub_group#) and it
inherits from [code]#std::false_type# otherwise.
A SYCL implementation may introduce additional specializations of
[code]#is_group<T># for implementation-defined group types, if the interface of
those types supports all member functions and static members common to the
[code]#group# and [code]#sub_group# classes.

==== [code]#group_broadcast#

The [code]#group_broadcast# function communicates a value held by one work-item
to all other work-items in the group.

[source,,linenums]
----
include::{header_dir}/groups/broadcast.h[lines=4..-1]
----

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true and [code]#T# is a
    trivially copyable type.
+
--
_Effects:_ Blocks until all work-items in group [code]#g# have reached this
synchronization point, then executes the broadcast operation.

_Synchronization:_ The call to this function in each work-item happens before
the broadcast operation begins execution.
The completion of the broadcast operation happens before any work-item blocking
on the same synchronization point is unblocked.

_Returns:_ The value of [code]#x# from the work-item with the smallest linear id
within group [code]#g#.
--

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true and [code]#T# is a
    trivially copyable type.
+
--
_Preconditions:_ [code]#local_linear_id# must be the same for all work-items in
the group and must be in the range [code]#[0, get_local_linear_range())#.

_Effects:_ Blocks until all work-items in group [code]#g# have reached this
synchronization point, then executes the broadcast operation.

_Synchronization:_ The call to this function in each work-item happens before
the broadcast operation begins execution.
The completion of the broadcast operation happens before any work-item blocking
on the same synchronization point is unblocked.

_Returns:_ The value of [code]#x# from the work-item with the specified linear
id within group [code]#g#.
--

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true and [code]#T# is a
    trivially copyable type.
+
--
_Preconditions:_ [code]#local_id# must be the same for all work-items in the
group, and its dimensionality must match the dimensionality of the group.
The value of [code]#local_id# in each dimension must be greater than or equal to
0 and less than the value of [code]#get_local_range()# in the same dimension.

_Effects:_ Blocks until all work-items in group [code]#g# have reached this
synchronization point, then executes the broadcast operation.

_Synchronization:_ The call to this function in each work-item happens before
the broadcast operation begins execution.
The completion of the broadcast operation happens before any work-item blocking
on the same synchronization point is unblocked.

_Returns:_ The value of [code]#x# from the work-item with the specified id
within group [code]#g#.
--

==== [code]#group_barrier#

The [code]#group_barrier# function is a coordination mechanism for all
work-items in a group.

[source,,linenums]
----
include::{header_dir}/groups/barrier.h[lines=4..-1]
----

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true.
+
--
_Effects:_ Blocks until all work-items in group [code]#g# have reached this
synchronization point.

_Synchronization:_ The call to [code]#group_barrier# in each work-item happens
before any work-item blocking on the same synchronization point is unblocked.
Synchronization operations used in an implementation of [code]#group_barrier#
must respect the memory scope specified by the [code]#scope# parameter, which
defaults to the narrowest scope including all work-items in group [code]#g# (as
reported by [code]#Group::fence_scope#).
--

[[sec:algorithms]]
=== Group algorithms library

SYCL provides an algorithms library based on the functions described in Section
28 of the {cpp17} specification.
The first argument to each function is a <<group>>, and data ranges can be
described using pointers or instances of the [code]#multi_ptr# class.
The functions defined in this section are free functions available in the
[code]#sycl# namespace.

Any restrictions from the standard algorithms library apply.
Some of the functions in the SYCL algorithms library introduce additional
restrictions in order to maximize portability across different devices and to
minimize the chances of encountering unexpected behavior.

All algorithms are supported for the fundamental scalar types supported by SYCL
(see <<table.types.fundamental>>) and instances of the SYCL [code]#vec# and
[code]#marray# classes.

The <<group>> argument to a SYCL algorithm denotes that it should be performed
collaboratively by the work-items in the specified group.
All algorithms act as group functions (as defined in <<sec:group-functions>>),
inheriting all restrictions of group functions.
Unless the description of a function says otherwise, how the elements of a range
are processed by the work-items in a group is undefined.

SYCL provides separate functions for algorithms which use the work-items in a
group to execute an operation over a range (specified by a start pointer and an
end pointer) and algorithms which are applied to data held directly by the
work-items in a group.
An example of the usage of these functions is given below:

[source,,linenums]
----
include::{code_dir}/algorithms.cpp[lines=4..-1]
----

==== [code]#any_of#, [code]#all_of# and [code]#none_of#

The [code]#any_of#, [code]#all_of# and [code]#none_of# functions from standard
{cpp} test whether Boolean conditions hold for any of, all of or none of the
values in a range, respectively.

SYCL provides two sets of similar algorithms:

. [code]#joint_any_of#, [code]#joint_all_of# and [code]#joint_none_of# use the
work-items in a group to execute the corresponding algorithm in parallel.

. [code]#any_of_group#, [code]#all_of_group# and [code]#none_of_group# test
Boolean conditions applied to data held directly by the work-items in a group.

[source,,linenums]
----
include::{header_dir}/algorithms/any_of.h[lines=4..-1]
----

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true and [code]#Ptr# is a
    pointer.
+
--
_Preconditions:_ [code]#first# and [code]#last# must be the same for all
work-items in group [code]#g#, and [code]#pred# must be an immutable callable
with the same type and state for all work-items in group [code]#g#.

_Effects:_ Blocks until all work-items in group [code]#g# have reached this
synchronization point, then executes the algorithm.

_Synchronization:_ The call to this function in each work-item happens before
the algorithm begins execution.
The completion of the algorithm happens before any work-item blocking on the
same synchronization point is unblocked.

_Returns:_ true if [code]#pred# returns true when applied to the result of
dereferencing any pointer in the range [code]#[first, last)#.
--

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true.
+
--
_Preconditions:_ [code]#pred# must be an immutable callable with the same type
and state for all work-items in group [code]#g#.

_Effects:_ Blocks until all work-items in group [code]#g# have reached this
synchronization point, then executes the algorithm.

_Synchronization:_ The call to this function in each work-item happens before
the algorithm begins execution.
The completion of the algorithm happens before any work-item blocking on the
same synchronization point is unblocked.

_Returns:_ true if [code]#pred(x)# returns true for any work-item in group
[code]#g#.
--

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true.
+
--
_Effects:_ Blocks until all work-items in group [code]#g# have reached this
synchronization point, then executes the algorithm.

_Synchronization:_ The call to this function in each work-item happens before
the algorithm begins execution.
The completion of the algorithm happens before any work-item blocking on the
same synchronization point is unblocked.

_Returns:_ true if [code]#pred# is true for any work-item in group [code]#g#.
--

[source,,linenums]
----
include::{header_dir}/algorithms/all_of.h[lines=4..-1]
----

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true and [code]#Ptr# is a
    pointer.
+
--
_Preconditions:_ [code]#first# and [code]#last# must be the same for all
work-items in group [code]#g#, and [code]#pred# must be an immutable callable
with the same type and state for all work-items in group [code]#g#.

_Effects:_ Blocks until all work-items in group [code]#g# have reached this
synchronization point, then executes the algorithm.

_Synchronization:_ The call to this function in each work-item happens before
the algorithm begins execution.
The completion of the algorithm happens before any work-item blocking on the
same synchronization point is unblocked.

_Returns:_ true if [code]#pred# returns true when applied to the result of
dereferencing all pointers in the range [code]#[first, last)#.
--

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true.
+
--
_Preconditions:_ [code]#pred# must be an immutable callable with the same type
and state for all work-items in group [code]#g#.

_Effects:_ Blocks until all work-items in group [code]#g# have reached this
synchronization point, then executes the algorithm.

_Synchronization:_ The call to this function in each work-item happens before
the algorithm begins execution.
The completion of the algorithm happens before any work-item blocking on the
same synchronization point is unblocked.

_Returns:_ true if [code]#pred(x)# returns true for all work-items in group
[code]#g#.
--

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true.
+
--
_Effects:_ Blocks until all work-items in group [code]#g# have reached this
synchronization point, then executes the algorithm.

_Synchronization:_ The call to this function in each work-item happens before
the algorithm begins execution.
The completion of the algorithm happens before any work-item blocking on the
same synchronization point is unblocked.

_Returns:_ true if [code]#pred# is true for all work-items in group [code]#g#.
--

[source,,linenums]
----
include::{header_dir}/algorithms/none_of.h[lines=4..-1]
----

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true and [code]#Ptr# is a
    pointer.
+
--
_Preconditions:_ [code]#first# and [code]#last# must be the same for all
work-items in group [code]#g#, and [code]#pred# must be an immutable callable
with the same type and state for all work-items in group [code]#g#.

_Effects:_ Blocks until all work-items in group [code]#g# have reached this
synchronization point, then executes the algorithm.

_Synchronization:_ The call to this function in each work-item happens before
the algorithm begins execution.
The completion of the algorithm happens before any work-item blocking on the
same synchronization point is unblocked.

_Returns:_ true if [code]#pred# returns false when applied to the result of
dereferencing all pointers in the range [code]#[first, last)#.
--

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true.
+
--
_Preconditions:_ [code]#pred# must be an immutable callable with the same type
and state for all work-items in group [code]#g#.

_Effects:_ Blocks until all work-items in group [code]#g# have reached this
synchronization point, then executes the algorithm.

_Synchronization:_ The call to this function in each work-item happens before
the algorithm begins execution.
The completion of the algorithm happens before any work-item blocking on the
same synchronization point is unblocked.

_Returns:_ true if [code]#pred(x)# returns false for all work-items in group
[code]#g#.
--

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true.
+
--
_Effects:_ Blocks until all work-items in group [code]#g# have reached this
synchronization point, then executes the algorithm.

_Synchronization:_ The call to this function in each work-item happens before
the algorithm begins execution.
The completion of the algorithm happens before any work-item blocking on the
same synchronization point is unblocked.

_Returns:_ true if [code]#pred# is false for all work-items in group [code]#g#.
--

==== [code]#shift_left# and [code]#shift_right#

The [code]#shift_left# and [code]#shift_right# functions from standard {cpp}
move values in a range down (to the left) or up (to the right) respectively.

SYCL provides similar algorithms compatible with the [code]#sub_group# class:

. [code]#shift_group_left# and [code]#shift_group_right# move values held by
the work-items in a group directly to another work-item in group [code]#g#, by
shifting values a fixed number of work-items to the left or right.

[source,,linenums]
----
include::{header_dir}/algorithms/shift.h[lines=4..-1]
----

  . _Constraints:_ Available only if [code]#std::is_same_v<std::decay_t<Group>,
    sub_group># is true and [code]#T# is a trivially copyable type.
+
--
_Preconditions:_ [code]#delta# must be the same for all work-items in the group.

_Effects:_ Blocks until all work-items in group [code]#g# have reached this
synchronization point, then executes the algorithm.

_Synchronization:_ The call to this function in each work-item happens before
the algorithm begins execution.
The completion of the algorithm happens before any work-item blocking on the
same synchronization point is unblocked.

_Returns:_ the value of [code]#x# from the work-item whose group local id
([code]#id#) is [code]#delta# larger than that of the calling work-item.
[code]#pass:[id + delta]# may be greater than or equal to the group's linear
size, but the value returned in this case is unspecified.
--

  . _Constraints:_ Available only if [code]#std::is_same_v<std::decay_t<Group>,
    sub_group># is true and [code]#T# is a trivially copyable type.
+
--
_Preconditions:_ [code]#delta# must be the same for all work-items in the group.

_Effects:_ Blocks until all work-items in group [code]#g# have reached this
synchronization point, then executes the algorithm.

_Synchronization:_ The call to this function in each work-item happens before
the algorithm begins execution.
The completion of the algorithm happens before any work-item blocking on the
same synchronization point is unblocked.

_Returns:_ the value of [code]#x# from the work-item whose group local id
([code]#id#) is [code]#delta# smaller than that of the calling work-item.
[code]#id - delta# may be less than 0, but the value returned in this case is
unspecified.
--

==== [code]#permute#

SYCL provides an algorithm to permute the values held by work-items in a
sub-group:

. [code]#permute_group_by_xor# permutes values by exchanging values held by pairs
of work-items identified by computing the bitwise exclusive OR of the work-item
id and some fixed mask.

[source,,linenums]
----
include::{header_dir}/algorithms/permute.h[lines=4..-1]
----

  . _Constraints:_ Available only if [code]#std::is_same_v<std::decay_t<Group>,
    sub_group># is true and [code]#T# is a trivially copyable type.
+
--
_Preconditions:_ [code]#mask# must be the same for all work-items in the group.

_Effects:_ Blocks until all work-items in group [code]#g# have reached this
synchronization point, then executes the algorithm.

_Synchronization:_ The call to this function in each work-item happens before
the algorithm begins execution.
The completion of the algorithm happens before any work-item blocking on the
same synchronization point is unblocked.

_Returns:_ the value of [code]#x# from the work-item whose group local id is
equal to the bitwise exclusive OR of the calling work-item's group local id and
[code]#mask#.
The result of the exclusive OR may be greater than or equal to the group's
linear size, but the value returned in this case is unspecified.
--

==== [code]#select#

SYCL provides an algorithm to directly exchange the values held by work-items in
a sub-group:

. [code]#select_from_group# allows work-items to obtain a copy of a value held
by any other work-item in group [code]#g#.

[source,,linenums]
----
include::{header_dir}/algorithms/select.h[lines=4..-1]
----

  . _Constraints:_ Available only if [code]#std::is_same_v<std::decay_t<Group>,
    sub_group># is true and [code]#T# is a trivially copyable type.
+
--
_Effects:_ Blocks until all work-items in group [code]#g# have reached this
synchronization point, then executes the algorithm.

_Synchronization:_ The call to this function in each work-item happens before
the algorithm begins execution.
The completion of the algorithm happens before any work-item blocking on the
same synchronization point is unblocked.

_Returns:_ the value of [code]#x# from the work-item with the group local id
specified by [code]#remote_local_id#.
The value of [code]#remote_local_id# may be outside of the group, but the value
returned in this case is unspecified.
--

==== [code]#reduce#

The [code]#reduce# function from standard {cpp} combines the values in a range
in an unspecified order using a binary operator.

SYCL provides two similar algorithms that compute the same generalized sum as
defined by standard {cpp}:

. [code]#joint_reduce# uses the work-items in a group to execute a
[code]#reduce# operation in parallel.

. [code]#reduce_over_group# combines values held directly by the work-items in
a group.

The result of a call to these functions is non-deterministic if the binary
operator is not commutative and associative.
Only the binary operators defined in <<sec:function-objects>> are currently
supported by the SYCL [code]#reduce# functions, but the standard {cpp} syntax is
used for forward compatibility with future SYCL versions.

[source,,linenums]
----
include::{header_dir}/algorithms/reduce.h[lines=4..-1]
----

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true, [code]#Ptr# is a
    pointer to a fundamental type, and [code]#BinaryOperation# is a SYCL
    function object type.
+
--
_Mandates:_ [code]#binary_op(*first, *first)# must return a value of type
[code]#std::iterator_traits<Ptr>::value_type#.

_Preconditions:_ [code]#first#, [code]#last# and the type of [code]#binary_op#
must be the same for all work-items in group [code]#g#.
[code]#binary_op# must be an instance of a SYCL function object.

_Effects:_ Blocks until all work-items in group [code]#g# have reached this
synchronization point, then executes the algorithm.

_Synchronization:_ The call to this function in each work-item happens before
the algorithm begins execution.
The completion of the algorithm happens before any work-item blocking on the
same synchronization point is unblocked.

_Returns:_ The result of combining the values resulting from dereferencing all
pointers in the range [code]#[first, last)# using the operator
[code]#binary_op#, where the values are combined according to the generalized
sum defined in standard {cpp}.
--

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true, [code]#Ptr# is a
    pointer to a fundamental type, [code]#T# is a fundamental type, and
    [code]#BinaryOperation# is a SYCL function object type.
+
--
_Mandates:_ [code]#binary_op(init, *first)# must return a value of type
[code]#T#.

_Preconditions:_ [code]#first#, [code]#last#, [code]#init# and the type of
[code]#binary_op# must be the same for all work-items in group [code]#g#.
[code]#binary_op# must be an instance of a SYCL function object.

_Effects:_ Blocks until all work-items in group [code]#g# have reached this
synchronization point, then executes the algorithm.

_Synchronization:_ The call to this function in each work-item happens before
the algorithm begins execution.
The completion of the algorithm happens before any work-item blocking on the
same synchronization point is unblocked.

_Returns:_ The result of combining the values resulting from dereferencing all
pointers in the range [code]#[first, last)# and the initial value [code]#init#
using the operator [code]#binary_op#, where the values are combined according to
the generalized sum defined in standard {cpp}.
--

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true, [code]#T# is a
    fundamental type and [code]#BinaryOperation# is a SYCL function object type.
+
--
_Mandates:_ [code]#binary_op(x, x)# must return a value of type [code]#T#.

_Preconditions:_ [code]#binary_op# must be an instance of a SYCL function
object.

_Effects:_ Blocks until all work-items in group [code]#g# have reached this
synchronization point, then executes the algorithm.

_Synchronization:_ The call to this function in each work-item happens before
the algorithm begins execution.
The completion of the algorithm happens before any work-item blocking on the
same synchronization point is unblocked.

_Returns:_ The result of combining all the values of [code]#x# specified by each
work-item in group [code]#g# using the operator [code]#binary_op#, where the
values are combined according to the generalized sum defined in standard {cpp}.
--

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true, [code]#V# and
    [code]#T# are fundamental types, and [code]#BinaryOperation# is a SYCL
    function object type.
+
--
_Mandates:_ [code]#binary_op(init, x)# must return a value of type [code]#T#.

_Preconditions:_ [code]#binary_op# must be an instance of a SYCL function
object.

_Effects:_ Blocks until all work-items in group [code]#g# have reached this
synchronization point, then executes the algorithm.

_Synchronization:_ The call to this function in each work-item happens before
the algorithm begins execution.
The completion of the algorithm happens before any work-item blocking on the
same synchronization point is unblocked.

_Returns:_ The result of combining all the values of [code]#x# specified by each
work-item in group [code]#g# and the initial value [code]#init# using the
operator [code]#binary_op#, where the values are combined according to the
generalized sum defined in standard {cpp}.
--

==== [code]#exclusive_scan# and [code]#inclusive_scan#

The [code]#exclusive_scan# and [code]#inclusive_scan# functions in standard
{cpp} compute a prefix sum using a binary operator.
For a scan of elements _[x~0~, {ldots}, x~n~]_, the _i_ th result in an
exclusive scan is the generalized noncommutative sum of all elements preceding
_x~i~_ (excluding _x~i~_ itself), whereas the _i_ th result in an inclusive scan
is the generalized noncommutative sum of all elements preceding _x~i~_
(including _x~i~_ itself).

SYCL provides two similar sets of algorithms that compute the same prefix sums
using the generalized noncommutative sum as defined by standard {cpp}:

. [code]#joint_exclusive_scan# and [code]#joint_inclusive_scan# use the
work-items in a group to execute the corresponding algorithm in parallel, and
intermediate partial prefix sums are written to memory as in standard {cpp}.

. [code]#exclusive_scan_over_group# and [code]#inclusive_scan_over_group#
perform a scan over values held directly by the work-items in a group, and the
result returned to each work-item represents a partial prefix sum.

The result of a call to a scan is non-deterministic if the binary operator is
not associative.
Only the binary operators defined in <<sec:function-objects>> are currently
supported by the SYCL scan functions, but the standard {cpp} syntax is used for
forward compatibility with future SYCL versions.

[source,,linenums]
----
include::{header_dir}/algorithms/exclusive_scan.h[lines=4..-1]
----

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true, [code]#InPtr# and
    [code]#OutPtr# are pointers to fundamental types, and
    [code]#BinaryOperation# is a SYCL function object type.
+
--
_Mandates:_ [code]#binary_op(*first, *first)# must return a value of type
[code]#std::iterator_traits<OutPtr>::value_type#.

_Preconditions:_ [code]#first#, [code]#last#, [code]#result# and the type of
[code]#binary_op# must be the same for all work-items in group [code]#g#.
[code]#binary_op# must be an instance of a SYCL function object.

[NOTE]
====
Note that [code]#first# may be equal to [code]#result#.
====

_Effects:_ Blocks until all work-items in group [code]#g# have reached this
synchronization point, then executes the algorithm.

The value written to [code]#result# + _i_ is the exclusive scan of the values
resulting from dereferencing the first _i_ values in the range [code]#[first,
last)# and the identity value of [code]#binary_op# (as identified by
[code]#sycl::known_identity#), using the operator [code]#binary_op#.
The scan is computed using a generalized noncommutative sum as defined in
standard {cpp}.

_Synchronization:_ The call to this function in each work-item happens before
the algorithm begins execution.
The completion of the algorithm happens before any work-item blocking on the
same synchronization point is unblocked.

_Returns:_ A pointer to the end of the output range.
--

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true, [code]#InPtr# and
    [code]#OutPtr# are pointers to fundamental types, [code]#T# is a fundamental
    type, and [code]#BinaryOperation# is a SYCL function object type.
+
--
_Mandates:_ [code]#binary_op(init, *first)# must return a value of type
[code]#T#.

_Preconditions:_ [code]#first#, [code]#last#, [code]#result#, [code]#init# and
the type of [code]#binary_op# must be the same for all work-items in group
[code]#g#.
[code]#binary_op# must be an instance of a SYCL function object.

[NOTE]
====
Note that [code]#first# may be equal to [code]#result#.
====

_Effects:_ Blocks until all work-items in group [code]#g# have reached this
synchronization point, then executes the algorithm.

The value written to [code]#result# + _i_ is the exclusive scan of the values
resulting from dereferencing the first _i_ values in the range [code]#[first,
last)# and an initial value specified by [code]#init#, using the operator
[code]#binary_op#.
The scan is computed using a generalized noncommutative sum as defined in
standard {cpp}.

_Synchronization:_ The call to this function in each work-item happens before
the algorithm begins execution.
The completion of the algorithm happens before any work-item blocking on the
same synchronization point is unblocked.

_Returns:_ A pointer to the end of the output range.
--

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true, [code]#T# is a
    fundamental type, and [code]#BinaryOperation# is a SYCL function object
    type.
+
--
_Mandates:_ [code]#binary_op(x, x)# must return a value of type [code]#T#.

_Preconditions:_ [code]#binary_op# must be an instance of a SYCL function
object.

_Effects:_ Blocks until all work-items in group [code]#g# have reached this
synchronization point, then executes the algorithm.

_Synchronization:_ The call to this function in each work-item happens before
the algorithm begins execution.
The completion of the algorithm happens before any work-item blocking on the
same synchronization point is unblocked.

_Returns:_ The value returned on work-item _i_ is the exclusive scan of the
first _i_ values in group [code]#g# and the identity value of [code]#binary_op#
(as identified by [code]#sycl::known_identity#), using the operator
[code]#binary_op#.
The scan is computed using a generalized noncommutative sum as defined in
standard {cpp}.
For multi-dimensional groups, the order of work-items in group [code]#g# is
determined by their linear id.
--

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true, [code]#V# and
    [code]#T# are fundamental types, and [code]#BinaryOperation# is a SYCL
    function object type.
+
--
_Mandates:_ [code]#binary_op(init, x)# must return a value of type [code]#T#.

_Preconditions:_ [code]#binary_op# must be an instance of a SYCL function
object.

_Effects:_ Blocks until all work-items in group [code]#g# have reached this
synchronization point, then executes the algorithm.

_Synchronization:_ The call to this function in each work-item happens before
the algorithm begins execution.
The completion of the algorithm happens before any work-item blocking on the
same synchronization point is unblocked.

_Returns:_ The value returned on work-item _i_ is the exclusive scan of the
first _i_ values in group [code]#g# and an initial value specified by
[code]#init#, using the operator [code]#binary_op#.
The scan is computed using a generalized noncommutative sum as defined in
standard {cpp}.
For multi-dimensional groups, the order of work-items in group [code]#g# is
determined by their linear id.
--

[source,,linenums]
----
include::{header_dir}/algorithms/inclusive_scan.h[lines=4..-1]
----

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true, [code]#InPtr# and
    [code]#OutPtr# are pointers to fundamental types, and
    [code]#BinaryOperation# is a SYCL function object type.
+
--
_Mandates:_ [code]#binary_op(*first, *first)# must return a value of type
[code]#std::iterator_traits<OutPtr>::value_type#.

_Preconditions:_ [code]#first#, [code]#last#, [code]#result# and the type of
[code]#binary_op# must be the same for all work-items in group [code]#g#.
[code]#binary_op# must be an instance of a SYCL function object.

[NOTE]
====
Note that [code]#first# may be equal to [code]#result#.
====

_Effects:_ Blocks until all work-items in group [code]#g# have reached this
synchronization point, then executes the algorithm.

The value written to [code]#result# + _i_ is the inclusive scan of the values
resulting from dereferencing the first _i_ values in the range [code]#[first,
last)#, using the operator [code]#binary_op#.
The scan is computed using a generalized noncommutative sum as defined in
standard {cpp}.

_Synchronization:_ The call to this function in each work-item happens before
the algorithm begins execution.
The completion of the algorithm happens before any work-item blocking on the
same synchronization point is unblocked.

_Returns:_ A pointer to the end of the output range.
--

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true, [code]#InPtr# and
    [code]#OutPtr# are pointers to fundamental types, [code]#BinaryOperation# is
    a SYCL function object type, and [code]#T# is a fundamental type.
+
--
_Mandates:_ [code]#binary_op(init, *first)# must return a value of type
[code]#T#.

_Preconditions:_ [code]#first#, [code]#last#, [code]#result#, [code]#init# and
the type of [code]#binary_op# must be the same for all work-items in group
[code]#g#.
[code]#binary_op# must be an instance of a SYCL function object.

[NOTE]
====
Note that [code]#first# may be equal to [code]#result#.
====

_Effects:_ Blocks until all work-items in group [code]#g# have reached this
synchronization point, then executes the algorithm.

The value written to [code]#result# + _i_ is the inclusive scan of the values
resulting from dereferencing the first _i_ values in the range [code]#[first,
last)# and an initial value specified by [code]#init#, using the operator
[code]#binary_op#.
The scan is computed using a generalized noncommutative sum as defined in
standard {cpp}.

_Synchronization:_ The call to this function in each work-item happens before
the algorithm begins execution.
The completion of the algorithm happens before any work-item blocking on the
same synchronization point is unblocked.

_Returns:_ A pointer to the end of the output range.
--

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true, [code]#T# is a
    fundamental type, and [code]#BinaryOperation# is a SYCL function object
    type.
+
--
_Mandates:_ [code]#binary_op(x, x)# must return a value of type [code]#T#.

_Preconditions:_ [code]#binary_op# must be an instance of a SYCL function
object.

_Effects:_ Blocks until all work-items in group [code]#g# have reached this
synchronization point, then executes the algorithm.

_Synchronization:_ The call to this function in each work-item happens before
the algorithm begins execution.
The completion of the algorithm happens before any work-item blocking on the
same synchronization point is unblocked.

_Returns:_ The value returned on work-item _i_ is the inclusive scan of the
first _i_ values in group [code]#g#, using the operator [code]#binary_op#.
The scan is computed using a generalized noncommutative sum as defined in
standard {cpp}.
For multi-dimensional groups, the order of work-items in group [code]#g# is
determined by their linear id.
--

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true, [code]#V# is a
    fundamental type, [code]#BinaryOperation# is a SYCL function object type,
    and [code]#T# is a fundamental type.
+
--
_Mandates:_ [code]#binary_op(init, x)# must return a value of type [code]#T#.

_Preconditions:_ [code]#binary_op# must be an instance of a SYCL function
object.

_Effects:_ Blocks until all work-items in group [code]#g# have reached this
synchronization point, then executes the algorithm.

_Synchronization:_ The call to this function in each work-item happens before
the algorithm begins execution.
The completion of the algorithm happens before any work-item blocking on the
same synchronization point is unblocked.

_Returns:_ The value returned on work-item _i_ is the inclusive scan of the
first _i_ values in group [code]#g# and an initial value specified by
[code]#init#, using the operator [code]#binary_op#.
The scan is computed using a generalized noncommutative sum as defined in
standard {cpp}.
For multi-dimensional groups, the order of work-items in group [code]#g# is
determined by their linear id.
--


[[sec:math-functions]]
=== Math functions

This section describes the math functions that are available in the [code]#sycl#
namespace in both host and device code.

The function descriptions in this section use the term _writeable address space_
to represent the following address spaces:

* [code]#access::address_space::global_space#
* [code]#access::address_space::local_space#
* [code]#access::address_space::private_space#
* [code]#access::address_space::generic_space#

The descriptions in this section use the type name [code]#+__swizzle__+# to
refer to the classes defined in <<swizzled-vec-class>>.
This type can be any instantiation of the class templates named
[code]#+__writeable_swizzle__+# or [code]#+__const_swizzle__+# in that section,
so long as the instantiation satisfies the constraints listed in the function's
description.

'''

.[apidef]#acos#
[source,role=synopsis,id=api:acos]
----
float acos(float x)                (1)
double acos(double x)              (2)
half acos(half x)                  (3)

template<typename NonScalar>       (4)
/*return-type*/ acos(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The inverse cosine of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the inverse cosine of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#acosh#
[source,role=synopsis,id=api:acosh]
----
float acosh(float x)                (1)
double acosh(double x)              (2)
half acosh(half x)                  (3)

template<typename NonScalar>        (4)
/*return-type*/ acosh(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The inverse hyperbolic cosine of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the inverse hyperbolic cosine of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#acospi#
[source,role=synopsis,id=api:acospi]
----
float acospi(float x)                (1)
double acospi(double x)              (2)
half acospi(half x)                  (3)

template<typename NonScalar>         (4)
/*return-type*/ acospi(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The value [code]#acos(x) / {pi}#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the value [code]#acos(x[i]) / {pi}#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#asin#
[source,role=synopsis,id=api:asin]
----
float asin(float x)                (1)
double asin(double x)              (2)
half asin(half x)                  (3)

template<typename NonScalar>       (4)
/*return-type*/ asin(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The inverse sine of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the inverse sine of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#asinh#
[source,role=synopsis,id=api:asinh]
----
float asinh(float x)                (1)
double asinh(double x)              (2)
half asinh(half x)                  (3)

template<typename NonScalar>        (4)
/*return-type*/ asinh(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The inverse hyperbolic sine of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the inverse hyperbolic sine of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#asinpi#
[source,role=synopsis,id=api:asinpi]
----
float asinpi(float x)                (1)
double asinpi(double x)              (2)
half asinpi(half x)                  (3)

template<typename NonScalar>         (4)
/*return-type*/ asinpi(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The value [code]#asin(x) / {pi}#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the value [code]#asin(x[i]) / {pi}#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#atan#
[source,role=synopsis,id=api:atan]
----
float atan(float y_over_x)                (1)
double atan(double y_over_x)              (2)
half atan(half y_over_x)                  (3)

template<typename NonScalar>              (4)
/*return-type*/ atan(NonScalar y_over_x)
----

*Overloads (1) - (3):*

_Returns:_ The inverse tangent of the input.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of the input, the inverse tangent of the element.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#atan2#
[source,role=synopsis,id=api:atan2]
----
float atan2(float y, float x)                       (1)
double atan2(double y, double x)                    (2)
half atan2(half y, half x)                          (3)

template<typename NonScalar1, typename NonScalar2>  (4)
/*return-type*/ atan2(NonScalar1 y, NonScalar2 x)
----

*Overloads (1) - (3):*

_Returns:_ The arc tangent of [code]#y / x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzle__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements;
* [code]#NonScalar1# and [code]#NonScalar2# have the same element type; and
* The element type of [code]#NonScalar1# and [code]#NonScalar2# is
  [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x# and [code]#y#, the arc tangent of
[code]#y[i] / x[i]#.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#atanh#
[source,role=synopsis,id=api:atanh]
----
float atanh(float x)                (1)
double atanh(double x)              (2)
half atanh(half x)                  (3)

template<typename NonScalar>        (4)
/*return-type*/ atanh(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The hyperbolic inverse tangent of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the hyperbolic inverse tangent of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#atanpi#
[source,role=synopsis,id=api:atanpi]
----
float atanpi(float x)                (1)
double atanpi(double x)              (2)
half atanpi(half x)                  (3)

template<typename NonScalar>         (4)
/*return-type*/ atanpi(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The value [code]#atan(x) / {pi}#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the value [code]#atan(x[i]) / {pi}#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#atan2pi#
[source,role=synopsis,id=api:atan2pi]
----
float atan2pi(float y, float x)                      (1)
double atan2pi(double y, double x)                   (2)
half atan2pi(half y, half x)                         (3)

template<typename NonScalar1, typename NonScalar2>   (4)
/*return-type*/ atan2pi(NonScalar1 y, NonScalar2 x)
----

*Overloads (1) - (3):*

_Returns:_ The value [code]#atan2(y, x) / {pi}#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzle__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements;
* [code]#NonScalar1# and [code]#NonScalar2# have the same element type; and
* The element type of [code]#NonScalar1# and [code]#NonScalar2# is
  [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x# and [code]#y#, the value
[code]#atan2(y[i], x[i]) / {pi}#.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#cbrt#
[source,role=synopsis,id=api:cbrt]
----
float cbrt(float x)                (1)
double cbrt(double x)              (2)
half cbrt(half x)                  (3)

template<typename NonScalar>       (4)
/*return-type*/ cbrt(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The cube-root of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the cube-root of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#ceil#
[source,role=synopsis,id=api:ceil]
----
float ceil(float x)                (1)
double ceil(double x)              (2)
half ceil(half x)                  (3)

template<typename NonScalar>       (4)
/*return-type*/ ceil(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The value [code]#x# rounded to an integral value using the round to
positive infinity rounding mode.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the value [code]#x[i]# rounded to an
integral value using the round to positive infinity rounding mode.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#copysign#
[source,role=synopsis,id=api:copysign]
----
float copysign(float x, float y)                      (1)
double copysign(double x, double y)                   (2)
half copysign(half x, half y)                         (3)

template<typename NonScalar1, typename NonScalar2>    (4)
/*return-type*/ copysign(NonScalar1 x, NonScalar2 y)
----

*Overloads (1) - (3):*

_Returns:_ The value of [code]#x# with its sign changed to match the sign of
[code]#y#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzle__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements;
* [code]#NonScalar1# and [code]#NonScalar2# have the same element type; and
* The element type of [code]#NonScalar1# and [code]#NonScalar2# is
  [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x# and [code]#y#, the value of
[code]#x[i]# with its sign changed to match the sign of [code]#y[i]#.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#cos#
[source,role=synopsis,id=api:cos]
----
float cos(float x)                (1)
double cos(double x)              (2)
half cos(half x)                  (3)

template<typename NonScalar>      (4)
/*return-type*/ cos(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The cosine of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the cosine of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#cosh#
[source,role=synopsis,id=api:cosh]
----
float cosh(float x)                (1)
double cosh(double x)              (2)
half cosh(half x)                  (3)

template<typename NonScalar>       (4)
/*return-type*/ cosh(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The hyperbolic cosine of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the hyperbolic cosine of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#cospi#
[source,role=synopsis,id=api:cospi]
----
float cospi(float x)                (1)
double cospi(double x)              (2)
half cospi(half x)                  (3)

template<typename NonScalar>         (4)
/*return-type*/ cospi(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The value [code]#cos({pi} * x)#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the value [code]#cos({pi} * x[i])#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#erfc#
[source,role=synopsis,id=api:erfc]
----
float erfc(float x)                (1)
double erfc(double x)              (2)
half erfc(half x)                  (3)

template<typename NonScalar>       (4)
/*return-type*/ erfc(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The complementary error function of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the complementary error function of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#erf#
[source,role=synopsis,id=api:erf]
----
float erf(float x)                (1)
double erf(double x)              (2)
half erf(half x)                  (3)

template<typename NonScalar>      (4)
/*return-type*/ erf(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The error function of [code]#x# (encountered in integrating the
normal distribution).

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the error function of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#exp#
[source,role=synopsis,id=api:exp]
----
float exp(float x)                (1)
double exp(double x)              (2)
half exp(half x)                  (3)

template<typename NonScalar>      (4)
/*return-type*/ exp(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The base-_e_ exponential of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the base-_e_ exponential of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#exp2#
[source,role=synopsis,id=api:exp2]
----
float exp2(float x)                (1)
double exp2(double x)              (2)
half exp2(half x)                  (3)

template<typename NonScalar>       (4)
/*return-type*/ exp2(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The base-2 exponential of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the base-2 exponential of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#exp10#
[source,role=synopsis,id=api:exp10]
----
float exp10(float x)                (1)
double exp10(double x)              (2)
half exp10(half x)                  (3)

template<typename NonScalar>        (4)
/*return-type*/ exp10(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The base-10 exponential of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the base-10 exponential of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#expm1#
[source,role=synopsis,id=api:expm1]
----
float expm1(float x)                (1)
double expm1(double x)              (2)
half expm1(half x)                  (3)

template<typename NonScalar>        (4)
/*return-type*/ expm1(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The value [code]#e^x^-1.0#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the value [code]#e^x[i]^-1.0#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#fabs#
[source,role=synopsis,id=api:fabs]
----
float fabs(float x)                (1)
double fabs(double x)              (2)
half fabs(half x)                  (3)

template<typename NonScalar>       (4)
/*return-type*/ fabs(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The absolute value of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the absolute value of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#fdim#
[source,role=synopsis,id=api:fdim]
----
float fdim(float x, float y)                        (1)
double fdim(double x, double y)                     (2)
half fdim(half x, half y)                           (3)

template<typename NonScalar1, typename NonScalar2>  (4)
/*return-type*/ fdim(NonScalar1 x, NonScalar2 y)
----

*Overloads (1) - (3):*

_Returns:_ The value [code]#x - y# if [code]#x > y#, otherwise +0.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzle__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements;
* [code]#NonScalar1# and [code]#NonScalar2# have the same element type; and
* The element type of [code]#NonScalar1# and [code]#NonScalar2# is
  [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x# and [code]#y#, the value [code]#x[i] -
y[i]# if [code]#x[i] > y[i]#, otherwise +0.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#floor#
[source,role=synopsis,id=api:floor]
----
float floor(float x)                (1)
double floor(double x)              (2)
half floor(half x)                  (3)

template<typename NonScalar>        (4)
/*return-type*/ floor(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The value [code]#x# rounded to an integral value using the round to
negative infinity rounding mode.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the value [code]#x[i]# rounded to an
integral value using the round to negative infinity rounding mode.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#fma#
[source,role=synopsis,id=api:fma]
----
float fma(float a, float b, float c)                                     (1)
double fma(double a, double b, double c)                                 (2)
half fma(half a, half b, half c)                                         (3)

template<typename NonScalar1, typename NonScalar2, typename NonScalar3>  (4)
/*return-type*/ fma(NonScalar1 a, NonScalar2 b, NonScalar3 c)
----

*Overloads (1) - (3):*

_Returns:_ The correctly rounded floating-point representation of the sum of
[code]#c# with the infinitely precise product of [code]#a# and [code]#b#.
Rounding of intermediate products shall not occur.
Edge case behavior is per the IEEE 754-2008 standard.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1#,
  [code]#NonScalar2#, and [code]#NonScalar3#:
** [code]#NonScalar1#, [code]#NonScalar2#, and [code]#NonScalar3# are each
   [code]#marray#; or
** [code]#NonScalar1#, [code]#NonScalar2#, and [code]#NonScalar3# are any
   combination of [code]#vec# and the [code]#+__swizzle__+# type;
* [code]#NonScalar1#, [code]#NonScalar2#, and [code]#NonScalar3# have the same
  number of elements;
* [code]#NonScalar1#, [code]#NonScalar2#, and [code]#NonScalar3# have the same
  element type; and
* The element type of [code]#NonScalar1#, [code]#NonScalar2#, and
  [code]#NonScalar3# is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#a#, [code]#b#, and [ode]#c#; the correctly
rounded floating-point representation of the sum of [code]#c[i]# with the
infinitely precise product of [code]#a[i]# and [code]#b[i]#.
Rounding of intermediate products shall not occur.
Edge case behavior is per the IEEE 754-2008 standard.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#fmax#
[source,role=synopsis,id=api:fmax]
----
float fmax(float x, float y)                                (1)
double fmax(double x, double y)                             (2)
half fmax(half x, half y)                                   (3)

template<typename NonScalar1, typename NonScalar2>          (4)
/*return-type*/ fmax(NonScalar1 x, NonScalar2 y)

template<typename NonScalar>                                (5)
/*return-type*/ fmax(NonScalar x, NonScalar::value_type y)
----

*Overloads (1) - (3):*

_Returns:_ [code]#y# if [code]#x < y#, otherwise [code]#x#.
If one argument is a NaN, returns the other argument.
If both arguments are NaNs, returns a NaN.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzle__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements;
* [code]#NonScalar1# and [code]#NonScalar2# have the same element type; and
* The element type of [code]#NonScalar1# and [code]#NonScalar2# is
  [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x# and [code]#y#, the value [code]#y[i]#
if [code]#x[i] < y[i]#, otherwise [code]#x[i]#.
If one element is a NaN, the result is the other element.
If both elements are NaNs, the result is NaN.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

*Overload (5):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the value [code]#y# if [code]#x[i] <
y#, otherwise [code]#x[i]#.
If one value is a NaN, the result is the other value.
If both value are NaNs, the result is a NaN.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#fmin#
[source,role=synopsis,id=api:fmin]
----
float fmin(float x, float y)                                (1)
double fmin(double x, double y)                             (2)
half fmin(half x, half y)                                   (3)

template<typename NonScalar1, typename NonScalar2>          (4)
/*return-type*/ fmin(NonScalar1 x, NonScalar2 y)

template<typename NonScalar>                                (5)
/*return-type*/ fmin(NonScalar x, NonScalar::value_type y)
----

*Overloads (1) - (3):*

_Returns:_ [code]#y# if [code]#y < x#, otherwise [code]#x#.
If one argument is a NaN, returns the other argument.
If both arguments are NaNs, returns a NaN.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzle__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements;
* [code]#NonScalar1# and [code]#NonScalar2# have the same element type; and
* The element type of [code]#NonScalar1# and [code]#NonScalar2# is
  [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x# and [code]#y#, the value [code]#y[i]#
if [code]#y[i] < x[i]#, otherwise [code]#x[i]#.
If one element is a NaN, the result is the other element.
If both elements are NaNs, the result is NaN.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

*Overload (5):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the value [code]#y# if [code]#y <
x[i]#, otherwise [code]#x[i]#.
If one value is a NaN, the result is the other value.
If both value are NaNs, the result is a NaN.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#fmod#
[source,role=synopsis,id=api:fmod]
----
float fmod(float x, float y)                        (1)
double fmod(double x, double y)                     (2)
half fmod(half x, half y)                           (3)

template<typename NonScalar1, typename NonScalar2>  (4)
/*return-type*/ fmod(NonScalar1 x, NonScalar2 y)
----

*Overloads (1) - (3):*

_Returns:_ The value [code]#x - y * trunc(x/y)#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzle__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements;
* [code]#NonScalar1# and [code]#NonScalar2# have the same element type; and
* The element type of [code]#NonScalar1# and [code]#NonScalar2# is
  [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x# and [code]#y#, the value [code]#x[i] -
y[i] * trunc(x[i]/y[i])#.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#fract#
[source,role=synopsis,id=api:fract]
----
template<typename Ptr>                        (1)
float fract(float x, Ptr iptr)

template<typename Ptr>                        (2)
double fract(double x, Ptr iptr)

template<typename Ptr>                        (3)
half fract(half x, Ptr iptr)

template<typename NonScalar, typename Ptr>    (4)
/*return-type*/ fract(NonScalar x, Ptr iptr)
----

*Overloads (1) - (3):*

_Constraints:_ Available only if [code]#Ptr# is one of the following:

* A {cpp} cv-unqualified pointer to the same type as [code]#x#; or
* A [code]#multi_ptr# with [code]#ElementType# equal to the same type as
  [code]#x# and with [code]#Space# equal to one of the _writeable address
  spaces_ as defined above.

_Effects:_ Writes the value [code]#floor(x)# to [code]#iptr#.

_Returns:_ The value [code]#fmin(x - floor(x), nextafter(T{1.0}, T{0.0}) )#,
where [code]#T# is the type of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type with element type [code]#float#, [code]#double#, or [code]#half#;
* [code]#Ptr# is one of the following:
** A {cpp} cv-unqualified pointer to [code]#NonScalar#, unless [code]#NonScalar#
   is the [code]#+__swizzle__+# type, in which case it is a cv-unqualified
   pointer to the corresponding [code]#vec#; or
** A [code]#multi_ptr# where:
*** The [code]#ElementType# is equal to [code]#NonScalar#, unless
    [code]#NonScalar# is the [code]#+__swizzle__+# type, in which case the
    [code]#ElementType# is the corresponding [code]#vec#; and
*** The [code]#Space# is equal to one of the _writeable address spaces_ as
    defined above.

_Effects:_ Writes the value [code]#floor(x)# to [code]#iptr#.

_Returns:_ For each element of [code]#x#, the value [code]#fmin(x[i] -
floor(x[i]), nextafter(T{1.0}, T{0.0}) )#, where [code]#T# is the element type
of [code]#x#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#frexp#
[source,role=synopsis,id=api:frexp]
----
template<typename Ptr>                        (1)
float frexp(float x, Ptr exp)

template<typename Ptr>                        (2)
double frexp(double x, Ptr exp)

template<typename Ptr>                        (3)
half frexp(half x, Ptr exp)

template<typename NonScalar, typename Ptr>    (4)
/*return-type*/ frexp(NonScalar x, Ptr exp)
----

*Overloads (1) - (3):*

_Constraints:_ Available only if [code]#Ptr# is one of the following:

* A {cpp} cv-unqualified pointer to [code]#int#; or
* A [code]#multi_ptr# with [code]#ElementType# of [code]#int# and with
  [code]#Space# equal to one of the _writeable address spaces_ as defined above.

_Effects:_ Extracts the mantissa and exponent from [code]#x#.
The mantissa is a floating point number whose magnitude is in the interval
+[0.5, 1)+ or 0.
The extracted mantissa and exponent are such that mantissa * 2^exp^ equals
[code]#x#.
The exponent is written to [code]#exp#.

_Returns:_ The mantissa of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type with element type [code]#float#, [code]#double#, or [code]#half#;
* [code]#Ptr# is one of the following:
** (If [code]#NonScalar# is [code]#marray#): A {cpp} cv-unqualified pointer to
   [code]#marray# of [code]#int# with the same number of elements as
   [code]#NonScalar#; or
** (If [code]#NonScalar# is [code]#vec# or the [code]#+__swizzle__+# type): A
   {cpp} cv-unqualified pointer to [code]#vec# of [code]#int32_t# with the same
   number of elements as [code]#NonScalar#; or
** (If [code]#NonScalar# is [code]#marray#): A [code]#multi_ptr# whose
   [code]#Space# is equal to one of the _writeable address spaces_ as defined
   above and whose [code]#ElementType# is [code]#marray# of [code]#int# with the
   same number of elements as [code]#NonScalar#; or
** (If [code]#NonScalar# is [code]#vec# or the [code]#+__swizzle__+# type): A
   [code]#multi_ptr# whose [code]#Space# is equal to one of the _writeable
   address spaces_ as defined above and whose [code]#ElementType# is [code]#vec#
   of [code]#int32_t# with the same number of elements as [code]#NonScalar#.

_Effects:_ Extracts the mantissa and exponent from each element of [code]#x#.
Each mantissa is a floating point number whose magnitude is in the interval
+[0.5, 1)+ or 0.
Each extracted mantissa and exponent are such that mantissa * 2^exp^ equals
[code]#x[i]#.
The exponent of each element of [code]#x# is written to [code]#exp#.

_Returns:_ For each element of [code]#x#, the mantissa of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#hypot#
[source,role=synopsis,id=api:hypot]
----
float hypot(float x, float y)                       (1)
double hypot(double x, double y)                    (2)
half hypot(half x, half y)                          (3)

template<typename NonScalar1, typename NonScalar2>  (4)
/*return-type*/ hypot(NonScalar1 x, NonScalar2 y)
----

*Overloads (1) - (3):*

_Returns:_ The value of the square root of x^2^ + y^2^ without undue overflow or
underflow.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzle__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements;
* [code]#NonScalar1# and [code]#NonScalar2# have the same element type; and
* The element type of [code]#NonScalar1# and [code]#NonScalar2# is
  [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x# and [code]#y#, the value of the square
root of +x[i]+^2^ + +y[i]+^2^ without undue overflow or underflow.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#ilogb#
[source,role=synopsis,id=api:ilogb]
----
int ilogb(float x)                  (1)
int ilogb(double x)                 (2)
int ilogb(half x)                   (3)

template<typename NonScalar>        (4)
/*return-type*/ ilogb(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ Compute the integral part of log~r~|x| and return the result as an
integer, where r is the value returned by
[code]#std::numeric_limits<decltype(x)>::radix#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, compute the integral part of
log~r~|x[i]| and return the result as an integer, where r is the value returned
by [code]#std::numeric_limits<NonScalar::value_type)>::radix#.

The return type depends on [code]#NonScalar#.
If [code]#NonScalar# is [code]#marray#, the return type is [code]#marray# of
[code]#int# with the same number of element as [code]#NonScalar#.
If [code]#NonScalar# is [code]#vec# or the [code]#+__swizzle__+# type, the
return type is [code]#vec# of [code]#int32_t# with the same number of elements
as [code]#NonScalar#.

'''

.[apidef]#ldexp#
[source,role=synopsis,id=api:ldexp]
----
float ldexp(float x, int k)                         (1)
double ldexp(double x, int k)                       (2)
half ldexp(half x, int k)                           (3)

template<typename NonScalar1, typename NonScalar2>  (4)
/*return-type*/ ldexp(NonScalar1 x, NonScalar2 k)

template<typename NonScalar>                        (5)
/*return-type*/ ldexp(NonScalar x, int k)
----

*Overloads (1) - (3):*

_Returns:_ The value [code]#x# multiplied by 2^k^.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar1# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzle__+# type;
* The element type of [code]#NonScalar1# is [code]#float#, [code]#double#, or
  [code]#half#;
* If [code]#NonScalar1# is [code]#marray#, [code]#NonScalar2# is [code]#marray#
  of [code]#int# with the same number of elements as [code]#NonScalar1#; and
* If [code]#NonScalar1# is [code]#vec# or the [code]#+__swizzle__+# type,
  [code]#NonScalar2# is [code]#vec# or the [code]#+__swizzle__+# type of
  [code]#int32_t# with the same number of elements as [code]#NonScalar1#.

_Returns:_ For each element of [code]#x# and [code]#k#, the value [code]#x[i]#
multiplied by 2^k[i]^.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

*Overload (5):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type of [code]#NonScalar# is [code]#float#, [code]#double#, or
  [code]#half#.

_Returns:_ For each element of [code]#x#, the value [code]#x[i]# multiplied by
2^k^.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#lgamma#
[source,role=synopsis,id=api:lgamma]
----
float lgamma(float x)                (1)
double lgamma(double x)              (2)
half lgamma(half x)                  (3)

template<typename NonScalar>         (4)
/*return-type*/ lgamma(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The natural logarithm of the absolute value of the gamma function of
[code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the natural logarithm of the absolute
value of the gamma function of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#lgamma_r#
[source,role=synopsis,id=api:lgamma_r]
----
template<typename Ptr>                        (1)
float lgamma_r(float x, Ptr signp)

template<typename Ptr>                        (2)
double lgamma_r(double x, Ptr signp)

template<typename Ptr>                        (3)
half lgamma_r(half x, Ptr signp)

template<typename NonScalar, typename Ptr>    (4)
/*return-type*/ lgamma_r(NonScalar x, Ptr signp)
----

*Overloads (1) - (3):*

_Constraints:_ Available only if [code]#Ptr# is one of the following:

* A {cpp} cv-unqualified pointer to [code]#int#; or
* A [code]#multi_ptr# with [code]#ElementType# of [code]#int# and with
  [code]#Space# equal to one of the _writeable address spaces_ as defined above.

_Effects:_ Writes the sign of the gamma function of [code]#x# to [code]#signp#.

_Returns:_ The natural logarithm of the absolute value of the gamma function of
[code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type with element type [code]#float#, [code]#double#, or [code]#half#;
* [code]#Ptr# is one of the following:
** (If [code]#NonScalar# is [code]#marray#): A {cpp} cv-unqualified pointer to
   [code]#marray# of [code]#int# with the same number of elements as
   [code]#NonScalar#; or
** (If [code]#NonScalar# is [code]#vec# or the [code]#+__swizzle__+# type): A
   {cpp} cv-unqualified pointer to [code]#vec# of [code]#int32_t# with the same
   number of elements as [code]#NonScalar#; or
** (If [code]#NonScalar# is [code]#marray#): A [code]#multi_ptr# whose
   [code]#Space# is equal to one of the _writeable address spaces_ as defined
   above and whose [code]#ElementType# is [code]#marray# of [code]#int# with the
   same number of elements as [code]#NonScalar#; or
** (If [code]#NonScalar# is [code]#vec# or the [code]#+__swizzle__+# type): A
   [code]#multi_ptr# whose [code]#Space# is equal to one of the _writeable
   address spaces_ as defined above and whose [code]#ElementType# is [code]#vec#
   of [code]#int32_t# with the same number of elements as [code]#NonScalar#.

_Effects:_ Computes the gamma function for each element of [code]#x# and writes
the sign for each of these values to [code]#signp#.

_Returns:_ For each element of [code]#x#, the natural logarithm of the absolute
value of the gamma function of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#log#
[source,role=synopsis,id=api:log]
----
float log(float x)                (1)
double log(double x)              (2)
half log(half x)                  (3)

template<typename NonScalar>      (4)
/*return-type*/ log(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The natural logarithm of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the natural logarithm of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#log2#
[source,role=synopsis,id=api:log2]
----
float log2(float x)                (1)
double log2(double x)              (2)
half log2(half x)                  (3)

template<typename NonScalar>       (4)
/*return-type*/ log2(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The base 2 logarithm of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the base 2 logarithm of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#log10#
[source,role=synopsis,id=api:log10]
----
float log10(float x)                (1)
double log10(double x)              (2)
half log10(half x)                  (3)

template<typename NonScalar>        (4)
/*return-type*/ log10(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The base 10 logarithm of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the base 10 logarithm of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#log1p#
[source,role=synopsis,id=api:log1p]
----
float log1p(float x)                (1)
double log1p(double x)              (2)
half log1p(half x)                  (3)

template<typename NonScalar>        (4)
/*return-type*/ log1p(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The value [code]#log(1.0 + x)#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the value [code]#log(1.0 + x[i])#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#logb#
[source,role=synopsis,id=api:logb]
----
float logb(float x)                (1)
double logb(double x)              (2)
half logb(half x)                  (3)

template<typename NonScalar>       (4)
/*return-type*/ logb(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The integral part of log~r~|x|, where r is the value returned by
[code]#std::numeric_limits<decltype(x)>::radix#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the integral part of log~r~|x[i]|,
where r is the value returned by
[code]#std::numeric_limits<NonScalar::value_type>::radix#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#mad#
[source,role=synopsis,id=api:mad]
----
float mad(float a, float b, float c)                                     (1)
double mad(double a, double b, double c)                                 (2)
half mad(half a, half b, half c)                                         (3)

template<typename NonScalar1, typename NonScalar2, typename NonScalar3>  (4)
/*return-type*/ mad(NonScalar1 a, NonScalar2 b, NonScalar3 c)
----

*Overloads (1) - (3):*

_Effects:_ Computes the approximate value of [code]#a * b + c#.
Whether or how the product of [code]#a * b# is rounded and how supernormal or
subnormal intermediate products are handled is not defined.
The [code]#mad# function is intended to be used where speed is preferred over
accuracy.

_Returns:_ The approximate value of [code]#a * b + c#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1#,
  [code]#NonScalar2#, and [code]#NonScalar3#:
** [code]#NonScalar1#, [code]#NonScalar2#, and [code]#NonScalar3# are each
   [code]#marray#; or
** [code]#NonScalar1#, [code]#NonScalar2#, and [code]#NonScalar3# are any
   combination of [code]#vec# and the [code]#+__swizzle__+# type;
* [code]#NonScalar1#, [code]#NonScalar2#, and [code]#NonScalar3# have the same
  number of elements;
* [code]#NonScalar1#, [code]#NonScalar2#, and [code]#NonScalar3# have the same
  element type; and
* The element type of [code]#NonScalar1#, [code]#NonScalar2#, and
  [code]#NonScalar3# is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#a#, [code]#b#, and [ode]#c#; the The
approximate value of [code]#a[i] * b[i] + c[i]#.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#maxmag#
[source,role=synopsis,id=api:maxmag]
----
float maxmag(float x, float y)                      (1)
double maxmag(double x, double y)                   (2)
half maxmag(half x, half y)                         (3)

template<typename NonScalar1, typename NonScalar2>  (4)
/*return-type*/ maxmag(NonScalar1 x, NonScalar2 y)
----

*Overloads (1) - (3):*

_Returns:_ The value [code]#x# if |x| > |y|, [code]#y# if |y| > |x|, otherwise
[code]#fmax(x, y)#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzle__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements;
* [code]#NonScalar1# and [code]#NonScalar2# have the same element type; and
* The element type of [code]#NonScalar1# and [code]#NonScalar2# is
  [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x# and [code]#y#, the value [code]#x[i]#
if |x[i]| > |y[i]|, [code]#y[i]# if |y[i]| > |x[i]|, otherwise [code]#fmax(x[i],
y[i])#.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#minmag#
[source,role=synopsis,id=api:minmag]
----
float minmag(float x, float y)                      (1)
double minmag(double x, double y)                   (2)
half minmag(half x, half y)                         (3)

template<typename NonScalar1, typename NonScalar2>  (4)
/*return-type*/ minmag(NonScalar1 x, NonScalar2 y)
----

*Overloads (1) - (3):*

_Returns:_ The value [code]#x# if |x| < |y|, [code]#y# if |y| < |x|, otherwise
[code]#fmin(x, y)#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzle__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements;
* [code]#NonScalar1# and [code]#NonScalar2# have the same element type; and
* The element type of [code]#NonScalar1# and [code]#NonScalar2# is
  [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x# and [code]#y#, the value [code]#x[i]#
if |x[i]| < |y[i]|, [code]#y[i]# if |y[i]| < |x[i]|, otherwise [code]#fmin(x[i],
y[i])#.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#modf#
[source,role=synopsis,id=api:modf]
----
template<typename Ptr>                        (1)
float modf(float x, Ptr iptr)

template<typename Ptr>                        (2)
double modf(double x, Ptr iptr)

template<typename Ptr>                        (3)
half modf(half x, Ptr iptr)

template<typename NonScalar, typename Ptr>    (4)
/*return-type*/ modf(NonScalar x, Ptr iptr)
----

*Overloads (1) - (3):*

_Constraints:_ Available only if [code]#Ptr# is one of the following:

* A {cpp} cv-unqualified pointer to the same type as [code]#x#; or
* A [code]#multi_ptr# with [code]#ElementType# equal to the same type as
  [code]#x# and with [code]#Space# equal to one of the _writeable address
  spaces_ as defined above.

_Effects:_ The [code]#modf# function breaks the argument [code]#x# into integral
and fractional parts, each of which has the same sign as the argument.
It stores the integral part to the object pointed to by [code]#iptr#.

_Returns:_ The fractional part of the argument [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type with element type [code]#float#, [code]#double#, or [code]#half#;
* [code]#Ptr# is one of the following:
** A {cpp} cv-unqualified pointer to [code]#NonScalar#, unless [code]#NonScalar#
   is the [code]#+__swizzle__+# type, in which case it is a cv-unqualified
   pointer to the corresponding [code]#vec#; or
** A [code]#multi_ptr# where:
*** The [code]#ElementType# is equal to [code]#NonScalar#, unless
    [code]#NonScalar# is the [code]#+__swizzle__+# type, in which case the
    [code]#ElementType# is the corresponding [code]#vec#; and
*** The [code]#Space# is equal to one of the _writeable address spaces_ as
    defined above.

_Effects:_ The [code]#modf# function breaks each element of the argument
[code]#x# into integral and fractional parts, each of which has the same sign as
the element.
It stores the integral parts of each element to the object pointed to by
[code]#iptr#.

_Returns:_ The fractional parts of each element of the argument [code]#x#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#nan#
[source,role=synopsis,id=api:nan]
----
float nan(uint32_t nancode)             (1)
double nan(uint64_t nancode)            (2)
half nan(uint16_t nancode)              (3)

template<typename NonScalar>            (4)
/*return-type*/ nan(NonScalar nancode)
----

*Overloads (1) - (3):*

_Returns:_ A quiet NaN.
The [code]#nancode# may be placed in the significand of the resulting NaN.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#uint32_t#, [code]#uint64_t#, or [code]#uint16_t#.

_Returns:_ A quiet NaN for each element of [code]#nancode#.
Each [code]#nancode[i]# may be placed in the significand of the resulting NaN.

The return type depends on [code]#NonScalar#:

[options="header",separator="@",cols="70%,30%"]
|====
@NonScalar @ Return Type
@[code]#marray<uint32_t, N># @[code]#marray<float, N>#
@[code]#marray<uint64_t, N># @[code]#marray<double, N>#
@[code]#marray<uint16_t, N># @[code]#marray<half, N>#

@[code]#vec<uint32_t, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<uint32_t, N>#
@[code]#vec<float, N>#

@[code]#vec<uint64_t, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<uint64_t, N>#
@[code]#vec<double, N>#

@[code]#vec<uint16_t, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<uint16_t, N>#
@[code]#vec<half, N>#
|====

'''

.[apidef]#nextafter#
[source,role=synopsis,id=api:nextafter]
----
float nextafter(float x, float y)                      (1)
double nextafter(double x, double y)                   (2)
half nextafter(half x, half y)                         (3)

template<typename NonScalar1, typename NonScalar2>     (4)
/*return-type*/ nextafter(NonScalar1 x, NonScalar2 y)
----

*Overloads (1) - (3):*

_Returns:_ The next representable floating-point value following [code]#x# in
the direction of [code]#y#.
Thus, if [code]#y# is less than [code]#x#, [code]#nextafter# returns the largest
representable floating-point number less than [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzle__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements;
* [code]#NonScalar1# and [code]#NonScalar2# have the same element type; and
* The element type of [code]#NonScalar1# and [code]#NonScalar2# is
  [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x# and [code]#y#, the next representable
floating-point value following [code]#x[i]# in the direction of [code]#y[i]#.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#pow#
[source,role=synopsis,id=api:pow]
----
float pow(float x, float y)                         (1)
double pow(double x, double y)                      (2)
half pow(half x, half y)                            (3)

template<typename NonScalar1, typename NonScalar2>  (4)
/*return-type*/ pow(NonScalar1 x, NonScalar2 y)
----

*Overloads (1) - (3):*

_Returns:_ The value of [code]#x# raised to the power [code]#y#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzle__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements;
* [code]#NonScalar1# and [code]#NonScalar2# have the same element type; and
* The element type of [code]#NonScalar1# and [code]#NonScalar2# is
  [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x# and [code]#y#, the value of
[code]#x[i]# raised to the power [code]#y[i]#.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#pown#
[source,role=synopsis,id=api:pown]
----
float pown(float x, int y)                          (1)
double pown(double x, int y)                        (2)
half pown(half x, int y)                            (3)

template<typename NonScalar1, typename NonScalar2>  (4)
/*return-type*/ pown(NonScalar1 x, NonScalar2 y)
----

*Overloads (1) - (3):*

_Returns:_ The value of [code]#x# raised to the power [code]#y#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar1# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzle__+# type;
* The element type of [code]#NonScalar1# is [code]#float#, [code]#double#, or
  [code]#half#;
* If [code]#NonScalar1# is [code]#marray#, [code]#NonScalar2# is [code]#marray#
  of [code]#int# with the same number of elements as [code]#NonScalar1#; and
* If [code]#NonScalar1# is [code]#vec# or the [code]#+__swizzle__+# type,
  [code]#NonScalar2# is [code]#vec# or the [code]#+__swizzle__+# type of
  [code]#int32_t# with the same number of elements as [code]#NonScalar1#.

_Returns:_ For each element of [code]#x# and [code]#y#, the value of
[code]#x[i]# raised to the power [code]#y[i]#.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#powr#
[source,role=synopsis,id=api:powr]
----
float powr(float x, float y)                        (1)
double powr(double x, double y)                     (2)
half powr(half x, half y)                           (3)

template<typename NonScalar1, typename NonScalar2>  (4)
/*return-type*/ powr(NonScalar1 x, NonScalar2 y)
----

*Overloads (1) - (3):*

_Preconditions:_ The value of [code]#x# must be greater than or equal to zero.

_Returns:_ The value of [code]#x# raised to the power [code]#y#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzle__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements;
* [code]#NonScalar1# and [code]#NonScalar2# have the same element type; and
* The element type of [code]#NonScalar1# and [code]#NonScalar2# is
  [code]#float#, [code]#double#, or [code]#half#.

_Preconditions:_ Each element of [code]#x# must be greater than or equal to
zero.

_Returns:_ For each element of [code]#x# and [code]#y#, the value of
[code]#x[i]# raised to the power [code]#y[i]#.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#remainder#
[source,role=synopsis,id=api:remainder]
----
float remainder(float x, float y)                      (1)
double remainder(double x, double y)                   (2)
half remainder(half x, half y)                         (3)

template<typename NonScalar1, typename NonScalar2>     (4)
/*return-type*/ remainder(NonScalar1 x, NonScalar2 y)
----

*Overloads (1) - (3):*

_Returns:_ The value [code]#r# such that [code]#r = x - n*y#, where [code]#n# is
the integer nearest the exact value of [code]#x/y#.
If there are two integers closest to [code]#x/y#, [code]#n# shall be the even
one.
If [code]#r# is zero, it is given the same sign as [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzle__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements;
* [code]#NonScalar1# and [code]#NonScalar2# have the same element type; and
* The element type of [code]#NonScalar1# and [code]#NonScalar2# is
  [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x# and [code]#y#, the value [code]#r# such
that [code]#r = x[i] - n*y[i]#, where [code]#n# is the integer nearest the exact
value of [code]#x[i]/y[i]#.
If there are two integers closest to [code]#x[i]/y[i]#, [code]#n# shall be the
even one.
If [code]#r# is zero, it is given the same sign as [code]#x[i]#.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#remquo#
[source,role=synopsis,id=api:remquo]
----
template<typename Ptr>                                            (1)
float remquo(float x, float y, Ptr quo)

template<typename Ptr>                                            (2)
double remquo(double x, double y, Ptr quo)

template<typename Ptr>                                            (3)
half remquo(half x, half y, Ptr quo)

template<typename NonScalar1, typename NonScalar2, typename Ptr>  (4)
/*return-type*/ remquo(NonScalar1 x, NonScalar2 y, Ptr quo)
----

*Overloads (1) - (3):*

_Constraints:_ Available only if [code]#Ptr# is one of the following:

* A {cpp} cv-unqualified pointer to [code]#int#; or
* A [code]#multi_ptr# with [code]#ElementType# of [code]#int# and with
  [code]#Space# equal to one of the _writeable address spaces_ as defined above.

_Effects:_ Computes the value [code]#r# such that [code]#r = x - k*y#, where
[code]#k# is the integer nearest the exact value of [code]#x/y#.
If there are two integers closest to [code]#x/y#, [code]#k# shall be the even
one.
If [code]#r# is zero, it is given the same sign as [code]#x#.
This is the same value that is returned by the [api]#remainder# function.
The [code]#remquo# function also calculates the lower seven bits of the integral
quotient [code]#x/y# and gives that value the same sign as [code]#x/y#.
It stores this signed value to the object pointed to by [code]#quo#.

_Returns:_ The value [code]#r# defined above.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzle__+# type;
* [code]#Ptr# is one of the following:
** (If [code]#NonScalar1# is [code]#marray#): A {cpp} cv-unqualified pointer to
   [code]#marray# of [code]#int# with the same number of elements as
   [code]#NonScalar1#; or
** (If [code]#NonScalar1# is [code]#vec# or the [code]#+__swizzle__+# type): A
   {cpp} cv-unqualified pointer to [code]#vec# of [code]#int32_t# with the same
   number of elements as [code]#NonScalar1#; or
** (If [code]#NonScalar1# is [code]#marray#): A [code]#multi_ptr# whose
   [code]#Space# is equal to one of the _writeable address spaces_ as defined
   above and whose [code]#ElementType# is [code]#marray# of [code]#int# with the
   same number of elements as [code]#NonScalar1#; or
** (If [code]#NonScalar1# is [code]#vec# or the [code]#+__swizzle__+# type): A
   [code]#multi_ptr# whose [code]#Space# is equal to one of the _writeable
   address spaces_ as defined above and whose [code]#ElementType# is [code]#vec#
   of [code]#int32_t# with the same number of elements as [code]#NonScalar1#.

_Effects:_ Computes the value [code]#r# for each element of [code]#x# and
[code]#y# such that [code]#r = x[i] - k*y[i]#, where [code]#k# is the integer
nearest the exact value of [code]#x[i]/y[i]#.
If there are two integers closest to [code]#x[i]/y[i]#, [code]#k# shall be the
even one.
If [code]#r# is zero, it is given the same sign as [code]#x[i]#.
This is the same value that is returned by the [api]#remainder# function.
The [code]#remquo# function also calculates the lower seven bits of the integral
quotient [code]#x[i]/y[i]# and gives that value the same sign as
[code]#x[i]/y[i]#.
It stores these signed values to the object pointed to by [code]#quo#.

_Returns:_ The values of [code]#r# defined above.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#rint#
[source,role=synopsis,id=api:rint]
----
float rint(float x)                (1)
double rint(double x)              (2)
half rint(half x)                  (3)

template<typename NonScalar>       (4)
/*return-type*/ rint(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The value [code]#x# rounded to an integral value (using round to
nearest even rounding mode) in floating-point format.
Refer to <<opencl12, section 7.1 of the OpenCL 1.2 specification document>> for
a description of the rounding modes.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the value [code]#x[i]# rounded to an
integral value (using round to nearest even rounding mode) in floating-point
format.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#rootn#
[source,role=synopsis,id=api:rootn]
----
float rootn(float x, int y)                         (1)
double rootn(double x, int y)                       (2)
half rootn(half x, int y)                           (3)

template<typename NonScalar1, typename NonScalar2>  (4)
/*return-type*/ rootn(NonScalar1 x, NonScalar2 y)
----

*Overloads (1) - (3):*

_Returns:_ The value of [code]#x# raised to the power [code]#1/y#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar1# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzle__+# type;
* The element type of [code]#NonScalar1# is [code]#float#, [code]#double#, or
  [code]#half#;
* If [code]#NonScalar1# is [code]#marray#, [code]#NonScalar2# is [code]#marray#
  of [code]#int# with the same number of elements as [code]#NonScalar1#; and
* If [code]#NonScalar1# is [code]#vec# or the [code]#+__swizzle__+# type,
  [code]#NonScalar2# is [code]#vec# or the [code]#+__swizzle__+# type of
  [code]#int32_t# with the same number of elements as [code]#NonScalar1#.

_Returns:_ For each element of [code]#x# and [code]#y#, the value of
[code]#x[i]# raised to the power [code]#1/y[i]#.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#round#
[source,role=synopsis,id=api:round]
----
float round(float x)                (1)
double round(double x)              (2)
half round(half x)                  (3)

template<typename NonScalar>        (4)
/*return-type*/ round(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The integral value nearest to [code]#x# rounding halfway cases away
from zero, regardless of the current rounding direction.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the integral value nearest to
[code]#x[i]# rounding halfway cases away from zero, regardless of the current
rounding direction.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#rsqrt#
[source,role=synopsis,id=api:rsqrt]
----
float rsqrt(float x)                (1)
double rsqrt(double x)              (2)
half rsqrt(half x)                  (3)

template<typename NonScalar>        (4)
/*return-type*/ rsqrt(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The reciprocal square root of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the reciprocal square root of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#sin#
[source,role=synopsis,id=api:sin]
----
float sin(float x)                (1)
double sin(double x)              (2)
half sin(half x)                  (3)

template<typename NonScalar>      (4)
/*return-type*/ sin(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The sine of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the sine of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#sincos#
[source,role=synopsis,id=api:sincos]
----
template<typename Ptr>                           (1)
float sincos(float x, Ptr cosval)

template<typename Ptr>                           (2)
double sincos(double x, Ptr cosval)

template<typename Ptr>                           (3)
half sincos(half x, Ptr cosval)

template<typename NonScalar, typename Ptr>       (4)
/*return-type*/ sincos(NonScalar x, Ptr cosval)
----

*Overloads (1) - (3):*

_Constraints:_ Available only if [code]#Ptr# is one of the following:

* A {cpp} cv-unqualified pointer to the same type as [code]#x#; or
* A [code]#multi_ptr# with [code]#ElementType# equal to the same type as
  [code]#x# and with [code]#Space# equal to one of the _writeable address
  spaces_ as defined above.

_Effects:_ Compute the sine and cosine of [code]#x#.
The computed cosine is written to [code]#cosval#.

_Returns:_ The sine of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type with element type [code]#float#, [code]#double#, or [code]#half#;
* [code]#Ptr# is one of the following:
** A {cpp} cv-unqualified pointer to [code]#NonScalar#, unless [code]#NonScalar#
   is the [code]#+__swizzle__+# type, in which case it is a cv-unqualified
   pointer to the corresponding [code]#vec#; or
** A [code]#multi_ptr# where:
*** The [code]#ElementType# is equal to [code]#NonScalar#, unless
    [code]#NonScalar# is the [code]#+__swizzle__+# type, in which case the
    [code]#ElementType# is the corresponding [code]#vec#; and
*** The [code]#Space# is equal to one of the _writeable address spaces_ as
    defined above.

_Effects:_ Compute the sine and cosine of each element of [code]#x#.
The computed cosine values are written to [code]#cosval#.

_Returns:_ The sine of each element of [code]#x#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#sinh#
[source,role=synopsis,id=api:sinh]
----
float sinh(float x)                (1)
double sinh(double x)              (2)
half sinh(half x)                  (3)

template<typename NonScalar>       (4)
/*return-type*/ sinh(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The hyperbolic sine of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the hyperbolic sine of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#sinpi#
[source,role=synopsis,id=api:sinpi]
----
float sinpi(float x)                (1)
double sinpi(double x)              (2)
half sinpi(half x)                  (3)

template<typename NonScalar>        (4)
/*return-type*/ sinpi(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The value [code]#sin({pi} * x)#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the value [code]#sin({pi} * x[i])#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#sqrt#
[source,role=synopsis,id=api:sqrt]
----
float sqrt(float x)                (1)
double sqrt(double x)              (2)
half sqrt(half x)                  (3)

template<typename NonScalar>       (4)
/*return-type*/ sqrt(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The square root of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the square root of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#tan#
[source,role=synopsis,id=api:tan]
----
float tan(float x)                (1)
double tan(double x)              (2)
half tan(half x)                  (3)

template<typename NonScalar>      (4)
/*return-type*/ tan(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The tangent of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the tangent of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#tanh#
[source,role=synopsis,id=api:tanh]
----
float tanh(float x)                (1)
double tanh(double x)              (2)
half tanh(half x)                  (3)

template<typename NonScalar>       (4)
/*return-type*/ tanh(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The hyperbolic tangent of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the hyperbolic tangent of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#tanpi#
[source,role=synopsis,id=api:tanpi]
----
float tanpi(float x)                (1)
double tanpi(double x)              (2)
half tanpi(half x)                  (3)

template<typename NonScalar>        (4)
/*return-type*/ tanpi(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The value [code]#tan({pi} * x)#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the value [code]#tan({pi} * x[i])#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#tgamma#
[source,role=synopsis,id=api:tgamma]
----
float tgamma(float x)                (1)
double tgamma(double x)              (2)
half tgamma(half x)                  (3)

template<typename NonScalar>         (4)
/*return-type*/ tgamma(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The gamma function of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the gamma function of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#trunc#
[source,role=synopsis,id=api:trunc]
----
float trunc(float x)                (1)
double trunc(double x)              (2)
half trunc(half x)                  (3)

template<typename NonScalar>        (4)
/*return-type*/ trunc(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The value [code]#x# rounded to an integral value using the round to
zero rounding mode.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the value [code]#x[i]# rounded to an
integral value using the round to zero rounding mode.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''


=== Native precision math functions

This section describes the native precision math functions that are available in
the [code]#sycl::native# namespace in both host and device code.

The precision requirements and the set of legal input values for these functions
are defined in the backend specification.
The intent is that these functions might make use of native device functionality
which has better performance than their counterparts in <<sec:math-functions>>,
but they may sacrifice accuracy or limit the set of legal input values.

The descriptions in this section use the type name [code]#+__swizzle__+# to
refer to the classes defined in <<swizzled-vec-class>>.
This type can be any instantiation of the class templates named
[code]#+__writeable_swizzle__+# or [code]#+__const_swizzle__+# in that section,
so long as the instantiation satisfies the constraints listed in the function's
description.

'''

.[apidef]#native::cos#
[source,role=synopsis,id=api:native-cos]
----
float cos(float x)                (1)

template<typename NonScalar>      (2)
/*return-type*/ cos(NonScalar x)
----

*Overload (1):*

_Returns:_ The cosine of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the cosine of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#native::divide#
[source,role=synopsis,id=api:native-divide]
----
float divide(float x, float y)                      (1)

template<typename NonScalar1, typename NonScalar2>  (2)
/*return-type*/ divide(NonScalar1 x, NonScalar2 y)
----

*Overload (1):*

_Returns:_ The value [code]#x / y#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x# and [code]#y#, the value [code]#x[i] /
y[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#native::exp#
[source,role=synopsis,id=api:native-exp]
----
float exp(float x)                (1)

template<typename NonScalar>      (2)
/*return-type*/ exp(NonScalar x)
----

*Overload (1):*

_Returns:_ The base-_e_ exponential of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the base-_e_ exponential of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#native::exp2#
[source,role=synopsis,id=api:native-exp2]
----
float exp2(float x)                (1)

template<typename NonScalar>       (2)
/*return-type*/ exp2(NonScalar x)
----

*Overload (1):*

_Returns:_ The base-2 exponential of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the base-2 exponential of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#native::exp10#
[source,role=synopsis,id=api:native-exp10]
----
float exp10(float x)                (1)

template<typename NonScalar>        (2)
/*return-type*/ exp10(NonScalar x)
----

*Overload (1):*

_Returns:_ The base-10 exponential of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the base-10 exponential of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#native::log#
[source,role=synopsis,id=api:native-log]
----
float log(float x)                (1)

template<typename NonScalar>      (2)
/*return-type*/ log(NonScalar x)
----

*Overload (1):*

_Returns:_ The natural logarithm of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the natural logarithm of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#native::log2#
[source,role=synopsis,id=api:native-log2]
----
float log2(float x)                (1)

template<typename NonScalar>       (2)
/*return-type*/ log2(NonScalar x)
----

*Overload (1):*

_Returns:_ The base 2 logarithm of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the base 2 logarithm of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#native::log10#
[source,role=synopsis,id=api:native-log10]
----
float log10(float x)                (1)

template<typename NonScalar>        (2)
/*return-type*/ log10(NonScalar x)
----

*Overload (1):*

_Returns:_ The base 10 logarithm of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the base 10 logarithm of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#native::powr#
[source,role=synopsis,id=api:native-powr]
----
float powr(float x, float y)                        (1)

template<typename NonScalar1, typename NonScalar2>  (2)
/*return-type*/ powr(NonScalar1 x, NonScalar2 y)
----

*Overload (1):*

_Preconditions:_ The value of [code]#x# must be greater than or equal to zero.

_Returns:_ The value of [code]#x# raised to the power [code]#y#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#.

_Preconditions:_ Each element of [code]#x# must be greater than or equal to
zero.

_Returns:_ For each element of [code]#x# and [code]#y#, the value of
[code]#x[i]# raised to the power [code]#y[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#native::recip#
[source,role=synopsis,id=api:native-recip]
----
float recip(float x)                (1)

template<typename NonScalar>        (2)
/*return-type*/ recip(NonScalar x)
----

*Overload (1):*

_Returns:_ The reciprocal of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the reciprocal of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#native::rsqrt#
[source,role=synopsis,id=api:native-rsqrt]
----
float rsqrt(float x)                (1)

template<typename NonScalar>        (2)
/*return-type*/ rsqrt(NonScalar x)
----

*Overload (1):*

_Returns:_ The reciprocal square root of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the reciprocal square root of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#native::sin#
[source,role=synopsis,id=api:native-sin]
----
float sin(float x)                (1)

template<typename NonScalar>      (2)
/*return-type*/ sin(NonScalar x)
----

*Overload (1):*

_Returns:_ The sine of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the sine of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#native::sqrt#
[source,role=synopsis,id=api:native-sqrt]
----
float sqrt(float x)                (1)

template<typename NonScalar>       (2)
/*return-type*/ sqrt(NonScalar x)
----

*Overload (1):*

_Returns:_ The square root of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the square root of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#native::tan#
[source,role=synopsis,id=api:native-tan]
----
float tan(float x)                (1)

template<typename NonScalar>      (2)
/*return-type*/ tan(NonScalar x)
----

*Overload (1):*

_Returns:_ The tangent of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the tangent of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''


=== Half precision math functions

This section describes the half precision math functions that are available in
the [code]#sycl::half_precision# namespace in both host and device code.

The precision requirements for these functions are defined in the backend
specification.
The intent is that these functions have higher performance than their
counterparts in <<sec:math-functions>>, but they have lower accuracy.

The descriptions in this section use the type name [code]#+__swizzle__+# to
refer to the classes defined in <<swizzled-vec-class>>.
This type can be any instantiation of the class templates named
[code]#+__writeable_swizzle__+# or [code]#+__const_swizzle__+# in that section,
so long as the instantiation satisfies the constraints listed in the function's
description.

'''

.[apidef]#half_precision::cos#
[source,role=synopsis,id=api:half-cos]
----
float cos(float x)                (1)

template<typename NonScalar>      (2)
/*return-type*/ cos(NonScalar x)
----

*Overload (1):*

_Preconditions:_ The value of [code]#x# must be in the range [-2^16^, +2^16^].

_Returns:_ The cosine of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#.

_Preconditions:_ The value of each element of [code]#x# must be in the range
[-2^16^, +2^16^].

_Returns:_ For each element of [code]#x#, the cosine of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#half_precision::divide#
[source,role=synopsis,id=api:half-divide]
----
float divide(float x, float y)                      (1)

template<typename NonScalar1, typename NonScalar2>  (2)
/*return-type*/ divide(NonScalar1 x, NonScalar2 y)
----

*Overload (1):*

_Returns:_ The value [code]#x / y#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x# and [code]#y#, the value [code]#x[i] /
y[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#half_precision::exp#
[source,role=synopsis,id=api:half-exp]
----
float exp(float x)                (1)

template<typename NonScalar>      (2)
/*return-type*/ exp(NonScalar x)
----

*Overload (1):*

_Returns:_ The base-_e_ exponential of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the base-_e_ exponential of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#half_precision::exp2#
[source,role=synopsis,id=api:half-exp2]
----
float exp2(float x)                (1)

template<typename NonScalar>       (2)
/*return-type*/ exp2(NonScalar x)
----

*Overload (1):*

_Returns:_ The base-2 exponential of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the base-2 exponential of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#half_precision::exp10#
[source,role=synopsis,id=api:half-exp10]
----
float exp10(float x)                (1)

template<typename NonScalar>        (2)
/*return-type*/ exp10(NonScalar x)
----

*Overload (1):*

_Returns:_ The base-10 exponential of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the base-10 exponential of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#half_precision::log#
[source,role=synopsis,id=api:half-log]
----
float log(float x)                (1)

template<typename NonScalar>      (2)
/*return-type*/ log(NonScalar x)
----

*Overload (1):*

_Returns:_ The natural logarithm of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the natural logarithm of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#half_precision::log2#
[source,role=synopsis,id=api:half-log2]
----
float log2(float x)                (1)

template<typename NonScalar>       (2)
/*return-type*/ log2(NonScalar x)
----

*Overload (1):*

_Returns:_ The base 2 logarithm of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the base 2 logarithm of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#half_precision::log10#
[source,role=synopsis,id=api:half-log10]
----
float log10(float x)                (1)

template<typename NonScalar>        (2)
/*return-type*/ log10(NonScalar x)
----

*Overload (1):*

_Returns:_ The base 10 logarithm of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the base 10 logarithm of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#half_precision::powr#
[source,role=synopsis,id=api:half-powr]
----
float powr(float x, float y)                        (1)

template<typename NonScalar1, typename NonScalar2>  (2)
/*return-type*/ powr(NonScalar1 x, NonScalar2 y)
----

*Overload (1):*

_Preconditions:_ The value of [code]#x# must be greater than or equal to zero.

_Returns:_ The value of [code]#x# raised to the power [code]#y#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#.

_Preconditions:_ Each element of [code]#x# must be greater than or equal to
zero.

_Returns:_ For each element of [code]#x# and [code]#y#, the value of
[code]#x[i]# raised to the power [code]#y[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#half_precision::recip#
[source,role=synopsis,id=api:half-recip]
----
float recip(float x)                (1)

template<typename NonScalar>        (2)
/*return-type*/ recip(NonScalar x)
----

*Overload (1):*

_Returns:_ The reciprocal of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the reciprocal of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#half_precision::rsqrt#
[source,role=synopsis,id=api:half-rsqrt]
----
float rsqrt(float x)                (1)

template<typename NonScalar>        (2)
/*return-type*/ rsqrt(NonScalar x)
----

*Overload (1):*

_Returns:_ The reciprocal square root of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the reciprocal square root of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#half_precision::sin#
[source,role=synopsis,id=api:half-sin]
----
float sin(float x)                (1)

template<typename NonScalar>      (2)
/*return-type*/ sin(NonScalar x)
----

*Overload (1):*

_Preconditions:_ The value of [code]#x# must be in the range [-2^16^, +2^16^].

_Returns:_ The sine of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#.

_Preconditions:_ The value of each element of [code]#x# must be in the range
[-2^16^, +2^16^].

_Returns:_ For each element of [code]#x#, the sine of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#half_precision::sqrt#
[source,role=synopsis,id=api:half-sqrt]
----
float sqrt(float x)                (1)

template<typename NonScalar>       (2)
/*return-type*/ sqrt(NonScalar x)
----

*Overload (1):*

_Returns:_ The square root of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the square root of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#half_precision::tan#
[source,role=synopsis,id=api:half-tan]
----
float tan(float x)                (1)

template<typename NonScalar>      (2)
/*return-type*/ tan(NonScalar x)
----

*Overload (1):*

_Preconditions:_ The value of [code]#x# must be in the range [-2^16^, +2^16^].

_Returns:_ The tangent of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#.

_Preconditions:_ The value of each element of [code]#x# must be in the range
[-2^16^, +2^16^].

_Returns:_ For each element of [code]#x#, the tangent of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''


[[sec:integer-functions]]
=== Integer functions

This section describes the integer math functions that are available in the
[code]#sycl# namespace in both host and device code.

The descriptions in this section use the type name [code]#+__swizzle__+# to
refer to the classes defined in <<swizzled-vec-class>>.
This type can be any instantiation of the class templates named
[code]#+__writeable_swizzle__+# or [code]#+__const_swizzle__+# in that section,
so long as the instantiation satisfies the constraints listed in the function's
description.

The function descriptions in this section also use the term _generic integer
type_ to represent the following types:

* [code]#char#
* [code]#signed char#
* [code]#short#
* [code]#int#
* [code]#long#
* [code]#long long#
* [code]#unsigned char#
* [code]#unsigned short#
* [code]#unsigned int#
* [code]#unsigned long#
* [code]#unsigned long long#
* [code]#marray<char, N>#
* [code]#marray<signed char, N>#
* [code]#marray<short, N>#
* [code]#marray<int, N>#
* [code]#marray<long, N>#
* [code]#marray<long long, N>#
* [code]#marray<unsigned char, N>#
* [code]#marray<unsigned short, N>#
* [code]#marray<unsigned int, N>#
* [code]#marray<unsigned long, N>#
* [code]#marray<unsigned long long, N>#
* [code]#vec<int8_t, N>#
* [code]#vec<int16_t, N>#
* [code]#vec<int32_t, N>#
* [code]#vec<int64_t, N>#
* [code]#vec<uint8_t, N>#
* [code]#vec<uint16_t, N>#
* [code]#vec<uint32_t, N>#
* [code]#vec<uint64_t, N>#
* [code]#+__swizzle__+# that is convertible to [code]#vec<int8_t, N>#
* [code]#+__swizzle__+# that is convertible to [code]#vec<int16_t, N>#
* [code]#+__swizzle__+# that is convertible to [code]#vec<int32_t, N>#
* [code]#+__swizzle__+# that is convertible to [code]#vec<int64_t, N>#
* [code]#+__swizzle__+# that is convertible to [code]#vec<uint8_t, N>#
* [code]#+__swizzle__+# that is convertible to [code]#vec<uint16_t, N>#
* [code]#+__swizzle__+# that is convertible to [code]#vec<uint32_t, N>#
* [code]#+__swizzle__+# that is convertible to [code]#vec<uint64_t, N>#

'''

.[apidef]#abs#
[source,role=synopsis,id=api:abs]
----
template<typename GenInt>
/*return-type*/ abs(GenInt x)
----

_Constraints:_ Available only if [code]#GenInt# is a _generic integer type_ as
defined above.

_Returns:_ When the input is a scalar, returns |x|.
Otherwise, returns |x[i]| for each element of [code]#x#.
The behavior is undefined if the result cannot be represented by the return
type.

The return type is [code]#GenInt# unless [code]#GenInt# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#abs_diff#
[source,role=synopsis,id=api:abs_diff]
----
template<typename GenInt1, typename GenInt2>
/*return-type*/ abs_diff(GenInt1 x, GenInt2 y)
----

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenInt1# is a _generic integer type_ as defined above;
* If [code]#GenInt1# is not [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#GenInt2# must be the same as [code]#GenInt1#; and
* If [code]#GenInt1# is [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#GenInt2# must also be [code]#vec# or the [code]#+__swizzle__+# type,
  and both must have the same element type and the same number of elements.

_Returns:_ When the inputs are scalars, returns |x - y|.
Otherwise, returns |x[i] - y[i]| for each element of [code]#x# and [code]#y#.
The subtraction is done without modulo overflow.
The behavior is undefined if the result cannot be represented by the return
type.

The return type is [code]#GenInt1# unless [code]#GenInt1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#add_sat#
[source,role=synopsis,id=api:add_sat]
----
template<typename GenInt1, typename GenInt2>
/*return-type*/ add_sat(GenInt1 x, GenInt2 y)
----

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenInt1# is a _generic integer type_ as defined above;
* If [code]#GenInt1# is not [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#GenInt2# must be the same as [code]#GenInt1#; and
* If [code]#GenInt1# is [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#GenInt2# must also be [code]#vec# or the [code]#+__swizzle__+# type,
  and both must have the same element type and the same number of elements.

_Returns:_ When the inputs are scalars, returns [code]#x + y#.
Otherwise, returns [code]#x[i] + y[i]# for each element of [code]#x# and
[code]#y#.
The addition operation saturates the result.

The return type is [code]#GenInt1# unless [code]#GenInt1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#hadd#
[source,role=synopsis,id=api:hadd]
----
template<typename GenInt1, typename GenInt2>
/*return-type*/ hadd(GenInt1 x, GenInt2 y)
----

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenInt1# is a _generic integer type_ as defined above;
* If [code]#GenInt1# is not [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#GenInt2# must be the same as [code]#GenInt1#; and
* If [code]#GenInt1# is [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#GenInt2# must also be [code]#vec# or the [code]#+__swizzle__+# type,
  and both must have the same element type and the same number of elements.

_Returns:_ When the inputs are scalars, returns [code]#(x + y) >> 1#.
Otherwise, returns [code]#(x[i] + y[i]) >> 1# for each element of [code]#x# and
[code]#y#.
The intermediate sum does not modulo overflow.

The return type is [code]#GenInt1# unless [code]#GenInt1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#rhadd#
[source,role=synopsis,id=api:rhadd]
----
template<typename GenInt1, typename GenInt2>
/*return-type*/ rhadd(GenInt1 x, GenInt2 y)
----

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenInt1# is a _generic integer type_ as defined above;
* If [code]#GenInt1# is not [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#GenInt2# must be the same as [code]#GenInt1#; and
* If [code]#GenInt1# is [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#GenInt2# must also be [code]#vec# or the [code]#+__swizzle__+# type,
  and both must have the same element type and the same number of elements.

_Returns:_ When the inputs are scalars, returns [code]#(x + y + 1) >> 1#.
Otherwise, returns [code]#(x[i] + y[i] + 1) >> 1# for each element of [code]#x#
and [code]#y#.
The intermediate sum does not modulo overflow.

The return type is [code]#GenInt1# unless [code]#GenInt1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apititle]#clamp#
[source,role=synopsis,id=api:clamp-int]
----
template<typename GenInt1, typename GenInt2, typename GenInt3>    (1)
/*return-type*/ clamp(GenInt1 x, GenInt2 minval, GenInt3 maxval)

template<typename NonScalar>                                      (2)
/*return-type*/ clamp(NonScalar x, NonScalar::value_type minval,
                      NonScalar::value_type maxval)
----

*Overload (1):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenInt1# is a _generic integer type_ as defined above;
* If [code]#GenInt1# is not [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#GenInt2# and [code]#GenInt3# must be the same as [code]#GenInt1#; and
* If [code]#GenInt1# is [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#GenInt2# and [code]#GenInt3# must also be [code]#vec# or the
  [code]#+__swizzle__+# type, and all three must have the same element type and
  the same number of elements.

_Preconditions:_ If the inputs are scalars, the value of [code]#minval# must be
less than or equal to the value of [code]#maxval#.
If the inputs are not scalars, each [code]#minval# must be less than or equal to
the corresponding [code]#maxval# value.

_Returns:_ When the inputs are scalars, returns [code]#min(max(x, minval),
maxval)#.
Otherwise, returns [code]#min(max(x[i], minval[i]), maxval[i])# for each element
of [code]#x#, [code]#minval#, and [code]#maxval#.

The return type is [code]#GenInt1# unless [code]#GenInt1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

*Overload (2):*

_Constraints:_ Available only if [code]#NonScalar# is [code]#marray#,
[code]#vec#, or the [code]#+__swizzle__+# type and is a _generic integer type_
as defined above.

_Preconditions:_ The value of [code]#minval# must be less than or equal to the
value of [code]#maxval#.

_Returns:_ [code]#min(max(x[i], minval), maxval)# for each element of [code]#x#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#clz#
[source,role=synopsis,id=api:clz]
----
template<typename GenInt>
/*return-type*/ clz(GenInt x)
----

_Constraints:_ Available only if [code]#GenInt# is a _generic integer type_ as
defined above.

_Returns:_ When the input is a scalar, returns the number of leading 0-bits in
[code]#x#, starting at the most significant bit position.
Otherwise, returns the number of leading 0-bits in each element of [code]#x#.
When a value is 0, the computed count is the size in bits of that value.

The return type is [code]#GenInt# unless [code]#GenInt# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#ctz#
[source,role=synopsis,id=api:ctz]
----
template<typename GenInt>
/*return-type*/ ctz(GenInt x)
----

_Constraints:_ Available only if [code]#GenInt# is a _generic integer type_ as
defined above.

_Returns:_ When the input is a scalar, returns the number of trailing 0-bits in
[code]#x#.
Otherwise, returns the number of trailing 0-bits in each element of [code]#x#.
When a value is 0, the computed count is the size in bits of that value.

The return type is [code]#GenInt# unless [code]#GenInt# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#mad_hi#
[source,role=synopsis,id=api:mad_hi]
----
template<typename GenInt1, typename GenInt2, typename GenInt3>
/*return-type*/ mad_hi(GenInt1 a, GenInt2 b, GenInt3 c)
----

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenInt1# is a _generic integer type_ as defined above;
* If [code]#GenInt1# is not [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#GenInt2# and [code]#GenInt3# must be the same as [code]#GenInt1#; and
* If [code]#GenInt1# is [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#GenInt2# and [code]#GenInt3# must also be [code]#vec# or the
  [code]#+__swizzle__+# type, and all three must have the same element type and
  the same number of elements.

_Returns:_ When the inputs are scalars, returns [code]#mul_hi(a, b)+c#.
Otherwise, returns [code]#mul_hi(a[i], b[i])+c[i]# for each element of
[code]#a#, [code]#b#, and [code]#c#.

The return type is [code]#GenInt1# unless [code]#GenInt1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#mad_sat#
[source,role=synopsis,id=api:mad_sat]
----
template<typename GenInt1, typename GenInt2, typename GenInt3>
/*return-type*/ mad_sat(GenInt1 a, GenInt2 b, GenInt3 c)
----

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenInt1# is a _generic integer type_ as defined above;
* If [code]#GenInt1# is not [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#GenInt2# and [code]#GenInt3# must be the same as [code]#GenInt1#; and
* If [code]#GenInt1# is [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#GenInt2# and [code]#GenInt3# must also be [code]#vec# or the
  [code]#+__swizzle__+# type, and all three must have the same element type and
  the same number of elements.

_Returns:_ When the inputs are scalars, returns [code]#a * b + c#.
Otherwise, returns [code]#a[i] * b[i] + c[i]# for each element of [code]#a#,
[code]#b#, and [code]#c#.
The operation saturates the result.

The return type is [code]#GenInt1# unless [code]#GenInt1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apititle]#max#
[source,role=synopsis,id=api:max-int]
----
template<typename GenInt1, typename GenInt2>               (1)
/*return-type*/ max(GenInt1 x, GenInt2 y)

template<typename NonScalar>                               (2)
/*return-type*/ max(NonScalar x, NonScalar::value_type y)
----

*Overload (1):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenInt1# is a _generic integer type_ as defined above;
* If [code]#GenInt1# is not [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#GenInt2# must be the same as [code]#GenInt1#; and
* If [code]#GenInt1# is [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#GenInt2# must also be [code]#vec# or the [code]#+__swizzle__+# type,
  and both must have the same element type and the same number of elements.

_Returns:_ When the inputs are scalars, returns [code]#y# if [code]#x < y#
otherwise [code]#x#.
When the inputs are not scalars, returns [code]#y[i]# if [code]#x[i] < y[i]#
otherwise [code]#x[i]# for each element of [code]#x# and [code]#y#.

The return type is [code]#GenInt1# unless [code]#GenInt1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

*Overload (2):*

_Constraints:_ Available only if [code]#NonScalar# is [code]#marray#,
[code]#vec#, or the [code]#+__swizzle__+# type and is a _generic integer type_
as defined above.

_Returns:_ [code]#y# if [code]#x[i] < y# otherwise [code]#x[i]# for each element
of [code]#x#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apititle]#min#
[source,role=synopsis,id=api:min-int]
----
template<typename GenInt1, typename GenInt2>               (1)
/*return-type*/ min(GenInt1 x, GenInt2 y)

template<typename NonScalar>                               (2)
/*return-type*/ min(NonScalar x, NonScalar::value_type y)
----

*Overload (1):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenInt1# is a _generic integer type_ as defined above;
* If [code]#GenInt1# is not [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#GenInt2# must be the same as [code]#GenInt1#; and
* If [code]#GenInt1# is [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#GenInt2# must also be [code]#vec# or the [code]#+__swizzle__+# type,
  and both must have the same element type and the same number of elements.

_Returns:_ When the inputs are scalars, returns [code]#y# if [code]#y < x#
otherwise [code]#x#.
When the inputs are not scalars, returns [code]#y[i]# if [code]#y[i] < x[i]#
otherwise [code]#x[i]# for each element of [code]#x# and [code]#y#.

The return type is [code]#GenInt1# unless [code]#GenInt1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

*Overload (2):*

_Constraints:_ Available only if [code]#NonScalar# is [code]#marray#,
[code]#vec#, or the [code]#+__swizzle__+# type and is a _generic integer type_
as defined above.

_Returns:_ [code]#y# if [code]#y < x[i]# otherwise [code]#x[i]# for each element
of [code]#x#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#mul_hi#
[source,role=synopsis,id=api:mul_hi]
----
template<typename GenInt1, typename GenInt2>
/*return-type*/ mul_hi(GenInt1 x, GenInt2 y)
----

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenInt1# is a _generic integer type_ as defined above;
* If [code]#GenInt1# is not [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#GenInt2# must be the same as [code]#GenInt1#; and
* If [code]#GenInt1# is [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#GenInt2# must also be [code]#vec# or the [code]#+__swizzle__+# type,
  and both must have the same element type and the same number of elements.

_Effects:_ Computes [code]#x * y# and returns the high half of the product of
[code]#x# and [code]#y#.

_Returns:_ When the inputs are scalars, returns the high half of the product of
[code]#x * y#.
Otherwise, returns the high half of the product of [code]#x[i] * y[i]# for each
element of [code]#x# and [code]#y#.

The return type is [code]#GenInt1# unless [code]#GenInt1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#rotate#
[source,role=synopsis,id=api:rotate]
----
template<typename GenInt1, typename GenInt2>
/*return-type*/ rotate(GenInt1 v, GenInt2 count)
----

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenInt1# is a _generic integer type_ as defined above;
* If [code]#GenInt1# is not [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#GenInt2# must be the same as [code]#GenInt1#; and
* If [code]#GenInt1# is [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#GenInt2# must also be [code]#vec# or the [code]#+__swizzle__+# type,
  and both must have the same element type and the same number of elements.

_Effects:_ For each element in [code]#v#, the bits are shifted left by the
number of bits given by the corresponding element in [code]#count# (subject to
usual shift modulo rules described in the OpenCL 1.2 specification <<opencl12,
section 6.3>>).
Bits shifted off the left side of the element are shifted back in from the
right.

_Returns:_ When the inputs are scalars, the result of rotating [code]#v# by
[code]#count# as described above.
Otherwise, the result of rotating [code]#v[i]# by [code]#count[i]# for each
element of [code]#v# and [code]#count#.

The return type is [code]#GenInt1# unless [code]#GenInt1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#sub_sat#
[source,role=synopsis,id=api:sub_sat]
----
template<typename GenInt1, typename GenInt2>
/*return-type*/ sub_sat(GenInt1 x, GenInt2 y)
----

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenInt1# is a _generic integer type_ as defined above;
* If [code]#GenInt1# is not [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#GenInt2# must be the same as [code]#GenInt1#; and
* If [code]#GenInt1# is [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#GenInt2# must also be [code]#vec# or the [code]#+__swizzle__+# type,
  and both must have the same element type and the same number of elements.

_Returns:_ When the inputs are scalars, returns [code]#x - y#.
Otherwise, returns [code]#x[i] - y[i]# for each element of [code]#x# and
[code]#y#.
The subtraction operation saturates the result.

The return type is [code]#GenInt1# unless [code]#GenInt1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apititle]#upsample#
[source,role=synopsis,id=api:upsample-uint16]
----
template<typename UInt8Bit1, typename UInt8Bit2>
/*return-type*/ upsample(UInt8Bit1 hi, UInt8Bit2 lo)
----

_Constraints:_ Available only if one of the following conditions is met:

* [code]#UInt8Bit1# and [code]#UInt8Bit2# are both [code]#uint8_t#;
* [code]#UInt8Bit1# and [code]#UInt8Bit2# are both [code]#marray# with element
  type [code]#uint8_t# and the same number of elements; or
* [code]#UInt8Bit1# and [code]#UInt8Bit2# are any combination of [code]#vec# or
  the [code]#+__swizzle__+# type with element type [code]#uint8_t# and the same
  number of elements.

_Returns:_ When the inputs are scalars, returns [code]#((uint16_t)hi << 8) |
lo#.
Otherwise, returns [code]#((uint16_t)hi[i] << 8) | lo[i]# for each element of
[code]#hi# and [code]#lo#.

The return type is [code]#uint16_t# when the inputs are scalar.
When the inputs are [code]#marray#, the return type is [code]#marray# with
element type [code]#uint16_t# and the same number of elements as the inputs.
Otherwise, the return type is [code]#vec# with element type [code]#uint16_t# and
the same number of elements as the inputs.

'''

.[apititle]#upsample#
[source,role=synopsis,id=api:upsample,id=api:upsample-int16]
----
template<typename Int8Bit, typename UInt8Bit>
/*return-type*/ upsample(Int8Bit hi, UInt8Bit lo)
----

_Constraints:_ Available only if one of the following conditions is met:

* [code]#Int8Bit# is [code]#int8_t# and [code]#UInt8Bit# is [code]#uint8_t#;
* [code]#Int8Bit# is [code]#marray# with element type [code]#int8_t# and
  [code]#UInt8Bit# is [code]#marray# with element type [code]#uint8_t# and both
  have the same number of elements; or
* [code]#Int8Bit# is [code]#vec# or the [code]#+__swizzle__+# type with element
  type [code]#int8_t# and [code]#UInt8Bit# is [code]#vec# or the
  [code]#+__swizzle__+# type with element type [code]#uint8_t# and both have the
  same number of elements.

_Returns:_ When the inputs are scalars, returns [code]#((int16_t)hi << 8) | lo#.
Otherwise, returns [code]#((int16_t)hi[i] << 8) | lo[i]# for each element of
[code]#hi# and [code]#lo#.

The return type is [code]#int16_t# when the inputs are scalar.
When the inputs are [code]#marray#, the return type is [code]#marray# with
element type [code]#int16_t# and the same number of elements as the inputs.
Otherwise, the return type is [code]#vec# with element type [code]#int16_t# and
the same number of elements as the inputs.

'''

.[apititle]#upsample#
[source,role=synopsis,id=api:upsample-uint32]
----
template<typename UInt16Bit1, typename UInt16Bit2>
/*return-type*/ upsample(UInt16Bit1 hi, UInt16Bit2 lo)
----

_Constraints:_ Available only if one of the following conditions is met:

* [code]#UInt16Bit1# and [code]#UInt16Bit2# are both [code]#uint16_t#;
* [code]#UInt16Bit1# and [code]#UInt16Bit2# are both [code]#marray# with element
  type [code]#uint16_t# and the same number of elements; or
* [code]#UInt16Bit1# and [code]#UInt16Bit2# are any combination of [code]#vec#
  or the [code]#+__swizzle__+# type with element type [code]#uint16_t# and the
  same number of elements.

_Returns:_ When the inputs are scalars, returns [code]#((uint32_t)hi << 16) |
lo#.
Otherwise, returns [code]#((uint32_t)hi[i] << 16) | lo[i]# for each element of
[code]#hi# and [code]#lo#.

The return type is [code]#uint32_t# when the inputs are scalar.
When the inputs are [code]#marray#, the return type is [code]#marray# with
element type [code]#uint32_t# and the same number of elements as the inputs.
Otherwise, the return type is [code]#vec# with element type [code]#uint32_t# and
the same number of elements as the inputs.

'''

.[apititle]#upsample#
[source,role=synopsis,id=api:upsample-int32]
----
template<typename Int16Bit, typename UInt16Bit>
/*return-type*/ upsample(Int16Bit hi, UInt16Bit lo)
----

_Constraints:_ Available only if one of the following conditions is met:

* [code]#Int16Bit# is [code]#int16_t# and [code]#UInt16Bit# is [code]#uint16_t#;
* [code]#Int16Bit# is [code]#marray# with element type [code]#int16_t# and
  [code]#UInt16Bit# is [code]#marray# with element type [code]#uint16_t# and
  both have the same number of elements; or
* [code]#Int16Bit# is [code]#vec# or the [code]#+__swizzle__+# type with element
  type [code]#int16_t# and [code]#UInt16Bit# is [code]#vec# or the
  [code]#+__swizzle__+# type with element type [code]#uint16_t# and both have
  the same number of elements.

_Returns:_ When the inputs are scalars, returns [code]#((int32_t)hi << 16) |
lo#.
Otherwise, returns [code]#((int32_t)hi[i] << 16) | lo[i]# for each element of
[code]#hi# and [code]#lo#.

The return type is [code]#int32_t# when the inputs are scalar.
When the inputs are [code]#marray#, the return type is [code]#marray# with
element type [code]#int32_t# and the same number of elements as the inputs.
Otherwise, the return type is [code]#vec# with element type [code]#int32_t# and
the same number of elements as the inputs.

'''

.[apititle]#upsample#
[source,role=synopsis,id=api:upsample-uint64]
----
template<typename UInt32Bit1, typename UInt32Bit2>
/*return-type*/ upsample(UInt32Bit1 hi, UInt32Bit2 lo)
----

_Constraints:_ Available only if one of the following conditions is met:

* [code]#UInt32Bit1# and [code]#UInt32Bit2# are both [code]#uint32_t#;
* [code]#UInt32Bit1# and [code]#UInt32Bit2# are both [code]#marray# with element
  type [code]#uint32_t# and the same number of elements; or
* [code]#UInt32Bit1# and [code]#UInt32Bit2# are any combination of [code]#vec#
  or the [code]#+__swizzle__+# type with element type [code]#uint32_t# and the
  same number of elements.

_Returns:_ When the inputs are scalars, returns [code]#((uint64_t)hi << 32) |
lo#.
Otherwise, returns [code]#((uint64_t)hi[i] << 32) | lo[i]# for each element of
[code]#hi# and [code]#lo#.

The return type is [code]#uint64_t# when the inputs are scalar.
When the inputs are [code]#marray#, the return type is [code]#marray# with
element type [code]#uint64_t# and the same number of elements as the inputs.
Otherwise, the return type is [code]#vec# with element type [code]#uint64_t# and
the same number of elements as the inputs.

'''

.[apititle]#upsample#
[source,role=synopsis,id=api:upsample-int64]
----
template<typename Int32Bit, typename UInt32Bit>
/*return-type*/ upsample(Int32Bit hi, UInt32Bit lo)
----

_Constraints:_ Available only if one of the following conditions is met:

* [code]#Int32Bit# is [code]#int32_t# and [code]#UInt32Bit# is [code]#uint32_t#;
* [code]#Int32Bit# is [code]#marray# with element type [code]#int32_t# and
  [code]#UInt32Bit# is [code]#marray# with element type [code]#uint32_t# and
  both have the same number of elements; or
* [code]#Int32Bit# is [code]#vec# or the [code]#+__swizzle__+# type with element
  type [code]#int32_t# and [code]#UInt32Bit# is [code]#vec# or the
  [code]#+__swizzle__+# type with element type [code]#uint32_t# and both have
  the same number of elements.

_Returns:_ When the inputs are scalars, returns [code]#((int64_t)hi << 32) |
lo#.
Otherwise, returns [code]#((int64_t)hi[i] << 32) | lo[i]# for each element of
[code]#hi# and [code]#lo#.

The return type is [code]#int64_t# when the inputs are scalar.
When the inputs are [code]#marray#, the return type is [code]#marray# with
element type [code]#int64_t# and the same number of elements as the inputs.
Otherwise, the return type is [code]#vec# with element type [code]#int64_t# and
the same number of elements as the inputs.

'''

.[apidef]#popcount#
[source,role=synopsis,id=api:popcount]
----
template<typename GenInt>
/*return-type*/ popcount(GenInt x)
----

_Constraints:_ Available only if [code]#GenInt# is a _generic integer type_ as
defined above.

_Returns:_ When the input is a scalar, returns the number of non-zero bits in
[code]#x#.
Otherwise, returns the number of non-zero bits in [code]#x[i]# for each element
of [code]#x#.

The return type is [code]#GenInt# unless [code]#GenInt# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#mad24#
[source,role=synopsis,id=api:mad24]
----
template<typename Int32Bit1, typename Int32Bit2, typename Int32Bit3>
/*return-type*/ mad24(Int32Bit1 x, Int32Bit2 y, Int32Bit3 z)
----

_Constraints:_ Available only if all of the following conditions are met:

* [code]#Int32Bit1# is one of the following types:
** [code]#int32_t#
** [code]#uint32_t#
** [code]#marray<int32_t, N>#
** [code]#marray<uint32_t, N>#
** [code]#vec<int32_t, N>#
** [code]#vec<uint32_t, N>#
** [code]#+__swizzle__+# that is convertible to [code]#vec<int32_t, N>#
** [code]#+__swizzle__+# that is convertible to [code]#vec<uint32_t, N>#
* If [code]#Int32Bit1# is not [code]#vec# or the [code]#+__swizzle__+# type,
  then [code]#Int32Bit2# and [code]#Int32Bit# must be the same as
  [code]#Int32Bit1#; and
* If [code]#Int32Bit1# is [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#Int32Bit2# and [code]#Int32Bit3# must also be [code]#vec# or the
  [code]#+__swizzle__+# type, and all three must have the same element type and
  the same number of elements.

_Preconditions:_ If the inputs are signed scalars, the values of [code]#x# and
[code]#y# must be in the range [-2^23^, 2^23^-1].
If the inputs are unsigned scalars, the values of [code]#x# and [code]#y# must
be in the range [0, 2^24^-1].
If the inputs are not scalars, each element of [code]#x# and [code]#y# must be
in these ranges.

_Returns:_ When the inputs are scalars, returns [code]#x * y + z#.
Otherwise, returns [code]#x[i] * y[i] + z[i]# for each element of [code]#x#,
[code]#y#, and [code]#z#.

The return type is [code]#Int32Bit1# unless [code]#Int32Bit1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#mul24#
[source,role=synopsis,id=api:mul24]
----
template<typename Int32Bit1, typename Int32Bit2>
/*return-type*/ mul24(Int32Bit1 x, Int32Bit2 y)
----

_Constraints:_ Available only if all of the following conditions are met:

* [code]#Int32Bit1# is one of the following types:
** [code]#int32_t#
** [code]#uint32_t#
** [code]#marray<int32_t, N>#
** [code]#marray<uint32_t, N>#
** [code]#vec<int32_t, N>#
** [code]#vec<uint32_t, N>#
** [code]#+__swizzle__+# that is convertible to [code]#vec<int32_t, N>#
** [code]#+__swizzle__+# that is convertible to [code]#vec<uint32_t, N>#
* If [code]#Int32Bit1# is not [code]#vec# or the [code]#+__swizzle__+# type,
  then [code]#Int32Bit2# must be the same as [code]#Int32Bit1#; and
* If [code]#Int32Bit1# is [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#Int32Bit2# must also be [code]#vec# or the [code]#+__swizzle__+# type,
  and both must have the same element type and the same number of elements.

_Preconditions:_ If the inputs are signed scalars, the values of [code]#x# and
[code]#y# must be in the range [-2^23^, 2^23^-1].
If the inputs are unsigned scalars, the values of [code]#x# and [code]#y# must
be in the range [0, 2^24^-1].
If the inputs are not scalars, each element of [code]#x# and [code]#y# must be
in these ranges.

_Returns:_ When the inputs are scalars, returns [code]#x * y#.
Otherwise, returns [code]#x[i] * y[i]# for each element of [code]#x# and
[code]#y#.

The return type is [code]#Int32Bit1# unless [code]#Int32Bit1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''


=== Common functions

This section describes the common functions that are available in the
[code]#sycl# namespace in both host and device code.

The descriptions in this section use the type name [code]#+__swizzle__+# to
refer to the classes defined in <<swizzled-vec-class>>.
This type can be any instantiation of the class templates named
[code]#+__writeable_swizzle__+# or [code]#+__const_swizzle__+# in that section,
so long as the instantiation satisfies the constraints listed in the function's
description.

The function descriptions in this section also use the term _generic floating
point type_ to represent the following types:

* [code]#float#
* [code]#double#
* [code]#half#
* [code]#marray<float, N>#
* [code]#marray<double, N>#
* [code]#marray<half, N>#
* [code]#vec<float, N>#
* [code]#vec<double, N>#
* [code]#vec<half, N>#
* [code]#+__swizzle__+# that is convertible to [code]#vec<float, N>#
* [code]#+__swizzle__+# that is convertible to [code]#vec<double, N>#
* [code]#+__swizzle__+# that is convertible to [code]#vec<half, N>#

'''

.[apititle]#clamp#
[source,role=synopsis,id=api:clamp-fp]
----
template<typename GenFloat1, typename GenFloat2, typename GenFloat3>    (1)
/*return-type*/ clamp(GenFloat1 x, GenFloat2 minval, GenFloat3 maxval)

template<typename NonScalar>                                            (2)
/*return-type*/ clamp(NonScalar x, NonScalar::value_type minval,
                      NonScalar::value_type maxval)
----

*Overload (1):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenFloat1# is a _generic floating point type_ as defined above;
* If [code]#GenFloat1# is not [code]#vec# or the [code]#+__swizzle__+# type,
  then [code]#GenFloat2# and [code]#GenFloat3# must be the same as
  [code]#GenFloat1#; and
* If [code]#GenFloat1# is [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#GenFloat2# and [code]#GenFloat3# must also be [code]#vec# or the
  [code]#+__swizzle__+# type, and all three must have the same element type and
  the same number of elements.

_Preconditions:_ If the inputs are scalars, the value of [code]#minval# must be
less than or equal to the value of [code]#maxval#.
If the inputs are not scalars, each element of [code]#minval# must be less than
or equal to the corresponding element of [code]#maxval#.

_Returns:_ When the inputs are scalars, returns [code]#fmin(fmax(x, minval),
maxval)#.
Otherwise, returns [code]#fmin(fmax(x[i], minval[i]), maxval[i])# for each
element of [code]#x#, [code]#minval#, and [code]#maxval#.

The return type is [code]#GenFloat1# unless [code]#GenFloat1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

*Overload (2):*

_Constraints:_ Available only if [code]#NonScalar# is [code]#marray#,
[code]#vec#, or the [code]#+__swizzle__+# type and is a _generic floating point
type_ as defined above.

_Preconditions:_ The value of [code]#minval# must be less than or equal to the
value of [code]#maxval#.

_Returns:_ [code]#fmin(fmax(x[i], minval), maxval)# for each element of
[code]#x#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#degrees#
[source,role=synopsis,id=api:degrees]
----
template<typename GenFloat>
/*return-type*/ degrees(GenFloat radians)
----

_Constraints:_ Available only if [code]#GenFloat# is a _generic floating point
type_ as defined above.

_Effects:_ Converts radians to degrees.

_Returns:_ When the inputs are scalars, returns [code]#(180 / {pi}) * radians#.
Otherwise, returns [code]#(180 / {pi}) * radians[i]# for each element of
[code]#radians#.

The return type is [code]#GenFloat# unless [code]#GenFloat# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apititle]#max#
[source,role=synopsis,id=api:max-fp]
----
template<typename GenFloat1, typename GenFloat2>           (1)
/*return-type*/ max(GenFloat1 x, GenFloat2 y)

template<typename NonScalar>                               (2)
/*return-type*/ max(NonScalar x, NonScalar::value_type y)
----

*Overload (1):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenFloat1# is a _generic floating point type_ as defined above;
* If [code]#GenFloat1# is not [code]#vec# or the [code]#+__swizzle__+# type,
  then [code]#GenFloat2# must be the same as [code]#GenFloat1#; and
* If [code]#GenFloat1# is [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#GenFloat2# must also be [code]#vec# or the [code]#+__swizzle__+# type,
  and both must have the same element type and the same number of elements.

_Preconditions:_ When the inputs are scalars, [code]#x# and [code]#y# must not
be infinite or NaN.
When the inputs are not scalars, no element of [code]#x# or [code]#y# may be
infinite or NaN.

_Returns:_ When the inputs are scalars, returns [code]#y# if [code]#x < y#
otherwise [code]#x#.
When the inputs are not scalars, returns [code]#y[i]# if [code]#x[i] < y[i]#
otherwise [code]#x[i]# for each element of [code]#x# and [code]#y#.

The return type is [code]#GenFloat1# unless [code]#GenFloat1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

*Overload (2):*

_Constraints:_ Available only if [code]#NonScalar# is [code]#marray#,
[code]#vec#, or the [code]#+__swizzle__+# type and is a _generic floating point
type_ as defined above.

_Preconditions:_ No element of [code]#x# may be infinite or NaN.
The value of [code]#y# must not be infinite or NaN.

_Returns:_ [code]#y# if [code]#x[i] < y# otherwise [code]#x[i]# for each element
of [code]#x#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apititle]#min#
[source,role=synopsis,id=api:min-fp]
----
template<typename GenFloat1, typename GenFloat2>           (1)
/*return-type*/ min(GenFloat1 x, GenFloat2 y)

template<typename NonScalar>                               (2)
/*return-type*/ min(NonScalar x, NonScalar::value_type y)
----

*Overload (1):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenFloat1# is a _generic floating point type_ as defined above;
* If [code]#GenFloat1# is not [code]#vec# or the [code]#+__swizzle__+# type,
  then [code]#GenFloat2# must be the same as [code]#GenFloat1#; and
* If [code]#GenFloat1# is [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#GenFloat2# must also be [code]#vec# or the [code]#+__swizzle__+# type,
  and both must have the same element type and the same number of elements.

_Preconditions:_ When the inputs are scalars, [code]#x# and [code]#y# must not
be infinite or NaN.
When the inputs are not scalars, no element of [code]#x# or [code]#y# may be
infinite or NaN.

_Returns:_ When the inputs are scalars, returns [code]#y# if [code]#y < x#
otherwise [code]#x#.
When the inputs are not scalars, returns [code]#y[i]# if [code]#y[i] < x[i]#
otherwise [code]#x[i]# for each element of [code]#x# and [code]#y#.

The return type is [code]#GenFloat1# unless [code]#GenFloat1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

*Overload (2):*

_Constraints:_ Available only if [code]#NonScalar# is [code]#marray#,
[code]#vec#, or the [code]#+__swizzle__+# type and is a _generic floating point
type_ as defined above.

_Preconditions:_ No element of [code]#x# may be infinite or NaN.
The value of [code]#y# must not be infinite or NaN.

_Returns:_ [code]#y# if [code]#y < x[i]# otherwise [code]#x[i]# for each element
of [code]#x#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#mix#
[source,role=synopsis,id=api:mix]
----
template<typename GenFloat1, typename GenFloat2, typename GenFloat3>       (1)
/*return-type*/ mix(GenFloat1 x, GenFloat2 y, GenFloat3 a)

template<typename NonScalar1, typename NonScalar2>                         (2)
/*return-type*/ mix(NonScalar1 x, NonScalar2 y, NonScalar1::value_type a)
----

*Overload (1):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenFloat1# is a _generic floating point type_ as defined above;
* If [code]#GenFloat1# is not [code]#vec# or the [code]#+__swizzle__+# type,
  then [code]#GenFloat2# and [code]#GenFloat3# must be the same as
  [code]#GenFloat1#; and
* If [code]#GenFloat1# is [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#GenFloat2# and [code]#GenFloat3# must also be [code]#vec# or the
  [code]#+__swizzle__+# type, and all three must have the same element type and
  the same number of elements.

_Preconditions:_ If the inputs are scalars, the value of [code]#a# must be in
the range [0.0, 1.0].
If the inputs are not scalars, each element of [code]#a# must be in the range
[0.0, 1.0].

_Returns:_ The linear blend of [code]#x# and [code]#y#.
When the inputs are scalars, returns [code]#x + (y - x) * a#.
Otherwise, returns [code]#x[i] + (y[i] - x[i]) * a[i]# for each element of
[code]#x#, [code]#y#, and [code]#a#.

The return type is [code]#GenFloat1# unless [code]#GenFloat1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

*Overload (2):*

_Constraints:_ Available only if [code]#NonScalar# is [code]#marray#,
[code]#vec#, or the [code]#+__swizzle__+# type and is a _generic floating point
type_ as defined above.

_Preconditions:_ The value of [code]#a# must be in the range [0.0, 1.0].

_Returns:_ The linear blend of [code]#x# and [code]#y#, computed as [code]#x[i]
+ (y[i] - x[i]) * a# for each element of [code]#x# and [code]#y#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#radians#
[source,role=synopsis,id=api:radians]
----
template<typename GenFloat>
/*return-type*/ radians(GenFloat degrees)
----

_Constraints:_ Available only if [code]#GenFloat# is a _generic floating point
type_ as defined above.

_Effects:_ Converts degrees to radians.

_Returns:_ When the inputs are scalars, returns [code]#({pi} / 180) * degrees#.
Otherwise, returns [code]#({pi} / 180) * degrees[i]# for each element of
[code]#degrees#.

The return type is [code]#GenFloat# unless [code]#GenFloat# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#step#
[source,role=synopsis,id=api:step]
----
template<typename GenFloat1, typename GenFloat2>               (1)
/*return-type*/ step(GenFloat1 edge, GenFloat2 x)

template<typename NonScalar>                                   (2)
/*return-type*/ step(NonScalar::value_type edge, NonScalar x)
----

*Overload (1):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenFloat1# is a _generic floating point type_ as defined above;
* If [code]#GenFloat1# is not [code]#vec# or the [code]#+__swizzle__+# type,
  then [code]#GenFloat2# must be the same as [code]#GenFloat1#; and
* If [code]#GenFloat1# is [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#GenFloat2# must also be [code]#vec# or the [code]#+__swizzle__+# type,
  and both must have the same element type and the same number of elements.

_Returns:_ When the inputs are scalars, returns the value [code]#(x < edge) ?
0.0 : 1.0#.
When the inputs are not scalars, returns the value [code]#(x[i] < edge[i]) ? 0.0
: 1.0# for each element of [code]#x# and [code]#edge#.

The return type is [code]#GenFloat1# unless [code]#GenFloat1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

*Overload (2):*

_Constraints:_ Available only if [code]#NonScalar# is [code]#marray#,
[code]#vec#, or the [code]#+__swizzle__+# type and is a _generic floating point
type_ as defined above.

_Returns:_ The value [code]#(x[i] < edge) ? 0.0 : 1.0# for each element of
[code]#x#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#smoothstep#
[source,role=synopsis,id=api:smoothstep]
----
template<typename GenFloat1, typename GenFloat2, typename GenFloat3>                  (1)
/*return-type*/ smoothstep(GenFloat1 edge0, GenFloat2 edge1, GenFloat3 x)

template<typename NonScalar>                                                          (2)
/*return-type*/ smoothstep(NonScalar::value_type edge0, NonScalar::value_type edge1,
                           NonScalar x)
----

*Overload (1):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenFloat1# is a _generic floating point type_ as defined above;
* If [code]#GenFloat1# is not [code]#vec# or the [code]#+__swizzle__+# type,
  then [code]#GenFloat2# and [code]#GenFloat3# must be the same as
  [code]#GenFloat1#; and
* If [code]#GenFloat1# is [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#GenFloat2# and [code]#GenFloat3# must also be [code]#vec# or the
  [code]#+__swizzle__+# type, and all three must have the same element type and
  the same number of elements.

_Preconditions:_ If the inputs are scalar, [code]#edge0# must be less than
[code]#edge1# and none of [code]#edge0#, [code]#edge1#, or [code]#x# may be NaN.
If the inputs are not scalar, each element of [code]#edge0# must be less than
the corresponding element of [code]#edge1# and no element of [code]#edge0#,
[code]#edge1#, or [code]#x# may be NaN.

_Returns:_ When the inputs are scalars, returns 0.0 if [code]#+x <= edge0+# and
1.0 if [code]#x >= edge1# and performs smooth Hermite interpolation between 0
and 1 when [code]#edge0 < x < edge1#.
This is useful in cases where you would want a threshold function with a smooth
transition.
This is equivalent to:

[source,role=synopsis]
----
GenFloat1 t;
t = clamp((x - edge0) / (edge1 - edge0), 0, 1);
return t * t * (3 - 2 * t);
----

When the inputs are not scalars, returns the following value for each element of
[code]#edge0#, [code]#edge1#, and [code]#x#:

[source,role=synopsis]
----
GenFloat1::value_type t;
t = clamp((x[i] - edge0[i]) / (edge1[i] - edge0[i]), 0, 1);
return t * t * (3 - 2 * t);
----

The return type is [code]#GenFloat1# unless [code]#GenFloat1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

*Overload (2):*

_Constraints:_ Available only if [code]#NonScalar# is [code]#marray#,
[code]#vec#, or the [code]#+__swizzle__+# type and is a _generic floating point
type_ as defined above.

_Preconditions:_ The value of [code]#edge0# must be less than [code]#edge1# and
neither [code]#edge0# nor [code]#edge1# may be NaN.
No element of [code]#x# may be NaN.

_Returns:_ The following value for each element of [code]#x#:

[source,role=synopsis]
----
NonScalar::value_type t;
t = clamp((x[i] - edge0) / (edge1 - edge0), 0, 1);
return t * t * (3 - 2 * t);
----

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#sign#
[source,role=synopsis,id=api:sign]
----
template<typename GenFloat>
/*return-type*/ sign(GenFloat x)
----

_Constraints:_ Available only if [code]#GenFloat# is a _generic floating point
type_ as defined above.

_Returns:_ When the input is scalar, returns 1.0 if [code]#x > 0#, -0.0 if
[code]#x == -0.0#, +0.0 if [code]#x == +0.0#, -1.0 if [code]#x < 0#, or 0.0 if
[code]#x# is a NaN.
When the input is not scalar, returns these values for each element of
[code]#x#.

The return type is [code]#GenFloat# unless [code]#GenFloat# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''


[[sec:geometric-functions]]
=== Geometric functions

This section describes the geometric functions that are available in the
[code]#sycl# namespace in both host and device code.

The descriptions in this section use the type name [code]#+__swizzle__+# to
refer to the classes defined in <<swizzled-vec-class>>.
This type can be any instantiation of the class templates named
[code]#+__writeable_swizzle__+# or [code]#+__const_swizzle__+# in that section,
so long as the instantiation satisfies the constraints listed in the function's
description.

The function descriptions in this section also use two terms that refer to a
specific list of types.
The term _generic geometric type_ represents the following types:

* [code]#float#
* [code]#double#
* [code]#half#
* [code]#marray<float, N>#, where [code]#N# is 2, 3, or 4
* [code]#marray<double, N>#, where [code]#N# is 2, 3, or 4
* [code]#marray<half, N>#, where [code]#N# is 2, 3, or 4
* [code]#vec<float, N>#, where [code]#N# is 2, 3, or 4
* [code]#vec<double, N>#, where [code]#N# is 2, 3, or 4
* [code]#vec<half, N>#, where [code]#N# is 2, 3, or 4
* [code]#+__swizzle__+# that is convertible to [code]#vec<float, N>#, where
  [code]#N# is 2, 3, or 4
* [code]#+__swizzle__+# that is convertible to [code]#vec<double, N>#, where
  [code]#N# is 2, 3, or 4
* [code]#+__swizzle__+# that is convertible to [code]#vec<half, N>#, where
  [code]#N# is 2, 3, or 4

The term _float geometric type_ represents these types:

* [code]#float#
* [code]#marray<float, N>#, where [code]#N# is 2, 3, or 4
* [code]#vec<float, N>#, where [code]#N# is 2, 3, or 4
* [code]#+__swizzle__+# that is convertible to [code]#vec<float, N>#, where
  [code]#N# is 2, 3, or 4

'''

.[apidef]#cross#
[source,role=synopsis,id=api:cross]
----
template<typename Geo3or4Float1, typename Geo3or4Float2>
/*return-type*/ cross(Geo3or4Float1 p0, Geo3or4Float2 p1)
----

_Constraints:_ Available only if all of the following conditions are met:

* [code]#Geo3or4Float1# is one of the following types:
** [code]#marray<float, 3>#
** [code]#marray<double, 3>#
** [code]#marray<half, 3>#
** [code]#marray<float, 4>#
** [code]#marray<double, 4>#
** [code]#marray<half, 4>#
** [code]#vec<float, 3>#
** [code]#vec<double, 3>#
** [code]#vec<half, 3>#
** [code]#vec<float, 4>#
** [code]#vec<double, 4>#
** [code]#vec<half, 4>#
** [code]#+__swizzle__+# that is convertible to [code]#vec<float, 3>#
** [code]#+__swizzle__+# that is convertible to [code]#vec<double, 3>#
** [code]#+__swizzle__+# that is convertible to [code]#vec<half, 3>#
** [code]#+__swizzle__+# that is convertible to [code]#vec<float, 4>#
** [code]#+__swizzle__+# that is convertible to [code]#vec<double, 4>#
** [code]#+__swizzle__+# that is convertible to [code]#vec<half, 4>#
* If [code]#Geo3or4Float1# is [code]#marray#, then [code]#Geo3or4Float2# must be
  the same as [code]#Geo3or4Float1#; and
* If [code]#Geo3or4Float1# is [code]#vec# or the [code]#+__swizzle__+# type,
  then [code]#Geo3or4Float2# must also be [code]#vec# or the
  [code]#+__swizzle__+# type, and both must have the same element type and the
  same number of elements.

_Returns:_ The cross product of first 3 components of [code]#p0# and [code]#p1#.
When the inputs have 4 components, the 4th component of the result is 0.0.

The return type is [code]#Geo3or4Float1# unless [code]#Geo3or4Float1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#dot#
[source,role=synopsis,id=api:dot]
----
template<typename GeoFloat1, typename GeoFloat2>
/*return-type*/ dot(GeoFloat1 p0, GeoFloat2 p1)
----

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GeoFloat1# is a _generic geometric type_ as defined above;
* If [code]#GeoFloat1# is not [code]#vec# or the [code]#+__swizzle__+# type,
  then [code]#GeoFloat2# must be the same as [code]#GeoFloat1#; and
* If [code]#GeoFloat1# is [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#GeoFloat2# must also be [code]#vec# or the [code]#+__swizzle__+# type,
  and both must have the same element type and the same number of elements.

_Returns:_ The dot product of [code]#p0# and [code]#p1#.

The return type is [code]#GeoFloat1# if the input types are scalar.
Otherwise, the return type is [code]#GeoFloat1::value_type#.

'''

.[apidef]#distance#
[source,role=synopsis,id=api:distance]
----
template<typename GeoFloat1, typename GeoFloat2>
/*return-type*/ distance(GeoFloat1 p0, GeoFloat2 p1)
----

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GeoFloat1# is a _generic geometric type_ as defined above;
* If [code]#GeoFloat1# is not [code]#vec# or the [code]#+__swizzle__+# type,
  then [code]#GeoFloat2# must be the same as [code]#GeoFloat1#; and
* If [code]#GeoFloat1# is [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#GeoFloat2# must also be [code]#vec# or the [code]#+__swizzle__+# type,
  and both must have the same element type and the same number of elements.

_Returns:_ The distance between [code]#p0# and [code]#p1#.
This is calculated as [code]#length(p0 - p1)#.

The return type is [code]#GeoFloat1# if the input types are scalar.
Otherwise, the return type is [code]#GeoFloat1::value_type#.

'''

.[apidef]#length#
[source,role=synopsis,id=api:length]
----
template<typename GeoFloat>
/*return-type*/ length(GeoFloat p)
----

_Constraints:_ Available only if [code]#GeoFloat# is a _generic geometric type_
as defined above.

_Returns:_ The length of vector [code]#p#, i.e., [code]#+sqrt(pow(p[0],2) +
pow(p[1],2) + ...)+#.

The return type is [code]#GeoFloat# if the input type is scalar.
Otherwise, the return type is [code]#GeoFloat::value_type#.

'''

.[apidef]#normalize#
[source,role=synopsis,id=api:normalize]
----
template<typename GeoFloat>
/*return-type*/ normalize(GeoFloat p)
----

_Constraints:_ Available only if [code]#GeoFloat# is a _generic geometric type_
as defined above.

_Returns:_ A vector in the same direction as [code]#p# but with a length of 1.

The return type is [code]#GeoFloat# unless [code]#GeoFloat# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#fast_distance#
[source,role=synopsis,id=api:fast_distance]
----
template<typename GeoFloat1, typename GeoFloat2>
/*return-type*/ fast_distance(GeoFloat1 p0, GeoFloat2 p1)
----

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GeoFloat1# is a _float geometric type_ as defined above;
* If [code]#GeoFloat1# is not [code]#vec# or the [code]#+__swizzle__+# type,
  then [code]#GeoFloat2# must be the same as [code]#GeoFloat1#; and
* If [code]#GeoFloat1# is [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#GeoFloat2# must also be [code]#vec# or the [code]#+__swizzle__+# type,
  and both must have the same number of elements.

_Returns:_ The value [code]#fast_length(p0 - p1)#.

The return type is [code]#GeoFloat1# if the input type is scalar.
Otherwise, the return type is [code]#GeoFloat1::value_type#.

'''

.[apidef]#fast_length#
[source,role=synopsis,id=api:fast_length]
----
template<typename GeoFloat>
/*return-type*/ fast_length(GeoFloat p)
----

_Constraints:_ Available only if [code]#GeoFloat# is a _float geometric type_ as
defined above.

_Returns:_ The length of vector [code]#p# computed as:
[code]#+half_precision::sqrt(pow(p[0],2) + pow(p[1],2) + ...)+#.

The return type is [code]#GeoFloat# if the input type is scalar.
Otherwise, the return type is [code]#GeoFloat::value_type#.

'''

.[apidef]#fast_normalize#
[source,role=synopsis,id=api:fast_normalize]
----
template<typename GeoFloat>
/*return-type*/ fast_normalize(GeoFloat p)
----

_Constraints:_ Available only if [code]#GeoFloat# is a _float geometric type_ as
defined above.

_Returns:_ A vector in the same direction as [code]#p# but with a length of 1
computed as [code]#+p * half_precision::rsqrt(pow(p[0],2) + pow(p[1],2) +
...)+#.

The result shall be within 8192 ulps error from the infinitely precise result of

[source,role=synopsis]
----
if (all(p == 0.0f))
  result = p;
else
  result = p / sqrt(pow(p[0], 2) + pow(p[1], 2) + ...);
----

with the following exceptions:

--
  . If the sum of squares is greater than [code]#FLT_MAX# then the value of the
    floating-point values in the result vector are undefined.
  . If the sum of squares is less than [code]#FLT_MIN# then the implementation
    may return back [code]#p#.
--

The return type is [code]#GeoFloat# unless [code]#GeoFloat# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''


[[sec:relational-functions]]
=== Relational functions

This section describes the relational functions that are available in the
[code]#sycl# namespace in both host and device code.
These functions perform various relational comparisons on [code]#vec#,
[code]#marray#, and scalar types.

The comparisons performed by [api]#isequal#, [api]#isgreater#,
[api]#isgreaterequal#, [api]#isless#, [api]#islessequal#, and
[api]#islessgreater# are false when one or both operands are NaN.
The comparison performed by [api]#isnotequal# is true when one or both operands
are NaN.

The descriptions in this section use the type name [code]#+__swizzle__+# to
refer to the classes defined in <<swizzled-vec-class>>.
This type can be any instantiation of the class templates named
[code]#+__writeable_swizzle__+# or [code]#+__const_swizzle__+# in that section,
so long as the instantiation satisfies the constraints listed in the function's
description.

The function descriptions in this section also use two terms that refer to a
specific list of types.
The term _generic scalar type_ represents the following types:

* [code]#char#
* [code]#signed char#
* [code]#short#
* [code]#int#
* [code]#long#
* [code]#long long#
* [code]#unsigned char#
* [code]#unsigned short#
* [code]#unsigned int#
* [code]#unsigned long#
* [code]#unsigned long long#
* [code]#float#
* [code]#double#
* [code]#half#

The term _vector element type_ represents these types:

* [code]#int8_t#
* [code]#int16_t#
* [code]#int32_t#
* [code]#int64_t#
* [code]#uint8_t#
* [code]#uint16_t#
* [code]#uint32_t#
* [code]#uint64_t#
* [code]#float#
* [code]#double#
* [code]#half#

'''

.[apidef]#isequal#
[source,role=synopsis,id=api:isequal]
----
bool isequal(float x, float y)                       (1)
bool isequal(double x, double y)                     (2)
bool isequal(half x, half y)                         (3)

template<typename NonScalar1, typename NonScalar2>   (4)
/*return-type*/ isequal(NonScalar1 x, NonScalar2 y)
----

*Overloads (1) - (3):*

_Returns:_ The value [code]#(x == y)#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzle__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements and
  the same element type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ If [code]#NonScalar1# is [code]#marray#, the value [code]#(x[i] ==
y[i])# for each element of [code]#x# and [code]#y#.
If [code]#NonScalar1# is [code]#vec# or the [code]#+__swizzle__+# type, returns
the value [code]#((x[i] == y[i]) ? -1 : 0)# for each element of [code]#x# and
[code]#y#.

The return type depends on [code]#NonScalar1#:

[options="header",separator="@",cols="70%,30%"]
|====
@NonScalar1 @ Return Type
@[code]#marray<float, N># +
 [code]#marray<double, N># +
 [code]#marray<half, N>#
@[code]#marray<bool, N>#

@[code]#vec<float, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<float, N>#
@[code]#vec<int32_t, N>#

@[code]#vec<double, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<double, N>#
@[code]#vec<int64_t, N>#

@[code]#vec<half, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<half, N>#
@[code]#vec<int16_t, N>#
|====

'''

.[apidef]#isnotequal#
[source,role=synopsis,id=api:isnotequal]
----
bool isnotequal(float x, float y)                       (1)
bool isnotequal(double x, double y)                     (2)
bool isnotequal(half x, half y)                         (3)

template<typename NonScalar1, typename NonScalar2>      (4)
/*return-type*/ isnotequal(NonScalar1 x, NonScalar2 y)
----

*Overloads (1) - (3):*

_Returns:_ The value [code]#(x != y)#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzle__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements and
  the same element type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ If [code]#NonScalar1# is [code]#marray#, the value [code]#(x[i] !=
y[i])# for each element of [code]#x# and [code]#y#.
If [code]#NonScalar1# is [code]#vec# or the [code]#+__swizzle__+# type, returns
the value [code]#((x[i] != y[i]) ? -1 : 0)# for each element of [code]#x# and
[code]#y#.

The return type depends on [code]#NonScalar1#:

[options="header",separator="@",cols="70%,30%"]
|====
@NonScalar1 @ Return Type
@[code]#marray<float, N># +
 [code]#marray<double, N># +
 [code]#marray<half, N>#
@[code]#marray<bool, N>#

@[code]#vec<float, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<float, N>#
@[code]#vec<int32_t, N>#

@[code]#vec<double, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<double, N>#
@[code]#vec<int64_t, N>#

@[code]#vec<half, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<half, N>#
@[code]#vec<int16_t, N>#
|====

'''

.[apidef]#isgreater#
[source,role=synopsis,id=api:isgreater]
----
bool isgreater(float x, float y)                       (1)
bool isgreater(double x, double y)                     (2)
bool isgreater(half x, half y)                         (3)

template<typename NonScalar1, typename NonScalar2>     (4)
/*return-type*/ isgreater(NonScalar1 x, NonScalar2 y)
----

*Overloads (1) - (3):*

_Returns:_ The value [code]#(x > y)#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzle__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements and
  the same element type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ If [code]#NonScalar1# is [code]#marray#, the value [code]#(x[i] >
y[i])# for each element of [code]#x# and [code]#y#.
If [code]#NonScalar1# is [code]#vec# or the [code]#+__swizzle__+# type, returns
the value [code]#((x[i] > y[i]) ? -1 : 0)# for each element of [code]#x# and
[code]#y#.

The return type depends on [code]#NonScalar1#:

[options="header",separator="@",cols="70%,30%"]
|====
@NonScalar1 @ Return Type
@[code]#marray<float, N># +
 [code]#marray<double, N># +
 [code]#marray<half, N>#
@[code]#marray<bool, N>#

@[code]#vec<float, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<float, N>#
@[code]#vec<int32_t, N>#

@[code]#vec<double, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<double, N>#
@[code]#vec<int64_t, N>#

@[code]#vec<half, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<half, N>#
@[code]#vec<int16_t, N>#
|====

'''

.[apidef]#isgreaterequal#
[source,role=synopsis,id=api:isgreaterequal]
----
bool isgreaterequal(float x, float y)                       (1)
bool isgreaterequal(double x, double y)                     (2)
bool isgreaterequal(half x, half y)                         (3)

template<typename NonScalar1, typename NonScalar2>          (4)
/*return-type*/ isgreaterequal(NonScalar1 x, NonScalar2 y)
----

*Overloads (1) - (3):*

_Returns:_ The value [code]#(x >= y)#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzle__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements and
  the same element type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ If [code]#NonScalar1# is [code]#marray#, the value [code]#(x[i] >=
y[i])# for each element of [code]#x# and [code]#y#.
If [code]#NonScalar1# is [code]#vec# or the [code]#+__swizzle__+# type, returns
the value [code]#((x[i] >= y[i]) ? -1 : 0)# for each element of [code]#x# and
[code]#y#.

The return type depends on [code]#NonScalar1#:

[options="header",separator="@",cols="70%,30%"]
|====
@NonScalar1 @ Return Type
@[code]#marray<float, N># +
 [code]#marray<double, N># +
 [code]#marray<half, N>#
@[code]#marray<bool, N>#

@[code]#vec<float, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<float, N>#
@[code]#vec<int32_t, N>#

@[code]#vec<double, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<double, N>#
@[code]#vec<int64_t, N>#

@[code]#vec<half, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<half, N>#
@[code]#vec<int16_t, N>#
|====

'''

.[apidef]#isless#
[source,role=synopsis,id=api:isless]
----
bool isless(float x, float y)                       (1)
bool isless(double x, double y)                     (2)
bool isless(half x, half y)                         (3)

template<typename NonScalar1, typename NonScalar2>  (4)
/*return-type*/ isless(NonScalar1 x, NonScalar2 y)
----

*Overloads (1) - (3):*

_Returns:_ The value [code]#(x < y)#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzle__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements and
  the same element type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ If [code]#NonScalar1# is [code]#marray#, the value [code]#(x[i] <
y[i])# for each element of [code]#x# and [code]#y#.
If [code]#NonScalar1# is [code]#vec# or the [code]#+__swizzle__+# type, returns
the value [code]#((x[i] < y[i]) ? -1 : 0)# for each element of [code]#x# and
[code]#y#.

The return type depends on [code]#NonScalar1#:

[options="header",separator="@",cols="70%,30%"]
|====
@NonScalar1 @ Return Type
@[code]#marray<float, N># +
 [code]#marray<double, N># +
 [code]#marray<half, N>#
@[code]#marray<bool, N>#

@[code]#vec<float, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<float, N>#
@[code]#vec<int32_t, N>#

@[code]#vec<double, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<double, N>#
@[code]#vec<int64_t, N>#

@[code]#vec<half, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<half, N>#
@[code]#vec<int16_t, N>#
|====

'''

.[apidef]#islessequal#
[source,role=synopsis,id=api:islessequal]
----
bool islessequal(float x, float y)                       (1)
bool islessequal(double x, double y)                     (2)
bool islessequal(half x, half y)                         (3)

template<typename NonScalar1, typename NonScalar2>       (4)
/*return-type*/ islessequal(NonScalar1 x, NonScalar2 y)
----

*Overloads (1) - (3):*

_Returns:_ The value [code]#+(x <= y)+#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzle__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements and
  the same element type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ If [code]#NonScalar1# is [code]#marray#, the value [code]#+(x[i] <=
y[i])+# for each element of [code]#x# and [code]#y#.
If [code]#NonScalar1# is [code]#vec# or the [code]#+__swizzle__+# type, returns
the value [code]#+((x[i] <= y[i]) ? -1 : 0)+# for each element of [code]#x# and
[code]#y#.

The return type depends on [code]#NonScalar1#:

[options="header",separator="@",cols="70%,30%"]
|====
@NonScalar1 @ Return Type
@[code]#marray<float, N># +
 [code]#marray<double, N># +
 [code]#marray<half, N>#
@[code]#marray<bool, N>#

@[code]#vec<float, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<float, N>#
@[code]#vec<int32_t, N>#

@[code]#vec<double, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<double, N>#
@[code]#vec<int64_t, N>#

@[code]#vec<half, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<half, N>#
@[code]#vec<int16_t, N>#
|====

'''

.[apidef]#islessgreater#
[source,role=synopsis,id=api:islessgreater]
----
bool islessgreater(float x, float y)                       (1)
bool islessgreater(double x, double y)                     (2)
bool islessgreater(half x, half y)                         (3)

template<typename NonScalar1, typename NonScalar2>         (4)
/*return-type*/ islessgreater(NonScalar1 x, NonScalar2 y)
----

*Overloads (1) - (3):*

_Returns:_ The value [code]#(x < y) || (x > y)#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzle__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements and
  the same element type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ If [code]#NonScalar1# is [code]#marray#, the value [code]#(x[i] <
y[i] || x[i] > y[i])# for each element of [code]#x# and [code]#y#.
If [code]#NonScalar1# is [code]#vec# or the [code]#+__swizzle__+# type, returns
the value [code]#((x[i] < y[i] || x[i] > y[i]) ? -1 : 0)# for each element of
[code]#x# and [code]#y#.

The return type depends on [code]#NonScalar1#:

[options="header",separator="@",cols="70%,30%"]
|====
@NonScalar1 @ Return Type
@[code]#marray<float, N># +
 [code]#marray<double, N># +
 [code]#marray<half, N>#
@[code]#marray<bool, N>#

@[code]#vec<float, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<float, N>#
@[code]#vec<int32_t, N>#

@[code]#vec<double, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<double, N>#
@[code]#vec<int64_t, N>#

@[code]#vec<half, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<half, N>#
@[code]#vec<int16_t, N>#
|====

'''

.[apidef]#isfinite#
[source,role=synopsis,id=api:isfinite]
----
bool isfinite(float x)                 (1)
bool isfinite(double x)                (2)
bool isfinite(half x)                  (3)

template<typename NonScalar>           (4)
/*return-type*/ isfinite(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The value [code]#true# only if [code]#x# has finite value.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ If [code]#NonScalar# is [code]#marray#, returns true for each element
of [code]#x# only if [code]#x[i]# is a finite value.
If [code]#NonScalar# is [code]#vec# or the [code]#+__swizzle__+# type, returns
-1 for each element of [code]#x# if [code]#x[i]# is a finite value and returns 0
otherwise.

The return type depends on [code]#NonScalar#:

[options="header",separator="@",cols="70%,30%"]
|====
@NonScalar @ Return Type
@[code]#marray<float, N># +
 [code]#marray<double, N># +
 [code]#marray<half, N>#
@[code]#marray<bool, N>#

@[code]#vec<float, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<float, N>#
@[code]#vec<int32_t, N>#

@[code]#vec<double, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<double, N>#
@[code]#vec<int64_t, N>#

@[code]#vec<half, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<half, N>#
@[code]#vec<int16_t, N>#
|====

'''

.[apidef]#isinf#
[source,role=synopsis,id=api:isinf]
----
bool isinf(float x)                 (1)
bool isinf(double x)                (2)
bool isinf(half x)                  (3)

template<typename NonScalar>        (4)
/*return-type*/ isinf(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The value [code]#true# only if [code]#x# has an infinity value
(either positive or negative).

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ If [code]#NonScalar# is [code]#marray#, returns true for each element
of [code]#x# only if [code]#x[i]# has an infinity value.
If [code]#NonScalar# is [code]#vec# or the [code]#+__swizzle__+# type, returns
-1 for each element of [code]#x# if [code]#x[i]# has an infinity value and
returns 0 otherwise.

The return type depends on [code]#NonScalar#:

[options="header",separator="@",cols="70%,30%"]
|====
@NonScalar @ Return Type
@[code]#marray<float, N># +
 [code]#marray<double, N># +
 [code]#marray<half, N>#
@[code]#marray<bool, N>#

@[code]#vec<float, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<float, N>#
@[code]#vec<int32_t, N>#

@[code]#vec<double, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<double, N>#
@[code]#vec<int64_t, N>#

@[code]#vec<half, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<half, N>#
@[code]#vec<int16_t, N>#
|====

'''

.[apidef]#isnan#
[source,role=synopsis,id=api:isnan]
----
bool isnan(float x)                 (1)
bool isnan(double x)                (2)
bool isnan(half x)                  (3)

template<typename NonScalar>        (4)
/*return-type*/ isnan(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The value [code]#true# only if [code]#x# has a NaN value.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ If [code]#NonScalar# is [code]#marray#, returns true for each element
of [code]#x# only if [code]#x[i]# has a NaN value.
If [code]#NonScalar# is [code]#vec# or the [code]#+__swizzle__+# type, returns
-1 for each element of [code]#x# if [code]#x[i]# has a NaN value and returns 0
otherwise.

The return type depends on [code]#NonScalar#:

[options="header",separator="@",cols="70%,30%"]
|====
@NonScalar @ Return Type
@[code]#marray<float, N># +
 [code]#marray<double, N># +
 [code]#marray<half, N>#
@[code]#marray<bool, N>#

@[code]#vec<float, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<float, N>#
@[code]#vec<int32_t, N>#

@[code]#vec<double, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<double, N>#
@[code]#vec<int64_t, N>#

@[code]#vec<half, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<half, N>#
@[code]#vec<int16_t, N>#
|====

'''

.[apidef]#isnormal#
[source,role=synopsis,id=api:isnormal]
----
bool isnormal(float x)                 (1)
bool isnormal(double x)                (2)
bool isnormal(half x)                  (3)

template<typename NonScalar>           (4)
/*return-type*/ isnormal(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The value [code]#true# only if [code]#x# has a normal value.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ If [code]#NonScalar# is [code]#marray#, returns true for each element
of [code]#x# only if [code]#x[i]# has a normal value.
If [code]#NonScalar# is [code]#vec# or the [code]#+__swizzle__+# type, returns
-1 for each element of [code]#x# if [code]#x[i]# has a normal value and returns
0 otherwise.

The return type depends on [code]#NonScalar#:

[options="header",separator="@",cols="70%,30%"]
|====
@NonScalar @ Return Type
@[code]#marray<float, N># +
 [code]#marray<double, N># +
 [code]#marray<half, N>#
@[code]#marray<bool, N>#

@[code]#vec<float, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<float, N>#
@[code]#vec<int32_t, N>#

@[code]#vec<double, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<double, N>#
@[code]#vec<int64_t, N>#

@[code]#vec<half, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<half, N>#
@[code]#vec<int16_t, N>#
|====

'''

.[apidef]#isordered#
[source,role=synopsis,id=api:isordered]
----
bool isordered(float x, float y)                       (1)
bool isordered(double x, double y)                     (2)
bool isordered(half x, half y)                         (3)

template<typename NonScalar1, typename NonScalar2>     (4)
/*return-type*/ isordered(NonScalar1 x, NonScalar2 y)
----

*Overloads (1) - (3):*

_Effects:_ Tests if [code]#x# and [code]#y# are ordered.

_Returns:_ The value [code]#isequal(x, x) && isequal(y, y)#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzle__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements and
  the same element type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Effects:_ Tests if each element of [code]#x# and [code]#y# are ordered.

_Returns:_ If [code]#NonScalar1# is [code]#marray#, the value
[code]#isequal(x[i], x[i]) && isequal(y[i], y[i])# for each element of [code]#x#
and [code]#y#.
If [code]#NonScalar1# is [code]#vec# or the [code]#+__swizzle__+# type, returns
the value [code]#((isequal(x[i], x[i]) && isequal(y[i], y[i]) ? -1 : 0)# for
each element of [code]#x# and [code]#y#.

The return type depends on [code]#NonScalar1#:

[options="header",separator="@",cols="70%,30%"]
|====
@NonScalar1 @ Return Type
@[code]#marray<float, N># +
 [code]#marray<double, N># +
 [code]#marray<half, N>#
@[code]#marray<bool, N>#

@[code]#vec<float, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<float, N>#
@[code]#vec<int32_t, N>#

@[code]#vec<double, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<double, N>#
@[code]#vec<int64_t, N>#

@[code]#vec<half, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<half, N>#
@[code]#vec<int16_t, N>#
|====

'''

.[apidef]#isunordered#
[source,role=synopsis,id=api:isunordered]
----
bool isunordered(float x, float y)                       (1)
bool isunordered(double x, double y)                     (2)
bool isunordered(half x, half y)                         (3)

template<typename NonScalar1, typename NonScalar2>       (4)
/*return-type*/ isunordered(NonScalar1 x, NonScalar2 y)
----

*Overloads (1) - (3):*

_Effects:_ Tests if [code]#x# and [code]#y# are unordered.

_Returns:_ The value [code]#isnan(x) || isnan(y)#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzle__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements and
  the same element type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Effects:_ Tests if each element of [code]#x# and [code]#y# are unordered.

_Returns:_ If [code]#NonScalar1# is [code]#marray#, the value [code]#isnan(x[i])
|| isnan(y[i])# for each element of [code]#x# and [code]#y#.
If [code]#NonScalar1# is [code]#vec# or the [code]#+__swizzle__+# type, returns
the value [code]#((isnan(x[i]) || isnan(y[i]) ? -1 : 0)# for each element of
[code]#x# and [code]#y#.

The return type depends on [code]#NonScalar1#:

[options="header",separator="@",cols="70%,30%"]
|====
@NonScalar1 @ Return Type
@[code]#marray<float, N># +
 [code]#marray<double, N># +
 [code]#marray<half, N>#
@[code]#marray<bool, N>#

@[code]#vec<float, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<float, N>#
@[code]#vec<int32_t, N>#

@[code]#vec<double, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<double, N>#
@[code]#vec<int64_t, N>#

@[code]#vec<half, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<half, N>#
@[code]#vec<int16_t, N>#
|====

'''

.[apidef]#signbit#
[source,role=synopsis,id=api:signbit]
----
bool signbit(float x)                 (1)
bool signbit(double x)                (2)
bool signbit(half x)                  (3)

template<typename NonScalar>          (4)
/*return-type*/ signbit(NonScalar x)
----

*Overloads (1) - (3):*

_Returns:_ The value [code]#true# only if the sign bit of [code]#x# is set.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the [code]#+__swizzle__+#
  type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ If [code]#NonScalar# is [code]#marray#, returns true for each element
of [code]#x# only if the sign bit of [code]#x[i]# is set.
If [code]#NonScalar# is [code]#vec# or the [code]#+__swizzle__+# type, returns
-1 for each element of [code]#x# if the sign bit of [code]#x[i]# is set and
returns 0 otherwise.

The return type depends on [code]#NonScalar#:

[options="header",separator="@",cols="70%,30%"]
|====
@NonScalar @ Return Type
@[code]#marray<float, N># +
 [code]#marray<double, N># +
 [code]#marray<half, N>#
@[code]#marray<bool, N>#

@[code]#vec<float, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<float, N>#
@[code]#vec<int32_t, N>#

@[code]#vec<double, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<double, N>#
@[code]#vec<int64_t, N>#

@[code]#vec<half, N># +
 [code]#+__swizzle__+# that is convertible to [code]#vec<half, N>#
@[code]#vec<int16_t, N>#
|====

'''

.[apidef]#any#
[source,role=synopsis,id=api:any]
----
template<typename GenInt>      (1)
/*return-type*/ any(GenInt x)

template<typename GenInt>      (2)  /* deprecated */
bool any(GenInt x)
----

*Overload (1):*

_Constraints:_ Available only if [code]#GenInt# is one of the following types:

* [code]#marray<bool, N>#
* [code]#vec<int8_t, N>#
* [code]#vec<int16_t, N>#
* [code]#vec<int32_t, N>#
* [code]#vec<int64_t, N>#
* [code]#+__swizzle__+# that is convertible to [code]#vec<int8_t, N>#
* [code]#+__swizzle__+# that is convertible to [code]#vec<int16_t, N>#
* [code]#+__swizzle__+# that is convertible to [code]#vec<int32_t, N>#
* [code]#+__swizzle__+# that is convertible to [code]#vec<int64_t, N>#

_Returns:_ When [code]#x# is [code]#marray#, returns a Boolean telling whether
any element of [code]#x# is true.
When [code]#x# is [code]#vec# or the [code]#+__swizzle__+# type, returns the
value 1 if any element in [code]#x# has its most significant bit set, otherwise
returns the value 0.

The return type is [code]#bool# if [code]#GenInt# is [code]#marray#.
Otherwise, the return type is [code]#int#.

*Overload (2):*

This overload is deprecated in SYCL 2020.

_Constraints:_ Available only if [code]#GenInt# is one of the following types:

* [code]#signed char#
* [code]#short#
* [code]#int#
* [code]#long#
* [code]#long long#
* [code]#marray<signed char, N>#
* [code]#marray<short, N>#
* [code]#marray<int, N>#
* [code]#marray<long, N>#
* [code]#marray<long long, N>#

_Returns:_ When [code]#x# is a scalar, returns a Boolean telling whether the
most significant bit of [code]#x# is set.
When [code]#x# is [code]#marray#, returns a Boolean telling whether the most
significant bit of any element in [code]#x# is set.

'''

.[apidef]#all#
[source,role=synopsis,id=api:all]
----
template<typename GenInt>      (1)
/*return-type*/ all(GenInt x)

template<typename GenInt>      (2)  /* deprecated */
bool all(GenInt x)
----

*Overload (1):*

_Constraints:_ Available only if [code]#GenInt# is one of the following types:

* [code]#marray<bool, N>#
* [code]#vec<int8_t, N>#
* [code]#vec<int16_t, N>#
* [code]#vec<int32_t, N>#
* [code]#vec<int64_t, N>#
* [code]#+__swizzle__+# that is convertible to [code]#vec<int8_t, N>#
* [code]#+__swizzle__+# that is convertible to [code]#vec<int16_t, N>#
* [code]#+__swizzle__+# that is convertible to [code]#vec<int32_t, N>#
* [code]#+__swizzle__+# that is convertible to [code]#vec<int64_t, N>#

_Returns:_ When [code]#x# is [code]#marray#, returns a Boolean telling whether
all elements of [code]#x# are true.
When [code]#x# is [code]#vec# or the [code]#+__swizzle__+# type, returns the
value 1 if all elements in [code]#x# have their most significant bit set,
otherwise returns the value 0.

The return type is [code]#bool# if [code]#GenInt# is [code]#marray#.
Otherwise, the return type is [code]#int#.

*Overload (2):*

This overload is deprecated in SYCL 2020.

_Constraints:_ Available only if [code]#GenInt# is one of the following types:

* [code]#signed char#
* [code]#short#
* [code]#int#
* [code]#long#
* [code]#long long#
* [code]#marray<signed char, N>#
* [code]#marray<short, N>#
* [code]#marray<int, N>#
* [code]#marray<long, N>#
* [code]#marray<long long, N>#

_Returns:_ When [code]#x# is a scalar, returns a Boolean telling whether the
most significant bit of [code]#x# is set.
When [code]#x# is [code]#marray#, returns a Boolean telling whether the most
significant bit of all elements in [code]#x# are set.

'''

.[apidef]#bitselect#
[source,role=synopsis,id=api:bitselect]
----
template<typename GenType1, typename GenType2, typename GenType3>
/*return-type*/ bitselect(GenType1 a, GenType2 b, GenType3 c)
----

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenType1# is one of the following types:
** One of the _generic scalar types_ as defined above;
** [code]#marray<T, N>#, where [code]#T# is one of the _generic scalar types_;
** [code]#vec<T, N>#, where [code]#T# is one of the _vector element types_ as
   defined above; or
** [code]#+__swizzle__+# that is convertible to [code]#vec<T, N>#, where
   [code]#T# is one of the _vector element types_;
* If [code]#GenType1# is not [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#GenType2# and [code]#GenType3# must be the same as [code]#GenType1#;
  and
* If [code]#GenType1# is [code]#vec# or the [code]#+__swizzle__+# type, then
  [code]#GenType2# and [code]#GenType3# must also be [code]#vec# or the
  [code]#+__swizzle__+# type, and all three must have the same element type and
  the same number of elements.

_Returns:_ When the input parameters are scalars, returns a result where each
bit of the result is the corresponding bit of [code]#a# if the corresponding bit
of [code]#c# is 0.
Otherwise it is the corresponding bit of [code]#b#.

When the input parameters are not scalars, returns a result for each element
where each bit of the result for element [code]#i# is the corresponding bit of
[code]#a[i]# if the corresponding bit of [code]#c[i]# is 0.
Otherwise it is the corresponding bit of [code]#b[i]#.

The return type is [code]#GenType1# unless [code]#GenType1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

.[apidef]#select#
[source,role=synopsis,id=api:select]
----
template<typename Scalar>                                                (1)
Scalar select(Scalar a, Scalar b, bool c)

template<typename NonScalar1, typename NonScalar2, typename NonScalar3>  (2)
/*return-type*/ select(NonScalar1 a, NonScalar2 b, NonScalar3 c)
----

*Overload (1):*

_Constraints:_ Available only if [code]#Scalar# is one of the _generic scalar
types_ as defined above.

_Returns:_ The value [code]#(c ? b : a)#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar1# is one of the following types:
** [code]#marray<T, N>#, where [code]#T# is one of the _generic scalar types_ as
   defined above;
** [code]#vec<T, N>#, where [code]#T# is one of the _vector element types_ as
   defined above; or
** [code]#+__swizzle__+# that is convertible to [code]#vec<T, N>#, where
   [code]#T# is one of the _vector element types_;
* If [code]#NonScalar1# is [code]#marray#, then:
** [code]#NonScalar2# must be the same as [code]#NonScalar1#; and
** [code]#NonScalar3# must be [code]#marray# with element type [code]#bool# and
   the same number of elements as [code]#NonScalar1#;
* If [code]#NonScalar1# is [code]#vec# or the [code]#+__swizzle__+# type, then:
** [code]#NonScalar2# must also be [code]#vec# or the [code]#+__swizzle__+#
   type, and both must have the same element type and the same number of
   elements; and
** [code]#NonScalar3# must be [code]#vec# or the [code]#+__swizzle__+# type with
   the same number of elements as [code]#NonScalar1#.
   The element type of [code]#NonScalar3# must be a signed or unsigned integer
   with the same number of bits as the element type of [code]#NonScalar1#.

_Returns:_ If [code]#NonScalar1# is [code]#marray#, return the value
[code]#(c[i] ? b[i] : a[i])# for each element of [code]#a#, [code]#b#, and
[code]#c#.

If [code]#NonScalar1# is [code]#vec# or the [code]#+__swizzle__+# type, returns
the value [code]#((MSB of c[i] is set) ? b[i] : a[i])# for each element of
[code]#a#, [code]#b#, and [code]#c#.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzle__+# type, in which case the return type is the corresponding
[code]#vec#.

'''

// %%%%%%%%%%%%%%%%%%%%%%%%%%%% end builtin_functions %%%%%%%%%%%%%%%%%%%%%%%%%%%%


// %%%%%%%%%%%%%%%%%%%%%%%%%%%% end programming_interface %%%%%%%%%%%%%%%%%%%%%%%%%%%%
