[[chapter:sycl-programming-interface]]
= SYCL programming interface

The SYCL programming interface provides a common abstracted feature set to
one or more <<backend>> APIs. This section describes the {cpp} library
interface to the <<sycl-runtime>> which executes across those <<backend, SYCL backends>>.

The entirety of the SYCL interface defined in this section is required to be
available for any <<backend, SYCL backends>>, with the exception of the interoperability
interface, which is described in general terms in this document, not
pertaining to any particular <<backend>>.

SYCL guarantees that all the member functions and special member functions of
the SYCL classes described are thread safe.

The underlying types for all enumerations defined in this specification are
implementation-defined.  In addition, all enumerators within an enumeration
have some implementation-defined unique value unless the specification
specifically indicates a values for the enumerator.


[[sec:backends]]
== Backends

The <<backend, SYCL backends>> that can be supported by a SYCL implementation are identified
using the [code]#enum class backend#.

[source,,linenums]
----
include::{header_dir}/backends.h[lines=4..-1]
----

The [code]#enum class backend# is implementation-defined and must be populated
with a unique identifier for each <<backend>> that the SYCL implementation can
support. Note that the <<backend, SYCL backends>> listed in the [code]#enum
class backend# are not guaranteed to be available in a given installation.

Each named <<backend>> enumerated in the [code]#enum class backend#
must be associated with a <<backend>> specification.
Many sections of this specification
will refer to the associated <<backend>> specification.


[[sec:backend-macros]]
=== Backend macros

As the identifiers defined in [code]#enum class backend# are
implementation-defined, and the associated backends not guaranteed to be available,
a SYCL implementation must also define a preprocessor macro for each of
these identifiers.  If the <<backend>> is defined by the Khronos SYCL group, the
name of the macro has the form [code]#SYCL_BACKEND_<backend_name>#, where
_backend_name_ is the associated identifier from [code]#backend# in
all upper-case.  See <<chapter.extensions>> for the name of the macro
if the vendor defines the <<backend>> outside of the Khronos SYCL group.

If a backend listed in the [code]#enum class backend# is not available, the
associated macro must be left undefined.

[[sec:generic-vs-non-generic]]
== Generic vs non-generic SYCL

The SYCL programming API is split into two categories; generic SYCL and
non-generic SYCL. Almost everything in the SYCL programming API is considered
generic SYCL. However any usage of the [code]#enum class backend# is
considered non-generic SYCL and should only be used for <<backend>> specialized
code paths, as the identifiers defined in [code]#backend# are
implementation-defined.

In any non-generic SYCL application code where the [code]#backend# enum
class is used, the expression must be guarded with a preprocessor
[code]#{hash}ifdef# guard using the associated preprocessor macro to ensure that
the SYCL application will compile even if the SYCL implementation does not
support that <<backend>> being specialized for.


[[sec:headers-and-namespaces]]
== Header files and namespaces

SYCL provides one standard header file: [code]#<sycl/sycl.hpp>#, which needs to
be included in every translation unit that uses the SYCL programming API.

All SYCL classes, constants, types and functions defined by this
specification should exist within the [code]#::sycl# namespace.

For compatibility with SYCL 1.2.1, SYCL provides another standard
header file: [code]#<CL/sycl.hpp>#, which can be included in
place of [code]#<sycl/sycl.hpp>#.  In that case, all SYCL classes, constants,
types and functions defined by this specification should exist within the
[code]#::cl::sycl# {cpp} namespace.

For consistency, the programming API will only refer to the
[code]#<sycl/sycl.hpp># header and the [code]#::sycl# namespace, but this
should be considered synonymous with the SYCL 1.2.1 header and namespace.

Include paths starting with [code]#"sycl/ext/"# and [code]#"sycl/backend/"# are
reserved for extensions to SYCL and for backend interop headers respectively.
Other include paths starting with [code]#"sycl/"# and the [code]#sycl::detail#
namespace are reserved for implementation details.

When a <<backend>> is defined by the Khronos SYCL group, functionality
for that <<backend>> is available via the header
[code]#"sycl/backend/<backend_name>.hpp"#, and all <<backend>>-specific
functionality is made available in the namespace [code]#sycl::<backend_name>#
where [code]#<backend_name># is the name of the <<backend>> as defined in the
<<backend>> specification.

<<chapter.extensions>> defines the allowable header files and
namespaces for any extensions that a vendor may provide, including any
<<backend>> that the vendor may define outside of the Khronos SYCL group.

Unless otherwise specified, the behavior of a SYCL program is undefined
if it adds any entity to namespace [code]#sycl# or to a
namespace within namespace [code]#sycl#.


== Class availability

In SYCL some <<sycl-runtime>> classes are available to the SYCL application,
some are available within a <<sycl-kernel-function>> and some are available
on both and can be passed as arguments to a <<sycl-kernel-function>>.

Each of the following <<sycl-runtime>> classes:
[code]#buffer#,
[code]#buffer_allocator#,
[code]#context#,
[code]#device#,
[code]#device_image#,
[code]#event#,
[code]#exception#,
[code]#handler#,
[code]#host_accessor#,
[code]#host_sampled_image_accessor#,
[code]#host_unsampled_image_accessor#,
[code]#id#,
[code]#image_allocator#,
[code]#kernel#,
[code]#kernel_id#,
[code]#marray#,
[code]#kernel_bundle#,
[code]#nd_range#,
[code]#platform#,
[code]#queue#,
[code]#range#,
[code]#sampled_image#,
[code]#image_sampler#,
[code]#stream#,
[code]#unsampled_image# and
[code]#vec#
must be available to the host application.

Each of the following <<sycl-runtime>> classes:
[code]#accessor#,
[code]#atomic_ref#,
[code]#device_event#,
[code]#group#,
[code]#h_item#,
[code]#id#,
[code]#item#,
[code]#local_accessor#,
[code]#marray#,
[code]#multi_ptr#,
[code]#nd_item#,
[code]#range#,
[code]#reducer#,
[code]#sampled_image_accessor#,
[code]#stream#,
[code]#sub_group#,
[code]#unsampled_image_accessor# and
[code]#vec#
must be available within a <<sycl-kernel-function>>.

== Common interface

When a dimension template parameter is used in SYCL classes, it is
defaulted as 1 in most cases.


[[sec:backend-interoperability]]
=== Backend interoperability

Many of the <<sycl-runtime>> classes may be implemented such that they
encapsulate an object unique to the <<backend>> that underpins the
functionality of that class. Where appropriate, these classes may provide an
interface for interoperating between the <<sycl-runtime>> object and the
<<native-backend-object>> in order to support interoperability within an
application between SYCL and the associated <<backend-api>>.

There are three forms of interoperability with <<sycl-runtime>> classes:
interoperability on the <<sycl-application>> with the <<backend-api>>,
interoperability within a <<sycl-kernel-function>> with the equivalent kernel
language types of the <<backend>>, and interoperability within a <<host-task>>
with the [code]#interop_handle#.

<<sycl-application,SYCL application>> interoperability,
<<sycl-kernel-function>> interoperability and <<host-task>> interoperability
are provided via different interfaces and may have different behavior for the
same SYCL object.

<<sycl-application,SYCL application>> interoperability may be provided for
[code]#buffer#,
[code]#context#,
[code]#device#,
[code]#device_image#,
[code]#event#,
[code]#kernel#,
[code]#kernel_bundle#,
[code]#platform#,
[code]#queue#,
[code]#sampled_image#, and
[code]#unsampled_image#.

<<sycl-kernel-function,SYCL kernel function>> interoperability may be provided for
[code]#accessor#,
[code]#device_event#,
[code]#local_accessor#,
[code]#sampled_image_accessor#,
[code]#stream# and
[code]#unsampled_image_accessor#
inside <<kernel-scope>> only and is not available outside of that scope.

<<host-task>> interoperability may be provided for
[code]#accessor#,
[code]#sampled_image_accessor#,
[code]#unsampled_image_accessor#,
[code]#queue#,
[code]#device#,
[code]#context#
inside the scope of a <<host-task>> only, see <<subsec:interfaces.hosttasks>>.

Support for <<backend>> interoperability is optional and therefore not required
to be provided by a SYCL implementation. A SYCL application using <<backend>>
interoperability is considered to be non-generic SYCL.

Details on the interoperability for a given <<backend>> are available on the
<<backend>> specification document for that <<backend>>.

==== Type traits [code]#backend_traits#

[source,,linenums]
----
include::{header_dir}/interop/typeTraitsBackendTraits.h[lines=4..-1]
----

A series of type traits are provided for <<backend>> interoperability,
defined in the [code]#backend_traits# class.

A specialization of [code]#backend_traits# must be provided for each named
<<backend>> enumerated in the enum class [code]#backend# that is available at
compile time.

  * For each <<sycl-runtime>> class [code]#T# which supports
    <<sycl-application>> interoperability with the <<backend>>, a
    specialization of [code]#input_type# must be defined as the type
    of <<sycl-application>> interoperability <<native-backend-object>>
    associated with [code]#T# for the <<backend>>, specified in the
    <<backend>> specification.
    [code]#input_type# is used when constructing SYCL objects
    from backend specific native objects.
    See the relevant backend specification for details.
  * For each <<sycl-runtime>> class [code]#T# which supports
    <<sycl-application>> interoperability with the <<backend>>, a
    specialization of [code]#return_type# must be defined as the type
    of <<sycl-application>> interoperability <<native-backend-object>>
    associated with [code]#T# for the <<backend>>, specified in the
    <<backend>> specification.
    [code]#return_type# is used when retrieving
    the backend specific native object from a SYCL object.
    See the relevant backend specification for details.
  * For each <<sycl-runtime>> class [code]#T# which supports kernel
    function interoperability with the <<backend>>, a specialization of
    [code]#return_type# within [code]#backend_traits# must be
    defined as the type of the kernel function interoperability
    <<native-backend-object>> associated with [code]#T# for the
    <<backend>>, specified in the backend specification.
    See the relevant backend specification for details.

The type alias [code]#backend_input_t# is provided
to enable less verbose access to the [code]#input_type# type
within [code]#backend_traits# for a specific SYCL object of type [code]#T#.
The type alias [code]#backend_return_t# is provided
to enable less verbose access to the [code]#return_type# type
within [code]#backend_traits# for a specific SYCL object of type [code]#T#.

==== Template function [code]#get_native#

[source,,linenums]
----
include::{header_dir}/interop/templateFunctionGetNative.h[lines=4..-1]
----

For each <<sycl-runtime>> class [code]#T# which supports
<<sycl-application>> interoperability, a specialization of
[code]#get_native# must be defined, which takes an instance of
[code]#T# and returns a <<sycl-application>> interoperability
<<native-backend-object>> associated with [code]#syclObject# which
can be used for <<sycl-application>> interoperability. The lifetime of the
object returned are backend-defined and specified in the backend
specification.

For each <<sycl-runtime>> class [code]#T# which supports kernel
function interoperability, a specialization of [code]#get_native# must
be defined, which takes an instance of [code]#T# and returns the kernel
function interoperability <<native-backend-object>> associated with
[code]#syclObject# which can be used for kernel function
interoperability. The availability and behavior of these template
functions is defined by the <<backend>> specification document.

The [code]#get_native# function
must throw an [code]#exception# with the
[code]#errc::backend_mismatch# error code
if the backend of the SYCL object
doesn't match the target backend.

[[sec:backend-interoperability-make]]
==== Template functions [code]#make_*#

[source,,linenums]
----
include::{header_dir}/interop/templateFunctionMakeX.h[lines=4..-1]
----

For each <<sycl-runtime>> class [code]#T# which supports
<<sycl-application>> interoperability, a specialization of the appropriate
template function [code]#make_{sycl_class}# where
[code]#{sycl_class}# is the class name of [code]#T#, must be
defined, which takes a <<sycl-application>> interoperability
<<native-backend-object>> and constructs and returns an instance of
[code]#T#. The availability and behavior of these template
functions is defined by the <<backend>> specification document.

Overloads of the [code]#make_{sycl_class}# function
which take a SYCL <<context>> object as an argument
must throw an [code]#exception# with the
[code]#errc::backend_mismatch# error code
if the backend of the provided SYCL context
doesn't match the target backend.

[[sec:reference-semantics]]
=== Common reference semantics

Each of the following <<sycl-runtime>> classes:
[code]#accessor#,
[code]#buffer#,
[code]#context#,
[code]#device#,
[code]#device_image#,
[code]#event#,
[code]#host_accessor#,
[code]#host_sampled_image_accessor#,
[code]#host_unsampled_image_accessor#,
[code]#kernel#,
[code]#kernel_id#,
[code]#kernel_bundle#,
[code]#local_accessor#,
[code]#platform#,
[code]#queue#,
[code]#sampled_image#,
[code]#sampled_image_accessor#,
[code]#stream#,
[code]#unsampled_image# and
[code]#unsampled_image_accessor#
must obey the following statements, where [code]#T# is the runtime class type:

  * [code]#T# must be copy constructible and copy assignable on the
    host application and within SYCL kernel functions in the case that
    [code]#T# is a valid kernel argument. Any instance of
    [code]#T# that is constructed as a copy of another instance, via
    either the copy constructor or copy assignment operator, must behave
    as-if it were the original instance and as-if any action performed on it
    were also performed on the original instance and must represent the same
    underlying <<native-backend-object>> as the original instance where
    applicable.
  * [code]#T# must be destructible on the host application and within
    SYCL kernel functions in the case that [code]#T# is a valid kernel
    argument. When any instance of [code]#T# is destroyed, including as
    a result of the copy assignment operator, any behavior specific to
    [code]#T# that is specified as performed on destruction is only
    performed if this instance is the last remaining host copy, in
    accordance with the above definition of a copy.
  * [code]#T# must be move constructible and move assignable on the
    host application and within SYCL kernel functions in the case that T is
    a valid kernel argument. Any instance of T that is constructed as a move
    of another instance, via either the move constructor or move assignment
    operator, must replace the original instance rendering said instance
    invalid and must represent the same underlying <<native-backend-object>> as
    the original instance where applicable.
  * [code]#T# must be equality comparable on the host application.
    Equality between two instances of [code]#T# (i.e. [code]#a == b#) must be true if one instance is a copy of the other and non-equality
    between two instances of [code]#T# (i.e. [code]#a != b#) must
    be true if neither instance is a copy of the other, in accordance with
    the above definition of a copy, unless either instance has become
    invalidated by a move operation. By extension of the requirements above,
    equality on [code]#T# must guarantee to be reflexive (i.e. [code]#a == a#),
    symmetric (i.e. [code]#a == b# implies [code]#b == a# and [code]#a != b#
    implies [code]#b != a#) and transitive (i.e. [code]#a == b && b == c#
    implies [code]#c == a#).
  * A specialization of [code]#std::hash# for [code]#T# must exist
    on the host application that returns a unique value such that if two
    instances of T are equal, in accordance with the above definition, then
    their resulting hash values are also equal and subsequently if two hash
    values are not equal, then their corresponding instances are also not
    equal, in accordance with the above definition.

Some <<sycl-runtime>> classes will have additional behavior associated
with copy, movement, assignment or destruction semantics. If these are
specified they are in addition to those specified above unless stated
otherwise.

Each of the runtime classes mentioned above must provide a common
interface of special member functions in order to fulfill the copy,
move, destruction requirements and hidden friend functions in order to
fulfill the equality requirements.

A hidden friend function is a function first declared via a
[code]#friend# declaration with no additional out of class or namespace
scope declarations. Hidden friend functions are only visible to ADL
(Argument Dependent Lookup) and are hidden from qualified and unqualified
lookup. Hidden friend functions have the benefits of avoiding accidental
implicit conversions and faster compilation.

These common special member functions and hidden friend functions are
described in <<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>> respectively.

[source,,linenums]
----
include::{header_dir}/common-reference.h[lines=4..-1]
----

[[table.specialmembers.common.reference]]
.Common special member functions for reference semantics
[width="100%",options="header",separator="@",cols="1,2"]
|====
@ Special member function @ Description
a@
[source]
----
T(const T& rhs)
----
   a@ Constructs a [code]#T# instance as a copy of the RHS SYCL
      [code]#T# in accordance with the requirements set out above.

a@
[source]
----
T(T&& rhs)
----
   a@ Constructs a SYCL [code]#T# instance as a move of the RHS SYCL
      [code]#T# in accordance with the requirements set out above.

a@
[source]
----
T& operator=(const T& rhs)
----
   a@ Assigns this SYCL [code]#T# instance with a copy of the RHS SYCL
      [code]#T# in accordance with the requirements set out above.

a@
[source]
----
T& operator=(T&& rhs)
----
   a@ Assigns this SYCL [code]#T# instance with a move of the RHS SYCL
      [code]#T# in accordance with the requirements set out above.

a@
[source]
----
~T()
----
   a@ Destroys this SYCL [code]#T# instance in accordance with the
      requirements set out in <<sec:reference-semantics>>. On destruction
      of the last copy, may perform additional lifetime related operations
      required for the underlying <<native-backend-object>> specified in
      the <<backend>> specification document, if this SYCL [code]#T# instance
      was originally constructed using one of the backend interoperability
      [code]#make_*# functions specified in 
      <<sec:backend-interoperability-make>>.
      See the relevant backend specification for details.

|====

[[table.hiddenfriends.common.reference]]
.Common hidden friend functions for reference semantics
[width="100%",options="header",separator="@"]
|====
@ Hidden friend function @ Description
a@
[source]
----
bool operator==(const T& lhs, const T& rhs)
----
   a@ Returns true if this LHS SYCL [code]#T# is equal to the RHS SYCL
      [code]#T# in accordance with the requirements set out above,
      otherwise returns false.

a@
[source]
----
bool operator!=(const T& lhs, const T& rhs)
----
   a@ Returns true if this LHS SYCL [code]#T# is not equal to the RHS
      SYCL [code]#T# in accordance with the requirements set out above,
      otherwise returns false.

|====


[[sec:byval-semantics]]
=== Common by-value semantics

Each of the following <<sycl-runtime>> classes: [code]#id#,
[code]#range#, [code]#item#, [code]#nd_item#,
[code]#h_item#, [code]#group#, [code]#sub_group# and
[code]#nd_range# must follow the following statements, where
[code]#T# is the runtime class type:

  * [code]#T# must be default copy constructible and copy assignable on
    the host application (in the case where T is available on the host) and
    within SYCL kernel functions.
  * [code]#T# must be default destructible on the host application (in
    the case where T is available on the host) and within SYCL kernel
    functions.
  * [code]#T# must be default move constructible and default move
    assignable on the host application (in the case where T is available on
    the host) and within SYCL kernel functions.
  * [code]#T# must be equality comparable on the host application (in
    the case where T is available on the host) and within SYCL kernel
    functions. Equality between two instances of [code]#T# (i.e.
    [code]#a == b#) must be true if the value of all members are equal
    and non-equality between two instances of [code]#T# (i.e.
    [code]#a != b#) must be true if the value of any members are not
    equal, unless either instance has become invalidated by a move
    operation. By extension of the requirements above, equality on
    [code]#T# must guarantee to be reflexive (i.e. [code]#a == a#),
    symmetric (i.e. [code]#a == b# implies [code]#b == a# and [code]#a != b#
    implies [code]#b != a#) and transitive (i.e. [code]#a == b && b == c#
    implies [code]#c == a#).

Some <<sycl-runtime>> classes will have additional behavior associated
with copy, movement, assignment or destruction semantics. If these are
specified they are in addition to those specified above unless stated
otherwise.

Each of the runtime classes mentioned above must provide a common
interface of special member functions and member functions in order to
fulfill the copy, move, destruction and equality requirements,
following the <<rule-of-five>> and the <<rule-of-zero>>.

These common special member functions and hidden friend functions are
described in <<table.specialmembers.common.byval>> and
<<table.hiddenfriends.common.byval>> respectively.

[source,,linenums]
----
include::{header_dir}/common-byval.h[lines=4..-1]
----

[[table.specialmembers.common.byval]]
.Common special member functions for by-value semantics
[width="100%",options="header",separator="@",cols="2,1"]
|====
@ Special member function _(see <<rule-of-five>> and <<rule-of-zero>>)_ @ Description
a@
[source]
----
T(const T& rhs);
----
   a@ Copy constructor.

a@
[source]
----
T(T&& rhs);
----
   a@ Move constructor.

a@
[source]
----
T& operator=(const T& rhs);
----
   a@ Copy assignment operator.

a@
[source]
----
T& operator=(T&& rhs);
----
   a@ Move assignment operator.

a@
[source]
----
~T();
----
   a@ Destructor.

|====

[[table.hiddenfriends.common.byval]]
.Common hidden friend functions for by-value semantics
[width="100%",options="header",separator="@",cols="1,1"]
|====
@ Hidden friend function @ Description
a@
[source]
----
bool operator==(const T& lhs, const T& rhs)
----
   a@ Returns true if this LHS SYCL [code]#T# is equal to the RHS SYCL [code]#T# in accordance with the requirements set out above, otherwise returns false.

a@
[source]
----
bool operator!=(const T& lhs, const T& rhs)
----
   a@ Returns true if this LHS SYCL [code]#T# is not equal to the RHS SYCL [code]#T# in accordance with the requirements set out above, otherwise returns false.

|====

=== Properties

Each of the following <<sycl-runtime>> classes:
[code]#accessor#,
[code]#buffer#,
[code]#host_accessor#,
[code]#host_sampled_image_accessor#,
[code]#host_unsampled_image_accessor#,
[code]#context#,
[code]#local_accessor#,
[code]#queue#,
[code]#sampled_image#,
[code]#sampled_image_accessor#,
[code]#stream#,
[code]#unsampled_image#,
[code]#unsampled_image_accessor# and
[code]#usm_allocator#
provide an optional parameter in each of
their constructors to provide a [code]#property_list# which
contains zero or more properties. Each of those properties augments
the semantics of the class with a particular feature. Each of those
classes must also provide [code]#has_property# and
[code]#get_property# member functions for querying for a
particular property.

The listing below illustrates the usage of various buffer properties,
described in <<sec:buffer-properties>>.

The example illustrates how using properties does not affect the type
of the object, thus, does not prevent the usage of SYCL objects in
containers.

[source,,linenums]
----
include::{code_dir}/propertyExample.cpp[lines=4..-1]
----

Each property is represented by a unique class and an instance of a property
is an instance of that type. Some properties can be default constructed
while others will require an argument on construction. A property may be
applicable to more than one class, however some properties may not be
compatible with each other. See the requirements for the properties of the
SYCL [code]#buffer# class, SYCL [code]#unsampled_image# class and
SYCL [code]#sampled_image# class in <<table.properties.buffer>>
and <<table.properties.image>> respectively.

Properties can be passed to a <<sycl-runtime>> class
via an instance of [code]#property_list#.
These properties get tied to the <<sycl-runtime>> class instance
and copies of the object will contain the same properties.

A SYCL implementation or a <<backend>> may provide additional properties
other than those defined here, provided they are defined in accordance with
the requirements described in <<sec:headers-and-namespaces>>.

==== Properties interface

Each of the runtime classes mentioned above must provide a common
interface of member functions in order to fulfill the property
interface requirements.

A synopsis of the common properties interface, the SYCL
[code]#property_list# class and the SYCL property classes is provided
below. The member functions of the common properties interface are listed in
<<table.members.propertyinterface>>. The constructors of the SYCL
[code]#property_list# class are listed in
<<table.constructors.propertylist>>.

[source,,linenums]
----
include::{header_dir}/properties.h[lines=4..-1]
----


[[table.traits.properties]]
.Traits for properties
[width="100%",options="header",separator="@"]
|====
@ Traits @ Description
a@
[source]
----
template <typename Property> struct is_property
----
   a@ An explicit specialization of [code]#is_property# that inherits
      from [code]#std::true_type# must be provided for each property,
      where [code]#Property# is the class defining the property.
      This includes both standard properties described in this
      specification and any additional non-standard properties defined by
      an implementation. All other specializations of
      [code]#is_property# must inherit from
      [code]#std::false_type#.
a@
[source,c++]
----
template <typename Property>
inline constexpr bool is_property_v;
----
   a@ Variable containing value of [code]#is_property<Property>#.

a@
[source]
----
template <typename Property, SyclObject> struct is_property_of
----
   a@ An explicit specialization of [code]#is_property_of# that
      inherits from [code]#std::true_type# must be provided for each
      property that can be used in constructing a given SYCL class, where
      [code]#Property# is the class defining the property and
      [code]#SyclObject# is the SYCL class. This includes both
      standard properties described in this specification and any
      additional non-standard properties defined by an implementation. All
      other specializations of [code]#is_property_of# must inherit
      from [code]#std::false_type#.
a@
[source,c++]
----
template <typename Property, SyclObject>
inline constexpr bool is_property_of_v;
----
   a@ Variable containing value of [code]#is_property_of<Property, SyclObject>#.

|====



[[table.members.propertyinterface]]
.Common member functions of the SYCL [code]#property# interface
[width="100%",options="header",separator="@",cols="2,3"]
|====
@ Member function @ Description
a@
[source]
----
template <typename Property> bool has_property() const noexcept
----
   a@ Returns true if [code]#T# was constructed with the property
      specified by [code]#Property#. Returns false if it was
      not.

a@
[source]
----
template <typename Property> Property get_property() const
----
   a@ Returns a copy of the property of type [code]#Property#
      that [code]#T# was constructed with. Must throw an
      [code]#exception# with the [code]#errc::invalid#
      error code if [code]#T# was not constructed with the
      [code]#Property# property.

|====



[[table.constructors.propertylist]]
.Constructors of the SYCL [code]#property_list# class
[width="100%",options="header",separator="@",cols="2,3"]
|====
@ Constructor @ Description
a@
[source]
----
template <typename... PropertyN> property_list(PropertyN... props)
----
   a@ Available only when: [code]#is_property<property>::value#
      evaluates to [code]#true# where [code]#property# is each
      property in [code]#PropertyN#.

Construct a SYCL [code]#property_list# with zero or more properties.

|====



== SYCL runtime classes


[[sec:device-selection]]
=== Device selection

Since a system can have several SYCL-compatible devices attached, it
is useful to have a way to select a specific device or a set of
devices to construct a specific object such as a
[code]#device# (see <<sec:device-class>>) or a
[code]#queue# (see <<sec:interface.queue.class>>), or
perform some operations on a device subset.

Device selection is done either by already having a specific instance
of a [code]#device# (see <<sec:device-class>>) or by
providing a <<device-selector>> which is a ranking function that will give
an integer ranking value to all the devices on the system.


[[sec:device-selector]]
==== Device selector

The interface for a <<device-selector>> is any object that meets the C++ named
requirement [code]#Callable#, taking a parameter of type [code]#const device &#
and returning a value that is implicitly convertible to [code]#int#.

At any point where the <<sycl-runtime>> needs to select a SYCL [code]#device#
using a <<device-selector>>, the system queries all
<<root-device, root devices>> from all <<backend, SYCL backends>> in the
system, calls the <<device-selector>> on each device and selects the one
which returns the highest score. If the highest value is strictly negative no
device is selected.

In places where only one device has to be picked and the high score is
obtained by more than one device, then one of the tied devices will be
returned, but which one is not defined and may depend on enumeration
order, for example, outside the control of the SYCL runtime.

Some predefined <<device-selector,device selectors>> are provided by the system as
described on <<table.device.selectors>> in a header file with
some definition similar to the following:


[[table.device.selectors]]
.Standard device selectors included with all SYCL implementations
[width="100%",options="header",separator="@",cols="50%,50%"]
|====
@ SYCL device selectors @ Description
a@
[source]
----
default_selector_v
----
   a@ Select a SYCL [code]#device# from any supported <<backend>>
      based on an implementation-defined heuristic. Since all
      implementations must support at least one device, this selector
      must always return a device.

[NOTE]
====
Implementations may choose to return an emulated device (with
[code]#aspect::emulated#) as a fallback if there is no physical device
available on the system.
====

a@
[source]
----
gpu_selector_v
----
   a@ Select a SYCL [code]#device# from any supported <<backend>>
      for which the device type is
      [code]#info::device_type::gpu#. The SYCL class
      constructor using it must throw an [code]#exception#
      with the [code]#errc::runtime# error code if no
      device matching this requirement can be found.

a@
[source]
----
accelerator_selector_v
----
   a@ Select a SYCL [code]#device# from any supported <<backend>>
      for which the device type is
      [code]#info::device_type::accelerator#. The SYCL
      class constructor using it must throw an [code]#exception#
      with the [code]#errc::runtime# error code if no device
      matching this requirement can be found.

a@
[source]
----
cpu_selector_v
----
   a@ Select a SYCL [code]#device# from any supported <<backend>>
      for which the device type is
      [code]#info::device_type::cpu#. The SYCL class
      constructor using it must throw an [code]#exception#
      with the [code]#errc::runtime# error code
      if no device matching this requirement can be found.

a@
[source]
----
__unspecified_callable__
aspect_selector(const std::vector<aspect>& aspectList,
                const std::vector<aspect>& denyList = {});

template <typename... AspectList>
__unspecified_callable__ aspect_selector(AspectList... aspectList);

template <aspect... AspectList> __unspecified_callable__ aspect_selector();
----
a@ The free function [code]#aspect_selector# has several overloads,
each of which returns a selector object that selects a
SYCL [code]#device# from any supported <<backend>>
which contains all the requested aspects,
i.e. for the specific device [code]#dev#
and each aspect [code]#devAspect# from [code]#aspectList#
[code]#dev.has(devAspect)# equals [code]#true#.
If no aspects are passed in,
the generated selector behaves like [code]#default_selector#.

Required aspects can be passed in as a vector, as function arguments,
or as template parameters, depending on the function overload.
The function overload that takes [code]#aspectList# as a vector
takes another vector argument [code]#denyList#
where the user can specify all the aspects that have to be avoided,
i.e. for the specific device [code]#dev#
and each aspect [code]#devAspect# from [code]#denyList#
[code]#dev.has(devAspect)# equals [code]#false#.

The SYCL class constructor using the generated selector
must throw an [code]#exception# with the [code]#errc::runtime# error code
if no device matching this requirement can be found.
There are multiple overloads of this function,
please refer to <<header:device-selector>> for full definitions
and to <<example:aspect-selector>> for examples.

|====


// Interface of the device selector
[[header:device-selector]]
[source,,linenums]
----
include::{header_dir}/deviceSelector.h[lines=4..-1]
----

Typical examples of default and user-provided <<device-selector,device selectors>> could be:

[source,,linenums]
----
sycl::device my_gpu { sycl::gpu_selector_v };

sycl::queue my_accelerator { sycl::accelerator_selector_v };

int prefer_my_vendor(const sycl::device& d) {
  // Return 1 if the vendor name is "MyVendor" or 0 else.
  // 0 does not prevent another device to be picked as a second choice
  return d.get_info<info::device::vendor>() == "MyVendor";
}

// Get the preferred device or another one if not available
sycl::device preferred_device { prefer_my_vendor };

// This throws if there is no such device in the system
sycl::queue half_precision_controller {
  // Can use a lambda as a device ranking function.
  // Returns a negative number to fail in the case there is no such device
  [] (auto& d) { return d.has(sycl::aspect::fp16) ? 1 : -1; }
};

// To ease porting SYCL 1.2.1 code, there are types whose
// construction leads to the equivalent predefined device selector
sycl::queue my_old_style_gpu { sycl::gpu_selector {} };
----

Examples of using [code]#aspect_selector#:

[[example:aspect-selector]]
[source,,linenums]
----
using namespace sycl; // (optional) avoids need for "sycl::" before SYCL names

// Unrestrained selection, equivalent to default_selector
auto dev0 = device{aspect_selector()};

// Pass aspects in a vector
// Only accept CPUs that support half
auto dev1 = device{aspect_selector(std::vector{aspect::cpu, aspect::fp16})};

// Pass aspects without a vector
// Only accept GPUs that support half
auto dev2 = device{aspect_selector(aspect::gpu, aspect::fp16)};

// Pass aspects as compile-time parameters
// Only accept devices that can be debugged on host and support half
auto dev3 = device{aspect_selector<aspect::host_debuggable, aspect::fp16>()};

// Pass aspects in an allowlist and a denylist
// Only accept devices that support half and double floating point precision,
// but exclude emulated devices and devices of type "custom"
auto dev4 = device{aspect_selector(
   std::vector{aspect::fp16, aspect::fp64},
   std::vector{aspect::emulated, aspect::custom}
)};
----

[NOTE]
====
In SYCL 1.2.1 the predefined device selectors were actually types
that had to be instantiated to be used. Now they are just
instances. To simplify porting code using the old type
instantiations, a backward-compatible API is still provided, such as
[code]#sycl::default_selector#. The new predefined device
selectors have their new names appended with "_v" to avoid
conflicts, thus following the naming style used by traits in the {cpp}
standard library. There is no requirement for the implementation to
have for example [code]#sycl::gpu_selector_v# being an instance
of [code]#sycl::gpu_selector#.
====

NOTE: Implementation note: the SYCL API might rely on SFINAE or {cpp20}
concepts to resolve some ambiguity in constructors with default
parameters.


[[sec:platform-class]]
=== Platform class

The SYCL [code]#platform# class encapsulates a single SYCL platform on
which SYCL kernel functions may be executed. A SYCL platform must be
associated with a single <<backend>>.

A SYCL [code]#platform# is also associated with one or more SYCL
[code]#devices# associated with the same <<backend>>.

All member functions of the [code]#platform# class are synchronous and
errors are handled by throwing synchronous SYCL exceptions.

The execution environment for a SYCL application has a fixed number of
platforms which does not vary as the application executes.  The application
can get a list of all these platforms via [code]#platform::get_platforms()#,
and the order of the platform objects is the same each time the application
calls that function.  The [code]#platform# class also provides constructors,
but constructing a new [code]#platform# instance merely creates a new object
that is a copy of one of the objects returned by
[code]#platform::get_platforms()#.

The SYCL [code]#platform# class provides the common reference semantics
(see <<sec:reference-semantics>>).

==== Platform interface

A synopsis of the SYCL [code]#platform# class is provided below. The
constructors, member functions and static member functions of the SYCL
[code]#platform# class are listed in
<<table.constructors.platform>>, <<table.members.platform>> and
<<table.staticmembers.platform>> respectively. The additional common
special member functions and common member functions are listed in
<<sec:reference-semantics>> in
<<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>> respectively.

// Interface of platform class
[source,,linenums]
----
include::{header_dir}/platform.h[lines=4..-1]
----


[[table.constructors.platform]]
.Constructors of the SYCL [code]#platform# class
// Jon: Dims{6.7cm}{8.3cm}
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
platform()
----
   a@ Constructs a SYCL [code]#platform# instance that is a copy of the
      [code]#platform# which contains the device returned by
      [code]#default_selector_v#.

a@
[source]
----
template <typename DeviceSelector> explicit platform(const DeviceSelector&)
----
   a@ Constructs a SYCL [code]#platform# instance that is a copy of the
      [code]#platform# which contains the device returned by the
      <<device-selector>> parameter.

|====



[[table.members.platform]]
.Member functions of the SYCL [code]#platform# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
backend get_backend() const noexcept
----
   a@ Returns a [code]#backend# identifying the <<backend>> associated
      with this [code]#platform#.

a@
[source]
----
template <typename Param> typename Param::return_type get_info() const
----
   a@ Queries this SYCL [code]#platform# for information requested by
      the template parameter [code]#Param#.
      The type alias [code]#Param::return_type# must be defined in
      accordance with the info parameters in <<table.platform.info>> to
      facilitate returning the type associated with the [code]#Param#
      parameter.

a@
[source]
----
template <typename Param> typename Param::return_type get_backend_info() const
----
   a@ Queries this SYCL [code]#platform# for <<backend>>-specific
      information requested by the template parameter [code]#Param#.
      The type alias [code]#Param::return_type# must be defined in
      accordance with the <<backend>> specification.
      Must throw an [code]#exception# with the [code]#errc::backend_mismatch#
      error code if the <<backend>> that corresponds with [code]#Param# is different
      from the <<backend>> that is associated with this [code]#platform#.

a@
[source]
----
bool has(aspect asp) const
----
   a@ Returns true if all of the SYCL [code]#devices# associated with this
      SYCL [code]#platform# have the given <<aspect>>.

a@
[source]
----
bool has_extension(const std::string& extension) const
----
   a@ Deprecated, use [code]#has()# instead.

Returns true if this SYCL [code]#platform# supports the extension queried by the [code]#extension# parameter. A SYCL [code]#platform# can only support an extension if all associated SYCL [code]#devices# support that extension.

a@
[source]
----
std::vector<device>
get_devices(info::device_type deviceType = info::device_type::all) const
----
   a@ Returns a [code]#std::vector# containing all the
      <<root-device, root devices>> associated with this SYCL [code]#platform#
      which have the device type encapsulated by [code]#deviceType#.

|====



[[table.staticmembers.platform]]
.Static member functions of the SYCL [code]#platform# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Static member function @ Description
a@
[source]
----
static std::vector<platform> get_platforms()
----
   a@ Returns a [code]#std::vector# containing all SYCL
      [code]#platforms# from all <<backend, SYCL backends>> available in the system.

|====



==== Platform information descriptors

A <<platform>> can be queried for information using the [code]#get_info#
member function of the [code]#platform# class, specifying one of the info
parameters in [code]#info::platform#.  The possible values for each info
parameter and any restrictions are defined in the specification of the
<<backend>> associated with the <<platform>>. All info parameters in
[code]#info::platform# are specified in <<table.platform.info>> and the
synopsis for [code]#info::platform# is described in
<<appendix.platform.descriptors>>.


[[table.platform.info]]
.Platform information descriptors
// Jon: Dims{5cm}{2cm}{7cm}
[width="100%",options="header",separator="@",cols="37%,19%,44%"]
|====
@ Platform descriptors @ Return type @ Description
a@
[source]
----
info::platform::version
----

    @ [.code]#std::string#
   a@ Returns a backend-defined <<platform>> version.

a@
[source]
----
info::platform::name
----

    @ [.code]#std::string#
   a@ Returns the name of the <<platform>>.

a@
[source]
----
info::platform::vendor
----

    @ [.code]#std::string#
   a@ Returns the name of the vendor providing the <<platform>>.

a@
[source]
----
info::platform::extensions
----

    @ [.code]#std::vector<std::string>#
   a@ Deprecated, use [code]#device::get_info()# with
      [code]#info::device::aspects# instead.

Returns the extensions supported by the <<platform>>.

|====



[[sec:interface.context.class]]
=== Context class

The <<context>> class represents a SYCL <<context>>. A <<context>>
represents the runtime data structures and state required by a <<backend>>
API to interact with a group of devices associated with a platform.

The SYCL [code]#context# class provides the common reference semantics
(see <<sec:reference-semantics>>).


==== Context interface

The constructors and member functions of the SYCL [code]#context# class
are listed in <<table.constructors.context>> and
<<table.members.context>>, respectively. The additional common special
member functions and common member functions are listed in
<<sec:reference-semantics>> in
<<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>>, respectively.

All member functions of the <<context>> class are synchronous and errors
are handled by throwing synchronous SYCL exceptions.

All constructors of the SYCL <<context>> class will construct an
instance associated with a particular <<backend>>, determined by the
constructor parameters or, in the case of the default constructor, the
SYCL [code]#device# produced by the
[code]#default_selector_v#.

A SYCL [code]#context# can optionally be constructed with an
[code]#async_handler# parameter. In this case the
[code]#async_handler# is used to report asynchronous SYCL exceptions,
as described in <<error-handling>>.

Information about a SYCL <<context>> may be queried through the
[code]#get_info()# member function.

// Interface for class: context
[source,,linenums]
----
include::{header_dir}/context.h[lines=4..-1]
----


[[table.constructors.context]]
.Constructors of the SYCL [code]#context# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
explicit context(async_handler asyncHandler = {})
----
   a@ Constructs a SYCL [code]#context# instance using an instance of
      [code]#default_selector_v# to select the associated SYCL
      [code]#platform# and [code]#device(s)#. The <<device,devices>> that
      are associated with the constructed <<context>> are implementation-defined
      but must contain the <<device>> chosen by the device selector. The
      constructed SYCL [code]#context# will use the [code]#asyncHandler#
      parameter to handle exceptions.

a@
[source]
----
explicit context(const device& dev, async_handler asyncHandler = {})
----
   a@ Constructs a SYCL [code]#context# instance using the [code]#dev# parameter as the associated SYCL [code]#device# and the SYCL [code]#platform# associated with the [code]#dev# parameter as the associated SYCL [code]#platform#. The constructed SYCL [code]#context# will use the [code]#asyncHandler# parameter to handle exceptions.

a@
[source]
----
explicit context(const std::vector<device>& deviceList,
                 async_handler asyncHandler = {})
----
   a@ Constructs a SYCL [code]#context# instance using the SYCL [code]#device(s)# in the [code]#deviceList# parameter as the associated SYCL [code]#device(s)# and the SYCL [code]#platform# associated with each SYCL [code]#device# in the [code]#deviceList# parameter as the associated SYCL [code]#platform#. This requires that all SYCL [code]#devices# in the [code]#deviceList# parameter have the same associated SYCL [code]#platform#. The constructed SYCL [code]#context# will use the [code]#asyncHandler# parameter to handle exceptions.

|====



[[table.members.context]]
.Member functions of the [code]#context# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
backend get_backend() const noexcept
----
   a@ Returns a [code]#backend# identifying the <<backend>> associated
      with this [code]#context#.

a@
[source]
----
template <typename Param> typename Param::return_type get_info() const
----
   a@ Queries this SYCL [code]#context# for information requested by the
      template parameter [code]#Param#.
      The type alias [code]#Param::return_type# must be defined in
      accordance with the info parameters in <<table.context.info>> to
      facilitate returning the type associated with the [code]#Param#
      parameter.

a@
[source]
----
template <typename Param> typename Param::return_type get_backend_info() const
----
   a@ Queries this SYCL [code]#context# for <<backend>>-specific information
      requested by the template parameter [code]#Param#.
      The type alias [code]#Param::return_type# must be defined in
      accordance with the <<backend>> specification.
      Must throw an [code]#exception# with the [code]#errc::backend_mismatch#
      error code if the <<backend>> that corresponds with [code]#Param# is different
      from the <<backend>> that is associated with this [code]#context#.

a@
[source]
----
platform get_platform() const
----
   a@ Returns the SYCL [code]#platform# that is associated with this SYCL [code]#context#. The value returned must be equal to that returned by [code]#get_info<info::context::platform>()#.

a@
[source]
----
std::vector<device> get_devices() const
----
   a@ Returns a [code]#std::vector# containing all SYCL [code]#devices# that are associated with this SYCL [code]#context#. The value returned must be equal to that returned by [code]#get_info<info::context::devices>()#.

|====



==== Context information descriptors

A <<context>> can be queried for information using the [code]#get_info#
member function of the [code]#context# class, specifying one of the info
parameters in [code]#info::context#.  The possible values for each info
parameter and any restrictions are defined in the specification of the
<<backend>> associated with the <<context>>. All info parameters in
[code]#info::context# are specified in <<table.context.info>> and the synopsis
for [code]#info::context# is described in <<appendix.context.descriptors>>.


[[table.context.info]]
.Context information descriptors
// Jon: Dims{5cm}{4.4cm}{5cm}
[width="100%",options="header",separator="@",cols="37%,19%,44%"]
|====
@ Context Descriptors @ Return type @ Description
a@
[source]
----
info::context::platform
----

    @ [.code]#platform#
   a@ Returns the <<platform>> associated with the <<context>>.

a@
[source]
----
info::context::devices
----

    @ [.code]#std::vector<device>#
   a@ Returns all of the <<device,devices>> associated with the <<context>>.

a@
[source]
----
info::context::atomic_memory_order_capabilities
----

    @ [.code]#std::vector<memory_order>#
   a@ This query applies only to the capabilities of atomic operations that are
      applied to memory that can be concurrently accessed by multiple devices
      in the context.  If these capabilities are not uniform across all devices
      in the context, the query reports only the capabilities that are common
      for all devices.

Returns the set of memory orders supported by these atomic operations.  When a
context returns a "stronger" memory order in this set, it must also return all
"weaker" memory orders.  (See <<sec:memory-ordering>> for a definition of
"stronger" and "weaker" memory orders.) The memory orders
[code]#memory_order::acquire#, [code]#memory_order::release#, and
[code]#memory_order::acq_rel# are all the same strength.  If a context returns
one of these, it must return them all.

At a minimum, each context must support [code]#memory_order::relaxed#.

a@
[source]
----
info::context::atomic_fence_order_capabilities
----

    @ [.code]#std::vector<memory_order>#
   a@ This query applies only to the capabilities of [code]#atomic_fence# when
      applied to memory that can be concurrently accessed by multiple devices
      in the context.  If these capabilities are not uniform across all devices
      in the context, the query reports only the capabilities that are common
      for all devices.

Returns the set of memory orders supported by these [code]#atomic_fence#
operations.  When a context returns a "stronger" memory order in this set, it
must also return all "weaker" memory orders.  (See <<sec:memory-ordering>> for
a definition of "stronger" and "weaker" memory orders.)

At a minimum, each context must support [code]#memory_order::relaxed#,
[code]#memory_order::acquire#, [code]#memory_order::release#, and
[code]#memory_order::acq_rel#.

a@
[source]
----
info::context::atomic_memory_scope_capabilities
----

    @ [.code]#std::vector<memory_scope>#
   a@ Returns the set of memory scopes supported by atomic operations on all
      devices in the context.  When a context returns a "wider" memory scope
      in this set, it must also return all "narrower" memory scopes.  (See
      <<sec:memory-scope>> for a definition of "wider" and "narrower" scopes.)
      At a minimum, each context must support [code]#memory_scope::work_item#,
      [code]#memory_scope::sub_group#, and [code]#memory_scope::work_group#.

a@
[source]
----
info::context::atomic_fence_scope_capabilities
----

    @ [.code]#std::vector<memory_scope>#
   a@ Returns the set of memory orderings supported by [code]#atomic_fence# on
      all devices in the context.  When a context returns a "wider" memory
      scope in this set, it must also return all "narrower" memory scopes.
      (See <<sec:memory-scope>> for a definition of "wider" and "narrower"
      scopes.) At a minimum, each context must support
      [code]#memory_scope::work_item#, [code]#memory_scope::sub_group#, and
      [code]#memory_scope::work_group#.

|====



[[sec:context-properties]]
==== Context properties

The [code]#property_list# constructor parameters are present for extensibility.

// \input{device_class}
// %%%%%%%%%%%%%%%%%%%%%%%%%%%% begin device_class %%%%%%%%%%%%%%%%%%%%%%%%%%%%

[[sec:device-class]]
=== Device class

The SYCL [code]#device# class encapsulates a single SYCL device on
which <<kernel,kernels>> can be executed.

All member functions of the [code]#device# class are synchronous and
errors are handled by throwing synchronous SYCL exceptions.

The execution environment for a SYCL application has a fixed number of
<<root-device, root devices>> which does not vary as the application executes.
The application can get a list of all these devices via
[code]#device::get_devices()#, and the order of the device objects is the same
each time the application calls that function (assuming the parameter to that
function is the same for each call).  The [code]#device# class also provides
constructors, but constructing a new [code]#device# instance merely creates a
new object that is a copy of one of the objects returned by
[code]#device::get_devices()#.

A SYCL [code]#device# can be partitioned into multiple SYCL devices, by
calling the [code]#create_sub_devices()# member function template. The
resulting SYCL [code]#devices# are considered sub devices, and it is
valid to partition these sub devices further. The range of support for this
feature is <<backend>> and device specific and can be queried for through
[code]#get_info()#.

The SYCL [code]#device# class provides the common reference semantics
(see <<sec:reference-semantics>>).

==== Device interface

A synopsis of the SYCL [code]#device# class is provided below. The
constructors, member functions and static member functions of the SYCL
[code]#device# class are listed in
<<table.constructors.device>>, <<table.members.device>> and
<<table.staticmembers.device>> respectively. The additional common special
member functions and common member functions are listed in
<<sec:reference-semantics>> in
<<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>>, respectively.

// Interface of the device class
[source,,linenums]
----
include::{header_dir}/device.h[lines=4..-1]
----


[[table.constructors.device]]
.Constructors of the SYCL [code]#device# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
device()
----
   a@ Constructs a SYCL [code]#device# instance that is a copy of the device
      returned by [code]#default_selector_v#.

a@
[source]
----
template <typename DeviceSelector> explicit device(const DeviceSelector&)
----
   a@ Constructs a SYCL [code]#device# instance that is a copy of the device
      returned by the <<device-selector>> parameter.

|====



[[table.members.device]]
.Member functions of the SYCL [code]#device# class
[width="100%",options="header",separator="@",cols="58%,42%"]
|====
@ Member function @ Description
a@
[source]
----
backend get_backend() const noexcept
----
   a@ Returns a [code]#backend# identifying the <<backend>> associated
      with this [code]#device#.

a@
[source]
----
platform get_platform() const
----
   a@ Returns the associated SYCL [code]#platform#.
      The value returned must be equal to that returned by [code]#get_info<info::device::platform>()#.

a@
[source]
----
bool is_cpu() const
----
   a@ Returns the same value as [code]#has(aspect::cpu)#.  See <<table.device.aspect>>.

a@
[source]
----
bool is_gpu() const
----
   a@ Returns the same value as [code]#has(aspect::gpu)#.  See <<table.device.aspect>>.

a@
[source]
----
bool is_accelerator() const
----
   a@ Returns the same value as [code]#has(aspect::accelerator)#.  See <<table.device.aspect>>.

a@
[source]
----
template <typename Param> typename Param::return_type get_info() const
----
   a@ Queries this SYCL [code]#device# for information requested by the
      template parameter [code]#Param#.
      The type alias [code]#Param::return_type# must be defined in
      accordance with the info parameters in <<table.device.info>> to
      facilitate returning the type associated with the [code]#Param#
      parameter.

a@
[source]
----
template <typename Param> typename Param::return_type get_backend_info() const
----
   a@ Queries this SYCL [code]#device# for <<backend>>-specific information
      requested by the template parameter [code]#Param#.
      The type alias [code]#Param::return_type# must be defined in
      accordance with the <<backend>> specification.
      Must throw an [code]#exception# with the [code]#errc::backend_mismatch#
      error code if the <<backend>> that corresponds with [code]#Param# is different
      from the <<backend>> that is associated with this [code]#device#.

a@
[source]
----
bool has(aspect asp) const
----
   a@ Returns true if this SYCL [code]#device# has the given <<aspect>>.
      SYCL applications can use this member function to determine which
      optional features this device supports (if any).

a@
[source]
----
bool has_extension(const std::string& extension) const
----
   a@ Deprecated, use [code]#has()# instead.

Returns true if this SYCL [code]#device# supports the extension queried by the [code]#extension# parameter.

a@
[source]
----
template <info::partition_property Prop>
std::vector<device> create_sub_devices(size_t count) const
----
   a@ Available only when [code]#Prop# is
      [code]#info::partition_property::partition_equally#.  Returns a
      [code]#std::vector# of sub devices partitioned from this SYCL
      [code]#device# based on the [code]#count# parameter.  The returned vector
      contains as many sub devices as can be created such that each sub device
      contains [code]#count# compute units.  If the device's total number of
      compute units (as returned by [code]#info::device::max_compute_units#) is
      not evenly divided by [code]#count#, then the remaining compute units are
      not included in any of the sub devices.

If this SYCL [code]#device# does not support
[code]#info::partition_property::partition_equally# an [code]#exception# with
the [code]#errc::feature_not_supported# error code must be thrown.  If
[code]#count# exceeds the total number of compute units in the device, an
[code]#exception# with the [code]#errc::invalid# error code must be thrown.

a@
[source]
----
template <info::partition_property Prop>
std::vector<device> create_sub_devices(const std::vector<size_t>& counts) const
----
   a@ Available only when [code]#Prop# is
      [code]#info::partition_property::partition_by_counts#.  Returns a
      [code]#std::vector# of sub devices partitioned from this SYCL
      [code]#device# based on the [code]#counts# parameter.  For each non-zero
      value _M_ in the [code]#counts# vector, a sub device with _M_ compute
      units is created.

If the SYCL [code]#device# does not support
[code]#info::partition_property::partition_by_counts# an [code]#exception# with
the [code]#errc::feature_not_supported# error code must be thrown.  If the
number of non-zero values in [code]#counts# exceeds the device's maximum
number of sub devices (as returned by
[code]#info::device::partition_max_sub_devices#) or if the total of all the
values in the [code]#counts# vector exceeds the total number of compute units
in the device (as returned by [code]#info::device::max_compute_units#), an
[code]#exception# with the [code]#errc::invalid# error code must be thrown.

a@
[source]
----
template <info::partition_property Prop>
std::vector<device>
create_sub_devices(info::partition_affinity_domain domain) const
----
// WARNING: The Asciidoctor PDF renderer seems to be unable to generate a table
// where any single row is taller than a page.  This row is already close to
// the page limit.  If you add any more text in this cell, check the PDF render
// to see if any of the text is cut off at the bottom of the page.  If so, try
// making this column wider so that this row still fits on a page.

   a@ Available only when [code]#Prop# is
      [code]#info::partition_property::partition_by_affinity_domain#.  Returns
      a [code]#std::vector# of sub devices partitioned from this SYCL
      [code]#device# by affinity domain based on the [code]#domain# parameter,
      which must be one of the following values:

* [code]#info::partition_affinity_domain::numa#: Split the device into
  sub devices comprised of compute units that share a NUMA node.

* [code]#info::partition_affinity_domain::L4_cache#: Split the device into
  sub devices comprised of compute units that share a level 4 data cache.

* [code]#info::partition_affinity_domain::L3_cache#: Split the device into
  sub devices comprised of compute units that share a level 3 data cache.

* [code]#info::partition_affinity_domain::L2_cache#: Split the device into
  sub devices comprised of compute units that share a level 2 data cache.

* [code]#info::partition_affinity_domain::L1_cache#: Split the device into
  sub devices comprised of compute units that share a level 1 data cache.

* [code]#info::partition_affinity_domain::next_partitionable#: Split the device
  along the next partitionable affinity domain.  The implementation shall find
  the first level along which the device or sub device may be further
  subdivided in the order [code]#numa#, [code]#L4_cache#, [code]#L3_cache#,
  [code]#L2_cache#, [code]#L1_cache#, and partition the device into sub devices
  comprised of compute units that share memory subsystems at this level.  The
  user may determine what happened via
  [code]#info::device::partition_type_affinity_domain#.

If the SYCL [code]#device# does not support
[code]#info::partition_property::partition_by_affinity_domain# or the
SYCL [code]#device# does not support the
[code]#info::partition_affinity_domain# provided, an [code]#exception#
with the [code]#errc::feature_not_supported# error code must be thrown.

|====



[[table.staticmembers.device]]
.Static member functions of the SYCL [code]#device# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Static member function @ Description
a@
[source]
----
static std::vector<device>
get_devices(info::device_type deviceType = info::device_type::all)
----
   a@ Returns a [code]#std::vector# containing all the
      <<root-device, root devices>> from all <<backend, SYCL backends>>
      available in the system which have the device type encapsulated by
      [code]#deviceType#.

|====



==== Device information descriptors

A <<device>> can be queried for information using the [code]#get_info#
member function of the [code]#device# class, specifying one of the info
parameters in [code]#info::device#.  The possible values for each info
parameter and any restriction are defined in the specification of the
<<backend>> associated with the <<device>>. All info parameters in
[code]#info::device# are specified in <<table.device.info>> and the synopsis
for [code]#info::device# is described in <<appendix.device.descriptors>>.


[[table.device.info]]
.Device information descriptors
// Jon: Dims{5cm}{2.5cm}{6.5cm}
[width="100%",options="header",separator="@",cols="37%,19%,44%"]
|====
@ Device descriptors @ Return type @ Description
a@
[source]
----
info::device::device_type
----

    @ [.code]#info::device_type#
   a@ Returns the device type associated with the <<device>>. May not return
      [code]#info::device_type::all#.

a@
[source]
----
info::device::vendor_id
----

    @ [.code]#uint32_t#
   a@ Returns a unique vendor device identifier.

a@
[source]
----
info::device::max_compute_units
----

    @ [.code]#uint32_t#
   a@ Returns the number of parallel compute units available to the
      <<device>>. The minimum value is 1.

a@
[source]
----
info::device::max_work_item_dimensions
----

    @ [.code]#uint32_t#
   a@ Returns the maximum dimensions that specify the global and local work-item IDs used by the data parallel execution model.
      The minimum value is 3 if this SYCL [code]#device# is not of device type [code]#info::device_type::custom#.

a@
[source]
----
info::device::max_work_item_sizes\<1>
----

    @ [.code]#range<1>#
   a@ Returns the maximum number of work-items that are permitted in a
      work-group for a kernel running in a one-dimensional index space. The
      minimum value is latexmath:[(1)] for [code]#devices# that are not of
      device type [code]#info::device_type::custom#.

a@
[source]
----
info::device::max_work_item_sizes\<2>
----

    @ [.code]#range<2>#
   a@ Returns the maximum number of work-items that are permitted in each
      dimension of a work-group for a kernel running in a two-dimensional index
      space. The minimum value is latexmath:[(1,1)] for [code]#devices# that
      are not of device type [code]#info::device_type::custom#.

a@
[source]
----
info::device::max_work_item_sizes\<3>
----

    @ [.code]#range<3>#
   a@ Returns the maximum number of work-items that are permitted in each
      dimension of a work-group for a kernel running in a three-dimensional
      index space. The minimum value is latexmath:[(1,1,1)] for [code]#devices#
      that are not of device type [code]#info::device_type::custom#.

a@
[source]
----
info::device::max_work_group_size
----

    @ [.code]#size_t#
   a@ Returns the maximum number of work-items that are permitted in a work-group executing a kernel on a single compute unit.
      The minimum value is 1.

a@
[source]
----
info::device::max_num_sub_groups
----

    @ [.code]#uint32_t#
   a@ Returns the maximum number of sub-groups in a work-group for any kernel executed on the device.  The minimum value is 1.

a@
[source]
----
info::device::sub_group_sizes
----

    @ [.code]#std::vector<size_t>#
   a@ Returns a [code]#std::vector# of [code]#size_t# containing the set of sub-group sizes supported by the device.

a@
[source]
----
info::device::preferred_vector_width_char
info::device::preferred_vector_width_short
info::device::preferred_vector_width_int
info::device::preferred_vector_width_long
info::device::preferred_vector_width_float
info::device::preferred_vector_width_double
info::device::preferred_vector_width_half
----

    @ [.code]#uint32_t#
   a@ Returns the preferred native vector width size for built-in scalar types that can be put into vectors. The vector width is defined as the number of scalar elements that can be stored in the vector. Must return 0 for [code]#info::device::preferred_vector_width_double# if the [code]#device# does not have [code]#aspect::fp64# and must return 0 for [code]#info::device::preferred_vector_width_half# if the [code]#device# does not have [code]#aspect::fp16#.

a@
[source]
----
info::device::native_vector_width_char
info::device::native_vector_width_short
info::device::native_vector_width_int
info::device::native_vector_width_long
info::device::native_vector_width_float
info::device::native_vector_width_double
info::device::native_vector_width_half
----

    @ [.code]#uint32_t#
   a@ Returns the native ISA vector width. The vector width is defined as the number of scalar elements that can be stored in the vector. Must return 0 for [code]#info::device::native_vector_width_double# if the [code]#device# does not have [code]#aspect::fp64# and must return 0 for  [code]#info::device::native_vector_width_half# if the [code]#device# does not have [code]#aspect::fp16#.

a@
[source]
----
info::device::max_clock_frequency
----

    @ [.code]#uint32_t#
   a@ Returns the maximum configured clock frequency of this SYCL [code]#device# in MHz.

a@
[source]
----
info::device::address_bits
----

    @ [.code]#uint32_t#
   a@ Returns the default compute device address space size specified as an unsigned integer value in bits. Must return either 32 or 64.

a@
[source]
----
info::device::max_mem_alloc_size
----

    @ [.code]#uint64_t#
   a@ Returns the maximum size of memory object allocation in  bytes. The minimum value is max (1/4th of [code]#info::device::global_mem_size#,128*1024*1024) if this SYCL [code]#device# is not of device type [code]#info::device_type::custom#.

a@
[source]
----
info::device::image_support
----

    @ [.code]#bool#
   a@ Deprecated.

Returns the same value as [code]#device::has(aspect::image)#.

a@
[source]
----
info::device::max_read_image_args
----

    @ [.code]#uint32_t#
   a@ Returns the maximum number of simultaneous image objects that can be read from by a kernel. The minimum value is 128 if the SYCL [code]#device# has [code]#aspect::image#.

a@
[source]
----
info::device::max_write_image_args
----

    @ [.code]#uint32_t#
   a@ Returns the maximum number of simultaneous image objects that can be written to by a kernel. The minimum value is 8 if the SYCL [code]#device# has [code]#aspect::image#.

a@
[source]
----
info::device::image2d_max_width
----

    @ [.code]#size_t#
   a@ Returns the maximum width of a 2D image or 1D image in pixels. The minimum value is 8192 if the SYCL [code]#device# has [code]#aspect::image#.

a@
[source]
----
info::device::image2d_max_height
----

    @ [.code]#size_t#
   a@ Returns the maximum height of a 2D image in pixels. The minimum value is 8192 if the SYCL [code]#device# has [code]#aspect::image#.

a@
[source]
----
info::device::image3d_max_width
----

    @ [.code]#size_t#
   a@ Returns the maximum width of a 3D image in pixels. The minimum value is 2048 if the SYCL [code]#device# has [code]#aspect::image#.

a@
[source]
----
info::device::image3d_max_height
----

    @ [.code]#size_t#
   a@ Returns the maximum height of a 3D image in pixels. The minimum value is 2048 if the SYCL [code]#device# has [code]#aspect::image#.

a@
[source]
----
info::device::image3d_max_depth
----

    @ [.code]#size_t#
   a@ Returns the maximum depth of a 3D image in pixels. The minimum value is 2048 if the SYCL [code]#device# has [code]#aspect::image#.

a@
[source]
----
info::device::image_max_buffer_size
----

    @ [.code]#size_t#
   a@ Returns the number of pixels for a 1D image created from a buffer object. The minimum value is 65536 if the SYCL [code]#device# has [code]#aspect::image#. Note that this information is intended for OpenCL interoperability only as this feature is not supported in SYCL.

a@
[source]
----
info::device::max_samplers
----

    @ [.code]#uint32_t#
   a@ Returns the maximum number of samplers that can be used in a kernel.  The minimum value is 16 if the SYCL [code]#device# has [code]#aspect::image#.

a@
[source]
----
info::device::max_parameter_size
----

    @ [.code]#size_t#
   a@ Returns the maximum size in bytes of the arguments that can be passed to a kernel. The minimum value is 1024 if this SYCL [code]#device# is not of device type [code]#info::device_type::custom#. For this minimum value, only a maximum of 128 arguments can be passed to a kernel.

a@
[source]
----
info::device::mem_base_addr_align
----

    @ [.code]#uint32_t#
   a@ Returns the minimum value in bits of the largest supported SYCL built-in
      data type if this SYCL [code]#device# is not of device type [code]#info::device_type::custom#.

a@
[source]
----
info::device::half_fp_config
----

    @ [.code]#std::vector<info::fp_config>#
   a@ Returns a [code]#std::vector# of [code]#info::fp_config#
      describing the half precision floating-point capability of this SYCL
      [code]#device#. The [code]#std::vector# may contain zero or
      more of the following values:
--
  * [code]#info::fp_config::denorm:# denorms are supported.
  * [code]#info::fp_config::inf_nan:# INF and quiet NaNs are supported.
  * [code]#info::fp_config::round_to_nearest:# round to nearest even
    rounding mode is supported.
  * [code]#info::fp_config::round_to_zero:# round to zero rounding mode
    is supported.
  * [code]#info::fp_config::round_to_inf:# round to positive and
    negative infinity rounding modes are supported.
  * [code]#info::fp_config::fma:# IEEE754-2008 fused multiply add is
    supported.
  * [code]#info::fp_config::correctly_rounded_divide_sqrt:# divide and
    sqrt are correctly rounded as defined by the IEEE754 specification.
    This property is deprecated.
  * [code]#info::fp_config::soft_float:# basic floating-point
    operations (such as addition, subtraction, multiplication) are
    implemented in software.

If half precision is supported by this SYCL [code]#device# (i.e. the
[code]#device# has [code]#aspect::fp16# there is no minimum
floating-point capability. If half support is not supported the returned
[code]#std::vector# must be empty.
--

a@
[source]
----
info::device::single_fp_config
----

    @ [.code]#std::vector<info::fp_config>#
   a@ Returns a [code]#std::vector# of [code]#info::fp_config#
      describing the single precision floating-point capability of this
      SYCL [code]#device#. The [code]#std::vector# must
      contain one or more of the following values:
--
  * [code]#info::fp_config::denorm:# denorms are supported.
  * [code]#info::fp_config::inf_nan:# INF and quiet NaNs are supported.
  * [code]#info::fp_config::round_to_nearest:# round to nearest even
    rounding mode is supported.
  * [code]#info::fp_config::round_to_zero:# round to zero rounding mode
    is supported.
  * [code]#info::fp_config::round_to_inf:# round to positive and
    negative infinity rounding modes are supported.
  * [code]#info::fp_config::fma:# IEEE754-2008 fused multiply add is
    supported.
  * [code]#info::fp_config::correctly_rounded_divide_sqrt:# divide and
    sqrt are correctly rounded as defined by the IEEE754 specification.
    This property is deprecated.
  * [code]#info::fp_config::soft_float:# basic floating-point
    operations (such as addition, subtraction, multiplication) are
    implemented in software.

If this SYCL [code]#device# is not of type
[code]#info::device_type::custom# then the minimum floating-point
capability must be: [code]#info::fp_config::round_to_nearest# and
[code]#info::fp_config::inf_nan#.
--

a@
[source]
----
info::device::double_fp_config
----

    @ [.code]#std::vector<info::fp_config>#
   a@ Returns a [code]#std::vector# of [code]#info::fp_config#
      describing the double precision floating-point capability of this
      SYCL [code]#device#. The [code]#std::vector# may contain
      zero or more of the following values:
--
  * [code]#info::fp_config::denorm:# denorms are supported.
  * [code]#info::fp_config::inf_nan:# INF and NaNs are supported.
  * [code]#info::fp_config::round_to_nearest:# round to nearest even
    rounding mode is supported.
  * [code]#info::fp_config::round_to_zero:# round to zero rounding mode
    is supported.
  * [code]#info::fp_config::round_to_inf:# round to positive and
    negative infinity rounding modes are supported.
  * [code]#info::fp_config::fma:# IEEE754-2008 fused multiply-add is
    supported.
  * [code]#info::fp_config::soft_float:# basic floating-point
    operations (such as addition, subtraction, multiplication) are
    implemented in software.

If double precision is supported by this SYCL [code]#device# (i.e. the
[code]#device# has [code]#aspect::fp64# and this SYCL
[code]#device# is not of type [code]#info::device_type::custom#
then the minimum floating-point capability must be:
[code]#info::fp_config::fma#,
[code]#info::fp_config::round_to_nearest#,
[code]#info::fp_config::round_to_zero#,
[code]#info::fp_config::round_to_inf#,
[code]#info::fp_config::inf_nan# and
[code]#info::fp_config::denorm#. If double support is not supported the
returned [code]#std::vector# must be empty.
--

a@
[source]
----
info::device::global_mem_cache_type
----

    @ [.code]#info::global_mem_cache_type#
   a@ Returns the type of global memory cache supported.

a@
[source]
----
info::device::global_mem_cache_line_size
----

    @ [.code]#uint32_t#
   a@ Returns the size of global memory cache line in bytes.

a@
[source]
----
info::device::global_mem_cache_size
----

    @ [.code]#uint64_t#
   a@ Returns the size of global memory cache in bytes.

a@
[source]
----
info::device::global_mem_size
----

    @ [.code]#uint64_t#
   a@ Returns the size of global device memory in bytes.

a@
[source]
----
info::device::max_constant_buffer_size
----

    @ [.code]#uint64_t#
   a@ Deprecated in SYCL 2020. Returns the maximum size in bytes of a constant buffer allocation. The minimum value is 64 KB if this SYCL [code]#device# is not of type [code]#info::device_type::custom#.

a@
[source]
----
info::device::max_constant_args
----

    @ [.code]#uint32_t#
   a@ Deprecated in SYCL 2020. Returns the maximum number of constant arguments that can be declared in a kernel. The minimum value is 8 if this SYCL [code]#device# is not of type [code]#info::device_type::custom#.

a@
[source]
----
info::device::local_mem_type
----

    @ [.code]#info::local_mem_type#
   a@ Returns the type of local memory supported. This can
      be [code]#info::local_mem_type::local# implying dedicated
      local memory storage such as SRAM, or [code]#info::local_mem_type::global#.
      If this SYCL [code]#device# is of type [code]#info::device_type::custom# this can also be [code]#info::local_mem_type::none#, indicating local memory is not supported.

a@
[source]
----
info::device::local_mem_size
----

    @ [.code]#uint64_t#
   a@ Returns the size of local memory arena in bytes. The minimum value is 32 KB if this SYCL [code]#device# is not of type [code]#info::device_type::custom#.

a@
[source]
----
info::device::error_correction_support
----

    @ [.code]#bool#
   a@ Returns true if the device implements error correction for all accesses to
      compute device memory (global and constant). Returns false if the device does
      not implement such error correction.

a@
[source]
----
info::device::host_unified_memory
----

    @ [.code]#bool#
   a@ Deprecated, use [code]#device::has()# with one of the [code]#aspect::usm_*# aspects instead.

Returns true if the device and the host have a unified memory subsystem and
returns false otherwise.

a@
[source]
----
info::device::atomic_memory_order_capabilities
----

    @ [.code]#std::vector<memory_order>#
   a@ Returns the set of memory orders supported by atomic operations on the
      device.  When a device returns a "stronger" memory order in this set, it
      must also return all "weaker" memory orders.  (See
      <<sec:memory-ordering>> for a definition of "stronger" and "weaker"
      memory orders.) The memory orders [code]#memory_order::acquire#,
      [code]#memory_order::release#, and [code]#memory_order::acq_rel# are all
      the same strength.  If a device returns one of these, it must return them
      all.

At a minimum, each device must support [code]#memory_order::relaxed#.

a@
[source]
----
info::device::atomic_fence_order_capabilities
----

    @ [.code]#std::vector<memory_order>#
   a@ Returns the set of memory orders supported by [code]#atomic_fence# on
      the device.  When a device returns a "stronger" memory order in this set,
      it must also return all "weaker" memory orders.  (See
      <<sec:memory-ordering>> for a definition of "stronger" and "weaker"
      memory orders.) At a minimum, each device must support
      [code]#memory_order::relaxed#, [code]#memory_order::acquire#,
      [code]#memory_order::release#, and [code]#memory_order::acq_rel#.

a@
[source]
----
info::device::atomic_memory_scope_capabilities
----

    @ [.code]#std::vector<memory_scope>#
   a@ Returns the set of memory scopes supported by atomic operations on the
      device.  When a device returns a "wider" memory scope in this set, it
      must also return all "narrower" memory scopes.  (See <<sec:memory-scope>>
      for a definition of "wider" and "narrower" scopes.) At a minimum, each
      device must support [code]#memory_scope::work_item#,
      [code]#memory_scope::sub_group#, and [code]#memory_scope::work_group#.

a@
[source]
----
info::device::atomic_fence_scope_capabilities
----

    @ [.code]#std::vector<memory_scope>#
   a@ Returns the set of memory scopes supported by [code]#atomic_fence# on the
      device.  When a device returns a "wider" memory scope in this set, it
      must also return all "narrower" memory scopes.  (See <<sec:memory-scope>>
      for a definition of "wider" and "narrower" scopes.)  At a minimum, each
      device must support [code]#memory_scope::work_item#,
      [code]#memory_scope::sub_group#, and [code]#memory_scope::work_group#.

a@
[source]
----
info::device::profiling_timer_resolution
----

    @ [.code]#size_t#
   a@ Returns the resolution of device timer in nanoseconds.

a@
[source]
----
info::device::is_endian_little
----

    @ [.code]#bool#
   a@ Deprecated.  Check the byte order of the host system instead.  The host
      and device are required to have the same byte order.

Returns true if this SYCL [code]#device# is a little endian device and returns
false otherwise.

a@
[source]
----
info::device::is_available
----

    @ [.code]#bool#
   a@ Returns true if the SYCL [code]#device# is available and returns false if the device is not
      available.

a@
[source]
----
info::device::is_compiler_available
----

    @ [.code]#bool#
   a@ Deprecated.

Returns the same value as [code]#device::has(aspect::online_compiler)#.

a@
[source]
----
info::device::is_linker_available
----

    @ [.code]#bool#
   a@ Deprecated.

Returns the same value as [code]#device::has(aspect::online_linker)#.

a@
[source]
----
info::device::execution_capabilities
----

    @ [.code]#std::vector<info::execution_capability>#
   a@ Returns a [code]#std::vector# of the [code]#info::execution_capability# describing the supported execution capabilities.
      Note that this information is intended for OpenCL interoperability only as  SYCL only supports [code]#info::execution_capability::exec_kernel#.

a@
[source]
----
info::device::queue_profiling
----

    @ [.code]#bool#
   a@ Deprecated.

Returns the same value as [code]#device::has(aspect::queue_profiling)#.

a@
[source]
----
info::device::built_in_kernel_ids
----

    @ [.code]#std::vector<kernel_id>#
   a@ Returns a [code]#std::vector# of identifiers for the built-in kernels
      supported by this SYCL [code]#device#.

a@
[source]
----
info::device::built_in_kernels
----

    @ [.code]#std::vector<std::string>#
   a@ Deprecated.  Use [code]#info::device::built_in_kernel_ids# instead.

Returns a [code]#std::vector# of built-in OpenCL kernels supported by this SYCL
[code]#device#.

a@
[source]
----
info::device::platform
----

    @ [.code]#platform#
   a@ Returns the SYCL [code]#platform# associated with this SYCL [code]#device#.

a@
[source]
----
info::device::name
----

    @ [.code]#std::string#
   a@ Returns the device name of this SYCL [code]#device#.

a@
[source]
----
info::device::vendor
----

    @ [.code]#std::string#
   a@ Returns the vendor of this SYCL [code]#device#.

a@
[source]
----
info::device::driver_version
----

    @ [.code]#std::string#
   a@ Returns a vendor-defined string describing the version of the underlying
      backend software driver.

a@
[source]
----
info::device::profile
----

    @ [.code]#std::string#
   a@ Deprecated in SYCL 2020.  Only supported when using the OpenCL backend
      (see <<chapter:opencl-backend>>).  Throws an [code]#exception# with the
      [code]#errc::invalid# error code if used with a device whose backend is
      not OpenCL.

The value returned can be one of the following strings:
--
  * FULL_PROFILE - if the device supports the OpenCL specification
    (functionality defined as part of the core specification and does not
    require any extensions to be supported).
  * EMBEDDED_PROFILE - if the device supports the OpenCL embedded profile.
--

a@
[source]
----
info::device::version
----

    @ [.code]#std::string#
   a@ Returns a backend-defined <<device>> version.

a@
[source]
----
info::device::backend_version
----

    @ [.code]#std::string#
   a@ Returns a string describing the version of the <<backend>> associated with
      the <<device>>. The possible values are specified in the <<backend>>
      specification of the <<backend>> associated with the <<device>>.

a@
[source]
----
info::device::aspects
----

    @ [.code]#std::vector<aspect>#
   a@ Returns a [code]#std::vector# of <<aspect>> values supported by this
      SYCL [code]#device#.

a@
[source]
----
info::device::extensions
----

    @ [.code]#std::vector<std::string>#
   a@ Deprecated, use [code]#info::device::aspects# instead.
--
Returns a [code]#std::vector# of extension names (the extension names
do not contain any spaces) supported by this SYCL [code]#device#. The
extension names returned can be vendor supported extension names and one or
more of the following Khronos approved extension names:

  * [code]#cl_khr_int64_base_atomics#
  * [code]#cl_khr_int64_extended_atomics#
  * [code]#cl_khr_3d_image_writes#
  * [code]#cl_khr_fp16#
  * [code]#cl_khr_gl_sharing#
  * [code]#cl_khr_gl_event#
  * [code]#cl_khr_d3d10_sharing#
  * [code]#cl_khr_dx9_media_sharing#
  * [code]#cl_khr_d3d11_sharing#
  * [code]#cl_khr_depth_images#
  * [code]#cl_khr_gl_depth_images#
  * [code]#cl_khr_gl_msaa_sharing#
  * [code]#cl_khr_image2d_from_buffer#
  * [code]#cl_khr_initialize_memory#
  * [code]#cl_khr_context_abort#
  * [code]#cl_khr_spir#

If this SYCL [code]#device# is an OpenCL device then following approved
Khronos extension names must be returned by all device that support OpenCL C
1.2:

  * [code]#cl_khr_global_int32_base_atomics#
  * [code]#cl_khr_global_int32_extended_atomics#
  * [code]#cl_khr_local_int32_base_atomics#
  * [code]#cl_khr_local_int32_extended_atomics#
  * [code]#cl_khr_byte_addressable_store#
  * [code]#cl_khr_fp64# (for backward compatibility if double precision
    is supported)

Please refer to the OpenCL 1.2 Extension Specification for a detailed
description of these extensions.
--

a@
[source]
----
info::device::printf_buffer_size
----

    @ [.code]#size_t#
   a@ Deprecated in SYCL 2020.

Returns the maximum size of the internal buffer that holds the output of
[code]#printf# calls from a kernel. The minimum value is 1 MB if
[code]#info::device::profile# returns true for this SYCL [code]#device#.

a@
[source]
----
info::device::preferred_interop_user_sync
----

    @ [.code]#bool#
   a@ Deprecated in SYCL 2020.  Only supported when using the OpenCL backend
      (see <<chapter:opencl-backend>>).  Throws an [code]#exception# with the
      [code]#errc::invalid# error code if used with a device whose backend is
      not OpenCL.

Returns true if the preference for this SYCL [code]#device# is for the user to
be responsible for synchronization, when sharing memory objects between OpenCL
and other APIs  such as DirectX, false if the device/implementation has a
performant path for performing synchronization of memory object shared between
OpenCL and other APIs such as DirectX.

a@
[source]
----
info::device::parent_device
----

    @ [.code]#device#
   a@ Returns the parent SYCL [code]#device# to which this sub-device is a child if this is a sub-device.
      Must throw an [code]#exception# with the [code]#errc::invalid# error code if this SYCL [code]#device# is not a sub device.

a@
[source]
----
info::device::partition_max_sub_devices
----

    @ [.code]#uint32_t#
   a@ Returns the maximum number of sub-devices that can be created when this SYCL [code]#device# is partitioned. The value returned cannot exceed the value returned by [code]#info::device::device_max_compute_units#.

a@
[source]
----
info::device::partition_properties
----

    @ [.code]#std::vector<info::partition_property>#
   a@ Returns the partition properties supported by this SYCL [code]#device;# a
      vector of [code]#info::partition_property#.  An element is returned in
      this vector only if the device can be partitioned into at least two sub
      devices along that partition property.

a@
[source]
----
info::device::partition_affinity_domains
----

    @ [.code]#std::vector<info::partition_affinity_domain>#
   a@ Returns a [code]#std::vector# of the partition affinity domains
      supported by this SYCL [code]#device# when partitioning with
      [code]#info::partition_property::partition_by_affinity_domain#.
      An element is returned in this vector only if the device can be
      partitioned into at least two sub devices along that affinity domain.

a@
[source]
----
info::device::partition_type_property
----

    @ [.code]#info::partition_property#
   a@ Returns the partition property of this SYCL [code]#device#. If this SYCL [code]#device# is not a sub device then the return value must be [code]#info::partition_property::no_partition#, otherwise it must be one of the following values:
--
  * [code]#info::partition_property::partition_equally#
  * [code]#info::partition_property::partition_by_counts#
  * [code]#info::partition_property::partition_by_affinity_domain#
--

a@
[source]
----
info::device::partition_type_affinity_domain
----

    @ [.code]#info::partition_affinity_domain#
   a@ Returns the partition affinity domain of this SYCL [code]#device#. If this SYCL [code]#device# is not a sub device or the sub device was not partitioned with [code]#info::partition_type::partition_by_affinity_domain# then the return value must be [code]#info::partition_affinity_domain::not_applicable#, otherwise it must be one of the following values:
--
  * [code]#info::partition_affinity_domain::numa#
  * [code]#info::partition_affinity_domain::L4_cache#
  * [code]#info::partition_affinity_domain::L3_cache#
  * [code]#info::partition_affinity_domain::L2_cache#
  * [code]#info::partition_affinity_domain::L1_cache#
--

|====



[[sec:device-aspects]]
==== Device aspects

Every SYCL <<device>> has an associated set of <<aspect,aspects>> which
identify characteristics of the [code]#device#.  Aspects are defined via
the [code]#enum class aspect# enumeration:

[source,,linenums]
----
include::{header_dir}/deviceEnumClassAspect.h[lines=4..-1]
----

SYCL applications can query the aspects for a [code]#device# via
[code]#device::has()# in order to determine whether the [code]#device#
supports any optional features.  <<table.device.aspect>> lists the aspects that
are defined in the <<core-spec>> and tells which optional features correspond
to each.  Backends and extensions may provide additional aspects and additional
optional device features.  If so, the <<backend>> specification document or the
extension document describes them.

[[table.device.aspect]]
.Device aspects defined by the <<core-spec>>
[width="100%",options="header",separator="@",cols="50%,50%"]
|====
@ Aspect @ Description
a@
[source]
----
aspect::cpu
----
   a@ A device that runs on a CPU.  Devices with this [code]#aspect# have
      device type [code]#info::device_type::cpu#.

a@
[source]
----
aspect::gpu
----
   a@ A device that can also be used to accelerate a 3D graphics API.  Devices
      with this [code]#aspect# have device type
      [code]#info::device_type::gpu#.

a@
[source]
----
aspect::accelerator
----
   a@ A dedicated accelerator device, usually using a peripheral interconnect for
      communication.  Devices with this [code]#aspect# have device type
      [code]#info::device_type::accelerator#.

a@
[source]
----
aspect::custom
----
   a@ A dedicated accelerator that can use the SYCL API, but programmable kernels
      cannot be dispatched to the device, only fixed functionality is available.
      See <<sec:pre-defined-kernels>>.  Devices with this
      [code]#aspect# have device type [code]#info::device_type::custom#.

a@
[source]
----
aspect::emulated
----
   a@ Indicates that the device is somehow emulated.  A device with this aspect
   is not intended for performance, and instead will generally have another
   purpose such as emulation or profiling.  The precise definition of this
   aspect is left open to the SYCL implementation.

[NOTE]
====
As an example, a vendor might support both a hardware FPGA device and a
software emulated FPGA, where the emulated FPGA has all the same features
as the hardware one but runs more slowly and can provide additional profiling
or diagnostic information.  In such a case, an application's
<<device-selector>> can use [code]#aspect::emulated# to distinguish the two.
====

a@
[source]
----
aspect::host_debuggable
----
   a@ Indicates that <<kernel,kernels>> running on this device can be debugged
      using standard debuggers that are normally available on the host system
      where the SYCL implementation resides.  The precise definition of this
      aspect is left open to the SYCL implementation.

a@
[source]
----
aspect::fp16
----
   a@ Indicates that kernels submitted to the device may use the
      [code]#sycl::half# data type.

a@
[source]
----
aspect::fp64
----
   a@ Indicates that kernels submitted to the device may use the [code]#double#
      data type.

a@
[source]
----
aspect::atomic64
----
   a@ Indicates that kernels submitted to the device may perform 64-bit atomic
      operations.

a@
[source]
----
aspect::image
----
   a@ Indicates that the device supports <<subsec:images, images>>.

a@
[source]
----
aspect::online_compiler
----
   a@ Indicates that the device supports online compilation of device code.
      <<device,Devices>> that have this aspect support the [code]#build()#
      and [code]#compile()# functions defined in <<sec:bundles.compile-link>>.

a@
[source]
----
aspect::online_linker
----
   a@ Indicates that the device supports online linking of device code.
      <<device,Devices>> that have this aspect support the [code]#link()#
      functions defined in <<sec:bundles.compile-link>>.  All
      <<device,devices>> that have this aspect also have
      [code]#aspect::online_compiler#.

a@
[source]
----
aspect::queue_profiling
----
   a@ Indicates that the device supports queue profiling via [code]#property::queue::enable_profiling#.

a@
[source]
----
aspect::usm_device_allocations
----
   a@ Indicates that the device supports explicit USM allocations as described
      in <<sec:usm>>.

a@
[source]
----
aspect::usm_host_allocations
----
   a@ Indicates that the device can access USM memory allocated via
      [code]#usm::alloc::host#.  The device only
      supports atomic modification of a host allocation if
      [code]#aspect::usm_atomic_host_allocations# is also supported.
      (See <<sec:usm>>.)

a@
[source]
----
aspect::usm_atomic_host_allocations
----
   a@ Indicates that the device supports USM memory allocated
      via [code]#usm::alloc::host#. The host and this device may
      concurrently access and atomically modify host allocations. (See <<sec:usm>>.)


a@
[source]
----
aspect::usm_shared_allocations
----
   a@ Indicates that the device supports USM memory allocated via
      [code]#usm::alloc::shared# on the same device. Concurrent access
      and atomic modification of a shared allocation is only supported
      if [code]#aspect::usm_atomic_shared_allocations# is also supported.
      (See <<sec:usm>>.)

a@
[source]
----
aspect::usm_atomic_shared_allocations
----
   a@ Indicates that the device supports USM memory allocated via
      [code]#usm::alloc::shared#. The host and other devices in the same
      context that also support this capability may concurrently access
      and atomically modify shared allocations.  The allocation is free
      to migrate between the host and the appropriate devices. (See <<sec:usm>>.)

a@
[source]
----
aspect::usm_system_allocations
----
   a@ Indicates that the system allocator may be used instead of SYCL USM
      allocation mechanisms for [code]#usm::alloc::shared# allocations on
      this device.  (See <<sec:usm>>.)

|====

The implementation also provides two traits that the application can use to
query aspects at compilation time.  The traits [code]#any_device_has<aspect>#
and [code]#all_devices_have<aspect># are set according to the collection of
devices _D_ that can possibly execute device code, as determined by the
compilation environment.  The trait [code]#any_device_has<aspect># inherits
from [code]#std::true_type# only if at least one device in _D_ has the
specified aspect.  The trait [code]#all_devices_have<aspect># inherits from
[code]#std::true_type# only if all devices in _D_ have the specified aspect.

[source,,linenums]
----
include::{header_dir}/aspectTraits.h[lines=4..-1]
----

Applications can use these traits to reduce their code size.  The following
example demonstrates one way to use these traits to avoid instantiating a
templated kernel for device features that are not supported by any device.

[source,,linenums]
----
include::{code_dir}/aspectTraitExample.cpp[lines=4..-1]
----

The kernel function [code]#MyKernel# is templated to use a different
algorithm depending on whether the device has the aspect [code]#aspect::fp16#,
and the call to [code]#dev.has()# chooses the kernel function instantiation
that matches the device's capabilities.  However, the use of
[code]#any_device_has_v# and [code]#all_devices_have_v# entirely avoid
useless instantiations of the kernel function.  For example, when the
compilation environment does not support any devices with [code]#aspect::fp16#,
[code]#any_device_has_v<aspect::fp16># is [code]#false#, and the kernel
function is never instantiated with support for the [code]#sycl::half# type.

[NOTE]
====
Like any trait, the definitions of [code]#any_device_has# and
[code]#all_devices_have# are uniform across all parts of a SYCL application.
If an implementation uses <<smcp>>, all compiler passes define a particular
aspect's specialization of the traits the same way, regardless of whether that
compiler pass' device supports the aspect.  Thus, [code]#any_device_has# and
[code]#all_devices_have# cannot be used to determine whether any particular
device supports an aspect.  Instead, applications must use
[code]#device::has()# or [code]#platform::has()# for this.
====

[NOTE]
====
An implementation could choose to provide command line options which affect the
set of devices that it supports.  If so, those command line options would also
affect these traits.  For example, if an implementation provides a command line
option that disables [code]#aspect::accelerator# devices, the trait
[code]#any_device_has<aspect::accelerator># would inherit from
[code]#std::false_type# when that command line option was specified.
====

[NOTE]
====
These traits only reflect the supported devices at the time the SYCL
application is compiled.  It's possible that unsupported devices are still
visible to the application when it runs.  However, if a device _D_ is not
supported when the application is compiled, the application will not be able
to submit kernels to that device _D_.
====

// %%%%%%%%%%%%%%%%%%%%%%%%%%%% end device_class %%%%%%%%%%%%%%%%%%%%%%%%%%%%


[[sec:interface.queue.class]]
=== Queue class

// \input{queue_class}
// %%%%%%%%%%%%%%%%%%%%%%%%%%%% begin queue_class %%%%%%%%%%%%%%%%%%%%%%%%%%%%

The SYCL [code]#queue# class encapsulates a single SYCL queue which
schedules kernels on a SYCL device.

A SYCL [code]#queue# can be used to submit <<command-group,command groups>> to be
executed by the <<sycl-runtime>> using the [code]#submit# member
function.

All member functions of the [code]#queue# class are synchronous and errors
are handled by throwing synchronous SYCL exceptions. The [code]#submit#
member function synchronously invokes the provided
<<command-group-function-object>> (as described in
<<sec:command-groups-exec-order>>) in the calling thread, thereby scheduling a
<<command-group>> for asynchronous execution. Any error in the submission of a
<<command-group>> is handled by throwing a synchronous SYCL exception.
Any errors from the <<command-group>> after it has been submitted are handled by
passing <<async-error,asynchronous errors>> at specific times to an
<<async-handler>>, as described in <<error-handling>>.

A SYCL [code]#queue# can wait for all <<command-group,command groups>> that it has
submitted by calling [code]#wait# or [code]#wait_and_throw#.

The default constructor of the SYCL [code]#queue# class will
construct a queue based on the SYCL [code]#device# returned from
the [code]#default_selector_v# (see <<sec:device-selector>>).
All other constructors construct a queue as determined by the
parameters provided. All constructors will implicitly construct a SYCL
[code]#platform#, [code]#device# and [code]#context# in order to
facilitate the construction of the queue.

Each constructor takes as the last
parameter an optional SYCL [code]#property_list# to provide properties to
the SYCL [code]#queue#.

A SYCL [code]#queue# may be destroyed even when there are uncompleted
<<command, commands>> that have been submitted to the queue.  Doing so does not
block.  Instead, any commands that have been submitted to the queue begin
execution when their requisites are satisfied, just as they would had the queue
not been destroyed.  Any event objects for those commands are signaled in the
normal manner when the command completes.  Resources associated with the queue
will be freed by the time the last command completes.

The SYCL [code]#queue# class provides the common reference semantics
(see <<sec:reference-semantics>>).


==== Queue interface

A synopsis of the SYCL [code]#queue# class is provided below. The
constructors and member functions of the SYCL [code]#queue# class are
listed in <<table.constructors.queue>> and <<table.members.queue>>
respectively. The additional common special member functions and common member
functions are listed in <<sec:reference-semantics>> in
<<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>>, respectively.

Some queue member functions are shortcuts to member functions of the [code]#handler# class.
These are listed in <<sec:queue-shortcuts>>.

// Interface for class: queue
[source,,linenums]
----
include::{header_dir}/queue.h[lines=4..-1]
----


[[table.constructors.queue]]
.Constructors of the [code]#queue# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
explicit queue(const property_list& propList = {})
----
a@ Constructs a SYCL [code]#queue# instance using the device
constructed from the [code]#default_selector_v#.
Zero or more properties can
be provided to the constructed SYCL [code]#queue# via an instance of
[code]#property_list#.

a@
[source]
----
explicit queue(const async_handler& asyncHandler,
               const property_list& propList = {})
----
a@ Constructs a SYCL [code]#queue# instance with an
[code]#async_handler# using the device constructed from the
[code]#default_selector_v#.
Zero or more properties can be provided to the
constructed SYCL [code]#queue# via an instance of
[code]#property_list#.

a@
[source]
----
template <typename DeviceSelector>
explicit queue(const DeviceSelector& deviceSelector,
               const property_list& propList = {})
----
a@ Constructs a SYCL [code]#queue# instance using the device
returned by the <<device-selector>> provided. Zero or
more properties can be provided to the constructed SYCL
[code]#queue# via an instance of
[code]#property_list#.

a@
[source]
----
template <typename DeviceSelector>
explicit queue(const DeviceSelector& deviceSelector,
               const async_handler& asyncHandler,
               const property_list& propList = {})
----
a@ Constructs a SYCL [code]#queue# instance with an
[code]#async_handler# using the device returned by the
<<device-selector>> provided. Zero or more properties
can be provided to the constructed SYCL [code]#queue# via
an instance of [code]#property_list#.

a@
[source]
----
explicit queue(const device& syclDevice, const property_list& propList = {})
----
a@ Constructs a SYCL [code]#queue# instance using the [code]#syclDevice# provided. Zero or more properties can be provided to the
constructed SYCL [code]#queue# via an instance of [code]#property_list#.

a@
[source]
----
explicit queue(const device& syclDevice, const async_handler& asyncHandler,
               const property_list& propList = {})
----
a@ Constructs a SYCL [code]#queue# instance with an [code]#async_handler# using the [code]#syclDevice# provided. Zero or more
properties can be provided to the constructed SYCL [code]#queue#
via an instance of [code]#property_list#.

a@
[source]
----
template <typename DeviceSelector>
explicit queue(const context& syclContext, const DeviceSelector& deviceSelector,
               const property_list& propList = {})
----
a@ Constructs a SYCL [code]#queue# instance that is associated
with the [code]#syclContext# provided, using the device
returned by the <<device-selector>> provided. Must
throw an [code]#exception# with the
[code]#errc::invalid# error code if
[code]#syclContext# does not encapsulate the SYCL
[code]#device# returned by
[code]#deviceSelector#. Zero or more properties can be
provided to the constructed SYCL [code]#queue# via an
instance of [code]#property_list#.

a@
[source]
----
template <typename DeviceSelector>
explicit queue(const context& syclContext, const DeviceSelector& deviceSelector,
               const async_handler& asyncHandler,
               const property_list& propList = {})
----
a@ Constructs a SYCL [code]#queue# instance with an
[code]#async_handler# that is associated with the
[code]#syclContext# provided, using the device returned by
the <<device-selector>> provided. Must throw an
[code]#exception# with the
[code]#errc::invalid# error code if
[code]#syclContext# does not encapsulate the SYCL
[code]#device# returned by
[code]#deviceSelector#. Zero or more properties can be
provided to the constructed SYCL [code]#queue# via an
instance of [code]#property_list#.

a@
[source]
----
explicit queue(const context& syclContext, const device& syclDevice,
               const property_list& propList = {})
----
a@ Constructs a SYCL [code]#queue# instance using the [code]#syclDevice#
provided.  This device must either be contained by [code]#syclContext# or it
must be a <<descendent-device>> of some device that is contained by that
context, otherwise this function throws a synchronous exception with the
[code]#errc::invalid# error code.  Zero or more properties can be provided to
the constructed SYCL [code]#queue# via an instance of [code]#property_list#.

a@
[source]
----
explicit queue(const context& syclContext, const device& syclDevice,
               const async_handler& asyncHandler,
               const property_list& propList = {})
----
a@ Constructs a SYCL [code]#queue# instance with an [code]#async_handler# using
the [code]#syclDevice# provided.  This device must either be contained by
[code]#syclContext# or it must be a <<descendent-device>> of some device that
is contained by that context, otherwise this function throws a synchronous
exception with the [code]#errc::invalid# error code.  Zero or more properties
can be provided to the constructed SYCL [code]#queue# via an instance of
[code]#property_list#.

|====



[[table.members.queue]]
.Member functions for [code]#queue# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
backend get_backend() const noexcept
----
a@ Returns a [code]#backend# identifying the <<backend>> associated
with this [code]#queue#.

a@
[source]
----
context get_context() const
----
a@ Returns the SYCL queue's context.
Reports errors using SYCL exception classes.
The value returned must be equal to that returned by [code]#get_info<info::queue::context>()#.

a@
[source]
----
device get_device() const
----
a@ Returns the SYCL device the queue is associated with.
Reports errors using SYCL exception classes.
The value returned must be equal to that returned by [code]#get_info<info::queue::device>()#.

a@
[source]
----
bool is_in_order() const
----
a@ Returns true if the SYCL [code]#queue# was created with the
[code]#in_order# property.
Equivalent to [code]#has_property<property::queue::in_order>()#.

a@
[source]
----
void wait()
----
a@ Performs a blocking wait for the completion of all enqueued tasks
in the queue.  Synchronous errors will be reported through SYCL
exceptions.

a@
[source]
----
void wait_and_throw()
----
a@ Performs a blocking wait for the completion of all enqueued tasks
in the queue.  Synchronous errors will be reported through SYCL
exceptions. Any unconsumed <<async-error,asynchronous errors>> will be passed to the
<<async-handler>> associated with the queue or enclosing context.
If no user defined [code]#async_handler# is associated with
the queue or enclosing context, then an implementation-defined
default <<async-handler>> is called to handle any errors, as
described in <<subsubsec:exception.nohandler>>.

a@
[source]
----
void throw_asynchronous()
----
a@ Checks to see if any unconsumed <<async-error,asynchronous errors>> have been produced by
the queue and if so reports them by passing them to the
<<async-handler>> associated with the queue or enclosing context.
If no user defined [code]#async_handler# is associated with
the queue or enclosing context, then an implementation-defined
default <<async-handler>> is called to handle any errors, as
described in <<subsubsec:exception.nohandler>>.

a@
[source]
----
template <typename Param> typename Param::return_type get_info() const
----
   a@ Queries this SYCL [code]#queue# for information requested by the
      template parameter [code]#Param#.
      The type alias [code]#Param::return_type# must be defined in
      accordance with the info parameters in <<table.queue.info>> to
      facilitate returning the type associated with the [code]#Param#
      parameter.

a@
[source]
----
template <typename T> event submit(T cgf)
----
a@ Submit a <<command-group-function-object>> to the queue, in order to be scheduled
for execution on the device.

a@
[source]
----
template <typename T> event submit(T cgf, queue& secondaryQueue)
----
a@ Submit a <<command-group-function-object>> to the queue, in order to be scheduled
for execution on the device. On a kernel error, this <<command-group-function-object>>
is then scheduled for execution on the secondary queue. Returns an
event, which corresponds to the queue the <<command-group-function-object>>
is being enqueued on.

a@
[source]
----
template <typename Param> typename Param::return_type get_backend_info() const
----
a@ Queries this SYCL [code]#queue# for <<backend>>-specific information
requested by the template parameter [code]#Param#.
      The type alias [code]#Param::return_type# must be defined in
      accordance with the <<backend>> specification.
      Must throw an [code]#exception# with the [code]#errc::backend_mismatch#
      error code if the <<backend>> that corresponds with [code]#Param# is different
      from the <<backend>> that is associated with this [code]#queue#.

|====


[[sec:queue-shortcuts]]
==== Queue shortcut functions

Queue shortcut functions are member functions of the [code]#queue# class
that implicitly create a command group with an implicit command group [code]#handler#
consisting of a single command,
a call to the member function of the handler object with the same signature
(e.g. [code]#queue::single_task# will call [code]#handler::single_task# with the same arguments),
and submit the command group.
The main signature difference comes from the return type:
member functions of the [code]#handler# return [code]#void#,
whereas corresponding queue shortcut functions return an [code]#event# object
that represents the submitted command group.
Queue shortcuts can additionally take a list of events to wait on,
as if passing the event list to [code]#handler::depends_on# for the implicit command group.

The full list of queue shortcuts is defined in <<table.queue.shortcuts>>.
The list of handler member functions is defined in <<table.members.handler.kernel>>.

It is not allowed to capture accessors into the implicitly created command group.
If a queue shortcut function launches a kernel
(via [code]#single_task# or [code]#parallel_for#),
only USM pointers are allowed inside such kernels.
However, queue shortcuts that perform non-kernel operations
can be provided with a valid placeholder accessor as an argument.
In that case there is an additional step performed:
the implicit command group [code]#handler# calls [code]#handler::require#
on each accessor passed in as a function argument.

An example of using queue shortcuts is shown below.

[[example.queue.shortcuts]]
[source,,linenums]
----
include::{code_dir}/queueShortcuts.cpp[lines=4..-1]
----

[[table.queue.shortcuts]]
.Queue shortcut functions
[width="100%",options="header",separator="@",cols="60%,10%,20%"]
|====
@ Function Definition @ Function Type @ Description
a@
[source]
----
template <typename KernelName, typename KernelType>
event single_task(const KernelType& kernelFunc)
----
a@ <<sycl-kernel-function, Kernel function>>
a@ Equivalent to submitting a command-group containing
[code]#handler::single_task(kernelFunc)#.
a@
[source]
----
template <typename KernelName, typename KernelType>
event single_task(event depEvent, const KernelType& kernelFunc)
----
a@ <<sycl-kernel-function, Kernel function>>
a@ Equivalent to submitting a command-group containing
[code]#handler::depends_on(depEvent)# and
[code]#handler::single_task(kernelFunc)#.
a@
[source]
----
template <typename KernelName, typename KernelType>
event single_task(const std::vector<event>& depEvents,
                  const KernelType& kernelFunc)
----
a@ <<sycl-kernel-function, Kernel function>>
a@ Equivalent to submitting a command-group containing
[code]#handler::depends_on(depEvents)# and
[code]#handler::single_task(kernelFunc)#.
a@
[source]
----
template <typename KernelName, int Dimensions, typename... Rest>
event parallel_for(range<Dimensions> numWorkItems, Rest&&... rest)
----
a@ <<sycl-kernel-function, Kernel function>>
a@ Equivalent to submitting a command-group containing
[code]#handler::parallel_for(numWorkItems, rest)#.
a@
[source]
----
template <typename KernelName, int Dimensions, typename... Rest>
event parallel_for(range<Dimensions> numWorkItems, event depEvent,
                   Rest&&... rest)
----
a@ <<sycl-kernel-function, Kernel function>>
a@ Equivalent to submitting a command-group containing
[code]#handler::depends_on(depEvent)# and
[code]#handler::parallel_for(numWorkItems, rest)#.
a@
[source]
----
template <typename KernelName, int Dimensions, typename... Rest>
event parallel_for(range<Dimensions> numWorkItems,
                   const std::vector<event>& depEvents, Rest&&... rest)
----
a@ <<sycl-kernel-function, Kernel function>>
a@ Equivalent to submitting a command-group containing
[code]#handler::depends_on(depEvents)# and
[code]#handler::parallel_for(numWorkItems, rest)#.
a@
[source]
----
template <typename KernelName, int Dimensions, typename... Rest>
event parallel_for(nd_range<Dimensions> executionRange, Rest&&... rest)
----
a@ <<sycl-kernel-function, Kernel function>>
a@ Equivalent to submitting a command-group containing
[code]#handler::parallel_for(executionRange, rest)#.
a@
[source]
----
template <typename KernelName, int Dimensions, typename... Rest>
event parallel_for(nd_range<Dimensions> executionRange, event depEvent,
                   Rest&&... rest)
----
a@ <<sycl-kernel-function, Kernel function>>
a@ Equivalent to submitting a command-group containing
[code]#handler::depends_on(depEvent)# and
[code]#handler::parallel_for(executionRange, rest)#.
a@
[source]
----
template <typename KernelName, int Dimensions, typename... Rest>
event parallel_for(nd_range<Dimensions> executionRange,
                   const std::vector<event>& depEvents, Rest&&... rest)
----
a@ <<sycl-kernel-function, Kernel function>>
a@ Equivalent to submitting a command-group containing
[code]#handler::depends_on(depEvents)# and
[code]#handler::parallel_for(executionRange, rest)#.
a@
[source]
----
event memcpy(void* dest, const void* src, size_t numBytes)
----
a@ <<sec:usm, USM>>
a@ Equivalent to submitting a command-group containing
[code]#handler::memcpy(dest, src, numBytes)#.
a@
[source]
----
event memcpy(void* dest, const void* src, size_t numBytes, event depEvent)
----
a@ <<sec:usm, USM>>
a@ Equivalent to submitting a command-group containing
[code]#handler::depends_on(depEvent)# and
[code]#handler::memcpy(dest, src, numBytes)#.
a@
[source]
----
event memcpy(void* dest, const void* src, size_t numBytes,
             const std::vector<event>& depEvents)
----
a@ <<sec:usm, USM>>
a@ Equivalent to submitting a command-group containing
[code]#handler::depends_on(depEvents)# and
[code]#handler::memcpy(dest, src, numBytes)#.
a@
[source]
----
template <typename T> event copy(const T* src, T* dest, size_t count)
----
a@ <<sec:usm, USM>>
a@ Equivalent to submitting a command-group containing
[code]#handler::copy(src, dest, count)#.
a@
[source]
----
template <typename T>
event copy(const T* src, T* dest, size_t count, event depEvent)
----
a@ <<sec:usm, USM>>
a@ Equivalent to submitting a command-group containing
[code]#handler::depends_on(depEvent)# and
[code]#handler::copy(src, dest, count)#.
a@
[source]
----
template <typename T>
event copy(const T* srct, T* dest, size_t count,
           const std::vector<event>& depEvents)
----
a@ <<sec:usm, USM>>
a@ Equivalent to submitting a command-group containing
[code]#handler::depends_on(depEvents)# and
[code]#handler::copy(src, dest, count)#.
a@
[source]
----
event memset(void* ptr, int value, size_t numBytes)
----
a@ <<sec:usm, USM>>
a@ Equivalent to submitting a command-group containing
[code]#handler::memset(ptr, value, numBytes)#.
a@
[source]
----
event memset(void* ptr, int value, size_t numBytes, event depEvent)
----
a@ <<sec:usm, USM>>
a@ Equivalent to submitting a command-group containing
[code]#handler::depends_on(depEvent)# and
[code]#handler::memset(ptr, value, numBytes)#.
a@
[source]
----
event memset(void* ptr, int value, size_t numBytes,
             const std::vector<event>& depEvents)
----
a@ <<sec:usm, USM>>
a@ Equivalent to submitting a command-group containing
[code]#handler::depends_on(depEvents)# and
[code]#handler::memset(ptr, value, numBytes)#.
a@
[source]
----
template <typename T> event fill(void* ptr, const T& pattern, size_t count)
----
a@ <<sec:usm, USM>>
a@ Equivalent to submitting a command-group containing
[code]#handler::fill(ptr, pattern, count)#.
a@
[source]
----
template <typename T>
event fill(void* ptr, const T& pattern, size_t count, event depEvent)
----
a@ <<sec:usm, USM>>
a@ Equivalent to submitting a command-group containing
[code]#handler::depends_on(depEvent)# and
[code]#handler::fill(ptr, pattern, count)#.
a@
[source]
----
template <typename T>
event fill(void* ptr, const T& pattern, size_t count,
           const std::vector<event>& depEvents)
----
a@ <<sec:usm, USM>>
a@ Equivalent to submitting a command-group containing
[code]#handler::depends_on(depEvents)# and
[code]#handler::fill(ptr, pattern, count)#.
a@
[source]
----
event prefetch(void* ptr, size_t numBytes)
----
a@ <<sec:usm, USM>>
a@ Equivalent to submitting a command-group containing
[code]#handler::prefetch(ptr, numBytes)#.
a@
[source]
----
event prefetch(void* ptr, size_t numBytes, event depEvent)
----
a@ <<sec:usm, USM>>
a@ Equivalent to submitting a command-group containing
[code]#handler::depends_on(depEvent)# and
[code]#handler::prefetch(ptr, numBytes)#.
a@
[source]
----
event prefetch(void* ptr, size_t numBytes, const std::vector<event>& depEvents)
----
a@ <<sec:usm, USM>>
a@ Equivalent to submitting a command-group containing
[code]#handler::depends_on(depEvents)# and
[code]#handler::prefetch(ptr, numBytes)#.
a@
[source]
----
event mem_advise(void* ptr, size_t numBytes, int advice)
----
a@ <<sec:usm, USM>>
a@ Equivalent to submitting a command-group containing
[code]#handler::mem_advise(ptr, numBytes, advice)#.
a@
[source]
----
event mem_advise(void* ptr, size_t numBytes, int advice, event depEvent)
----
a@ <<sec:usm, USM>>
a@ Equivalent to submitting a command-group containing
[code]#handler::depends_on(depEvent)# and
[code]#handler::mem_advise(ptr, numBytes, advice)#.
a@
[source]
----
event mem_advise(void* ptr, size_t numBytes, int advice,
                 const std::vector<event>& depEvents)
----
a@ <<sec:usm, USM>>
a@ Equivalent to submitting a command-group containing
[code]#handler::depends_on(depEvents)# and
[code]#handler::mem_advise(ptr, numBytes, advice)#.
a@
[source]
----
template <typename SrcT, int SrcDims, access_mode SrcMode, target SrcTgt,
          access::placeholder IsPlaceholder, typename DestT>
event copy(accessor<SrcT, SrcDims, SrcMode, SrcTgt, IsPlaceholder> src,
           std::shared_ptr<DestT> dest);
----
a@ <<subsec:explicitmemory,Explicit copy>>
a@ Equivalent to submitting a command-group containing
[code]#handler::require(src)# and
[code]#handler::copy(src, dest)#.
a@
[source]
----
template <typename SrcT, typename DestT, int DestDims, access_mode DestMode,
          target DestTgt, access::placeholder IsPlaceholder>
event copy(std::shared_ptr<SrcT> src,
           accessor<DestT, DestDims, DestMode, DestTgt, IsPlaceholder> dest);
----
a@ <<subsec:explicitmemory,Explicit copy>>
a@ Equivalent to submitting a command-group containing
[code]#handler::require(dest)# and
[code]#handler::copy(src, dest)#.
a@
[source]
----
template <typename SrcT, int SrcDims, access_mode SrcMode, target SrcTgt,
          access::placeholder IsPlaceholder, typename DestT>
event copy(accessor<SrcT, SrcDims, SrcMode, SrcTgt, IsPlaceholder> src,
           DestT* dest);
----
a@ <<subsec:explicitmemory,Explicit copy>>
a@ Equivalent to submitting a command-group containing
[code]#handler::require(src)# and
[code]#handler::copy(src, dest)#.
a@
[source]
----
template <typename SrcT, typename DestT, int DestDims, access_mode DestMode,
          target DestTgt, access::placeholder IsPlaceholder>
event copy(const SrcT* src,
           accessor<DestT, DestDims, DestMode, DestTgt, IsPlaceholder> dest);
----
a@ <<subsec:explicitmemory,Explicit copy>>
a@ Equivalent to submitting a command-group containing
[code]#handler::require(dest)# and
[code]#handler::copy(src, dest)#.
a@
[source]
----
template <typename SrcT, int SrcDims, access_mode SrcMode, target SrcTgt,
          access::placeholder IsSrcPlaceholder, typename DestT, int DestDims,
          access_mode DestMode, target DestTgt,
          access::placeholder IsDestPlaceholder>
event copy(
    accessor<SrcT, SrcDims, SrcMode, SrcTgt, IsSrcPlaceholder> src,
    accessor<DestT, DestDims, DestMode, DestTgt, IsDestPlaceholder> dest);
----
a@ <<subsec:explicitmemory,Explicit copy>>
a@ Equivalent to submitting a command-group containing
[code]#handler::require(src)#, [code]#handler::require(dest)# and
[code]#handler::copy(src, dest)#.
a@
[source]
----
template <typename T, int Dims, access_mode Mode, target Tgt,
          access::placeholder IsPlaceholder>
event update_host(accessor<T, Dims, Mode, Tgt, IsPlaceholder> acc);
----
a@ <<subsec:explicitmemory,Explicit copy>>
a@ Equivalent to submitting a command-group containing
[code]#handler::require(acc)# and
[code]#handler::update_host(acc)#.
a@
[source]
----
template <typename T, int Dims, access_mode Mode, target Tgt,
          access::placeholder IsPlaceholder>
event fill(accessor<T, Dims, Mode, Tgt, IsPlaceholder> dest, const T& src);
----
a@ <<subsec:explicitmemory,Explicit copy>>
a@ Equivalent to submitting a command-group containing
[code]#handler::require(dest)# and
[code]#handler::fill(dest, src)#.

|====


==== Queue information descriptors

A <<queue>> can be queried for information using the [code]#get_info#
member function of the [code]#queue# class, specifying one of the info
parameters in [code]#info::queue#.  The possible values for each info parameter
and any restriction are defined in the specification of the <<backend>>
associated with the <<queue>>. All info parameters in [code]#info::queue# are
specified in <<table.queue.info>> and the synopsis for [code]#info::queue# is
described in <<appendix.queue.descriptors>>.

[[table.queue.info]]
.Queue information descriptors
[width="100%",options="header",separator="@",cols="37%,19%,44%"]
|====
@ Queue Descriptors @ Return type @ Description
a@
[source]
----
info::queue::context
----

    @ [.code]#context#
   a@ Returns the SYCL [code]#context# associated with this SYCL [code]#queue#.

a@
[source]
----
info::queue::device
----

    @ [.code]#device#
   a@ Returns the SYCL <<device>> associated with this SYCL [code]#queue#.

|====


[[sec:queue-properties]]
==== Queue properties

The properties that can be provided when constructing the SYCL
[code]#queue# class are describe in
<<table.properties.queue>>.


[[table.properties.queue]]
.Properties supported by the SYCL [code]#queue# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Property @ Description
a@
[source]
----
property::queue::enable_profiling
----
   a@ The [code]#enable_profiling# property adds the requirement
      that the <<sycl-runtime>> must capture profiling information for
      the <<command-group,command groups>> that are submitted from this SYCL
      [code]#queue# and provide said information via the SYCL
      [code]#event# class [code]#get_profiling_info# member
      function.  If the queue's associated device does not have
      [code]#aspect::queue_profiling#, passing this property to the queue's
      constructor causes the constructor to throw a synchronous
      [code]#exception# with the [code]#errc::feature_not_supported# error
      code.

a@
[source]
----
property::queue::in_order
----
   a@ The [code]#in_order# property adds the requirement that
      a SYCL [code]#queue# provides in-order semantics whereby
      commands submitted to said [code]#queue# are executed in
      the order in which they are submitted.
      Commands submitted in this fashion can be viewed as-if
      having an implicit dependence on the previous command
      submitted to that [code]#queue#. Using the [code]#in_order#
      property makes no guarantees about the ordering of commands
      submitted to different queues with respect to each other.

|====


The constructors of the [code]#queue# [code]#property#
classes are listed in <<table.constructors.properties.queue>>.


[[table.constructors.properties.queue]]
.Constructors of the [code]#queue# [code]#property# classes
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
property::queue::enable_profiling::enable_profiling()
----
   a@ Constructs a SYCL [code]#enable_profiling# property instance.

a@
[source]
----
property::queue::in_order::in_order()
----
   a@ Constructs a SYCL [code]#in_order# property instance.

|====



[[sec:interface.queue.errors]]
==== Queue error handling

Queue errors come in two forms:

  * *Synchronous Errors* are those that we would expect to be
    reported directly at the point of waiting on an event, and hence waiting
    for a queue to complete, as well as any immediate errors reported by
    enqueuing work onto a queue. Such errors are reported through {cpp}
    exceptions.
  * <<async-error,Asynchronous errors>> are those that are produced or detected after
    associated host API calls have returned (so can't be thrown as
    exceptions by the API call), and that are handled by an
    <<async-handler>> through which the errors are reported. Handling of
    asynchronous errors from a queue occurs at specific times, as described
    by <<error-handling>>.

Note that if there are <<async-error,asynchronous errors>> to be processed when a queue
is destructed, the handler is called and
this might delay or block the destruction, according to the behavior
of the handler.


// %%%%%%%%%%%%%%%%%%%%%%%%%%%% end queue_class %%%%%%%%%%%%%%%%%%%%%%%%%%%%

[[sec:interface.event]]
=== Event class

An <<event>> in SYCL is an object that represents the status of an operation
that is being executed by the SYCL runtime.

Typically in SYCL, data dependency and execution order is handled implicitly by
the SYCL runtime. However, in some circumstances developers want fine grain control
of the execution, or want to retrieve properties of a command that is running.

Note that, although an event represents the status of a particular operation,
the dependencies of a certain event can be used to keep track of multiple steps
required to synchronize said operation.

A SYCL event is returned by the submission of a <<command-group>>.
The dependencies of the event returned via the submission of the command group
are the implementation-defined commands associated with the <<command-group>>
execution.

The SYCL [code]#event# class provides the common reference semantics
(see <<sec:reference-semantics>>).

The constructors and member functions of the SYCL [code]#event# class
are listed in <<table.constructors.event>> and
<<table.members.event>>, respectively. The additional common special
member functions and common member functions are listed in
<<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>>, respectively.

// Interface for class: event.h
[source,,linenums]
----
include::{header_dir}/event.h[lines=4..-1]
----


[[table.constructors.event]]
.Constructors of the [code]#event# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
event()
----
   a@ Constructs an [code]#event# that is immediately ready.  The
      [code]#event# has no dependencies and no associated commands.
      Waiting on this [code]#event# will return immediately and querying
      its status will return [code]#info::event_command_status::complete#.

The event is constructed as though it was created from a default-constructed
[code]#queue#.  Therefore, its backend is the same as the backend from the
default device.

|====



[[table.members.event]]
.Member functions for the [code]#event# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
backend get_backend() const noexcept
----
   a@ Returns a [code]#backend# identifying the <<backend>> associated
      with this [code]#event#.

a@
[source]
----
std::vector<event> get_wait_list()
----
   a@ Return the list of events that this event waits for in
      the dependence graph.  Only direct dependencies are returned,
      and not transitive dependencies that direct dependencies wait on.
      Whether already completed events are included in the returned list
      is implementation-defined.

a@
[source]
----
void wait()
----
   a@ Wait for the event and the command associated with
      it to complete.

a@
[source]
----
void wait_and_throw()
----
   a@ Wait for the event and the command associated with
      it to complete.

Any unconsumed <<async-error,asynchronous errors>> from any context that the event
was waiting on executions from will be passed to the
<<async-handler>> associated with the context.
If no user defined [code]#async_handler# is associated with
the context, then an implementation-defined
default <<async-handler>> is called to handle any errors, as
described in <<subsubsec:exception.nohandler>>.

a@
[source]
----
static void wait(const std::vector<event>& eventList)
----
   a@ Synchronously wait on a list of events.

a@
[source]
----
static void wait_and_throw(const std::vector<event>& eventList)
----
   a@ Synchronously wait on a list of events.

Any unconsumed <<async-error,asynchronous errors>> from any context that the event
was waiting on executions from will be passed to the
<<async-handler>> associated with the context.
If no user defined [code]#async_handler# is associated with
the context, then an implementation-defined
default <<async-handler>> is called to handle any errors, as
described in <<subsubsec:exception.nohandler>>.

a@
[source]
----
template <typename Param> typename Param::return_type get_info() const
----
   a@ Queries this SYCL [code]#event# for information requested by the
      template parameter [code]#Param#.
      The type alias [code]#Param::return_type# must be defined in
      accordance with the info parameters in <<table.event.info>> to
      facilitate returning the type associated with the [code]#Param#
      parameter.

a@
[source]
----
template <typename Param> typename Param::return_type get_backend_info() const
----
   a@ Queries this SYCL [code]#event# for <<backend>>-specific information
      requested by the template parameter [code]#Param#.
      The type alias [code]#Param::return_type# must be defined in
      accordance with the <<backend>> specification.
      Must throw an [code]#exception# with the [code]#errc::backend_mismatch#
      error code if the <<backend>> that corresponds with [code]#Param# is different
      from the <<backend>> that is associated with this [code]#event#.

a@
[source]
----
template <typename Param> typename Param::return_type get_profiling_info() const
----
   a@ Queries this SYCL [code]#event# for profiling information requested
      by the parameter [code]#Param#. If the requested profiling information
      is unavailable when [code]#get_profiling_info# is called due to
      incompletion of <<command-group,command groups>> associated with the [code]#event#,
      then the call to [code]#get_profiling_info# will block until
      the requested profiling information is available. An example is asking for
      [code]#info::event_profiling::command_end# when the associated
      <<command-group>> action has yet to finish execution.
      Calls to [code]#get_profiling_info# must throw an [code]#exception#
      with the [code]#errc::invalid# error code if the SYCL
      [code]#queue# which submitted the <<command-group>> this
      SYCL [code]#event# is associated with was not constructed with
      the [code]#property::queue::enable_profiling# property.
      The type alias [code]#Param::return_type# must be defined in
      accordance with the info parameters in
      <<table.event.profilinginfo>> to facilitate returning the type
      associated with the [code]#Param# parameter.

|====


==== Event information and profiling descriptors

An <<event>> can be queried for information using the [code]#get_info#
member function of the [code]#event# class, specifying one of the info
parameters in [code]#info::event#.  The possible values for each info parameter
and any restrictions are defined in the specification of the <<backend>>
associated with the <<event>>. All info parameters in [code]#info::event# are
specified in <<table.event.info>> and the synopsis for [code]#info::event# is
described in <<appendix.event.descriptors>>.

[[table.event.info]]
.Event class information descriptors
[width="100%",options="header",separator="@",cols="37%,19%,44%"]
|====
@ Event Descriptors @ Return type @ Description
a@
[source]
----
info::event::command_execution_status
----

    @ [.code]#info::event_command_status#
   a@ Returns the event status of the command group and contained action
      (e.g. kernel invocation) associated with this SYCL [code]#event#.

|====

The [code]#info::event::command_execution_status# query returns one of the
values defined in <<table.event.command-status>>.

[[table.event.command-status]]
.Event command status
[width="100%",options="header",separator="@",cols="45%,55%"]
|====
@ Status @ Description
a@
[source]
----
info::event_command_status::submitted
----
   a@ Indicates that the command has been submitted to the SYCL queue but has
      not yet started running on the device.

a@
[source]
----
info::event_command_status::running
----
   a@ Indicates that the command has started running on the device but has not
      yet completed.

a@
[source]
----
info::event_command_status::complete
----
   a@ Indicates that the command has finished running on the device.
      Attempting to wait on such an event will not block.

|====


An <<event>> can be queried for profiling information using the
[code]#get_profiling_info# member function of the [code]#event# class,
specifying one of the profiling info parameters enumerated in
[code]#info::event_profiling#.  The possible values for each info parameter and
any restrictions are defined in the specification of the <<backend>>
associated with the <<event>>. All info parameters in
[code]#info::event_profiling# are specified in <<table.event.profilinginfo>>
and the synopsis for [code]#info::event_profiling# is described in
<<appendix.event.descriptors>>.

Each profiling descriptor returns a 64-bit timestamp that represents the number
of nanoseconds that have elapsed since some implementation-defined timebase.
All events that share the same backend are guaranteed to share the same
timebase, therefore the difference between two timestamps from the same backend
yields the number of nanoseconds that have elapsed between those events.

[[table.event.profilinginfo]]
.Profiling information descriptors for the SYCL [code]#event# class
[width="100%",options="header",separator="@",cols="43%,13%,44%"]
|====
@ Event information profiling descriptor @ Return type @ Description
a@
[source]
----
info::event_profiling::command_submit
----

    @ [.code]#uint64_t#
   a@ Returns a timestamp telling when the associated <<command-group>> was
      submitted to the [code]#queue#.  This is always some time after the
      <<command-group-function-object>> returns and before the associated call
      to [code]#queue::submit# returns.

a@
[source]
----
info::event_profiling::command_start
----

    @ [.code]#uint64_t#
   a@ Querying this profiling descriptor blocks until the event's state becomes
      either [code]#info::event_command_status::running# or
      [code]#info::event_command_status::complete#.  The returned timestamp
      tells when the action associated with the <<command-group>> (e.g. kernel
      invocation) started executing on the device.  For any given event, this
      timestamp is always greater than or equal to the
      [code]#info::event_profiling::command_submit# timestamp.  Implementations
      are encouraged to return a timestamp that is as close as possible to the
      point when the action starts running on the device, but there is no
      specific accuracy that is guaranteed.

a@
[source]
----
info::event_profiling::command_end
----

    @ [.code]#uint64_t#
   a@ Querying this profiling descriptor blocks until the event's state becomes
      [code]#info::event_command_status::complete#.  The returned timestamp
      tells when the action associated with the <<command-group>> (e.g. kernel
      invocation) finished executing on the device.  For any given event, this
      timestamp is always greater than or equal to the
      [code]#info::event_profiling::command_start# timestamp.


|====



[[sec:data.access.and.storage]]
== Data access and storage in SYCL

In SYCL, when using <<buffer,buffers>> and <<image,images>>,
data storage and access are handled by separate classes.
<<buffer,Buffers>> and <<image,images>> handle
storage and ownership of the data, whereas <<accessor,accessors>> handle access to
the data.
Buffers and images in SYCL can be bound to more than one device or context,
including across different <<backend, SYCL backends>>.
They also handle ownership of the
data, while allowing exception handling for blocking
and non-blocking data transfers. Accessors manage data transfers between the host
and all of the devices in the system, as well as tracking of data dependencies.

Zero-sized buffers and accessors are permitted, but attempting to access data
within them produces undefined behavior, similar to dereferencing a null
pointer in {cpp}.  Note that zero-sized accessors can be created in several
ways: by creating an accessor from a zero-sized buffer, by creating an accessor
with a zero-sized buffer sub-range, or by creating an accessor with its default
constructor.

When using <<usm>> allocations, data storage is managed by USM allocation functions, and
data access is via pointers.  See <<sec:usm>> for greater detail.

=== Host allocation

A <<sycl-runtime>> may need to allocate temporary objects on the host
to handle some operations (such as copying data from one context to
another).
Allocation on the host is managed using an allocator object, following the
standard {cpp} allocator class definition.
The default allocator for memory objects is implementation-defined,
but the user can supply their own allocator class.

[source,,linenums]
----
{
    buffer<int, 1, UserDefinedAllocator<int>> b(d);
}
----

When an allocator returns a [code]#nullptr#, the runtime cannot allocate data on the
host. Note that in this case the runtime will raise an error if it requires
host memory but it is not available (e.g when moving data across <<backend>>
contexts).

In some cases, the implementation may retain a copy of the allocator object
even after the buffer is destroyed.  For example, this can happen when the
buffer object is destroyed before commands using accessors to the buffer have
completed.  Therefore, the application must be prepared for calls to the
allocator even after the buffer is destroyed.

[NOTE]
====
If the application needs to know when the implementation has destroyed all
copies of the allocator, it can maintain a reference count within the
allocator.
====

The definition of allocators extends the current functionality of SYCL,
ensuring that users can define allocator functions for specific hardware or
certain complex shared memory mechanisms (e.g. NUMA), and improves
interoperability with STL-based libraries (e.g, Intel's TBB provides an
allocator).


[[subsec:default.allocators]]
==== Default allocators

A default allocator is always defined by the implementation. For allocations
greater than size zero, it is guaranteed to return non-[code]#nullptr# and
new memory positions every call.
The default allocator for const buffers will remove the const-ness of the
type (therefore, the default allocator for a buffer of type [code]#const int#
will be an [code]#Allocator<int>)#.
This implies that host <<accessor,accessors>> will not synchronize with the pointer given
by the user in the buffer/image constructor, but will use the memory
returned by the [code]#Allocator# itself for that purpose.
The user can implement an allocator that returns the same address as the
one passed in the buffer constructor, but it is the responsibility of the
user to handle the potential race conditions.


[[table.default.allocators]]
.SYCL Default Allocators
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Allocators @ Description
a@
[source]
----
template <class T> buffer_allocator
----
   a@ It is the default buffer allocator used by the runtime, when no allocator is
      defined by the user.
      Meets the C++ named requirement [code]#Allocator#.
      A buffer of data type [code]#const T# uses [code]#buffer_allocator<T># by default.

a@
[source]
----
image_allocator
----
   a@ It is the default allocator used by the runtime for the SYCL [code]#unsampled_image# and [code]#sampled_image# classes when no allocator is provided by the user.
      The [code]#image_allocator# is required to allocate in elements of [code]#std::byte#.

|====


See <<subsec:mutex>> for details on manual host-device synchronization.


[[subsec:buffers]]
=== Buffers

The [code]#buffer# class defines a shared array of one, two or three
dimensions that can be used by the SYCL <<kernel>> and has to be accessed using
<<accessor>> classes. Buffers are templated on both the type of their data,
and the number of dimensions that the data is stored and accessed through.

A [code]#buffer# does not map to only one underlying backend
object, and all <<backend>> memory objects may be temporary for use
within a command group on a specific device.

The underlying data type of a buffer [code]#T# must be <<device-copyable>> as
defined in <<sec::device.copyable>>.  Some overloads of the [code]#buffer#
constructor initialize the buffer contents by copying objects from host memory
while other overloads construct the buffer without copying objects from the
host.  For the overloads that do not copy host objects, the initial state of
the objects in the buffer depends on whether [code]#T# is an implicit-lifetime
type (as defined in the {cpp} core language).  If [code]#T# is an
implicit-lifetime type, objects of that type are implicitly created in the
buffer with indeterminate values.  For other types, these constructor overloads
merely allocate uninitialized memory, and the application is responsible for
constructing objects by calling placement-new and for destroying them later
by manually calling the object's destructor.

For the overloads that do copy objects from host memory, the [code]#hostData#
pointer must point to at least _N_ bytes of memory where _N_ is
[code]#sizeof(T) * bufferRange.size()#.  If _N_ is zero, [code]#hostData# is
permitted to be a null pointer.

A SYCL [code]#buffer# can construct an instance of a SYCL [code]#buffer#
that reinterprets the original SYCL [code]#buffer# with a different
type, dimensionality and range using the member function
[code]#reinterpret#. The reinterpreted SYCL [code]#buffer# that is
constructed must behave as though it were a copy of the SYCL [code]#buffer#
that constructed it (see <<sec:reference-semantics>>) with the exception
that the type, dimensionality and range of the reinterpreted SYCL
[code]#buffer# must reflect the type, dimensionality and range specified
when calling the [code]#reinterpret# member function. By extension of this,
the class member types [code]#value_type#, [code]#reference# and
[code]#const_reference#, and the member functions [code]#get_range()#
and [code]#size()# of the reinterpreted SYCL [code]#buffer# must
reflect the new type, dimensionality and range. The data that the original SYCL
[code]#buffer# and the reinterpreted SYCL [code]#buffer# manage
remains unaffected, though the representation of the data when accessed through
the reinterpreted SYCL [code]#buffer# may alter to reflect the new type,
dimensionality and range. It is important to note that a reinterpreted SYCL
[code]#buffer# is a copy of the original SYCL [code]#buffer# only,
and not a new SYCL [code]#buffer#. Constructing more than one SYCL
[code]#buffer# managing the same host pointer is still undefined behavior.

The SYCL [code]#buffer# class template provides the common reference
semantics (see <<sec:reference-semantics>>).


==== Buffer interface

The constructors and member functions of the SYCL [code]#buffer# class
template are listed in <<table.constructors.buffer>> and
<<table.members.buffer>>, respectively. The additional common special
member functions and common member functions are listed in
<<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>>, respectively.

Each constructor takes as the last parameter an optional SYCL
[code]#property_list# to provide properties to the SYCL
[code]#buffer#.

The SYCL [code]#buffer# class template takes a template parameter
[code]#AllocatorT# for specifying an allocator which is used by
the <<sycl-runtime>> when allocating temporary memory on the
host. If no template argument is provided, then the default allocator
for the SYCL [code]#buffer# class [code]#buffer_allocator<T>#
will be used (see <<subsec:default.allocators>>).

// Interface for class: buffer

[source,,linenums]
----
include::{header_dir}/buffer.h[lines=4..-1]
----


[[table.constructors.buffer]]
.Constructors of the [code]#buffer# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
buffer(const range<Dimensions>& bufferRange,
       const property_list& propList = {})
----
   a@ Construct a SYCL [code]#buffer# instance with uninitialized memory.
      The constructed SYCL [code]#buffer# will use a default constructed [code]#AllocatorT# when allocating memory on the host.
      The range of the constructed SYCL [code]#buffer# is specified by the [code]#bufferRange# parameter provided.
      Data is not written back to the host on destruction of the [code]#buffer# unless the [code]#buffer# has a valid non-null pointer specified via the member function [code]#set_final_data()#.
      Zero or more properties can be provided to the constructed SYCL [code]#buffer# via an instance of [code]#property_list#.

a@
[source]
----
buffer(const range<Dimensions>& bufferRange,
       AllocatorT allocator,
       const property_list& propList = {})
----
   a@ Construct a SYCL [code]#buffer# instance with uninitialized memory.
      The constructed SYCL [code]#buffer# will use the [code]#allocator# parameter provided when allocating memory on the host.
      The range of the constructed SYCL [code]#buffer# is specified by the [code]#bufferRange# parameter provided.
      Data is not written back to the host on destruction of the [code]#buffer# unless the [code]#buffer# has a valid non-null pointer specified via the member function [code]#set_final_data()#.
      Zero or more properties can be provided to the constructed SYCL [code]#buffer# via an instance of [code]#property_list#.

a@
[source]
----
buffer(T* hostData, const range<Dimensions>& bufferRange,
       const property_list& propList = {})
----
   a@ Construct a SYCL [code]#buffer# instance with the [code]#hostData#
      parameter provided.  The buffer is initialized with the memory specified
      by [code]#hostData#, and the buffer assumes exclusive access to this
      memory for the duration of its lifetime.  The constructed SYCL
      [code]#buffer# will use a default constructed [code]#AllocatorT# when
      allocating memory on the host.  The range of the constructed SYCL
      [code]#buffer# is specified by the [code]#bufferRange# parameter
      provided.  Zero or more properties can be provided to the constructed
      SYCL [code]#buffer# via an instance of [code]#property_list#.

a@
[source]
----
buffer(T* hostData, const range<Dimensions>& bufferRange,
       AllocatorT allocator,
       const property_list& propList = {})
----
   a@ Construct a SYCL [code]#buffer# instance with the [code]#hostData#
      parameter provided.  The buffer is initialized with the memory specified
      by [code]#hostData#, and the buffer assumes exclusive access to this
      memory for the duration of its lifetime.  The constructed SYCL
      [code]#buffer# will use the [code]#allocator# parameter provided when
      allocating memory on the host.  The range of the constructed SYCL
      [code]#buffer# is specified by the [code]#bufferRange# parameter
      provided.  Zero or more properties can be provided to the constructed
      SYCL [code]#buffer# via an instance of [code]#property_list#.

a@
[source]
----
buffer(const T* hostData,
       const range<Dimensions>& bufferRange,
       const property_list& propList = {})
----
   a@ Construct a SYCL [code]#buffer# instance with the [code]#hostData#
      parameter provided.  The buffer assumes exclusive access to this memory
      for the duration of its lifetime.

The constructed SYCL [code]#buffer# will use a default
constructed [code]#AllocatorT# when allocating memory on
the host.

The host address is [code]#const T#, so the host accesses
can be read-only. However, the [code]#typename T# is not const so
the device accesses can be both read and write accesses. Since
the [code]#hostData# is const, this buffer is only initialized with
this memory and there is no write back after its destruction,
unless the [code]#buffer# has another valid non-null final
data address specified via the member function
[code]#set_final_data()# after construction of the
[code]#buffer#.

The range of the constructed SYCL [code]#buffer# is
specified by the [code]#bufferRange# parameter provided.

Zero or more properties can be provided to the constructed SYCL
[code]#buffer# via an instance of
[code]#property_list#.

a@
[source]
----
buffer(const T* hostData,
       const range<Dimensions>& bufferRange,
       AllocatorT allocator,
       const property_list& propList = {})
----
   a@ Construct a SYCL [code]#buffer# instance with the [code]#hostData#
      parameter provided.  The buffer assumes exclusive access to this
      memory for the duration of its lifetime.

The constructed SYCL [code]#buffer# will use the
[code]#allocator# parameter provided when allocating
memory on the host.

The host address is [code]#const T#, so the host accesses
can be read-only. However, the [code]#typename T# is not const so
the device accesses can be both read and write accesses. Since,
the [code]#hostData# is const, this buffer is only initialized
with this memory and there is no write back after its
destruction, unless the [code]#buffer# has another valid
non-null final data address specified via the member function
[code]#set_final_data()# after construction of the
[code]#buffer#.

The range of the constructed SYCL [code]#buffer# is
specified by the [code]#bufferRange# parameter provided.

Zero or more properties can be provided to the constructed SYCL
[code]#buffer# via an instance of
[code]#property_list#.


a@
[source]
----
template <typename Container>
buffer(Container& container,
       const property_list& propList = {})
----
   a@ Construct a one dimensional SYCL [code]#buffer# instance
      from the elements starting at [code]#std::data(container)#
      and containing [code]#std::size(container)# number of elements.
      The buffer is initialized with the contents of [code]#container#,
      and the buffer assumes exclusive access to [code]#container# for
      the duration of its lifetime.

Data is written back to [code]#container# before the completion of
[code]#buffer# destruction if the return type of [code]#std::data(container)#
is not [code]#const#.

The constructed SYCL [code]#buffer# will use a default constructed [code]#AllocatorT# when allocating memory on the host.

Zero or more properties can be provided to the constructed SYCL
[code]#buffer# via an instance of
[code]#property_list#.

This constructor is only defined for a [code]#buffer# parameterized
with [code]#Dimensions == 1#, and when [code]#std::data(container)#
is convertible to [code]#T*#.


a@
[source]
----
template <typename Container>
buffer(Container& container, AllocatorT allocator,
       const property_list& propList = {})
----
   a@ Construct a one dimensional SYCL [code]#buffer# instance
      from the elements starting at [code]#std::data(container)#
      and containing [code]#std::size(container)# number of elements.
      The buffer is initialized with the contents of [code]#container#,
      and the buffer assumes exclusive access to [code]#container# for
      the duration of its lifetime.

Data is written back to [code]#container# before the completion of
[code]#buffer# destruction if the return type of [code]#std::data(container)#
is not [code]#const#.

The constructed SYCL [code]#buffer# will use the [code]#allocator# parameter provided when allocating memory on the host.

Zero or more properties can be provided to the constructed SYCL
[code]#buffer# via an instance of
[code]#property_list#.

This constructor is only defined for a [code]#buffer# parameterized
with [code]#Dimensions == 1#, and when [code]#std::data(container)#
is convertible to [code]#T*#.


a@
[source]
----
buffer(const std::shared_ptr<T>& hostData,
       const range<Dimensions>& bufferRange,
       const property_list& propList = {})
----
   a@ When [code]#hostData# is not empty, construct a SYCL buffer with the
      contents of its stored pointer.  The buffer assumes exclusive access to
      this memory for the duration of its lifetime.  The buffer also creates
      its own internal copy of the [code]#shared_ptr# that shares ownership of
      the [code]#hostData# memory, which means the application can safely
      release ownership of this [code]#shared_ptr# when the constructor
      returns.

When [code]#hostData# is empty, construct a SYCL buffer with uninitialized
memory.

The constructed SYCL [code]#buffer# will use a default constructed
[code]#AllocatorT# when allocating memory on the host.  The range of the
constructed SYCL [code]#buffer# is specified by the [code]#bufferRange#
parameter provided.  Zero or more properties can be provided to the
constructed SYCL [code]#buffer# via an instance of [code]#property_list#.

a@
[source]
----
buffer(const std::shared_ptr<T>& hostData,
       const range<Dimensions>& bufferRange,
       AllocatorT allocator,
       const property_list& propList = {})
----
   a@ When [code]#hostData# is not empty, construct a SYCL buffer with the
      contents of its stored pointer.  The buffer assumes exclusive access to
      this memory for the duration of its lifetime.  The buffer also creates
      its own internal copy of the [code]#shared_ptr# that shares ownership of
      the [code]#hostData# memory, which means the application can safely
      release ownership of this [code]#shared_ptr# when the constructor
      returns.

When [code]#hostData# is empty, construct a SYCL buffer with uninitialized
memory.

The constructed SYCL [code]#buffer# will use the [code]#allocator# parameter
provided when allocating memory on the host.  The range of the constructed SYCL
[code]#buffer# is specified by the [code]#bufferRange# parameter provided.
Zero or more properties can be provided to the constructed SYCL [code]#buffer#
via an instance of [code]#property_list#.

a@
[source,c++]
----
buffer(const std::shared_ptr<T[]>& hostData,
       const range<Dimensions>&  bufferRange,
       const property_list& propList = {})
----
   a@ When [code]#hostData# is not empty, construct a SYCL buffer with the
      contents of its stored pointer.  The buffer assumes exclusive access to
      this memory for the duration of its lifetime.  The buffer also creates
      its own internal copy of the [code]#shared_ptr# that shares ownership of
      the [code]#hostData# memory, which means the application can safely
      release ownership of this [code]#shared_ptr# when the constructor
      returns.

When [code]#hostData# is empty, construct a SYCL buffer with uninitialized
memory.

The constructed SYCL [code]#buffer# will use a default constructed
[code]#AllocatorT# when allocating memory on the host.  The range of the
constructed SYCL [code]#buffer# is specified by the [code]#bufferRange#
parameter provided.  Zero or more properties can be provided to the
constructed SYCL [code]#buffer# via an instance of [code]#property_list#.

a@
[source,c++]
----
buffer(const std::shared_ptr<T[]>& hostData,
       const range<Dimensions>& bufferRange,
       AllocatorT allocator,
       const property_list& propList = {})
----
   a@ When [code]#hostData# is not empty, construct a SYCL buffer with the
      contents of its stored pointer.  The buffer assumes exclusive access to
      this memory for the duration of its lifetime.  The buffer also creates
      its own internal copy of the [code]#shared_ptr# that shares ownership of
      the [code]#hostData# memory, which means the application can safely
      release ownership of this [code]#shared_ptr# when the constructor
      returns.

When [code]#hostData# is empty, construct a SYCL buffer with uninitialized
memory.

The constructed SYCL [code]#buffer# will use the [code]#allocator# parameter
provided when allocating memory on the host.  The range of the constructed SYCL
[code]#buffer# is specified by the [code]#bufferRange# parameter provided.
Zero or more properties can be provided to the constructed SYCL [code]#buffer#
via an instance of [code]#property_list#.

a@
[source]
----
template <typename InputIterator>
buffer(InputIterator first, InputIterator last,
       const property_list& propList = {})
----
   a@ Create a new allocated 1D buffer initialized from the given elements
      ranging from [code]#first# up to one before [code]#last#.
      The data is copied to an intermediate memory position by the runtime.
      Data is not written back to the same iterator set provided. However, if the [code]#buffer# has a valid non-const iterator specified via the member function [code]#set_final_data()#, data will be copied back to that iterator.
      The constructed SYCL [code]#buffer# will use a default constructed [code]#AllocatorT# when allocating memory on the host.
      Zero or more properties can be provided to the constructed SYCL [code]#buffer# via an instance of [code]#property_list#.

a@
[source]
----
template <typename InputIterator>
buffer(InputIterator first, InputIterator last,
       AllocatorT allocator = {},
       const property_list& propList = {})
----
   a@ Create a new allocated 1D buffer initialized from the given elements
      ranging from [code]#first# up to one before [code]#last#.
      The data is copied to an intermediate memory position by the runtime.
      Data is not written back to the same iterator set provided. However, if the [code]#buffer# has a valid non-const iterator specified via the member function [code]#set_final_data()#, data will be copied back to that iterator.
      The constructed SYCL [code]#buffer# will use the [code]#allocator# parameter provided when allocating memory on the host.
      Zero or more properties can be provided to the constructed SYCL [code]#buffer# via an instance of [code]#property_list#.

a@
[source]
----
buffer(buffer& b, const id<Dimensions>& baseIndex,
       const range<Dimensions>& subRange)
----
   a@ Create a new sub-buffer without allocation to have separate
      accessors later. [code]#b# is the buffer with the real data, which must not be a sub-buffer.
      [code]#baseIndex# specifies the origin of the sub-buffer inside the
      buffer [code]#b#. [code]#subRange# specifies the size of the sub-buffer.
      The sum of [code]#baseIndex# and [code]#subRange# in any dimension must not
      exceed the parent buffer ([code]#b)# size ([code]#bufferRange)# in that dimension,
      and an [code]#exception# with the [code]#errc::invalid# error code must be thrown if violated.

The offset and range specified by [code]#baseIndex# and
[code]#subRange# together must represent a contiguous
region of the original SYCL [code]#buffer#.

If a non-contiguous region of a buffer is requested when
constructing a sub-buffer, then an [code]#exception# with
the [code]#errc::invalid# error code must be
thrown.

The origin (based on [code]#baseIndex#) of the sub-buffer being constructed
must be a multiple of the memory base address alignment of each SYCL
[code]#device# which accesses data from the buffer.  This value is retrievable
via the SYCL [code]#device# class info query
[code]#info::device::mem_base_addr_align#.  Violating this requirement causes
the implementation to throw an [code]#exception# with the [code]#errc::invalid#
error code from the [code]#accessor# constructor (if the accessor is not a
placeholder) or from [code]#handler::require()# (if the accessor is a
placeholder).  If the accessor is bound to a <<command-group>> with a secondary
queue, the sub-buffer's alignment must be compatible with both the primary
queue's device and the secondary queue's device, otherwise this exception is
thrown.

Must throw an [code]#exception# with the [code]#errc::invalid# error code if
[code]#b# is a sub-buffer.

|====



[[table.members.buffer]]
.Member functions for the [code]#buffer# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
range<Dimensions> get_range() const
----
   a@ Return a range object representing the
      size of the buffer in terms of number
      of elements in each dimension as passed
      to the constructor.

a@
[source]
----
size_t size() const noexcept
----
   a@ Returns the total number of elements in the buffer.
      Equal to [code]#+get_range()[0] * ... * get_range()[Dimensions-1]+#.
a@
[source]
----
size_t get_count() const
----
   a@ Returns the same value as [code]#size()#. Deprecated.
a@
[source]
----
size_t byte_size() const noexcept
----
   a@ Returns the size of the buffer storage in bytes.
      Equal to [code]#size()*sizeof(T)#.
a@
[source]
----
size_t get_size() const
----
   a@ Returns the same value as [code]#byte_size()#. Deprecated.
a@
[source]
----
AllocatorT get_allocator() const
----
   a@ Returns the allocator provided to the buffer.

a@
[source]
----
template <access_mode Mode = access_mode::read_write,
          target Targ = target::device>
accessor<T, Dimensions, Mode, Targ> get_access(handler& commandGroupHandler)
----
   a@ Returns a valid [code]#accessor# to the buffer with the specified
      access mode and target in the command group buffer.
      The value of target can be [code]#target::device# or
      [code]#target::constant_buffer#.

a@
[source]
----
template <access_mode Mode>
accessor<T, Dimensions, Mode, target::host_buffer> get_access()
----
   a@ Deprecated in SYCL 2020.  Use [code]#get_host_access()# instead.

Returns a valid host [code]#accessor# to the buffer with the specified
access mode and target.

a@
[source]
----
template <access_mode Mode = access_mode::read_write,
          target Targ = target::device>
accessor<T, Dimensions, Mode, Targ> get_access(handler& commandGroupHandler,
                                               range<Dimensions> accessRange,
                                               id<Dimensions> accessOffset = {})
----
   a@ Returns a valid [code]#accessor# to the buffer with the specified access
      mode and target in the command group buffer.  The accessor is a
      <<ranged-accessor>>, where the range starts at the given offset from the
      beginning of the buffer.  The value of target can be
      [code]#target::device# or [code]#target::constant_buffer#.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
the sum of [code]#accessRange# and [code]#accessOffset# exceeds the range of
the buffer in any dimension.

a@
[source]
----
template <access_mode Mode>
accessor<T, Dimensions, Mode, target::host_buffer>
get_access(range<Dimensions> accessRange, id<Dimensions> accessOffset = {})
----
   a@ Deprecated in SYCL 2020.  Use [code]#get_host_access()# instead.

Returns a valid host [code]#accessor# to the buffer with the specified access
mode and target.  The accessor is a <<ranged-accessor>>, where the range starts
at the given offset from the beginning of the buffer.  The value of target can
only be [code]#target::host_buffer#.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
the sum of [code]#accessRange# and [code]#accessOffset# exceeds the range of
the buffer in any dimension.

a@
[source]
----
template <typename... Ts> auto get_access(Ts... args)
----
   a@ Returns a valid [code]#accessor# as if constructed via passing the buffer
      and all provided arguments to the [code]#accessor# constructor.

Possible implementation:

[code]#+return accessor{*this, args...};+#

a@
[source]
----
template <typename... Ts> auto get_host_access(Ts... args)
----
   a@ Returns a valid [code]#host_accessor# as if constructed via passing the
      buffer and all provided arguments to the [code]#host_accessor#
      constructor.

Possible implementation:

[code]#+return host_accessor{*this, args...};+#

a@
[source]
----
template <typename Destination = std::nullptr_t>
void set_final_data(Destination finalData = nullptr)
----
   a@ The [code]#finalData# points to where the outcome of all
      the buffer processing is going to be copied to at destruction
      time, if the buffer was involved with a write accessor.

Destination can be either an output iterator or a
[code]#std::weak_ptr<T>#.

Note that a raw pointer is a special case of output iterator and
thus defines the host memory to which the result is to be
copied.

In the case of a weak pointer, the output is not updated if the
weak pointer has expired.

If [code]#Destination# is [code]#std::nullptr_t#, then
the copy back will not happen.

a@
[source]
----
void set_write_back(bool flag = true)
----
   a@ This member function allows dynamically forcing or canceling the
      write-back of the data of a buffer on destruction according to
      the value of [code]#flag#.

Forcing the write-back is similar to what happens during a
normal write-back as described in <<sec:buf-sync-rules>>
and <<sec:sharing-host-memory-with-dm>>.

If there is nowhere to write-back, using this function does not
have any effect.

a@
[source]
----
bool is_sub_buffer() const
----
   a@ Returns true if this SYCL [code]#buffer# is a sub-buffer, otherwise
      returns false.

a@
[source]
----
template <typename ReinterpretT, int ReinterpretDim>
buffer<ReinterpretT, ReinterpretDim,
       typename std::allocator_traits<AllocatorT>::template rebind_alloc<
           std::remove_const_t<ReinterpretT>>>
reinterpret(range<ReinterpretDim> reinterpretRange) const
----
   a@ Creates and returns a reinterpreted SYCL [code]#buffer#
      with the type specified by [code]#ReinterpretT#,
      dimensions specified by [code]#ReinterpretDim# and range
      specified by [code]#reinterpretRange#.  The buffer object
      being reinterpreted can be a SYCL sub-buffer that was created
      from a SYCL [code]#buffer# and must throw
      [code]#exception# with the
      [code]#errc::invalid# error code if the total
      size in bytes represented by the type and range of the
      reinterpreted SYCL [code]#buffer# (or sub-buffer) does not
      equal the total size in bytes represented by the type and range
      of this SYCL [code]#buffer# (or sub-buffer).
      Reinterpreting a sub-buffer provides a reinterpreted view of
      the sub-buffer only, and does not change the offset or size of
      the sub-buffer view (in bytes) relative to the parent
      [code]#buffer#.

a@
[source]
----
template <typename ReinterpretT, int ReinterpretDim = Dimensions>
buffer<ReinterpretT, ReinterpretDim,
       typename std::allocator_traits<AllocatorT>::template rebind_alloc<
           std::remove_const_t<ReinterpretT>>>
reinterpret() const
----
   a@ Creates and returns a reinterpreted SYCL [code]#buffer#
      with the type specified by [code]#ReinterpretT# and
      dimensions specified by [code]#ReinterpretDim#.
      Only valid when [code]#(ReinterpretDim == 1)# or when
      [code]#\((ReinterpretDim == Dimensions) && (sizeof(ReinterpretT) == sizeof(T)))#.
      The buffer object being reinterpreted can be a SYCL sub-buffer
      that was created from a SYCL [code]#buffer#.  The implementation must
      throw an [code]#exception# with the [code]#errc::invalid# error code
      if the total size in bytes represented by this SYCL [code]#buffer# (or
      sub-buffer) is not evenly divisible by [code]#sizeof(ReinterpretT)#.
      Reinterpreting a sub-buffer provides a reinterpreted view
      of the sub-buffer only,
      and does not change the offset or size of the sub-buffer view (in bytes)
      relative to the parent [code]#buffer#.

|====



[[sec:buffer-properties]]
==== Buffer properties

The properties that can be provided when constructing the SYCL
[code]#buffer# class are describe in
<<table.properties.buffer>>.


[[table.properties.buffer]]
.Properties supported by the SYCL [code]#buffer# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Property @ Description
a@
[source]
----
property::buffer::use_host_ptr
----
   a@ The [code]#use_host_ptr# property adds the requirement that the <<sycl-runtime>> must not allocate any memory for the SYCL [code]#buffer# and instead uses the provided host pointer directly. This prevents the <<sycl-runtime>> from allocating additional temporary storage on the host.

This property has a special guarantee for buffers that are constructed from a
[code]#hostData# pointer.  If a [code]#host_accessor# is constructed from such
a buffer, then the address of the [code]#reference# type returned from the
accessor's member functions such as [code]#operator[](id<>)# will be the same
as the corresponding [code]#hostData# address.

a@
[source]
----
property::buffer::use_mutex
----
   a@ The [code]#use_mutex# property is valid for the SYCL
      [code]#buffer#, [code]#unsampled_image# and
      [code]#sampled_image# classes. The property adds the
      requirement that the memory which is owned by the SYCL
      [code]#buffer# can be shared with the application via a
      [code]#std::mutex# provided to the property. The mutex
      [code]#m# is locked by the runtime whenever the data is in
      use and unlocked otherwise. Data is synchronized with
      [code]#hostData#, when the mutex is unlocked by the runtime.

a@
[source]
----
property::buffer::context_bound
----
   a@ The [code]#context_bound# property adds the requirement that the SYCL [code]#buffer# can only be associated with a single SYCL [code]#context# that is provided to the property.

|====


The constructors and special member functions of the buffer property
classes are listed in
<<table.constructors.properties.buffer>> and
<<table.members.properties.buffer>> respectively.


[[table.constructors.properties.buffer]]
.Constructors of the [code]#buffer# [code]#property# classes
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
property::buffer::use_host_ptr::use_host_ptr()
----
   a@ Constructs a SYCL [code]#use_host_ptr# property instance.

a@
[source]
----
property::buffer::use_mutex::use_mutex(std::mutex& mutexRef)
----
   a@ Constructs a SYCL [code]#use_mutex# property instance with a reference to [code]#mutexRef# parameter provided.

a@
[source]
----
property::buffer::context_bound::context_bound(context boundContext)
----
   a@ Constructs a SYCL [code]#context_bound# property instance with a copy of a SYCL [code]#context#.

|====



[[table.members.properties.buffer]]
.Member functions of the [code]#buffer# [code]#property# classes
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
std::mutex* property::buffer::use_mutex::get_mutex_ptr() const
----
   a@ Returns the [code]#std::mutex# which was specified when
      constructing this SYCL [code]#use_mutex# property.

a@
[source]
----
context property::buffer::context_bound::get_context() const
----
   a@ Returns the [code]#context# which was specified when
      constructing this SYCL [code]#context_bound# property.

|====



[[sec:buf-sync-rules]]
==== Buffer synchronization rules

Buffers are reference-counted. When a buffer value is constructed
from another buffer, the two values reference the same buffer and a
reference count is incremented. When a buffer value is destroyed,
the reference count is decremented. Only when there are no more
buffer values that reference a specific buffer is the actual
buffer destroyed and the buffer destruction behavior defined
below is followed.

If any error occurs on buffer destruction, it is reported
via the associated queue's asynchronous error handling mechanism.

The basic rule for the blocking behavior of a buffer destructor is
that it blocks if there is some data to write back because a
write accessor on it has been created, or if the buffer was constructed
with attached host memory and is still in use.

More precisely:

  . A buffer can be constructed from a [code]#range# (and without a
    [code]#hostData# pointer).  The memory management for this type of buffer
    is entirely handled by the SYCL system. The destructor for this type of
    buffer does not need to block, even if work on the buffer has not
    completed. Instead, the SYCL system frees any storage required for the
    buffer asynchronously when it is no longer in use in queues. The initial
    contents of the buffer are unspecified.
  . A buffer can be constructed from a [code]#hostData# pointer.  The buffer
    will use this host memory for its full lifetime, but the contents of this
    host memory are unspecified for the lifetime of the buffer. If the host
    memory is modified on the host or if it is used to construct another
    buffer or image during the lifetime of this buffer, then the results are
    undefined.  The initial contents of the buffer will be the contents of the
    host memory at the time of construction.
+
--
When the buffer is destroyed, the destructor will block until all
work in queues on the buffer have completed, then copy the contents
of the buffer back to the host memory (if required) and then
return.

  .. If the type of the host data is [code]#const#, then the buffer is
    read-only; only read accessors are allowed on the buffer and
    no-copy-back to host memory is performed (although the host memory must
    still be kept available for use by SYCL). When using the default buffer
    allocator, the const-ness of the type will be removed in order to allow
    host allocation of memory, which will allow temporary host copies of the
    data by the <<sycl-runtime>>, for example for speeding up host
    accesses.
+
When the buffer is destroyed, the destructor will block until all work
in queues on the buffer have completed and then return, as there is no
copy of data back to host.
  .. If the type of the host data is not [code]#const# but the pointer
    to host data is [code]#const#, then the read-only restriction
    applies only on host and not on device accesses.
+
When the buffer is destroyed, the destructor will block until all work
in queues on the buffer have completed.
--
  . A buffer can be constructed using a [code]#shared_ptr# to host
    data. This pointer is shared between the SYCL application and the
    runtime. In order to allow synchronization between the application and
    the runtime a [code]#mutex# is used which will be locked by the
    runtime whenever the data is in use, and unlocked when it is no longer
    needed.
+
--
The [code]#shared_ptr# reference counting is used in order to prevent
destroying the buffer host data prematurely. If the [code]#shared_ptr#
is deleted from the user application before buffer destruction, the buffer
can continue securely because the pointer hasn't been destroyed yet. It will
not copy data back to the host before destruction, however, as the
application side has already deleted its copy.

Note that since there is an implicit conversion of a
[code]#std::unique_ptr# to a [code]#std::shared_ptr#, a
[code]#std::unique_ptr# can also be used to pass the ownership to the
<<sycl-runtime>>.
--
  . A buffer can be constructed from a pair of iterator values. In this
    case, the buffer construction will copy the data from the data range
    defined by the iterator pair. The destructor will not copy back any data
    and does not need to block.

  . A buffer can be constructed from a container on which
    [code]#std::data(container)# and [code]#std::size(container)#
    are well-formed. The initial contents of the buffer will
    be the contents of the container at the time of construction.
+
--
The buffer may use the memory within the container for its full
lifetime, and the contents of this memory are unspecified for the
lifetime of the buffer. If the container memory is modified by the host
during the lifetime of this buffer, then the results are undefined.

When the buffer is destroyed, the destructor will block until all work in
queues on the buffer have completed.  If the return type of
[code]#std::data(container)# is not [code]#const# then the destructor will also
copy the contents of the buffer to the container (if required).
--


If [code]#set_final_data()# is used to change where to write the
data back to, then the destructor of the buffer will block if a
write accessor on it has been created.

A sub-buffer object can be created which is a sub-range reference to a
base buffer. This sub-buffer can be used to create accessors to the
base buffer, which have access to the range specified at time
of construction of the sub-buffer.  Sub-buffers cannot be created from
sub-buffers, but only from a base buffer which is not already a sub-buffer.

Sub-buffers must be constructed from a contiguous region of memory in a
buffer. This requirement is potentially non-intuitive when working with
buffers that have dimensionality larger than one, but maps to
one-dimensional <<backend>> native allocations without performance cost due
to index mapping computation. For example:

[source,,linenums]
----
include::{code_dir}/subbuffer.cpp[lines=4..-1]
----


[[subsec:images]]
=== Images

The classes [code]#unsampled_image#
(<<table.constructors.unsampledImage>>) and [code]#sampled_image#
(<<table.constructors.sampledImage>>) define shared image data of one,
two or three dimensions, that can be used by kernels in queues and have to be
accessed using the image <<accessor>> classes.

The constructors and member functions of the SYCL [code]#unsampled_image#
and [code]#sampled_image# class templates are listed in
<<table.constructors.unsampledImage>>, <<table.members.unsampledImage>>,
<<table.constructors.sampledImage>> and <<table.members.sampledImage>>,
respectively. The additional common special member functions and common member
functions are listed in <<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>>, respectively.

Where relevant, it is the responsibility of the user to ensure that the format
of the data matches the format described by [code]#image_format#.

The allocator template parameter of the SYCL [code]#unsampled_image# and
[code]#sampled_image# classes can be any allocator type including a custom
allocator, however it must allocate in units of [code]#std::byte#.

For any image that is constructed with the range latexmath:[(r1,r2,r3)] with an element
type size in bytes of _s_, the image row pitch and image slice pitch should be
calculated as follows:

[[image-row-pitch]]
[latexmath]
++++
r1 \cdot s
++++

[[image-slice-pitch]]
[latexmath]
++++
r1 \cdot r2 \cdot s
++++

The SYCL [code]#unsampled_image# and [code]#sampled_image# class
templates provide the common reference semantics
(see <<sec:reference-semantics>>).


==== Unsampled image interface

Each constructor of the [code]#unsampled_image# takes an
[code]#image_format# to describe the data layout of the image data.

Each constructor additionally takes as the last parameter an optional SYCL
[code]#property_list# to provide properties to the SYCL
[code]#unsampled_image#.

The SYCL [code]#unsampled_image# class template takes a template parameter
[code]#AllocatorT# for specifying an allocator which is used by the
<<sycl-runtime>> when allocating temporary memory on the host. If no template
argument is provided, the default allocator for the SYCL
[code]#unsampled_image# class [code]#image_allocator# is used
(see <<subsec:default.allocators>>).

// Interface for class: unsampled image
[source,,linenums]
----
include::{header_dir}/unsampledImage.h[lines=4..-1]
----


[[table.constructors.unsampledImage]]
.Constructors of the [code]#unsampled_image# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
unsampled_image(image_format format,
                const range<Dimensions>& rangeRef,
                const property_list& propList = {})
----
   a@ Construct a SYCL [code]#unsampled_image# instance with
      uninitialized memory.
      The constructed SYCL [code]#unsampled_image# will use a default
      constructed [code]#AllocatorT# when allocating memory on the
      host.
      The element size of the constructed SYCL [code]#unsampled_image#
      will be derived from the [code]#format# parameter.
      The range of the constructed SYCL [code]#unsampled_image# is
      specified by the [code]#rangeRef# parameter provided.
      The pitch of the constructed SYCL [code]#unsampled_image# will be
      the default size determined by the <<sycl-runtime>>.
      Unless the member function [code]#set_final_data()# is called
      with a valid non-null pointer, there will be no write back on
      destruction.
      Zero or more properties can be provided to the constructed SYCL
      [code]#unsampled_image# via an instance of
      [code]#property_list#.

a@
[source]
----
unsampled_image(image_format format,
                const range<Dimensions>& rangeRef,
                AllocatorT allocator,
                const property_list& propList = {})
----
   a@ Construct a SYCL [code]#unsampled_image# instance with
      uninitialized memory.
      The constructed SYCL [code]#unsampled_image# will use the
      [code]#allocator# parameter provided when allocating memory on
      the host.
      The element size of the constructed SYCL [code]#unsampled_image#
      will be derived from the [code]#format# parameter.
      The range of the constructed SYCL [code]#unsampled_image# is
      specified by the [code]#rangeRef# parameter provided.
      The pitch of the constructed SYCL [code]#unsampled_image# will be
      the default size determined by the <<sycl-runtime>>.
      Unless the member function [code]#set_final_data()# is called
      with a valid non-null pointer, there will be no write back on
      destruction.
      Zero or more properties can be provided to the constructed SYCL
      [code]#unsampled_image# via an instance of
      [code]#property_list#.

a@
[source]
----
unsampled_image(image_format format,
                const range<Dimensions>& rangeRef,
                const range<Dimensions - 1>& pitch,
                const property_list& propList = {})
----
   a@ Available only when: [code]#Dimensions > 1#.

Construct a SYCL [code]#unsampled_image# instance with
uninitialized memory.
The constructed SYCL [code]#unsampled_image# will use a default
constructed [code]#AllocatorT# when allocating memory on the
host.
The element size of the constructed SYCL [code]#unsampled_image#
will be derived from the [code]#format# parameter.
The range of the constructed SYCL [code]#unsampled_image# is
specified by the [code]#rangeRef# parameter provided.
The pitch of the constructed SYCL [code]#unsampled_image# will be
the [code]#pitch# parameter provided.
Unless the member function [code]#set_final_data()# is called
with a valid non-null pointer, there will be no write back on
destruction.
Zero or more properties can be provided to the constructed SYCL
[code]#unsampled_image# via an instance of
[code]#property_list#.

a@
[source]
----
unsampled_image(image_format format,
                const range<Dimensions>& rangeRef,
                const range<Dimensions - 1>& pitch,
                AllocatorT allocator,
                const property_list& propList = {})
----
   a@ Available only when: [code]#Dimensions > 1#.

Construct a SYCL [code]#unsampled_image# instance with
uninitialized memory.
The constructed SYCL [code]#unsampled_image# will use the
[code]#allocator# parameter provided when allocating memory on
the host.
The element size of the constructed SYCL [code]#unsampled_image#
will be derived from the [code]#format# parameter.
The range of the constructed SYCL [code]#unsampled_image# is
specified by the [code]#rangeRef# parameter provided.
The pitch of the constructed SYCL [code]#unsampled_image# will be
the [code]#pitch# parameter provided.
Unless the member function [code]#set_final_data()# is called
with a valid non-null pointer, there will be no write back on
destruction.
Zero or more properties can be provided to the constructed SYCL
[code]#unsampled_image# via an instance of
[code]#property_list#.

a@
[source]
----
unsampled_image(void* hostPointer, image_format format,
                const range<Dimensions>& rangeRef,
                const property_list& propList = {})
----
   a@ Construct a SYCL [code]#unsampled_image# instance with the
      [code]#hostPointer# parameter provided.  The [code]#unsampled_image#
      assumes exclusive access to this memory for the duration of its lifetime.
      The constructed SYCL [code]#unsampled_image# will use a default
      constructed [code]#AllocatorT# when allocating memory on the
      host.
      The element size of the constructed SYCL [code]#unsampled_image#
      will be derived from the [code]#format# parameter.
      The range of the constructed SYCL [code]#unsampled_image# is
      specified by the [code]#rangeRef# parameter provided.
      The pitch of the constructed SYCL [code]#unsampled_image# will be
      the default size determined by the <<sycl-runtime>>.
      Unless the member function [code]#set_final_data()# is called
      with a valid non-null pointer, any memory allocated by the
      <<sycl-runtime>> is written back to [code]#hostPointer#.
      Zero or more properties can be provided to the constructed SYCL
      [code]#unsampled_image# via an instance of
      [code]#property_list#.

a@
[source]
----
unsampled_image(void* hostPointer, image_format format,
                const range<Dimensions>& rangeRef,
                AllocatorT allocator,
                const property_list& propList = {})
----
   a@ Construct a SYCL [code]#unsampled_image# instance with the
      [code]#hostPointer# parameter provided.  The [code]#unsampled_image#
      assumes exclusive access to this memory for the duration of its lifetime.
      The constructed SYCL [code]#unsampled_image# will use the
      [code]#allocator# parameter provided when allocating memory on
      the host.
      The element size of the constructed SYCL [code]#unsampled_image#
      will be derived from the [code]#format# parameter.
      The range of the constructed SYCL [code]#unsampled_image# is
      specified by the [code]#rangeRef# parameter provided.
      The pitch of the constructed SYCL [code]#unsampled_image# will be
      the default size determined by the <<sycl-runtime>>.
      Unless the member function [code]#set_final_data()# is called
      with a valid non-null pointer, any memory allocated by the
      <<sycl-runtime>> is written back to [code]#hostPointer#.
      Zero or more properties can be provided to the constructed SYCL
      [code]#unsampled_image# via an instance of [code]#property_list#.

a@
[source]
----
unsampled_image(void* hostPointer, image_format format,
                const range<Dimensions>& rangeRef,
                const range<Dimensions - 1>& pitch,
                const property_list& propList = {})
----
   a@ Available only when: [code]#Dimensions > 1#

Construct a SYCL [code]#unsampled_image# instance with the
[code]#hostPointer# parameter provided.  The [code]#unsampled_image# assumes
exclusive access to this memory for the duration of its lifetime.
The constructed SYCL [code]#unsampled_image# will use a default
constructed [code]#AllocatorT# when allocating memory on the
host.
The element size of the constructed SYCL [code]#unsampled_image#
will be derived from the [code]#format# parameter.
The range of the constructed SYCL [code]#unsampled_image# is
specified by the [code]#rangeRef# parameter provided.
The pitch of the constructed SYCL [code]#unsampled_image# will be
the [code]#pitch# parameter provided.
Unless the member function [code]#set_final_data()# is called
with a valid non-null pointer, any memory allocated by the
<<sycl-runtime>> is written back to [code]#hostPointer#.
Zero or more properties can be provided to the constructed SYCL
[code]#unsampled_image# via an instance of
[code]#property_list#.

a@
[source]
----
unsampled_image(void* hostPointer, image_format format,
                const range<Dimensions>& rangeRef,
                const range<Dimensions - 1>& pitch,
                AllocatorT allocator,
                const property_list& propList = {})
----
   a@ Available only when: [code]#Dimensions > 1#.

Construct a SYCL [code]#unsampled_image# instance with the
[code]#hostPointer# parameter provided. The [code]#unsampled_image# assumes
exclusive access to this memory for the duration of its lifetime.
The constructed SYCL [code]#unsampled_image# will use the
[code]#allocator# parameter provided when allocating memory on
the host.
The element size of the constructed SYCL [code]#unsampled_image#
will be derived from the [code]#format# parameter.
The range of the constructed SYCL [code]#unsampled_image# is
specified by the [code]#rangeRef# parameter provided.
The pitch of the constructed SYCL [code]#unsampled_image# will be
the [code]#pitch# parameter provided.
Unless the member function [code]#set_final_data()# is called
with a valid non-null pointer, any memory allocated by the
<<sycl-runtime>> is written back to [code]#hostPointer#.
Zero or more properties can be provided to the constructed SYCL
[code]#unsampled_image# via an instance of [code]#property_list#.

a@
[source]
----
unsampled_image(std::shared_ptr<void>& hostPointer,
                image_format format,
                const range<Dimensions>& rangeRef,
                const property_list& propList = {})
----
   a@ When [code]#hostPointer# is not empty, construct a SYCL
      [code]#unsampled_image# with the contents of its stored pointer.  The
      [code]#unsampled_image# assumes exclusive access to this memory for the
      duration of its lifetime.  The [code]#unsampled_image# also creates its
      own internal copy of the [code]#shared_ptr# that shares ownership of the
      [code]#hostData# memory, which means the application can safely release
      ownership of this [code]#shared_ptr# when the constructor returns.

When [code]#hostPointer# is empty, construct a SYCL [code]#unsampled_image#
with uninitialized memory.

The constructed SYCL [code]#unsampled_image# will use a default
constructed [code]#AllocatorT# when allocating memory on the
host.
The element size of the constructed SYCL [code]#unsampled_image#
will be derived from the [code]#format# parameter.
The range of the constructed SYCL [code]#unsampled_image# is
specified by the [code]#rangeRef# parameter provided.
The pitch of the constructed SYCL [code]#unsampled_image# will be
the default size determined by the <<sycl-runtime>>.
Unless the member function [code]#set_final_data()# is called
with a valid non-null pointer, any memory allocated by the
<<sycl-runtime>> is written back to [code]#hostPointer#.
Zero or more properties can be provided to the constructed SYCL
[code]#unsampled_image# via an instance of [code]#property_list#.

a@
[source]
----
unsampled_image(std::shared_ptr<void>& hostPointer,
                image_format format,
                const range<Dimensions>& rangeRef,
                AllocatorT allocator,
                const property_list& propList = {})
----
   a@ When [code]#hostPointer# is not empty, construct a SYCL
      [code]#unsampled_image# with the contents of its stored pointer.  The
      [code]#unsampled_image# assumes exclusive access to this memory for the
      duration of its lifetime.  The [code]#unsampled_image# also creates its
      own internal copy of the [code]#shared_ptr# that shares ownership of the
      [code]#hostData# memory, which means the application can safely release
      ownership of this [code]#shared_ptr# when the constructor returns.

When [code]#hostPointer# is empty, construct a SYCL [code]#unsampled_image#
with uninitialized memory.

The constructed SYCL [code]#unsampled_image# will use the
[code]#allocator# parameter provided when allocating memory on
the host.
The element size of the constructed SYCL [code]#unsampled_image#
will be derived from the [code]#format# parameter.
The range of the constructed SYCL [code]#unsampled_image# is
specified by the [code]#rangeRef# parameter provided.
The pitch of the constructed SYCL [code]#unsampled_image# will be
the default size determined by the <<sycl-runtime>>.
Unless the member function [code]#set_final_data()# is called
with a valid non-null pointer, any memory allocated by the
<<sycl-runtime>> is written back to [code]#hostPointer#.
Zero or more properties can be provided to the constructed SYCL
[code]#unsampled_image# via an instance of [code]#property_list#.

a@
[source]
----
unsampled_image(std::shared_ptr<void>& hostPointer,
                image_format format,
                const range<Dimensions>& rangeRef,
                const range<Dimensions - 1>& pitch,
                const property_list& propList = {})
----
   a@ When [code]#hostPointer# is not empty, construct a SYCL
      [code]#unsampled_image# with the contents of its stored pointer.  The
      [code]#unsampled_image# assumes exclusive access to this memory for the
      duration of its lifetime.  The [code]#unsampled_image# also creates its
      own internal copy of the [code]#shared_ptr# that shares ownership of the
      [code]#hostData# memory, which means the application can safely release
      ownership of this [code]#shared_ptr# when the constructor returns.

When [code]#hostPointer# is empty, construct a SYCL [code]#unsampled_image#
with uninitialized memory.

The constructed SYCL [code]#unsampled_image# will use a default
constructed [code]#AllocatorT# when allocating memory on the
host.
The element size of the constructed SYCL [code]#unsampled_image#
will be derived from the [code]#format# parameter.
The range of the constructed SYCL [code]#unsampled_image# is
specified by the [code]#rangeRef# parameter provided.
The pitch of the constructed SYCL [code]#unsampled_image# will be
the [code]#pitch# parameter provided.
Unless the member function [code]#set_final_data()# is called
with a valid non-null pointer, any memory allocated by the
<<sycl-runtime>> is written back to [code]#hostPointer#.
Zero or more properties can be provided to the constructed SYCL
[code]#unsampled_image# via an instance of [code]#property_list#.

a@
[source]
----
unsampled_image(std::shared_ptr<void>& hostPointer,
                image_format format,
                const range<Dimensions>& rangeRef,
                const range<Dimensions - 1>& pitch,
                AllocatorT allocator,
                const property_list& propList = {})
----
   a@ When [code]#hostPointer# is not empty, construct a SYCL
      [code]#unsampled_image# with the contents of its stored pointer.  The
      [code]#unsampled_image# assumes exclusive access to this memory for the
      duration of its lifetime.  The [code]#unsampled_image# also creates its
      own internal copy of the [code]#shared_ptr# that shares ownership of the
      [code]#hostData# memory, which means the application can safely release
      ownership of this [code]#shared_ptr# when the constructor returns.

When [code]#hostPointer# is empty, construct a SYCL [code]#unsampled_image#
with uninitialized memory.

The constructed SYCL [code]#unsampled_image# will use the
[code]#allocator# parameter provided when allocating memory on
the host.
The element size of the constructed SYCL [code]#unsampled_image#
will be derived from the [code]#format# parameter.
The range of the constructed SYCL [code]#unsampled_image# is
specified by the [code]#rangeRef# parameter provided.
The pitch of the constructed SYCL [code]#unsampled_image# will be
the [code]#pitch# parameter provided.
Unless the member function [code]#set_final_data()# is called
with a valid non-null pointer, any memory allocated by the
<<sycl-runtime>> is written back to [code]#hostPointer#.
Zero or more properties can be provided to the constructed SYCL
[code]#unsampled_image# via an instance of [code]#property_list#.

|====



[[table.members.unsampledImage]]
.Member functions of the [code]#unsampled_image# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
range<Dimensions> get_range() const
----
   a@ Return a range object representing the
      size of the image in terms of the number
      of elements in each dimension as passed
      to the constructor.

a@
[source]
----
range<Dimensions - 1> get_pitch() const
----
   a@ Available only when: [code]#Dimensions > 1#.

Return a range object representing the
pitch of the image in bytes.

a@
[source]
----
size_t size() const noexcept
----
   a@ Returns the total number of elements in the image.
      Equal to [code]#+get_range()[0] * ... * get_range()[Dimensions-1]+#.

a@
[source]
----
size_t byte_size() const noexcept
----
   a@ Returns the size of the image storage in bytes.  The number of
      bytes may be greater than [code]#size()*element size#
      due to padding of elements, rows and slices of the image for
      efficient access.

a@
[source]
----
AllocatorT get_allocator() const
----
   a@ Returns the allocator provided to the image.

a@
[source]
----
template <typename DataT,
         access_mode Mode = (std::is_const_v<DataT>
                                 ? access_mode::read
                                 : access_mode::read_write),
         image_target Targ = image_target::device>
unsampled_image_accessor<DataT, Dimensions, Mode, Targ>
get_access(handler& commandGroupHandler)
----
   a@ Returns a valid [code]#unsampled_image_accessor# to the unsampled image
      with the specified data type, access mode and target in the command group.

a@
[source]
----
template <typename DataT, access_mode Mode = (std::is_const_v<DataT>
                                                   ? access_mode::read
                                                   : access_mode::read_write)>
host_unsampled_image_accessor<DataT, Dimensions, Mode> get_host_access();
----
   a@ Returns a valid [code]#host_unsampled_image_accessor# to the unsampled
      image with the specified data type and access mode.

a@
[source]
----
template <typename Destination = std::nullptr_t>
void set_final_data(Destination finalData = nullptr)
----
   a@ The [code]#finalData# point to where the output of all
      the image processing is going to be copied to at destruction
      time, if the image was involved with a write accessor.

Destination can be either an output iterator, a
[code]#std::weak_ptr<T>#.

Note that a raw pointer is a special case of output iterator and
thus defines the host memory to which the result is to be
copied.

In the case of a weak pointer, the output is not copied if the
weak pointer has expired.

If [code]#Destination# is [code]#std::nullptr_t#, then
the copy back will not happen.

a@
[source]
----
void set_write_back(bool flag = true)
----
   a@ This member function allows dynamically forcing or canceling the
      write-back of the data of an image on destruction according to
      the value of [code]#flag#.

Forcing the write-back is similar to what happens during a
normal write-back as described in <<sec:image-sync-rules>>
and <<sec:sharing-host-memory-with-dm>>.

If there is nowhere to write-back, using this function does not
have any effect.

|====



==== Sampled image interface

Each constructor of the [code]#sampled_image# class requires a
pointer to the host data the image will sample, an
[code]#image_format# to describe the data layout and an
[code]#image_sampler# (<<subsec:samplers>>) to describe
how to sample the image data.

Each constructor additionally takes as the last parameter an optional SYCL
[code]#property_list# to provide properties to the SYCL
[code]#sampled_image#.

// Interface for class: sampled image
[source,,linenums]
----
include::{header_dir}/sampledImage.h[lines=4..-1]
----


[[table.constructors.sampledImage]]
.Constructors of the [code]#sampled_image# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
sampled_image(const void* hostPointer, image_format format,
              image_sampler sampler,
              const range<Dimensions>& rangeRef,
              const property_list& propList = {})
----
   a@ Construct a SYCL [code]#sampled_image# instance with the
      [code]#hostPointer# parameter provided.  The [code]#sampled_image#
      assumes exclusive access to this memory for the duration of its lifetime.
      The host address is [code]#const#, so the host accesses must be
      read-only. Since, the [code]#hostPointer# is [code]#const#, this image is only
      initialized with this memory and there is no write after its
      destruction.
      The element size of the constructed SYCL [code]#sampled_image#
      will be derived from the [code]#format# parameter.
      Accessors that read the constructed SYCL [code]#sampled_image# will
      use the [code]#sampler# parameter to sample the image.
      The range of the constructed SYCL [code]#sampled_image# is
      specified by the [code]#rangeRef# parameter provided.
      The pitch of the constructed SYCL [code]#sampled_image# will be
      the default size determined by the <<sycl-runtime>>.
      Zero or more properties can be provided to the constructed SYCL
      [code]#sampled_image# via an instance of
      [code]#property_list#.

a@
[source]
----
sampled_image(const void* hostPointer, image_format format,
              image_sampler sampler,
              const range<Dimensions>& rangeRef,
              const range<Dimensions - 1>& pitch,
              const property_list& propList = {})
----
   a@ Available only when: [code]#Dimensions > 1#.

Construct a SYCL [code]#sampled_image# instance with the [code]#hostPointer#
parameter provided.  The [code]#sampled_image# assumes exclusive access to this
memory for the duration of its lifetime.
The host address is [code]#const#, so the host accesses must be
read-only. Since, the [code]#hostPointer# is [code]#const#, this
image is only initialized with this memory and there is no write after
destruction.
The element size of the constructed SYCL [code]#sampled_image#
will be derived from the [code]#format# parameter.
Accessors that read the constructed SYCL [code]#sampled_image# will
use the [code]#sampler# parameter to sample the image.
The range of the constructed SYCL [code]#sampled_image# is
specified by the [code]#rangeRef# parameter provided.
The pitch of the constructed SYCL [code]#sampled_image# will be
the [code]#pitch# parameter provided.
Zero or more properties can be provided to the constructed SYCL
[code]#sampled_image# via an instance of
[code]#property_list#.

a@
[source]
----
sampled_image(std::shared_ptr<const void>& hostPointer,
              image_format format,
              image_sampler sampler,
              const range<Dimensions>& rangeRef,
              const property_list& propList = {})
----
   a@ When [code]#hostPointer# is not empty, construct a SYCL
      [code]#sampled_image# with the contents of its stored pointer.  The
      [code]#sampled_image# assumes exclusive access to this memory for the
      duration of its lifetime.  The [code]#sampled_image# also creates its
      own internal copy of the [code]#shared_ptr# that shares ownership of the
      [code]#hostData# memory, which means the application can safely release
      ownership of this [code]#shared_ptr# when the constructor returns.

When [code]#hostPointer# is empty, construct a SYCL [code]#sampled_image#
with uninitialized memory.

The host address is [code]#const#, so the host accesses must be
read-only. Since, the [code]#hostPointer# is [code]#const#, this image is only
initialized with this memory and there is no write after its
destruction.
The element size of the constructed SYCL [code]#sampled_image#
will be derived from the [code]#format# parameter.
Accessors that read the constructed SYCL [code]#sampled_image# will
use the [code]#sampler# parameter to sample the image.
The range of the constructed SYCL [code]#sampled_image# is
specified by the [code]#rangeRef# parameter provided.
The pitch of the constructed SYCL [code]#sampled_image# will be
the default size determined by the <<sycl-runtime>>.
Zero or more properties can be provided to the constructed SYCL
[code]#sampled_image# via an instance of
[code]#property_list#.

a@
[source]
----
sampled_image(std::shared_ptr<const void>& hostPointer,
              image_format format,
              image_sampler sampler,
              const range<Dimensions>& rangeRef,
              const range<Dimensions - 1>& pitch,
              const property_list& propList = {})
----
   a@ When [code]#hostPointer# is not empty, construct a SYCL
      [code]#sampled_image# with the contents of its stored pointer.  The
      [code]#sampled_image# assumes exclusive access to this memory for the
      duration of its lifetime.  The [code]#sampled_image# also creates its
      own internal copy of the [code]#shared_ptr# that shares ownership of the
      [code]#hostData# memory, which means the application can safely release
      ownership of this [code]#shared_ptr# when the constructor returns.

When [code]#hostPointer# is empty, construct a SYCL [code]#sampled_image#
with uninitialized memory.

The host address is [code]#const#, so the host accesses can be
read-only. Since, the [code]#hostPointer# is [code]#const#, this image is only
initialized with this memory and there is no write after its
destruction.
The element size of the constructed SYCL [code]#sampled_image#
will be derived from the [code]#format# parameter.
Accessors that read the constructed SYCL [code]#sampled_image# will
use the [code]#sampler# parameter to sample the image.
The range of the constructed SYCL [code]#sampled_image# is
specified by the [code]#rangeRef# parameter provided.
The pitch of the constructed SYCL [code]#sampled_image# will be
the [code]#pitch# parameter provided.
Zero or more properties can be provided to the constructed SYCL
[code]#sampled_image# via an instance of
[code]#property_list#.

|====



[[table.members.sampledImage]]
.Member functions of the [code]#sampled_image# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
range<Dimensions> get_range() const
----
   a@ Return a range object representing the
      size of the image in terms of the number
      of elements in each dimension as passed
      to the constructor.

a@
[source]
----
range<Dimensions - 1> get_pitch() const
----
   a@ Available only when: [code]#Dimensions > 1#.

Return a range object representing the
pitch of the image in bytes.

a@
[source]
----
size_t size() const noexcept
----
   a@ Returns the total number of elements in the image.
      Equal to [code]#+get_range()[0] * ... * get_range()[Dimensions-1]+#.

a@
[source]
----
size_t byte_size() const noexcept
----
   a@ Returns the size of the image storage in bytes.  The number of
      bytes may be greater than [code]#size()*element size#
      due to padding of elements, rows and slices of the image for
      efficient access.

a@
[source]
----
template <typename DataT, image_target Targ = image_target::device>
sampled_image_accessor<DataT, Dimensions, Targ>
get_access(handler& commandGroupHandler)
----
   a@ Returns a valid [code]#sampled_image_accessor# to the sampled image with
      the specified data type and target in the command group.

a@
[source]
----
template <typename DataT>
host_sampled_image_accessor<DataT, Dimensions> get_host_access()
----
   a@ Returns a valid [code]#host_sampled_image_accessor# to the sampled image
      with the specified data type in the command group.

|====



[[sec:image-properties]]
==== Image properties

The properties that can be provided when constructing the SYCL
[code]#unsampled_image# and [code]#sampled_image# classes are
describe in <<table.properties.image>>.

// Interface for image properties
[source,,linenums]
----
include::{header_dir}/imageProperties.h[lines=4..-1]
----


[[table.properties.image]]
.Properties supported by the SYCL image classes
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Property @ Description
a@
[source]
----
property::image::use_host_ptr
----
   a@ The [code]#use_host_ptr# property adds the requirement that the <<sycl-runtime>> must not allocate any memory for the [code]#image# and instead uses the provided host pointer directly. This prevents the <<sycl-runtime>> from allocating additional temporary storage on the host.

a@
[source]
----
property::image::use_mutex
----
   a@ The property adds the requirement that the memory which
      is owned by the SYCL [code]#image# can be shared with the
      application via a [code]#std::mutex# provided to the
      property. The [code]#std::mutex# is locked by
      the runtime whenever the data is in use and unlocked
      otherwise. Data is synchronized with [code]#hostData#, when
      the [code]#std::mutex# is unlocked by the runtime.

a@
[source]
----
property::image::context_bound
----
   a@ The [code]#context_bound# property adds the requirement that the SYCL [code]#image# can only be associated with a single SYCL [code]#context# that is provided to the property.

|====


The constructors and member functions of the image [code]#property# classes
are listed in <<table.constructors.properties.image>> and
<<table.members.properties.image>>


[[table.constructors.properties.image]]
.Constructors of the image [code]#property# classes
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
property::image::use_host_ptr::use_host_ptr()
----
   a@ Constructs a SYCL [code]#use_host_ptr# property instance.

a@
[source]
----
property::image::use_mutex::use_mutex(std::mutex& mutexRef)
----
   a@ Constructs a SYCL [code]#use_mutex# property instance with a reference to [code]#mutexRef# parameter provided.

a@
[source]
----
property::image::context_bound::context_bound(context boundContext)
----
   a@ Constructs a SYCL [code]#context_bound# property instance with a copy of a SYCL [code]#context#.

|====



[[table.members.properties.image]]
.Member functions of the image [code]#property# classes
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
std::mutex* property::image::use_mutex::get_mutex_ptr() const
----
   a@ Returns the [code]#std::mutex# which was specified when
      constructing this SYCL [code]#use_mutex# property.

a@
[source]
----
context property::image::context_bound::get_context() const
----
   a@ Returns the [code]#context# which was specified when
      constructing this SYCL [code]#context_bound# property.

|====



[[sec:image-sync-rules]]
==== Image synchronization rules

The rules are similar to those described in <<sec:buf-sync-rules>>.

For the lifetime of the image object, the associated host memory must
be left available to the <<sycl-runtime>> and the contents of the associated
host memory is unspecified until the image object is destroyed. If an
image object value is copied, then only a reference to the underlying
image object is copied. The underlying image object is reference-counted.
Only after all image value references to the underlying image object
have been destroyed is the actual image object itself destroyed.

If an image object is constructed with associated host memory, then
its destructor blocks until all operations in all SYCL queues on
that image object have completed. Any modifications to the image data
will be copied back, if necessary, to the associated host memory.
Any errors occurring during destruction are reported to any associated
context's asynchronous error handler. If an image object is constructed
with a storage object, then the storage object defines what
synchronization or copying behavior occurs on image object destruction.


[[sec:sharing-host-memory-with-dm]]
=== Sharing host memory with the SYCL data management classes

In order to allow the <<sycl-runtime>> to do memory management and allow
for data dependencies, there are two classes defined, buffer and image. The
default behavior for them is that a "`raw`" pointer is given during the
construction of the data management class, with full ownership to use it until
the destruction of the SYCL object.

In this section we go in greater detail on sharing or explicitly not
sharing host memory with the SYCL data classes, and we will use the buffer
class as an example. The same rules will apply to images as well.


==== Default behavior

When using a SYCL buffer, the ownership of the pointer passed to the constructor
of the class is, by default, passed to <<sycl-runtime>>, and that pointer cannot be used
on the host side until the buffer or image is destroyed.
A SYCL application can access the contents of the memory managed by a SYCL buffer
by using a [code]#host_accessor# as defined in <<subsec:accessors>>.
However, there is no guarantee that the host accessor synchronizes with the
original host address used in its constructor.

The pointer passed in is the one used to copy data back to the host, if needed,
before buffer destruction.  The memory pointed by <<host-pointer>>
will not be de-allocated by the runtime,
and the data is copied back from the device if there is
a need for it.


==== SYCL ownership of the host memory

In the case where there is host memory to be used for initialization of data
but there is no intention of using that host memory after the buffer is
destroyed, then the buffer can take full ownership of that host memory.

When a buffer owns the <<host-pointer>> there is no copy back, by
default.  In this situation, the SYCL application may pass a unique
pointer to the host data, which will be then used by the runtime
internally to initialize the data in the device.

For example, the following could be used:

[source,,linenums]
----
{
  auto ptr = std::make_unique<int>(-1234);
  buffer<int, 1> b { std::move(ptr), range { 1 } };
  // ptr is not valid anymore.
  // There is nowhere to copy data back
}
----

However, optionally the [code]#buffer::set_final_data()# can be
set to a [code]#std::weak_ptr# to enable copying data
back, to another host memory address that is going to be valid after
buffer construction.

[source,,linenums]
----
{
  auto ptr = std::make_unique<int>(-42);
  buffer<int, 1> b { std::move(ptr), range { 1 } };
  // ptr is not valid anymore.
  // There is nowhere to copy data back.
  // To get copy back, a location can be specified:
  b.set_final_data(std::weak_ptr<int> { .... })
}
----


==== Shared SYCL ownership of the host memory

When an instance of [code]#std::shared_ptr# is passed to the buffer
constructor, then the buffer object and the developer's application share
the memory region. If the shared pointer is still used on the application's
side then the data will be copied back from the buffer or image and will be
available to the application after the buffer or image is destroyed.

If the [code]#shared_ptr# is not empty, the contents of the referenced
memory are used to initialize the buffer.  If the [code]#shared_ptr# is
empty, then the buffer is created with uninitialized memory.

When the buffer is destroyed and the data have potentially been updated, if
the number of copies of the shared pointer outside the runtime is 0, there
is no user-side shared pointer to read the data. Therefore the data is not
copied out, and the buffer destructor does not need to wait for the data
processes to be finished, as the outcome is not needed on the application's
side.

This behavior can be overridden using the [code]#set_final_data()#
member function of the buffer class, which will by any means force the buffer
destructor to wait until the data is copied to wherever the
[code]#set_final_data()# member function has put the data (or not wait nor copy
if set final data is [code]#nullptr)#.

[source,,linenums]
----
{
  std::shared_ptr<int> ptr { data };
  {
    buffer<int, 1> b { ptr, range<2>{ 10, 10 } };
    // update the data
    [...]
  } // Data is copied back because there is an user side shared_ptr
}
----

[source,,linenums]
----
{
  std::shared_ptr<int> ptr { data };
  {
    buffer<int, 1> b { ptr, range<2>{ 10, 10 } };
    // update the data
    [...]
    ptr.reset();
  } // Data is not copied back, there is no user side shared_ptr.
}
----


[[subsec:mutex]]
=== Synchronization primitives

When the user wants to use the [code]#buffer# simultaneously in
the <<sycl-runtime>> and their own code (e.g. a multi-threaded
mechanism) and wants to use manual synchronization without using a
[code]#host_accessor#, a [code]#std::mutex# can be passed to the
[code]#buffer# constructor via the right [code]#property#.

The runtime promises to lock the mutex whenever the data is in use and
unlock it when it no longer needs it.

[source,,linenums]
----
{
  std::mutex m;
  auto shD = std::make_shared<int>(42)
  sycl::buffer b { shD, { sycl::property::buffer::use_mutex { m } } };
  {
    std::lock_guard lck { m };
    // User accesses the data
    do_something(shD);
    /* m is unlocked when lck goes out of scope, by normal end of this
       block but also if an exception is thrown for example */
  }
}
----

When the runtime releases the mutex the user is guaranteed that the data was
copied back on the shared pointer --- unless the final data destination has been
changed using the member function [code]#set_final_data()#.


[[subsec:accessors]]
=== Accessors

// \input{accessors}
// %%%%%%%%%%%%%%%%%%%%%%%%%%%% begin accessors %%%%%%%%%%%%%%%%%%%%%%%%%%%%

<<accessor,Accessors>> provide three different capabilities: they provide
access to the data managed by a <<buffer>> or <<image>>, they provide access
to local memory on a <<device>>, and they define the *requirements* to memory
objects which determine the scheduling of <<kernel,kernels>> (see
<<sub.section.memmodel.app>>).

A memory object requirement is created when an accessor is constructed, unless
the accessor is a placeholder in which case the requirement is created when
the accessor is bound to a <<command>> by calling [code]#handler::require()#.

There are several different {cpp} classes that implement accessors:

* The [code]#accessor# class provides access to data in a [code]#buffer# from
  within a <<command>>.

* The [code]#host_accessor# class provides access to data in a [code]#buffer#
  from host code that is outside of a <<command>>.  These accessors are
  typically used in <<application-scope>>.

* The [code]#local_accessor# class provides access to device local memory from
  within a <<sycl-kernel-function>>.

* The [code]#unsampled_image_accessor# and [code]#sampled_image_accessor#
  classes provide access to data in an [code]#unsampled_image# and
  [code]#sampled_image# from within a <<command>>.

* The [code]#host_unsampled_image_accessor# and
  [code]#host_sampled_image_accessor# classes provide access to data in an
  [code]#unsampled_image# and [code]#sampled_image# from host code that is
  outside of a <<command>>.  These accessors are typically used in
  <<application-scope>>.

Accessor objects must always be constructed in host code, either in
<<command-group-scope>> or in <<application-scope>>.  Whether the constructor
blocks waiting for data to synchronize depends on the type of accessor.  Those
accessors which provide access to data within a <<command>> do not block.
Instead, these accessors define a requirement which influences the scheduling
of the <<command>>.  Those accessors which provide access to data from host
code do block until the data is available on the host.

For those accessors which provide access to data within a <<command>>, the
member functions which access data should only be called from within the
<<command>>.  Programs which call these member functions from outside of the
<<command>> are ill formed.  The sections below describe exactly which member
functions fall into this category.


==== Data type

All accessors have a [code]#DataT# template parameter which specifies the type
of each element that the accessor accesses.  For [code]#accessor# and
[code]#host_accessor#, this type must either match the type of each element in
the underlying [code]#buffer#, or it must be a [code]#const# qualified version
of that type.

For the image accessors ([code]#unsampled_image_accessor#,
[code]#sampled_image_accessor#, [code]#host_unsampled_image_accessor#, and
[code]#host_sampled_image_accessor#), [code]#DataT# must be one of:

* [code]#int4# ([code]#vec<int32_t,4>#),
* [code]#uint4# ([code]#vec<uint32_t,4>#),
* [code]#float4# ([code]#vec<float,4>#), or
* [code]#half4# ([code]#vec<half,4>#)

For [code]#local_accessor# see <<sec:accessor.local>> for the allowable
[code]#DataT# types.


==== Access modes

Most accessors have an [code]#AccessMode# template parameter which specifies
whether the accessor can read or write the underlying data.  This information
is used by the runtime when defining the requirements for the associated
<<command>>, and it tells the runtime whether data needs to be transferred to
or from a device before data can be accessed through the accessor.

The [code]#access_mode# enumeration, shown in <<table.accessors.accessmode>>,
describes the potential modes of an accessor.  However, not all accessor
classes support all modes, so see the description of each class for more
details.

[source,,linenums]
----
include::{header_dir}/accessMode.h[lines=4..-1]
----

[[table.accessors.accessmode]]
.Enumeration of access modes available to accessors
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ access_mode @ Description
a@
[source]
----
access_mode::read
----
   a@ Read-only access.

a@
[source]
----
access_mode::write
----
   a@ Write-only access.

a@
[source]
----
access_mode::read_write
----
   a@ Read and write access.

|====


==== Deduction tags

Some accessor constructors take a [code]#TagT# parameter, which is used to
deduce template arguments for the constructor's class.  Each of the access
modes in <<table.accessors.accessmode>> has an associated tag, but there are
additional tags which set other template parameters in addition to the access
mode.  The synopsis below shows the namespace scope variables that the
implementation provides as possible values for the [code]#TagT# parameter.

[source,,linenums]
----
include::{header_dir}/accessTags.h[lines=4..-1]
----

The precise meaning of these tags depends on the specific accessor class
that is being constructed, so they are described more fully below in the
section that pertains to each of the accessor types.


==== Properties

All accessor constructors accept a [code]#property_list# parameter, which
affects the semantics of the accessor.  <<table.accessors.properties>> shows
the set of all possible accessor properties and tells which properties are
allowed when constructing each accessor class.

[source,,linenums]
----
include::{header_dir}/accessProperties.h[lines=4..-1]
----

[[table.accessors.properties]]
.Properties supported by accessors
[width="100%",options="header",cols="20%,35%,45%"]
|====
|Property |Allowed with |Description

|[code]#property::no_init#
|[code]#accessor# +
 [code]#host_accessor# +
 [code]#unsampled_image_accessor# +
 [code]#host_unsampled_image_accessor#
|This property is useful when an application expects to write new values to all
of the accessor's elements without reading their previous values.  The
implementation can use this information to avoid copying the accessor's data in
some cases.  Following is a more formal description.

This property is allowed only for accessors with [code]#access_mode::write# or
[code]#access_mode::read_write# access modes.  Attempting to construct an
[code]#access_mode::read# accessor with this property causes an
[code]#exception# with the [code]#errc::invalid# error code to be thrown.

The usage of this property is different depending on whether the accessor's
underlying data type [code]#DataT# is an implicit-lifetime type (as defined in
the {cpp} core language).  If it is an implicit-lifetime type, the accessor
implicitly creates objects of that type with indeterminate values.  The
application is not required to write values to each element of the accessor,
but unwritten elements of the accessor's buffer or image receive indeterminate
values, even if those buffer or image elements previously had defined values.
If this is a <<ranged-accessor>>, this applies only to the elements within the
accessor's range.  The values of unwritten elements outside of this range are
preserved.

If [code]#DataT# is not an implicit-lifetime type, the accessor merely
allocates uninitialized memory, and the application is responsible for
constructing objects in that memory (e.g. by calling placement-new).  The
application must create an object in each element of the accessor unless the
corresponding element of the underlying buffer did not previously contain an
object.  If this is a <<ranged-accessor>>, this applies only to the elements
within the accessor's range.  The content of objects in the buffer outside of
this range is preserved.
|====

[NOTE]
====
As stated above, the [code]#property::no_init# property requires the
application to construct an object for each accessor element when the element's
type is not an implicit-lifetime type (except in the case when the
corresponding buffer element did not previously contain an object).  The reason
for this requirement is to avoid the possibility of overwriting a valid object
with indeterminate bytes, for example, when a <<command>> using the accessor
completes.  This means that the implementation can unconditionally copy memory
from the device back to the host when the <<command>> completes, regardless of
whether the [code]#DataT# type is an implicit-lifetime type.
====

The constructors of the accessor property classes are listed in
<<table.accessors.properties.constructors>>.

[[table.accessors.properties.constructors]]
.Constructors of the accessor property classes
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
property::no_init::no_init()
----
   a@ Constructs a [code]#no_init# property instance.

|====


==== Read only accessors

Accessors which have an [code]#AccessMode# template parameter can be declared
as read-only by specifying [code]#access_mode::read# for the template
parameter.  A read-only accessor provides read-only access to the underlying
data and provides a "read" requirement for the memory object when it is
constructed.

The [code]#DataT# template parameter for a read-only accessor can optionally
be [code]#const# qualified, and the semantics of the accessor are unchanged.
For example, an accessor declared with [code]#const DataT# and
[code]#access_mode::read# has the same semantics as an accessor declared with
[code]#DataT# and [code]#access_mode::read#.

As detailed in the sections below, some accessor types have a default value
for [code]#AccessMode#, which depends on whether the [code]#DataT# parameter
is [code]#const# qualified.  This provides a convenient way to declare a
read-only accessor without explicitly specifying the access mode.

A [code]#const# qualified [code]#DataT# is only allowed for a read-only
accessor.  Programs which specify a [code]#const# qualified [code]#DataT# and
any access mode other than [code]#access_mode::read# are ill formed, and the
implementation must issue a diagnostic in this case.

Each accessor class also provides implicit conversions between the two forms
of read-only accessors.  This makes it possible, for example, to assign an
accessor whose type has [code]#const DataT# and [code]#access_mode::read# to an
accessor whose type has [code]#DataT# and [code]#access_mode::read#, so long as
the other template parameters are the same.  There is also an implicit
conversion from a read-write accessor to either of the forms of a read-only
accessor.  These implicit conversions are described in detail for each accessor
class in the sections that follow.


==== Accessing elements of an accessor

Accessors of type [code]#accessor#, [code]#host_accessor#, and
[code]#local_accessor# can have zero, one, two, or three Dimensions.  A zero
dimension accessor provides access to a single scalar element via an implicit
conversion operator to the underlying type of that element and via an overloaded
copy/move assignment operators from the underlying type of the element.

One, two, or three dimensional specializations of these accessors provide
access to the elements they contain in two ways.  The first way is through a
subscript operator that takes an instance of an [code]#id# class which has the
same dimensionality as the accessor.  The second way is by passing a single
[code]#size_t# value to multiple consecutive subscript operators as specified
in <<sec:multi-dim-subscript>>.

In all these cases, the reference to the contained element is of type
[code]#const DataT&# for read-only accessors and of type [code]#DataT&# for
other accessors.

Accessors of all types have a range that defines the set of indices that may be
used to access elements.  For buffer accessors, this is the range of the
underlying buffer, unless it is a <<ranged-accessor>> in which case the range
comes from the accessor's constructor.  For image accessors, this is the range
of the underlying image.  Local accessors specify the range when the accessor
is constructed.  Any attempt to access an element via an index that is outside
of this range produces undefined behavior.


==== Container interface

Accessors of type [code]#accessor#, [code]#host_accessor#, and
[code]#local_accessor# meet the {cpp} requirement of
[code]#ReversibleContainer#.  The exception to this is that only
[code]#local_accessor# owns the underlying data, meaning that its destructor
destroys elements and frees the memory.  The [code]#accessor# and
[code]#host_accessor# types don't destroy any elements or free the memory on
destruction.  The iterator for the container interface meets the {cpp}
requirement of [code]#LegacyRandomAccessIterator# and the underlying
pointers/references correspond to the address space specified by the accessor
type.  For multidimensional accessors the iterator linearizes the data
according to <<sec:multi-dim-linearization>>.


[[sec:accessors.ranged]]
==== Ranged accessors

Accessors of type [code]#accessor# and [code]#host_accessor# can be constructed
from a sub-range of a [code]#buffer# by providing a range and offset to the
constructor.  This limits the elements that can be accessed to the specified
sub-range, which allows the implementation to perform certain optimizations such
as reducing the amount of memory that needs to be copied to or from a device.

If the ranged accessor is multi-dimensional, the sub-range is allowed to
describe a region of memory in the underlying buffer that is not contiguous
in the linear address space.  It is also legal to construct several ranged
accessors for the same underlying buffer, either overlapping or
non-overlapping.

A ranged accessor still creates a requisite for the entire underlying buffer,
even for the portions not within the range.  For example, if one command writes
through a ranged accessor to one region of a buffer and a second command reads
through a ranged accessor from a non-overlapping region of the same buffer, the
second command must still be scheduled after the first because the requisites
for the two commands are on the entire buffer, not on the sub-ranges of the
ranged accessors.

Most of the accessor member functions which provide a reference to the
underlying buffer elements are affected by a ranged accessor's offset and
range.  For example, calling [code]#operator[](0)# on a one-dimensional ranged
accessor returns a reference to the element at the position specified by the
accessor's offset, which is not necessarily the first element in the buffer.
In addition, the accessor's iterator functions iterate only over the elements
that are within the sub-range.

The only exceptions are the [code]#get_pointer# and [code]#get_multi_ptr#
member functions, which return a pointer to the beginning of the underlying
buffer regardless of the accessor's offset.  Applications using these functions
must take care to manually add the offset before dereferencing the pointer
because accessing an element that is outside of the accessor's range results
in undefined behavior.

[NOTE]
====
There is no change in behavior for ranged accessors with a range of zero.
It still creates a requisite for the entire underlying buffer, and 
an attempt to access an element produces undefined behaviour.
====

==== Buffer accessor for commands

The [code]#accessor# class provides access to data in a [code]#buffer# from
within a <<sycl-kernel-function>> or from within a <<host-task>>.  When used in
a <<sycl-kernel-function>>, it accesses the contents of the buffer via the
device's <<global-memory>>.  These two forms of the accessor are distinguished
by the [code]#AccessTarget# template parameter as shown in
<<table.accessors.command.buffer.capabilities>>.  Both forms support the
following values for the [code]#AccessMode# template parameter:
[code]#access_mode::read#, [code]#access_mode::write# and
[code]#access_mode::read_write#.

[[table.accessors.command.buffer.capabilities]]
.Description of access targets for buffer accessors
[width="100%",options="header",cols="25%,75%"]
|====
| Access target | Meaning
| [code]#target::device#
    | Access a buffer from a <<sycl-kernel-function>> via device global memory.
| [code]#target::host_task#
    | Access a buffer from a <<host-task>>.
|====

Programs which specify the access target as [code]#target::device# and then
capture the [code]#accessor# in a <<host-task>> can only use the accessor for
interoperability through the [code]#interop_handle#, any other uses result in
undefined behavior.

Programs which specify the access target as [code]#target::host_task# and then
use the [code]#accessor# from a <<sycl-kernel-function>> result in undefined
behavior.

The dimensionality of the accessor must match the underlying buffer, however,
there is a special case if the buffer is one-dimensional.  In this case, the
accessor may either be one-dimensional or it may be zero-dimensional.  A
zero-dimensional accessor has access to just the first element of the buffer,
whereas a one-dimensional accessor has access to the entire buffer.

Certain [code]#accessor# constructors create a "placeholder" accessor.  Such
an accessor is bound to a [code]#buffer# and its semantics such as access
target and access mode are defined.  However, a placeholder accessor is not
yet bound to a <<command-group>>.  Before such an accessor can be used in a
<<command>>, it must be bound by calling [code]#handler::require()#.  Passing a
placeholder accessor as an argument to a <<command>> without first being bound
to a <<command-group>> with [code]#handler::require()# will result in undefined
behavior.

[NOTE]
====
Implementations are encouraged to throw either a synchronous or an asynchronous
exception when a placeholder accessor, that has not been bound to the
corresponding <<command-group>> with [code]#handler::require()#, is either
passed as an argument to or is used inside a <<command>>.
====


===== Interface for buffer command accessors

A synopsis of the [code]#accessor# class is provided below, showing the
interface when it is specialized with [code]#target::device# or
[code]#target::host_task#.  Since some of the class types and member functions
have the same name and meaning as other accessors, the common types and
functions are described in <<sec:accessor.common.members>>.  The member types
are listed in <<table.accessors.common.types>> and
<<table.accessors.command.buffer.types>>.  The constructors are listed in
<<table.accessors.command.buffer.constructors>>, and the member functions are
listed in <<table.accessors.common.members>> and
<<table.accessors.command.buffer.members>>.

The additional common special member functions and common member functions are
listed in <<sec:reference-semantics>> in
<<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>>, respectively.  For valid implicit
conversions between accessor types refer to
<<sec:accessor.command.buffer.conversions>>.  Additionally, accessors of the
same type must be equality comparable both in the host application and also in
<<sycl-kernel-function,SYCL kernel functions>>.

[source,,linenums]
----
include::{header_dir}/accessorBuffer.h[lines=4..-1]
----


[[table.accessors.command.buffer.types]]
.Member types of the [code]#accessor# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member types @ Description
a@
[source]
----
template <access::decorated IsDecorated> accessor_ptr
----
   a@ If [code]#(AccessTarget == target::device)#:
      [code]#multi_ptr<value_type, access::address_space::global_space, IsDecorated>#.

The definition of this type is not specified when
[code]#(AccessTarget == target::host_task)#.

|====


[[table.accessors.command.buffer.constructors]]
.Constructors of the [code]#accessor# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
accessor()
----
   a@ Constructs an empty accessor which fulfills the following
      post-conditions:
--
  * [code]#(empty() == true)#
  * All size queries return [code]#0#.
  * The return values of [code]#get_pointer()# and [code]#get_multi_ptr()# are
    unspecified.
  * A default constructed accessor can be passed to a <<sycl-kernel-function>>,
    but attempting to access data elements from it produces undefined behavior.
--

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, 1, AllocatorT>& bufferRef,
         const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions == 0)#.

Constructs a placeholder [code]#accessor# for accessing the first element of a
[code]#buffer#.  The optional [code]#property_list# provides properties for the
constructed accessor.

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, 1, AllocatorT>& bufferRef,
         handler& commandGroupHandlerRef, const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions == 0)#.

Constructs an [code]#accessor# for accessing the first element of a
[code]#buffer# within a <<sycl-kernel-function>> on the [code]#queue#
associated with [code]#commandGroupHandlerRef#.  The optional
[code]#property_list# provides properties for the constructed accessor.

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs a placeholder [code]#accessor# for accessing a [code]#buffer#.  The
optional [code]#property_list# provides properties for the constructed
accessor.

a@
[source]
----
template <typename AllocatorT, typename TagT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef, TagT tag,
         const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs a placeholder [code]#accessor# for accessing a [code]#buffer#.  The
[code]#tag# is used to deduce template arguments of the accessor as described
in <<sec:accessor.command.buffer.tags>>.  The optional [code]#property_list#
provides properties for the constructed accessor.

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         handler& commandGroupHandlerRef, const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs an [code]#accessor# for accessing a [code]#buffer# within a
<<sycl-kernel-function>> on the [code]#queue# associated with
[code]#commandGroupHandlerRef#.  The optional [code]#property_list# provides
properties for the constructed accessor.

a@
[source]
----
template <typename AllocatorT, typename TagT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         handler& commandGroupHandlerRef, TagT tag,
         const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs an [code]#accessor# for accessing a [code]#buffer# within a
<<sycl-kernel-function>> on the [code]#queue# associated with
[code]#commandGroupHandlerRef#.  The [code]#tag# is used to deduce template
arguments of the accessor as described in <<sec:accessor.command.buffer.tags>>.
The optional [code]#property_list# provides properties for the constructed
accessor.

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         range<Dimensions> accessRange, const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs a placeholder [code]#accessor# that is a <<ranged-accessor>>, where
the range starts at the beginning of the [code]#buffer#.  The optional
[code]#property_list# provides properties for the constructed accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
[code]#accessRange# exceeds the range of [code]#bufferRef# in any dimension.

a@
[source]
----
template <typename AllocatorT, typename TagT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         range<Dimensions> accessRange, TagT tag,
         const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs a placeholder [code]#accessor# that is a <<ranged-accessor>>, where
the range starts at the beginning of the [code]#buffer#.  The [code]#tag# is
used to deduce template arguments of the accessor as described in
<<sec:accessor.command.buffer.tags>>.  The optional [code]#property_list#
provides properties for the constructed accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
[code]#accessRange# exceeds the range of [code]#bufferRef# in any dimension.

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         range<Dimensions> accessRange, id<Dimensions> accessOffset,
         const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs a placeholder [code]#accessor# that is a <<ranged-accessor>>, where
the range starts at an offset from the beginning of the [code]#buffer#.  The
optional [code]#property_list# provides properties for the constructed
accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
the sum of [code]#accessRange# and [code]#accessOffset# exceeds the range of
[code]#bufferRef# in any dimension.

a@
[source]
----
template <typename AllocatorT, typename TagT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         range<Dimensions> accessRange, id<Dimensions> accessOffset, TagT tag,
         const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs a placeholder [code]#accessor# that is a <<ranged-accessor>>, where
the range starts at an offset from the beginning of the [code]#buffer#.  The
[code]#tag# is used to deduce template arguments of the accessor as described
in <<sec:accessor.command.buffer.tags>>.  The optional [code]#property_list#
provides properties for the constructed accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
the sum of [code]#accessRange# and [code]#accessOffset# exceeds the range of
[code]#bufferRef# in any dimension.

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         handler& commandGroupHandlerRef, range<Dimensions> accessRange,
         const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs an [code]#accessor# that is a <<ranged-accessor>>, where the range
starts at the beginning of the [code]#buffer#.  The accessor can only be used
in a <<sycl-kernel-function>> on the [code]#queue# associated with
[code]#commandGroupHandlerRef#.  The optional [code]#property_list# provides
properties for the constructed accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
[code]#accessRange# exceeds the range of [code]#bufferRef# in any dimension.

a@
[source]
----
template <typename AllocatorT, typename TagT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         handler& commandGroupHandlerRef, range<Dimensions> accessRange,
         TagT tag, const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs an [code]#accessor# that is a <<ranged-accessor>>, where the range
starts at the beginning of the [code]#buffer#.  The accessor can only be used
in a <<sycl-kernel-function>> on the [code]#queue# associated with
[code]#commandGroupHandlerRef#.  The [code]#tag# is used to deduce template
arguments of the accessor as described in <<sec:accessor.command.buffer.tags>>.
The optional [code]#property_list# provides properties for the constructed
accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
[code]#accessRange# exceeds the range of [code]#bufferRef# in any dimension.

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         handler& commandGroupHandlerRef, range<Dimensions> accessRange,
         id<Dimensions> accessOffset, const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs an [code]#accessor# that is a <<ranged-accessor>>, where the range
starts at an offset from the beginning of the [code]#buffer#.  The accessor can
only be used in a <<sycl-kernel-function>> on the [code]#queue# associated with
[code]#commandGroupHandlerRef#.  The optional [code]#property_list# provides
properties for the constructed accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
the sum of [code]#accessRange# and [code]#accessOffset# exceeds the range of
[code]#bufferRef# in any dimension.

a@
[source]
----
template <typename AllocatorT, typename TagT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         handler& commandGroupHandlerRef, range<Dimensions> accessRange,
         id<Dimensions> accessOffset, TagT tag,
         const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs an [code]#accessor# that is a <<ranged-accessor>>, where the range
starts at an offset from the beginning of the [code]#buffer#.  The accessor can
only be used in a <<sycl-kernel-function>> on the [code]#queue# associated with
[code]#commandGroupHandlerRef#.  The [code]#tag# is used to deduce template
arguments of the accessor as described in <<sec:accessor.command.buffer.tags>>.
The optional [code]#property_list# provides properties for the constructed
accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
the sum of [code]#accessRange# and [code]#accessOffset# exceeds the range of
[code]#bufferRef# in any dimension.

|====


[[table.accessors.command.buffer.members]]
.Member functions of the [code]#accessor# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
void swap(accessor& other);
----
   a@ Swaps the contents of the current accessor with the contents of
      [code]#other#.

a@
[source]
----
bool is_placeholder() const
----
   a@ Returns [code]#true# if the accessor is a placeholder.  Otherwise returns
      [code]#false#.

a@
[source]
----
id<Dimensions> get_offset() const
----
   a@ Available only when [code]#(Dimensions > 0)#.

If this is a <<ranged-accessor>>, returns the offset that was specified when the
accessor was constructed.  For other accessors, returns the default constructed
[code]#id<Dimensions>{}#.

a@
[source]
----
global_ptr<access::decorated::legacy> get_pointer() const noexcept
----
   a@ Available only when [code]#(AccessTarget == target::device)#.

Returns a [code]#multi_ptr# to the start of this accessor's underlying buffer,
even if this is a <<ranged-accessor>> whose range does not start at the
beginning of the buffer.  The return value is unspecified if the accessor is
empty.

This function may only be called from within a <<command>>.

Deprecated in SYCL 2020.  Use [code]#get_multi_ptr# instead.

a@
[source]
----
std::add_pointer_t<value_type> get_pointer() const noexcept
----
   a@ Available only when [code]#(AccessTarget == target::host_task)#.

Returns a pointer to the start of this accessor's underlying buffer, even if
this is a <<ranged-accessor>> whose range does not start at the beginning of
the buffer.  The return value is unspecified if the accessor is empty.

This function may only be called from within a <<command>>.

a@
[source]
----
template <access::decorated IsDecorated>
accessor_ptr<IsDecorated> get_multi_ptr() const noexcept
----
   a@ Available only when [code]#(AccessTarget == target::device)#.

Returns a [code]#multi_ptr# to the start of this accessor's underlying buffer,
even if this is a <<ranged-accessor>> whose range does not start at the
beginning of the buffer.  The return value is unspecified if the accessor is
empty.

This function may only be called from within a <<command>>.

a@
[source]
----
const accessor& operator=(const value_type& other) const
----
   a@ Available only when
      [code]#(AccessMode != access_mode::atomic &&
      AccessMode != access_mode::read && Dimensions == 0)#.

Assignment to the single element that is accessed by this accessor.

This function may only be called from within a <<command>>.

a@
[source]
----
const accessor& operator=(value_type&& other) const
----
   a@ Available only when
      [code]#(AccessMode != access_mode::atomic &&
      AccessMode != access_mode::read && Dimensions == 0)#.

Assignment to the single element that is accessed by this accessor.

This function may only be called from within a <<command>>.

|====


[[sec:accessor.command.buffer.tags]]
===== Deduction tags for buffer command accessors

Some [code]#accessor# constructors take a [code]#TagT# parameter, which is used
to deduce template arguments.  The permissible values for this parameter are
listed in <<table.accessors.command.buffer.tags>> along with the access mode and
accessor target that they imply.

[[table.accessors.command.buffer.tags]]
.Enumeration of tags available for [code]#accessor# construction
[width="100%",options="header",cols="33%,33%,34%"]
|====
| Tag value | Access mode | Accessor target
| [code]#read_write#
    | [code]#access_mode::read_write#
    | [code]#target::device#
| [code]#read_only#
    | [code]#access_mode::read#
    | [code]#target::device#
| [code]#write_only#
    | [code]#access_mode::write#
    | [code]#target::device#
| [code]#read_write_host_task#
    | [code]#access_mode::read_write#
    | [code]#target::host_task#
| [code]#read_only_host_task#
    | [code]#access_mode::read#
    | [code]#target::host_task#
| [code]#write_only_host_task#
    | [code]#access_mode::write#
    | [code]#target::host_task#
|====


[[sec:accessor.command.buffer.conversions]]
===== Read only buffer command accessors and implicit conversions

<<table.accessors.command.buffer.read-only>> shows the specializations of
[code]#accessor# with [code]#target::device# or
[code]#target::host_task# that are read-only accessors.  There is an implicit
conversion between any of these specializations, provided that all other
template parameters are the same.

[[table.accessors.command.buffer.read-only]]
.Specializations of [code]#accessor# that are read-only
[width="100%",options="header",cols="50%,50%"]
|====
| Data type | Access mode
| not const-qualified | [code]#access_mode::read#
| const-qualified | [code]#access_mode::read#
|====

There is also an implicit conversion from the read-write specialization shown
in <<table.accessors.command.buffer.read-write>> to any of the read-only
specializations shown in <<table.accessors.command.buffer.read-only>>, provided
that all other template parameters are the same.

[[table.accessors.command.buffer.read-write]]
.Specializations of [code]#accessor# that are read-write
[width="100%",options="header",cols="50%,50%"]
|====
| Data type | Access mode
| not const-qualified | [code]#access_mode::read_write#
|====


===== Deprecated features of the [code]#accessor# class

All of the features defined in this section are deprecated and will likely be
removed from a future version of the specification.


====== Aliased names

The enumerated value [code]#target::global_buffer# is an alias for [code]#target:::device#.
It has the same type and value as its alias.

The enumerated type [code]#access::target# is an alias for [code]#target#, and
the enumerated type [code]#access::mode# is an alias for [code]#access_mode#.


====== Discard access modes

An [code]#accessor# instance specialized with access mode
[code]#access_mode::discard_write# has the same behavior as an [code]#accessor#
instance of mode [code]#access_mode::write# that is constructed with the
property [code]#property::no_init#.

An [code]#accessor# instance specialized with access mode
[code]#access_mode::discard_read_write# has the same behavior as an
[code]#accessor# instance of mode [code]#access_mode::read_write# that is
constructed with the property [code]#property::no_init#.


====== Placeholder template parameter

The [code]#accessor# template parameter [code]#IsPlaceholder# is allowed to be
specified, but it has no bearing on whether the [code]#accessor# instance is a
placeholder.  This is determined solely by the constructor used to create the
instance.

The associated type [code]#access::placeholder# is also deprecated.


====== Additional member functions for [code]#target::device# specialization

Specializations of the [code]#accessor# class with [code]#target::device# have
the additional member functions described in
<<table.accessors.deprecated.command.buffer.members>>.

[[table.accessors.deprecated.command.buffer.members]]
.Deprecated member functions of the [code]#accessor# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
size_t get_size() const
----
   a@ Returns the same value as [code]#byte_size()#.
a@
[source]
----
size_t get_count() const
----
   a@ Returns the same value as [code]#size()#.

|====


====== Accessor specialization with [code]#target::constant_buffer#

The [code]#accessor# class may be specialized with target
[code]#target::constant_buffer#, which results in an accessor that can be used
within a <<sycl-kernel-function>> to access the contents of a buffer through
the device's <<constant-memory>>.

As with other [code]#accessor# specializations, the dimensionality must match
the underlying buffer, however there is a special case if the buffer is
one-dimensional.  In this case, the accessor may either be one-dimensional or
it may be zero-dimensional.  A zero-dimensional accessor has access to just the
first element of the buffer, whereas a one-dimensional accessor has access to the
entire buffer.

This specialization of [code]#accessor# is available only for the access mode
[code]#access_mode::read#.

This accessor type can be constructed as a "placeholder" accessor.  As with
other [code]#accessor# specializations that are placeholders,
[code]#handler::require()# must be called before passing a placeholder accessor
to a <<command>>.  Passing a placeholder accessor as an argument to a
<<command>> without first being bound to a <<command-group>> with
[code]#handler::require()# will result in undefined behavior.

A synopsis for this specialization of [code]#accessor# is provided below.
Since some of the class types and member functions have the same name and
meaning as other accessors, the common types and functions are described in
<<sec:accessor.deprecated.common.members>>.  The member types are listed in
<<table.accessors.deprecated.common.types>>.  The constructors are listed in
<<table.accessors.deprecated.constant.constructors>>, and the member functions
are listed in <<table.accessors.deprecated.common.members>> and
<<table.accessors.deprecated.constant.members>>.

The additional common special member functions and common member functions are
listed in <<sec:reference-semantics>> in
<<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>>, respectively.  Additionally,
accessors of the same type must be equality comparable.

[source,,linenums]
----
include::{header_dir}/accessorDeprecatedConstant.h[lines=4..-1]
----


[[table.accessors.deprecated.constant.constructors]]
.Constructors of the deprecated constant accessor
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, 1, AllocatorT>& bufferRef,
         const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions == 0)#.

Constructs a placeholder [code]#accessor# for accessing the first element of a
[code]#buffer#.  The optional [code]#property_list# provides properties for the
constructed accessor.

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, 1, AllocatorT>& bufferRef,
         handler& commandGroupHandlerRef, const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions == 0)#.

Constructs an [code]#accessor# for accessing the first element of a
[code]#buffer# within a <<sycl-kernel-function>> on the [code]#queue#
associated with [code]#commandGroupHandlerRef#.  The optional
[code]#property_list# provides properties for the constructed accessor.

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs a placeholder [code]#accessor# for accessing a [code]#buffer#.  The
optional [code]#property_list# provides properties for the constructed
accessor.

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         handler& commandGroupHandlerRef, const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs an [code]#accessor# for accessing a [code]#buffer# within a
<<sycl-kernel-function>> on the [code]#queue# associated with
[code]#commandGroupHandlerRef#.  The optional [code]#property_list# provides
properties for the constructed accessor.

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         range<Dimensions> accessRange, const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs a placeholder [code]#accessor# that is a <<ranged-accessor>>, where
the range starts at the beginning of the [code]#buffer#.  The optional
[code]#property_list# provides properties for the constructed accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
[code]#accessRange# exceeds the range of [code]#bufferRef# in any dimension.

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         range<Dimensions> accessRange, id<Dimensions> accessOffset,
         const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs a placeholder [code]#accessor# that is a <<ranged-accessor>>, where
the range starts at an offset from the beginning of the [code]#buffer#.  The
optional [code]#property_list# provides properties for the constructed
accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
the sum of [code]#accessRange# and [code]#accessOffset# exceeds the range of
[code]#bufferRef# in any dimension.

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         handler& commandGroupHandlerRef, range<Dimensions> accessRange,
         const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs an [code]#accessor# that is a <<ranged-accessor>>, where the range
starts at the beginning of the [code]#buffer#.  The accessor can only be used
in a <<sycl-kernel-function>> on the [code]#queue# associated with
[code]#commandGroupHandlerRef#.  The optional [code]#property_list# provides
properties for the constructed accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
[code]#accessRange# exceeds the range of [code]#bufferRef# in any dimension.

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         handler& commandGroupHandlerRef, range<Dimensions> accessRange,
         id<Dimensions> accessOffset, const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs an [code]#accessor# that is a <<ranged-accessor>>, where the range
starts at an offset from the beginning of the [code]#buffer#.  The accessor can
only be used in a <<sycl-kernel-function>> on the [code]#queue# associated with
[code]#commandGroupHandlerRef#.  The optional [code]#property_list# provides
properties for the constructed accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
the sum of [code]#accessRange# and [code]#accessOffset# exceeds the range of
[code]#bufferRef# in any dimension.

|====


[[table.accessors.deprecated.constant.members]]
.Member functions of the deprecated constant accessor
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
bool is_placeholder() const
----
   a@ Returns [code]#true# if the accessor was constructed as a placeholder and
      returns [code]#false# otherwise.

a@
[source]
----
id<Dimensions> get_offset() const
----
   a@ Available only when [code]#(Dimensions > 0)#.

If this is a <<ranged-accessor>>, returns the offset that was specified when
the accessor was constructed, otherwise returns the default constructed
[code]#id<Dimensions>{}#.

a@
[source]
----
constant_ptr<DataT> get_pointer() const noexcept
----
   a@ Returns a [code]#multi_ptr# to the start of this accessor's underlying
      buffer, even if this is a <<ranged-accessor>> whose range does not start
      at the beginning of the buffer.  The return value is unspecified if the
      accessor is empty.

This function may only be called from within a <<command>>.

|====

====== Accessor specialization with [code]#target::host_buffer#

The [code]#accessor# class may be specialized with target
[code]#target::host_buffer#, which results in a host accessor similar to
[code]#host_accessor#.  This specialization provides access to data in a
[code]#buffer# from host code that is outside of a <<command>>, and
constructors of this specialization block until the requested data is available
on the host.

As with other [code]#accessor# specializations, the dimensionality must match
the underlying buffer, however there is a special case if the buffer is
one-dimensional.  In this case, the accessor may either be one-dimensional or
it may be zero-dimensional.  A zero-dimensional accessor has access to just the
first element of the buffer, whereas a one-dimensional accessor has access to the
entire buffer.

This specialization of [code]#accessor# is available for all access modes
except for [code]#access_mode::atomic#.

A synopsis for this specialization of [code]#accessor# is provided below.
Since some of the class types and member functions have the same name and
meaning as other accessors, the common types and functions are described in
<<sec:accessor.deprecated.common.members>>.  The member types are listed in
<<table.accessors.deprecated.common.types>>.  The constructors are listed in
<<table.accessors.deprecated.host.constructors>>, and the member functions are
listed in <<table.accessors.deprecated.common.members>> and
<<table.accessors.deprecated.host.members>>.

The additional common special member functions and common member functions are
listed in <<sec:reference-semantics>> in
<<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>>, respectively.  Additionally,
accessors of the same type must be equality comparable.

[source,,linenums]
----
include::{header_dir}/accessorDeprecatedHost.h[lines=4..-1]
----


[[table.accessors.deprecated.host.constructors]]
.Constructors of the deprecated host buffer accessor
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, 1, AllocatorT>& bufferRef,
         const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions == 0)#.

Constructs an [code]#accessor# for accessing the first element of a
[code]#buffer# immediately on the host.  The optional [code]#property_list#
provides properties for the constructed accessor.

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs an [code]#accessor# for accessing a [code]#buffer# immediately on
the host.  The optional [code]#property_list# provides properties for the
constructed accessor.

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         range<Dimensions> accessRange, const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs an [code]#accessor# that is a <<ranged-accessor>> which accesses a
buffer immediately on the host, where the range starts at the beginning of the
buffer.  The optional [code]#property_list# provides properties for the
constructed accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
[code]#accessRange# exceeds the range of [code]#bufferRef# in any dimension.

a@
[source]
----
template <typename AllocatorT>
accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
         range<Dimensions> accessRange, id<Dimensions> accessOffset,
         const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs an [code]#accessor# that is a <<ranged-accessor>> which accesses a
buffer immediately on the host, where the range starts at an offset from the
beginning of the buffer.  The optional [code]#property_list# provides
properties for the constructed accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
the sum of [code]#accessRange# and [code]#accessOffset# exceeds the range of
[code]#bufferRef# in any dimension.

|====


[[table.accessors.deprecated.host.members]]
.Member functions of the deprecated host buffer accessor
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
bool is_placeholder() const
----
   a@ Always returns [code]#false#.

a@
[source]
----
id<Dimensions> get_offset() const
----
   a@ Available only when [code]#(Dimensions > 0)#.

If this is a <<ranged-accessor>>, returns the offset that was specified when
the accessor was constructed, otherwise returns the default constructed
[code]#id<Dimensions>{}#.

a@
[source]
----
std::add_pointer_t<value_type> get_pointer() const noexcept
----
   a@ Returns a pointer to the start of this accessor's underlying buffer, even
      if this is a <<ranged-accessor>> whose range does not start at the
      beginning of the buffer.  The return value is unspecified if the accessor
      is empty.

|====


====== Accessor specialization with [code]#target::local#

The [code]#accessor# class may be specialized with target
[code]#target::local#, which results in a local accessor that has the same
semantics and restrictions as [code]#local_accessor#.

This specialization of [code]#accessor# is only available for access modes
[code]#access_mode::read_write# and [code]#access_mode::atomic#.

A synopsis for this specialization of [code]#accessor# is provided below.
Since some of the class types and member functions have the same name and
meaning as other accessors, the common types and functions are described in
<<sec:accessor.deprecated.common.members>>.  The member types are listed in
<<table.accessors.deprecated.common.types>>.  The constructors are listed in
<<table.accessors.deprecated.local.constructors>>, and the member functions
are listed in <<table.accessors.deprecated.common.members>> and
<<table.accessors.deprecated.local.members>>.

The additional common special member functions and common member functions are
listed in <<sec:reference-semantics>> in
<<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>>, respectively.  Additionally,
accessors of the same type must be equality comparable.

[source,,linenums]
----
include::{header_dir}/accessorDeprecatedLocal.h[lines=4..-1]
----


[[table.accessors.deprecated.local.constructors]]
.Constructors of the deprecated local accessor
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
accessor(handler& commandGroupHandlerRef, const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions == 0)#.

Constructs an [code]#accessor# instance for accessing <<local-memory>> of a
single [code]#DataT# element within a <<sycl-kernel-function>> on the queue
associated with [code]#commandGroupHandlerRef#.  The optional
[code]#property_list# provides properties for the constructed accessor.

a@
[source]
----
accessor(range<Dimensions> allocationSize, handler& commandGroupHandlerRef,
         const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs an [code]#accessor# instance for accessing <<local-memory>> of an
array of [code]#DataT# elements within a <<sycl-kernel-function>> on the queue
associated with [code]#commandGroupHandlerRef#.  The number of elements in the
array is defined by [code]#allocationSize#.  The optional [code]#property_list#
provides properties for the constructed accessor.

|====


[[table.accessors.deprecated.local.members]]
.Member functions of the deprecated local accessor
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
operator atomic<DataT, access::address_space::local_space>() const
----
   a@ Available only when
      [code]#(AccessMode == access_mode::atomic && Dimensions == 0)#.

Returns an instance of [code]#atomic# of type [code]#DataT# providing atomic
access to the element stored within the work-group's local memory allocation
that this accessor is accessing.

This function may only be called from within a <<command>>.

a@
[source]
----
atomic<DataT, access::address_space::local_space>
operator[](id<Dimensions> index) const
----
   a@ Available only when
      [code]#(AccessMode == access_mode::atomic && Dimensions > 0)#.

Returns an instance of [code]#atomic# of type [code]#DataT# providing atomic
access to the element stored within the work-group's local memory allocation
that this accessor is accessing, at the index specified by [code]#index#.

This function may only be called from within a <<command>>.

a@
[source]
----
atomic<DataT, access::address_space::local_space> operator[](size_t index) const
----
   a@ Available only when
      [code]#(AccessMode == access_mode::atomic && Dimensions == 1)#.

Returns an instance of [code]#atomic# of type [code]#DataT# providing atomic
access to the element stored within the work-group's local memory allocation
that this accessor is accessing, at the index specified by [code]#index#.

This function may only be called from within a <<command>>.

a@
[source]
----
local_ptr<DataT> get_pointer() const noexcept
----
   a@ Returns a [code]#multi_ptr# to the work-group's local memory allocation
      that this accessor is accessing.  The return value is unspecified if the
      accessor is empty.

This function may only be called from within a <<command>>.

|====


[[sec:accessor.deprecated.common.members]]
====== Common members for deprecated accessors

Specializations of the [code]#accessor# class with
[code]#target::constant_buffer#, [code]#target::host_buffer# and
[code]#target::local# have many member types and member functions with the same
name and meaning.  <<table.accessors.deprecated.common.types>> describes these
common types and <<table.accessors.deprecated.common.members>> describes the
common member functions.


[[table.accessors.deprecated.common.types]]
.Common member types of the deprecated accessors
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member types @ Description
a@
[source]
----
value_type
----
   a@ If [code]#(AccessMode == access_mode::read)#, equal to
      [code]#const DataT#, otherwise equal to [code]#DataT#.

a@
[source]
----
reference
----
   a@ Equal to [code]#value_type&#.

a@
[source]
----
const_reference
----
   a@ Equal to [code]#const DataT&#.

|====


[[table.accessors.deprecated.common.members]]
.Common member functions of the deprecated accessors
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
size_t get_size() const noexcept
----
   a@ Returns the size in bytes of the memory region this accessor may access.

When [code]#AccessTarget# is [code]#target::constant_buffer# or
[code]#target::host_buffer#, the returned value is the size of the elements in
the underlying buffer, unless this is a <<ranged-accessor>> in which case it is
the size of the elements within the accessor's range.

When [code]#AccessTarget# is [code]#target::local#, the returned value is the
size in bytes of the accessor's local memory allocation, per work-group.

a@
[source]
----
size_t get_count() const noexcept
----
   a@ Returns the number of [code]#DataT# elements of the memory region this
      accessor may access.

When [code]#AccessTarget# is [code]#target::constant_buffer# or
[code]#target::host_buffer#, the returned value is the number of elements in
the underlying buffer, unless this is a <<ranged-accessor>> in which case it is
the number of elements within the accessor's range.

When [code]#AccessTarget# is [code]#target::local#, the returned value is the
number of elements in the accessor's local memory allocation, per work-group.

a@
[source]
----
range<Dimensions> get_range() const
----
   a@ Available only when [code]#(Dimensions > 0)#.

Returns a [code]#range# object which represents the number of elements of
[code]#DataT# per dimension that this accessor may access.

When [code]#AccessTarget# is [code]#target::constant_buffer# or
[code]#target::host_buffer#, the returned value is the range of the underlying
buffer, unless this is a <<ranged-accessor>> in which case it is the range that
was specified when the accessor was constructed.

When [code]#AccessTarget# is [code]#target::local#, the returned value is the
range that was specified when the accessor was constructed.

a@
[source]
----
operator reference() const
----
   a@ When [code]#AccessTarget# is [code]#target::constant_buffer# or
      [code]#target::host_buffer#, available only when
      [code]#(Dimensions == 0)#.

When [code]#AccessTarget# is [code]#target::local#, available only when
[code]#(AccessMode == access_mode::read_write && Dimensions == 0)#.

Returns a reference to the single element that is accessed by this accessor.

When [code]#AccessTarget# is [code]#target::local# or
[code]#target::constant_buffer#, this function may only be called from within a
<<command>>.

a@
[source]
----
reference operator[](id<Dimensions> index) const
----
   a@ When [code]#AccessTarget# is [code]#target::constant_buffer# or
      [code]#target::host_buffer#, available only when
      [code]#(Dimensions > 0)#.

When [code]#AccessTarget# is [code]#target::local#, available only when
[code]#(AccessMode == access_mode::read_write && Dimensions > 0)#.

Returns a reference to the element at the location specified by [code]#index#.
If this is a <<ranged-accessor>>, the element is determined by adding
[code]#index# to the accessor's offset.

When [code]#AccessTarget# is [code]#target::local# or
[code]#target::constant_buffer#, this function may only be called from within a
<<command>>.

a@
[source]
----
__unspecified__ operator[](size_t index) const
----
   a@ Available only when [code]#(Dimensions > 1)#.

Returns an instance of an undefined intermediate type representing this
accessor, with the dimensionality [code]#Dimensions-1# and containing an
implicit [code]#id# with index [code]#Dimensions# set to [code]#index#.  The
intermediate type returned must provide all available subscript operators which
take a [code]#size_t# parameter defined by this accessor class that are
appropriate for the type it represents (including this subscript operator).

If this is a <<ranged-accessor>>, the implicit [code]#id# in the returned
instance also includes the accessor's offset.

When [code]#AccessTarget# is [code]#target::local# or
[code]#target::constant_buffer#, this function may only be called from within a
<<command>>.

a@
[source]
----
reference operator[](size_t index) const
----
   a@ When [code]#AccessTarget# is [code]#target::constant_buffer# or
      [code]#target::host_buffer#, available only when
      [code]#(Dimensions == 1)#.

When [code]#AccessTarget# is [code]#target::local#, available only when
[code]#(AccessMode == access_mode::read_write && Dimensions == 1)#.

Returns a reference to the element at the location specified by [code]#index#.
If this is a <<ranged-accessor>>, the element is determined by adding
[code]#index# to the accessor's offset.

When [code]#AccessTarget# is [code]#target::local# or
[code]#target::constant_buffer#, this function may only be called from within a
<<command>>.

|====


====== Accessor specialization with [code]#access_mode::atomic#

The [code]#accessor# class may be specialized with target
[code]#target::device# and access mode [code]#access_mode::atomic#.
This specialization provides additional member functions beyond those that are
provided for other [code]#target::device# specializations as described
in <<table.accessors.deprecated.atomic.members>>.


[[table.accessors.deprecated.atomic.members]]
.Deprecated atomic member functions of the [code]#accessor# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
operator atomic<DataT, access::address_space::global_space>() const
----
   a@ Available only when
      [code]#(AccessMode == access_mode::atomic && Dimensions == 0)#.

Returns an instance of [code]#atomic# of type [code]#DataT# providing atomic
access to the single element that is accessed by this accessor.

a@
[source]
----
atomic<DataT, access::address_space::global_space>
operator[](id<Dimensions> index) const
----
   a@ Available only when
      [code]#(AccessMode == access_mode::atomic && Dimensions > 0)#.

Returns an instance of [code]#atomic# of type [code]#DataT# providing atomic
access to the element stored within the accessor's buffer at the index
specified by [code]#index#.

If this is a <<ranged-accessor>>, the returned [code]#atomic# instance
provides access to the buffer element whose location is determined by adding
the accessor's offset to [code]#index#.

a@
[source]
----
atomic<DataT, access::address_space::global_space>
operator[](size_t index) const
----
   a@ Available only when
      [code]#(AccessMode == access_mode::atomic && Dimensions == 1)#.

Returns an instance of [code]#atomic# of type [code]#DataT# providing atomic
access to the element stored within the accessor's buffer at the index
specified by [code]#index#.

If this is a <<ranged-accessor>>, the returned [code]#atomic# instance
provides access to the buffer element whose location is determined by adding
the accessor's offset to [code]#index#.

|====


==== Buffer accessor for host code

The [code]#host_accessor# class provides access to data in a [code]#buffer#
from host code that is outside of a <<command>> (i.e. do not use this class to
access a buffer inside a host task).

As with [code]#accessor#, the dimensionality of [code]#host_accessor# must
match the underlying buffer, however, there is a special case if the buffer is
one-dimensional.  In this case, the accessor may either be one-dimensional or
it may be zero-dimensional.  A zero-dimensional accessor has access to just the
first element of the buffer, whereas a one-dimensional accessor has access to the
entire buffer.

The [code]#host_accessor# class supports the following access modes:
[code]#access_mode::read#, [code]#access_mode::write# and
[code]#access_mode::read_write#.


===== Interface for buffer host accessors

A synopsis of the [code]#host_accessor# class is provided below.  Since some of
the class types and member functions have the same name and meaning as other
accessors, the common types and functions are described in
<<sec:accessor.common.members>>.  The member types are listed in
<<table.accessors.common.types>>.
The constructors are listed in <<table.accessors.host.buffer.constructors>>,
and the member functions are listed in <<table.accessors.common.members>> and
<<table.accessors.host.buffer.members>>.

The additional common special member functions and common member functions are
listed in <<sec:reference-semantics>> in
<<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>>, respectively.  For valid implicit
conversions between accessor types refer to
<<sec:accessor.host.buffer.conversions>>.  Additionally, accessors of the same
type must be equality comparable.

[source,,linenums]
----
include::{header_dir}/accessorHost.h[lines=4..-1]
----


[[table.accessors.host.buffer.constructors]]
.Constructors of the [code]#host_accessor# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
host_accessor()
----
   a@ Constructs an empty accessor which fulfills the following
      post-conditions:
--
  * [code]#(empty() == true)#
  * All size queries return [code]#0#.
  * The return value of [code]#get_pointer()# is unspecified.
  * Trying to access the underlying memory is undefined behavior.
--

a@
[source]
----
template <typename AllocatorT>
host_accessor(buffer<DataT, 1, AllocatorT>& bufferRef,
              const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions == 0)#.

Constructs a [code]#host_accessor# for accessing the first element of a
[code]#buffer# immediately on the host.  The optional [code]#property_list#
provides properties for the constructed accessor.

a@
[source]
----
template <typename AllocatorT>
host_accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
              const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs a [code]#host_accessor# for accessing a [code]#buffer# immediately
on the host.  The optional [code]#property_list# provides properties for the
constructed accessor.

a@
[source]
----
template <typename AllocatorT, typename TagT>
host_accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef, TagT tag,
              const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs a [code]#host_accessor# for accessing a [code]#buffer# immediately
on the host.  The [code]#tag# is used to deduce template arguments of the
accessor as described in <<sec:accessor.host.buffer.tags>>.  The optional
[code]#property_list# provides properties for the constructed accessor.

a@
[source]
----
template <typename AllocatorT>
host_accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
              range<Dimensions> accessRange, const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs a [code]#host_accessor# that is a <<ranged-accessor>> which accesses
a buffer immediately on the host, where the range starts at the beginning of
the [code]#buffer#.  The optional [code]#property_list# provides properties for
the constructed accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
[code]#accessRange# exceeds the range of [code]#bufferRef# in any dimension.


a@
[source]
----
template <typename AllocatorT, typename TagT>
host_accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
              range<Dimensions> accessRange, TagT tag,
              const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs a [code]#host_accessor# that is a <<ranged-accessor>> which accesses
a buffer immediately on the host, where the range starts at the beginning of
the [code]#buffer#.  The [code]#tag# is used to deduce template arguments of
the accessor as described in <<sec:accessor.host.buffer.tags>>.  The optional
[code]#property_list# provides properties for the constructed accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
[code]#accessRange# exceeds the range of [code]#bufferRef# in any dimension.

a@
[source]
----
template <typename AllocatorT>
host_accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
              range<Dimensions> accessRange, id<Dimensions> accessOffset,
              const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs a [code]#host_accessor# that is a <<ranged-accessor>> which accesses
a buffer immediately on the host, where the range starts at an offset from the
beginning of the buffer.  The optional [code]#property_list# provides
properties for the constructed accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
the sum of [code]#accessRange# and [code]#accessOffset# exceeds the range of
[code]#bufferRef# in any dimension.

a@
[source]
----
template <typename AllocatorT, typename TagT>
host_accessor(buffer<DataT, Dimensions, AllocatorT>& bufferRef,
              range<Dimensions> accessRange, id<Dimensions> accessOffset,
              TagT tag, const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs a [code]#host_accessor# that is a <<ranged-accessor>> which accesses
a buffer immediately on the host, where the range starts at an offset from the
beginning of the buffer.  The [code]#tag# is used to deduce template arguments
of the accessor as described in <<sec:accessor.host.buffer.tags>>.  The
optional [code]#property_list# provides properties for the constructed
accessor.

Throws an [code]#exception# with the [code]#errc::invalid# error code if
the sum of [code]#accessRange# and [code]#accessOffset# exceeds the range of
[code]#bufferRef# in any dimension.

|====


[[table.accessors.host.buffer.members]]
.Member functions of the [code]#host_accessor# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
void swap(host_accessor& other);
----
   a@ Swaps the contents of the current accessor with the contents of
      [code]#other#.

a@
[source]
----
id<Dimensions> get_offset() const
----
   a@ Available only when [code]#(Dimensions > 0)#.

If this is a <<ranged-accessor>>, returns the offset that was specified when the
accessor was constructed.  For other accessors, returns the default constructed
[code]#id<Dimensions>{}#.

a@
[source]
----
std::add_pointer_t<value_type> get_pointer() const noexcept
----
   a@ Returns a pointer to the start of this accessor's underlying
      buffer, even if this is a <<ranged-accessor>> whose range does not start
      at the beginning of the buffer.  The return value is unspecified if the
      accessor is empty.

a@
[source]
----
const host_accessor& operator=(const value_type& other) const
----
   a@ Available only when [code]#(AccessMode != access_mode::read &&
      Dimensions == 0)#.

Assignment to the single element that is accessed by this accessor.

a@
[source]
----
const host_accessor& operator=(value_type&& other) const
----
   a@ Available only when [code]#(AccessMode != access_mode::read &&
      Dimensions == 0)#.

Assignment to the single element that is accessed by this accessor.

|====


[[sec:accessor.host.buffer.tags]]
===== Deduction tags for buffer host accessors

Some [code]#host_accessor# constructors take a [code]#TagT# parameter, which is
used to deduce template arguments.  The permissible values for this parameter
are listed in <<table.accessors.host.buffer.tags>> along with the access mode
that they imply.

[[table.accessors.host.buffer.tags]]
.Enumeration of tags available for [code]#host_accessor# construction
[width="100%",options="header",cols="50%,50%"]
|====
| Tag value | Access mode
| [code]#read_write#
    | [code]#access_mode::read_write#
| [code]#read_only#
    | [code]#access_mode::read#
| [code]#write_only#
    | [code]#access_mode::write#
|====


[[sec:accessor.host.buffer.conversions]]
===== Read only buffer host accessors and implicit conversions

<<table.accessors.host.buffer.read-only>> shows the specializations of
[code]#host_accessor# that are read-only accessors.  There is an implicit
conversion between any of these specializations, provided that all other
template parameters are the same.

[[table.accessors.host.buffer.read-only]]
.Specializations of [code]#host_accessor# that are read-only
[width="100%",options="header",cols="50%,50%"]
|====
| Data type | Access mode
| not const-qualified | [code]#access_mode::read#
| const-qualified | [code]#access_mode::read#
|====

There is also an implicit conversion from the read-write [code]#host_accessor#
type shown in <<table.accessors.host.buffer.read-write>> to any of the read-only
accessors in <<table.accessors.host.buffer.read-only>>, provided that all other
template parameters are the same.

[[table.accessors.host.buffer.read-write]]
.Specializations of [code]#host_accessor# that are read-write
[width="100%",options="header",cols="50%,50%"]
|====
| Data type | Access mode
| not const-qualified | [code]#access_mode::read_write#
|====


[[sec:accessor.local]]
==== Local accessor

The [code]#local_accessor# class allocates device local memory and provides
access to this memory from within a <<sycl-kernel-function>>.  The
<<local-memory>> that is allocated is shared between all
<<work-item,work-items>> of a <<work-group>>.  If multiple work-groups execute
simultaneously in an implementation, each work-group receives its own
independent copy of the allocated local memory.

The underlying [code]#DataT# type can be any {cpp} type that the device
supports.  If [code]#DataT# is an implicit-lifetime type (as defined in the
{cpp} core language), the local accessor implicitly creates objects of that
type with indeterminate values.  For other types, the local accessor merely
allocates uninitialized memory, and the application is responsible for
constructing objects in that memory (e.g. by calling placement-new).

A local accessor must not be used in a <<sycl-kernel-function>> that is invoked
via [code]#single_task# or via the simple form of [code]#parallel_for# that
takes a [code]#range# parameter.  In these cases submitting the kernel to
a queue must throw a synchronous [code]#exception# with the
[code]#errc::kernel_argument# error code.


===== Interface for local accessors

A synopsis of the [code]#local_accessor# class is provided below.  Since some
of the class types and member functions have the same name and meaning as other
accessors, the common types and functions are described in
<<sec:accessor.common.members>>.  The member types are listed in
<<table.accessors.common.types>> and <<table.accessors.local.types>>.
The constructors are listed in <<table.accessors.local.constructors>>,
and the member functions are listed in <<table.accessors.common.members>> and
<<table.accessors.local.members>>.

The additional common special member functions and common member functions are
listed in <<sec:reference-semantics>> in
<<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>>, respectively.  For valid implicit
conversions between accessor types refer to <<sec:accessor.local.conversions>>.
Additionally, accessors of the same type must be equality comparable.

[source,,linenums]
----
include::{header_dir}/accessorLocal.h[lines=4..-1]
----


[[table.accessors.local.types]]
.Member types of the [code]#local_accessor# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member types @ Description
a@
[source]
----
template <access::decorated IsDecorated> accessor_ptr
----
   a@ Equal to
      [code]#multi_ptr<value_type, access::address_space::local_space, IsDecorated>#.

|====


[[table.accessors.local.constructors]]
.Constructors of the [code]#local_accessor# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
local_accessor()
----
   a@ Constructs an empty local accessor which fulfills the following
      post-conditions:
--
  * [code]#(empty() == true)#
  * All size queries return [code]#0#.
  * The return values of [code]#get_pointer()# and [code]#get_multi_ptr()# are
    unspecified.
  * A default constructed local accessor can be passed to a
    <<sycl-kernel-function>>, but attempting to access data elements from it
    produces undefined behavior.
--

a@
[source]
----
local_accessor(handler& commandGroupHandlerRef,
               const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions == 0)#.

Constructs a [code]#local_accessor# for accessing <<local-memory>> of a single
[code]#DataT# element within a <<sycl-kernel-function>> on the queue associated
with [code]#commandGroupHandlerRef#.  The optional [code]#property_list#
provides properties for the constructed accessor.

a@
[source]
----
local_accessor(range<Dimensions> allocationSize,
               handler& commandGroupHandlerRef,
               const property_list& propList = {})
----
   a@ Available only when [code]#(Dimensions > 0)#.

Constructs a [code]#local_accessor# for accessing <<local-memory>> of an array
of [code]#DataT# elements within a <<sycl-kernel-function>> on the queue
associated with [code]#commandGroupHandlerRef#.  The number of elements in the
array is defined by [code]#allocationSize#.  The optional [code]#property_list#
provides properties for the constructed accessor.

|====


[[table.accessors.local.members]]
.Member functions of the [code]#local_accessor# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
void swap(local_accessor& other);
----
   a@ Swaps the contents of the current accessor with the contents of
      [code]#other#.

@
[source]
----
local_ptr<DataT> get_pointer() const noexcept
----
   a@ Returns a [code]#multi_ptr# to the start of this accessor's local memory
      region which corresponds to the calling work-group. The return value is
      unspecified if the accessor is empty.

This function may only be called from within a <<command>>.

Deprecated in SYCL 2020.  Use [code]#get_multi_ptr# instead.


a@
[source]
----
template <access::decorated IsDecorated>
accessor_ptr<IsDecorated> get_multi_ptr() const noexcept
----
   a@ Returns a [code]#multi_ptr# to the start of the accessor's local memory
      region which corresponds to the calling work-group.  The return value is
      unspecified if the accessor is empty.

This function may only be called from within a <<sycl-kernel-function>>.

a@
[source]
----
const local_accessor& operator=(const value_type& other) const
----
   a@ Available only when [code]#(!std::is_const_v<DataT> && Dimensions == 0)#.

Assignment to the single element that is accessed by this accessor.

This function may only be called from within a <<command>>.

a@
[source]
----
const local_accessor& operator=(const value_type&& other) const
----
   a@ Available only when [code]#(!std::is_const_v<DataT> && Dimensions == 0)#.

Assignment to the single element that is accessed by this accessor.

This function may only be called from within a <<command>>.

|====


[[sec:accessor.local.conversions]]
===== Read only local accessors and implicit conversions

Since [code]#local_accessor# has no template parameter for the access mode, the
only specialization for a read-only local accessor is by providing a
[code]#const# qualified [code]#DataT# parameter.  Specializations with a
non-[code]#const# qualified [code]#DataT# parameter are read-write.  There is
an implicit conversion from the read-write specialization to the read-only
specialization, provided that all other template parameters are the same.


[[sec:accessor.common.members]]
==== Common members for buffer and local accessors

The [code]#accessor#, [code]#host_accessor#, and [code]#local_accessor# classes
have many member types and member functions with the same name and meaning.
<<table.accessors.common.types>> describes these common types and
<<table.accessors.common.members>> describes the common member functions.


[[table.accessors.common.types]]
.Common buffer and local accessor member types
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member types @ Description
a@
[source]
----
value_type
----
   a@ If the accessor is read-only, equal to [code]#const DataT#, otherwise
      equal to [code]#DataT#.

See <<sec:accessor.command.buffer.conversions>>,
<<sec:accessor.host.buffer.conversions>> and <<sec:accessor.local.conversions>>
for which accessors are considered read-only.

a@
[source]
----
reference
----
   a@ Equal to [code]#value_type&#.

a@
[source]
----
const_reference
----
   a@ Equal to [code]#const DataT&#.

a@
[source]
----
iterator
----
   a@ Iterator that can provide ranged access.  Cannot be written to if the
      accessor is read-only.  The underlying pointer is address space qualified
      for [code]#accessor# specializations with [code]#target::device# and for
      [code]#local_accessor#.

a@
[source]
----
const_iterator
----
   a@ Iterator that can provide ranged access.  Cannot be written to.  The
      underlying pointer is address space qualified for [code]#accessor#
      specializations with [code]#target::device# and for
      [code]#local_accessor#.

a@
[source]
----
reverse_iterator
----
   a@ Iterator adaptor that reverses the direction of [code]#iterator#.

a@
[source]
----
const_reverse_iterator
----
   a@ Iterator adaptor that reverses the direction of [code]#const_iterator#.

a@
[source]
----
difference_type
----
   a@ Equal to
      [code]#typename std::iterator_traits<iterator>::difference_type#.

a@
[source]
----
size_type
----
   a@ Equal to [code]#size_t#.

|====


[[table.accessors.common.members]]
.Common buffer and local accessor member functions
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
size_type byte_size() const noexcept
----
   a@ Returns the size in bytes of the memory region this accessor may access.

For a buffer accessor this is the size of the underlying buffer, unless it is a
<<ranged-accessor>> in which case it is the size of the elements within the
accessor's range.

For a local accessor this is the size of the accessor's local memory
allocation, per work-group.

a@
[source]
----
size_type size() const noexcept
----
   a@ Returns the number of [code]#DataT# elements of the memory region this
      accessor may access.

For a buffer accessor this is the number of elements in the underlying buffer,
unless it is a <<ranged-accessor>> in which case it is the number of elements
within the accessor's range.

For a local accessor this is the number of elements in the accessor's local
memory allocation, per work-group.

a@
[source]
----
size_type max_size() const noexcept
----
   a@ Returns the maximum number of elements any accessor of this type would be
      able to access.

a@
[source]
----
bool empty() const noexcept
----
   a@ Returns [code]#true# if [code]#(size() == 0)#.

a@
[source]
----
range<Dimensions> get_range() const
----
   a@ Available only when [code]#(Dimensions > 0)#.

Returns a [code]#range# object which represents the number of elements of
[code]#DataT# per dimension that this accessor may access.

For a buffer accessor this is the range of the underlying buffer, unless it is
a <<ranged-accessor>> in which case it is the range that was specified when the
accessor was constructed.

a@
[source]
----
operator reference() const
----
   a@ For [code]#accessor# available only when
      [code]#(AccessMode != access_mode::atomic && Dimensions == 0)#.

For [code]#host_accessor# and [code]#local_accessor# available only when
[code]#(Dimensions == 0)#.

Returns a reference to the single element that is accessed by this accessor.

For [code]#accessor# and [code]#local_accessor#, this function may only be
called from within a <<command>>.

a@
[source]
----
reference operator[](id<Dimensions> index) const
----
   a@ For [code]#accessor# available only when
      [code]#(AccessMode != access_mode::atomic && Dimensions > 0)#.

For [code]#host_accessor# and [code]#local_accessor# available only when
[code]#(Dimensions > 0)#.

Returns a reference to the element at the location specified by [code]#index#.
If this is a <<ranged-accessor>>, the element is determined by adding
[code]#index# to the accessor's offset.

For [code]#accessor# and [code]#local_accessor#, this function may only be
called from within a <<command>>.

a@
[source]
----
__unspecified__ operator[](size_t index) const
----
   a@ Available only when [code]#(Dimensions > 1)#.

Returns an instance of an undefined intermediate type representing this
accessor, with the dimensionality [code]#Dimensions-1# and containing an
implicit [code]#id# with index [code]#Dimensions# set to [code]#index#.  The
intermediate type returned must provide all available subscript operators which
take a [code]#size_t# parameter defined by this accessor class that are
appropriate for the type it represents (including this subscript operator).

If this is a <<ranged-accessor>>, the implicit [code]#id# in the returned
instance also includes the accessor's offset.

For [code]#accessor# and [code]#local_accessor#, this function may only be
called from within a <<command>>.

a@
[source]
----
reference operator[](size_t index) const
----
   a@ For [code]#accessor# available only when
      [code]#(AccessMode != access_mode::atomic && Dimensions == 1)#.

For [code]#host_accessor# and [code]#local_accessor# available only when
[code]#(Dimensions == 1)#.

Returns a reference to the element at the location specified by [code]#index#.
If this is a <<ranged-accessor>>, the element is determined by adding
[code]#index# to the accessor's offset.

For [code]#accessor# and [code]#local_accessor#, this function may only be
called from within a <<command>>.

a@
[source]
----
iterator begin() const noexcept
----
   a@ Returns an iterator to the first element of the memory this accessor may
      access.

For a buffer accessor this is an iterator to the first element of the
underlying buffer, unless this is a <<ranged-accessor>> in which case it is an
iterator to first element within the accessor's range.

For [code]#accessor# and [code]#local_accessor#, this function may only be
called from within a <<command>>.

a@
[source]
----
iterator end() const noexcept
----
   a@ Returns an iterator to one element past the last element of the memory
      this accessor may access.

For a buffer accessor this is an iterator to one element past the last element
in the underlying buffer, unless this is a <<ranged-accessor>> in which case
it is an iterator to one element past the last element within the accessor's
range.

For [code]#accessor# and [code]#local_accessor#, this function may only be
called from within a <<command>>.

a@
[source]
----
const_iterator cbegin() const noexcept
----
   a@ Returns a const iterator to the first element of the memory this accessor
      may access.

For a buffer accessor this is a const iterator to the first element of the
underlying buffer, unless this is a <<ranged-accessor>> in which case it is a
const iterator to first element within the accessor's range.

For [code]#accessor# and [code]#local_accessor#, this function may only be
called from within a <<command>>.

a@
[source]
----
const_iterator cend() const noexcept
----
   a@ Returns a const iterator to one element past the last element of the
      memory this accessor may access.

For a buffer accessor this is a const iterator to one element past the last
element in the underlying buffer, unless this is a <<ranged-accessor>> in which
case it is a const iterator to one element past the last element within the
accessor's range.

For [code]#accessor# and [code]#local_accessor#, this function may only be
called from within a <<command>>.

a@
[source]
----
reverse_iterator rbegin() const noexcept
----
   a@ Returns an iterator adaptor to the last element of the memory this
      accessor may access.

For a buffer accessor this is an iterator adaptor to the last element of the
underlying buffer, unless this is a <<ranged-accessor>> in which case it is an
iterator adaptor to the last element within the accessor's range.

For [code]#accessor# and [code]#local_accessor#, this function may only be
called from within a <<command>>.

a@
[source]
----
reverse_iterator rend() const noexcept
----
   a@ Returns an iterator adaptor to one element before the first element of
      the memory this accessor may access.

For a buffer accessor this is an iterator adaptor to one element before the
first element in the underlying buffer, unless this is a <<ranged-accessor>> in
which case it is an iterator adaptor to one element before the first element
within the accessor's range.

For [code]#accessor# and [code]#local_accessor#, this function may only be
called from within a <<command>>.

a@
[source]
----
const_reverse_iterator crbegin() const noexcept
----
   a@ Returns a const iterator adaptor to the last element of the memory this
      accessor may access.

For a buffer accessor this is a const iterator adaptor to the last element of
the underlying buffer, unless this is a <<ranged-accessor>> in which case it is
an const iterator adaptor to last element within the accessor's range.

For [code]#accessor# and [code]#local_accessor#, this function may only be
called from within a <<command>>.

a@
[source]
----
const_reverse_iterator crend() const noexcept
----
   a@ Returns a const iterator adaptor to one element before the first element of
      the memory this accessor may access.

For a buffer accessor this is a const iterator adaptor to one element before the
first element in the underlying buffer, unless this is a <<ranged-accessor>> in
which case it is a const iterator adaptor to one element before the first element
within the accessor's range.

For [code]#accessor# and [code]#local_accessor#, this function may only be
called from within a <<command>>.

|====


==== Unsampled image accessors

There are two classes which implement accessors for unsampled images,
[code]#unsampled_image_accessor# and [code]#host_unsampled_image_accessor#.
The former provides access from within a <<sycl-kernel-function>> or from
within a <<host-task>>.  The latter provides access from host code that is
outside of a <<host-task>>.

The dimensionality of an unsampled image accessor must match the dimensionality
of the underlying image to which it provides access.  Both unsampled image
accessor classes support the [code]#access_mode::read# and
[code]#access_mode::write# access modes.  In addition, the
[code]#host_unsampled_image_accessor# class supports
[code]#access_mode::read_write#.

The [code]#AccessTarget# template parameter dictates how the
[code]#unsampled_image_accessor# can be used: [code]#image_target::device#
means the accessor can be used in a <<sycl-kernel-function>> while
[code]#image_target::host_task# means the accessor can be used in a
<<host-task>>.  Programs which specify this template parameter as
[code]#image_target::device# and then use the [code]#unsampled_image_accessor#
from a <<host-task>> are ill formed.  Likewise, programs which specify this
template parameter as [code]#image_target::host_task# and then use the
[code]#unsampled_image_accessor# from a <<sycl-kernel-function>> are ill
formed.


===== Interface for unsampled image accessors

A synopsis of the two unsampled image accessor classes is provided below.  Both
classes have member types with the same name, which are described in
<<table.accessors.unsampled.image.types>>.  The constructors for the two
classes are described in <<table.accessors.unsampled.image.constructors>> and
<<table.accessors.host.unsampled.image.constructors>>.  Both classes also have
member functions with the same name, which are described in
<<table.accessors.unsampled.image.members>>.

The additional common special member functions and common member functions are
listed in <<sec:reference-semantics>> in
<<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>>, respectively.  For valid implicit
conversions between unsampled accessor types refer to
<<sec:accessor.unsampled.image.conversions>>.

Two [code]#unsampled_image_accessor# objects of the same type must be equality
comparable in both the host code and in SYCL kernel functions.  Two
[code]#host_unsampled_image_accessor# objects of the same type must be equality
comparable in the host code.

[source,,linenums]
----
include::{header_dir}/accessorUnsampledImage.h[lines=4..-1]
----


[[table.accessors.unsampled.image.types]]
.Member types of the unsampled image classes
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member types @ Description
a@
[source]
----
value_type
----
   a@ If the accessor is read-only, equal to [code]#const DataT#, otherwise
      equal to [code]#DataT#.

See <<sec:accessor.unsampled.image.conversions>> for which accessors are
considered read-only.

a@
[source]
----
reference
----
   a@ Equal to [code]#value_type&#.

a@
[source]
----
const_reference
----
   a@ Equal to [code]#const DataT&#.

|====


[[table.accessors.unsampled.image.constructors]]
.Constructors of the [code]#unsampled_image_accessor# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
template <typename AllocatorT>
unsampled_image_accessor(unsampled_image<Dimensions, AllocatorT>& imageRef,
                         handler& commandGroupHandlerRef,
                         const property_list& propList = {})
----
   a@ Constructs an [code]#unsampled_image_accessor# for accessing an
      [code]#unsampled_image# within a <<command>> on the [code]#queue#
      associated with [code]#commandGroupHandlerRef#.  The optional
      [code]#property_list# provides properties for the constructed object.

If [code]#AccessTarget# is [code]#image_target::device#, throws an
[code]#exception# with the [code]#errc::feature_not_supported# error code if
the device associated with [code]#commandGroupHandlerRef# does not have
[code]#aspect::image#.

|====


[[table.accessors.host.unsampled.image.constructors]]
.Constructors of the [code]#host_unsampled_image_accessor# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
template <typename AllocatorT>
host_unsampled_image_accessor(unsampled_image<Dimensions, AllocatorT>& imageRef,
                              const property_list& propList = {})
----
   a@ Constructs a [code]#host_unsampled_image_accessor# for accessing an
      [code]#unsampled_image# immediately on the host.  The optional
      [code]#property_list# provides properties for the constructed object.

|====


[[table.accessors.unsampled.image.members]]
.Member functions of the unsampled image classes
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
size_t size() const noexcept
----
   a@ Returns the number of elements of the underlying [code]#unsampled_image#
      that this accessor is accessing.

a@
[source]
----
template <typename CoordT> DataT read(const CoordT& coords) const
----
   a@ Available only when [code]#(AccessMode == access_mode::read ||
      AccessMode == access_mode::read_write)#.

Reads and returns an element of the [code]#unsampled_image# at the coordinates
specified by [code]#coords#.  Permitted types for [code]#CoordT# are
[code]#int# when [code]#Dimensions == 1#, [code]#int2# when
[code]#Dimensions == 2# and [code]#int4# when [code]#Dimensions == 3#.

For [code]#unsampled_image_accessor#, this function may only be called from
within a <<command>>.

a@
[source]
----
template <typename CoordT>
void write(const CoordT& coords, const DataT& color) const
----
   a@ Available only when [code]#(AccessMode == access_mode::write ||
      AccessMode == access_mode::read_write)#.

Writes the value specified by [code]#color# to the element of the image at the
coordinates specified by [code]#coords#.  Permitted types for [code]#CoordT#
are [code]#int# when [code]#Dimensions == 1#, [code]#int2# when
[code]#Dimensions == 2# and [code]#int4# when [code]#Dimensions == 3#.

For [code]#unsampled_image_accessor#, this function may only be called from
within a <<command>>.

|====


[[sec:accessor.unsampled.image.conversions]]
===== Read only unsampled image accessors and implicit conversions

All specializations of unsampled image accessors with [code]#access_mode::read#
are read-only regardless of whether [code]#DataT# is [code]#const# qualified.
There is an implicit conversion between the [code]#const# qualified and
non-[code]#const# qualified specializations, provided that all other template
parameters are the same.


==== Sampled image accessors

There are two classes which implement accessors for sampled images,
[code]#sampled_image_accessor# and [code]#host_sampled_image_accessor#.
The former provides access from within a <<sycl-kernel-function>> or from
within a <<host-task>>.  The latter provides access from host code that is
outside of a <<host-task>>.

The dimensionality of a sampled image accessor must match the dimensionality
of the underlying image to which it provides access.  Sampled image accessors
are always read-only.

The [code]#AccessTarget# template parameter dictates how the
[code]#sampled_image_accessor# can be used: [code]#image_target::device# means
the accessor can be used in a <<sycl-kernel-function>> while
[code]#image_target::host_task# means the accessor can be used in a
<<host-task>>.  Programs which specify this template parameter as
[code]#image_target::device# and then use the [code]#sampled_image_accessor#
from a <<host-task>> are ill formed.  Likewise, programs which specify this
template parameter as [code]#image_target::host_task# and then use the
[code]#sampled_image_accessor# from a <<sycl-kernel-function>> are ill formed.



===== Interface for sampled image accessors

A synopsis of the two sampled image accessor classes is provided below.  Both
classes have member types with the same name, which are described in
<<table.accessors.sampled.image.types>>.  The constructors for the two
classes are described in <<table.accessors.sampled.image.constructors>> and
<<table.accessors.host.sampled.image.constructors>>.  Both classes also have
member functions with the same name, which are described in
<<table.accessors.sampled.image.members>>.

The additional common special member functions and common member functions are
listed in <<sec:reference-semantics>> in
<<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>>, respectively.  For valid implicit
conversions between sampled accessor types refer to
<<sec:accessor.sampled.image.conversions>>.

Two [code]#sampled_image_accessor# objects of the same type must be equality
comparable in both the host code and in SYCL kernel functions.  Two
[code]#host_sampled_image_accessor# objects of the same type must be equality
comparable in the host code.

[source,,linenums]
----
include::{header_dir}/accessorSampledImage.h[lines=4..-1]
----


[[table.accessors.sampled.image.types]]
.Member types of the sampled image classes
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member types @ Description
a@
[source]
----
value_type
----
   a@ Equal to [code]#const DataT#.

a@
[source]
----
reference
----
   a@ Equal to [code]#const DataT&#.

a@
[source]
----
const_reference
----
   a@ Equal to [code]#const DataT&#.

|====


[[table.accessors.sampled.image.constructors]]
.Constructors of the [code]#sampled_image_accessor# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
template <typename AllocatorT>
sampled_image_accessor(sampled_image<Dimensions, AllocatorT>& imageRef,
                       handler& commandGroupHandlerRef,
                       const property_list& propList = {})
----
   a@ Constructs a [code]#sampled_image_accessor# for accessing a
      [code]#sampled_image# within a <<command>> on the [code]#queue#
      associated with [code]#commandGroupHandlerRef#.  The optional
      [code]#property_list# provides properties for the constructed object.

If [code]#AccessTarget# is [code]#image_target::device#, throws an
[code]#exception# with the [code]#errc::feature_not_supported# error code if
the device associated with [code]#commandGroupHandlerRef# does not have
[code]#aspect::image#.

|====


[[table.accessors.host.sampled.image.constructors]]
.Constructors of the [code]#host_sampled_image_accessor# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
template <typename AllocatorT>
host_sampled_image_accessor(sampled_image<Dimensions, AllocatorT>& imageRef,
                            const property_list& propList = {})
----
   a@ Constructs a [code]#host_sampled_image_accessor# for accessing a
      [code]#sampled_image# immediately on the host.  The optional
      [code]#property_list# provides properties for the constructed object.

|====


[[table.accessors.sampled.image.members]]
.Member functions of the sampled image classes
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
size_t size() const noexcept
----
   a@ Returns the number of elements of the underlying [code]#sampled_image#
      that this accessor is accessing.

a@
[source]
----
template <typename CoordT> DataT read(const CoordT& coords) const
----
   a@ Reads and returns a sampled element of the [code]#sampled_image# at the
      coordinates specified by [code]#coords#.  Permitted types for
      [code]#CoordT# are [code]#float# when [code]#Dimensions == 1#,
      [code]#float2# when [code]#Dimensions == 2# and [code]#float4# when
      [code]#Dimensions == 3#.

For [code]#sampled_image_accessor#, this function may only be called from
within a <<command>>.

|====


[[sec:accessor.sampled.image.conversions]]
===== Read only sampled image accessors and implicit conversions

All specializations of sampled image accessors are read-only regardless of
whether [code]#DataT# is [code]#const# qualified.  There is an implicit
conversion between the [code]#const# qualified and non-[code]#const# qualified
specializations, provided that all other template parameters are the same.


// %%%%%%%%%%%%%%%%%%%%%%%%%%%% end accessors %%%%%%%%%%%%%%%%%%%%%%%%%%%%


=== Address space classes

In SYCL, there are five different address spaces: global, local, constant,
private and generic. In a SYCL generic implementation, types are not
affected by the address spaces. However, there are situations where users
need to explicitly carry address spaces in the type. For example:

  * For performance tuning and genericness. Even if the platform supports
    the representation of the generic address space, this may come at some
    performance sacrifice. In order to help the target compiler, it can be
    useful to track specifically which address space a pointer is
    addressing.
  * When linking SYCL kernels with <<backend>>-specific functions. In this
    case, it might be necessary to specify the address space for any pointer
    parameters.

Direct declaration of pointers with address spaces is discouraged as the
definition is implementation-defined. Users must rely on the
[code]#multi_ptr# class to handle address space boundaries and
interoperability.


[[sec:multiptr]]
==== Multi-pointer class

The multi-pointer class is the common interface for the explicit pointer
classes, defined in <<sec:pointerclasses>>.

There are situations where a user may want to make their type address space dependent.
This allows performing generic programming that depends on the address space associated
with their data. An example might be wrapping a pointer inside a class, where
a user may need to template the class according to the address space of the
pointer the class is initialized with. In this case, the [code]#multi_ptr#
class enables users to do this in a portable and stable way.

The [code]#multi_ptr# class exposes 3 flavors of the same interface.
If the value of [code]#access::decorated# is  [code]#access::decorated::no#,
the interface exposes pointers and references type that are not decorated by an address space.
If the value of [code]#access::decorated# is  [code]#access::decorated::yes#,
the interface exposes pointers and references type that are decorated by an address space.
The decoration is implementation dependent and relies on device compiler extensions.
The decorated type may be distinct from the non-decorated one.
For interoperability with the <<backend>>, users should rely on types exposed
by the decorated version.
If the value of [code]#access::decorated# is  [code]#access::decorated::legacy#,
the 1.2.1 interface is exposed.
This interface is deprecated.

The template traits [code]#remove_decoration# and type alias
[code]#remove_decoration_t# retrieve the non-decorated pointer or
reference from a decorated one.  Using this template trait with a
non-decorated type is safe and returns the same type.


It is possible to use the [code]#void# type for the [code]#multi_ptr#
class, but in that case some functionality is disabled.
[code]#multi_ptr<void># does not provide the [code]#reference# or
[code]#const_reference# types, the access operators
([code]#operator*()#, [code]#+operator->()+#), the arithmetic
operators or [code]#prefetch# member function.
Conversions from [code]#multi_ptr# to [code]#multi_ptr<void># of the
same address space are allowed, and will occur implicitly.
Conversions from [code]#multi_ptr<void># to any other
[code]#multi_ptr# type of the same address space
are allowed, but must be explicit.
The same rules apply to [code]#multi_ptr<const void>#.

An overview of the interface provided for the [code]#multi_ptr# class
follows.

[source,,linenums]
----
include::{header_dir}/multipointer.h[lines=4..-1]
----


[[table.constructors.multiptr]]
.Constructors of the SYCL [code]#multi_ptr# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
multi_ptr()
----
   a@ Default constructor.

a@
[source]
----
multi_ptr(const multi_ptr&)
----
   a@ Copy constructor.

a@
[source]
----
multi_ptr(multi_ptr&&)
----
   a@ Move constructor.

a@
[source]
----
explicit
multi_ptr(multi_ptr<ElementType, Space,
                    access::decorated::yes>::pointer)
----
   a@ Constructor that takes as an argument a decorated pointer.

a@
[source]
----
multi_ptr(std::nullptr_t)
----
   a@ Constructor from a [code]#nullptr#.

a@
[source]
----
template <typename AccDataT, int Dimensions,
          access_mode Mode,
          access::placeholder IsPlaceholder>
multi_ptr(accessor<AccDataT, Dimensions, Mode,
                   target::device, IsPlaceholder>)
----
   a@ Available only when:
      [code]#(Space == access::address_space::global_space || Space == access::address_space::generic_space) &&
      (std::is_void_v<ElementType> || std::is_same_v<std::remove_const_t<ElementType>, std::remove_const_t<AccDataT>>) &&
      (std::is_const_v<ElementType> ||
      !std::is_const_v<accessor<AccDataT, Dimensions, Mode, target::device, IsPlaceholder>::value_type>)#.

Constructs a [code]#multi_ptr# from an accessor of
[code]#target::device#.

This constructor may only be called from within a <<command>>.

a@
[source]
----
template <typename AccDataT, int Dimensions>
multi_ptr(local_accessor<AccDataT, Dimensions>)
----
   a@ Available only when:
      [code]#(Space == access::address_space::local_space || Space == access::address_space::generic_space) &&
      (std::is_void_v<ElementType> || std::is_same_v<std::remove_const_t<ElementType>, std::remove_const_t<AccDataT>>) &&
      (std::is_const_v<ElementType> || !std::is_const_v<AccDataT>)#.

Constructs a [code]#multi_ptr# from a [code]#local_accessor#.

This constructor may only be called from within a <<command>>.

a@
[source]
----
template <typename AccDataT, int Dimensions,
          access_mode Mode,
          access::placeholder IsPlaceholder>
multi_ptr(accessor<AccDataT, Dimensions, Mode,
                   target::local, IsPlaceholder>)
----
   a@ Deprecated in SYCL 2020.  Use the overload with
      [code]#local_accessor# instead.

Available only when:
[code]#(Space == access::address_space::local_space || Space == access::address_space::generic_space) &&
(std::is_void_v<ElementType> || std::is_same_v<std::remove_const_t<ElementType>, std::remove_const_t<AccDataT>>) &&
(std::is_const_v<ElementType> || !std::is_const_v<AccDataT>)#.

Constructs a [code]#multi_ptr# from an accessor of [code]#target::local#.

This constructor may only be called from within a <<command>>.

a@
[source]
----
template <typename ElementType,
          access::address_space Space,
          access::decorated DecorateAddress>
multi_ptr<ElementType, Space, DecorateAddress>
make_ptr(ElementType* pointer)
----
   a@ Deprecated in SYCL 2020.  Use [code]#address_space_cast# instead.

Global function to create a [code]#multi_ptr# instance depending
on the address space of the [code]#pointer# argument.
An implementation must return [code]#nullptr# if the run-time value of
[code]#pointer# is not compatible with [code]#Space#, and must issue a
compile-time diagnostic if the deduced address space is not compatible
with [code]#Space#.

a@
[source]
----
template <access::address_space Space,
          access::decorated DecorateAddress,
          typename ElementType>
multi_ptr<ElementType, Space, DecorateAddress>
address_space_cast(ElementType* pointer)
----
   a@ Global function to create a [code]#multi_ptr# instance from
      [code]#pointer#, using the address space and decoration specified
      via the [code]#Space# and [code]#DecorateAddress# template arguments.

An implementation must return [code]#nullptr# if the run-time value of
[code]#pointer# is not compatible with [code]#Space#, and must issue a
compile-time diagnostic if the deduced address space for [code]#pointer#
is not compatible with [code]#Space#.

|====



[[table.multiptr.operators]]
.Operators of [code]#multi_ptr# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Operators @ Description
a@
[source]
----
multi_ptr& operator=(const multi_ptr&)
----
   a@ Copy assignment operator.

a@
[source]
----
multi_ptr& operator=(multi_ptr&&)
----
   a@ Move assignment operator.

a@
[source]
----
multi_ptr& operator=(std::nullptr_t)
----
   a@ Assigns [code]#nullptr# to the [code]#multi_ptr#.

a@
[source]
----
template <access::address_space AS,
          access::decorated IsDecorated>
multi_ptr&
operator=(const multi_ptr<value_type, AS, IsDecorated>&)
----
   a@ Available only when: [code]#(Space == access::address_space::generic_space && AS != access::address_space::constant_space)#.

Assigns the value of the left hand side [code]#multi_ptr# into the [code]#generic_ptr#.

a@
[source]
----
template<access::address_space AS,
         access::decorated IsDecorated>
multi_ptr&
operator=(multi_ptr<value_type, AS, IsDecorated>&&)
----
   a@ Available only when:
      [code]#(Space == access::address_space::generic_space && AS != access::address_space::constant_space)#.

Move the value of the left hand side [code]#multi_ptr# into the [code]#generic_ptr#.

a@
[source]
----
reference operator[](std::ptrdiff_t i) const
----
   a@ Available only when: [code]#(!std::is_void_v<value_type>)#.

Returns a reference to the i-th pointed value. The value i can be negative.

a@
[source]
----
pointer operator->() const
----
   a@ Available only when: [code]#(!std::is_void_v<value_type>)#.

Returns the underlying pointer.

a@
[source]
----
reference operator*() const
----
   a@ Available only when: [code]#(!std::is_void_v<value_type>)#.

Returns a reference to the pointed value.

a@
[source]
----
operator pointer() const
----
   a@ Implicit conversion to the underlying pointer type.
      *Deprecated:* The member function [code]#get# should be used instead

a@
[source]
----
template <access::decorated IsDecorated>
explicit
operator multi_ptr<value_type,
                   access::address_space::private_space,
                   IsDecorated>() const
----
   a@ Available only when:
      [code]#(Space == access::address_space::generic_space)#.

Conversion from [code]#generic_ptr# to [code]#private_ptr#.
The result is undefined if the pointer does not address the private
address space.

a@
[source]
----
template <access::decorated IsDecorated>
explicit
operator multi_ptr<const value_type,
                   access::address_space::private_space,
                   IsDecorated>() const
----
   a@ Available only when:
      [code]#(Space == access::address_space::generic_space)#.

Conversion from [code]#generic_ptr# to [code]#private_ptr# of const data.
The result is undefined if the pointer does not address the private
address space.

a@
[source]
----
template <access::decorated IsDecorated>
explicit
operator multi_ptr<value_type,
                   access::address_space::global_space,
                   IsDecorated>() const
----
   a@ Available only when:
      [code]#(Space == access::address_space::generic_space)#.

Conversion from [code]#generic_ptr# to [code]#global_ptr#.
The result is undefined if the pointer does not address the global
address space.

a@
[source]
----
template <access::decorated IsDecorated>
explicit
operator multi_ptr<const value_type,
                   access::address_space::global_space,
                   IsDecorated>() const
----
   a@ Available only when:
      [code]#(Space == access::address_space::generic_space)#.

Conversion from [code]#generic_ptr# to [code]#global_ptr# of const data.
The result is undefined if the pointer does not address the global
address space.

a@
[source]
----
template <access::decorated IsDecorated>
explicit
operator multi_ptr<value_type,
                   access::address_space::local_space,
                   IsDecorated>() const
----
   a@ Available only when:
      [code]#(Space == access::address_space::generic_space)#.

Conversion from [code]#generic_ptr# to [code]#local_ptr#.
The result is undefined if the pointer does not address the local
address space.

a@
[source]
----
template <access::decorated IsDecorated>
explicit
operator multi_ptr<const value_type,
                   access::address_space::local_space,
                   IsDecorated>() const
----
   a@ Available only when:
      [code]#(Space == access::address_space::generic_space)#.

Conversion from [code]#generic_ptr# to [code]#local_ptr# of const data.
The result is undefined if the pointer does not address the local
address space.

a@
[source]
----
template <access::decorated IsDecorated>
operator multi_ptr<void, Space, IsDecorated>() const
----
   a@ Available only when:
      [code]#(!std::is_void_v<value_type> && !std::is_const_v<value_type>)#.

Implicit conversion to a [code]#multi_ptr# of type [code]#void#.

a@
[source]
----
template <access::decorated IsDecorated>
operator multi_ptr<const void, Space, IsDecorated>() const
----
   a@ Available only when:
      [code]#(!std::is_void_v<value_type> && std::is_const_v<value_type>)#.

Implicit conversion to a [code]#multi_ptr# of type [code]#const void#.

a@
[source]
----
template <access::decorated IsDecorated>
operator multi_ptr<const value_type, Space,
                   IsDecorated>() const
----
   a@ Implicit conversion to a [code]#multi_ptr#
      of type [code]#const value_type#.

a@
[source]
----
operator multi_ptr<value_type, Space,
                   access::decorated::no>() const
----
   a@ Available only when:
      [code]#(is_decorated == true)#.

Implicit conversion to the equivalent [code]#multi_ptr# object that does not expose
decorated pointers or references.

a@
[source]
----
operator multi_ptr<value_type, Space,
                   access::decorated::yes>() const
----
   a@ Available only when:
      [code]#(is_decorated == false)#.

Implicit conversion to the equivalent [code]#multi_ptr# object that exposes
decorated pointers and references.

|====



[[table.multiptr.members]]
.Member functions of [code]#multi_ptr# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
pointer get() const
----
   a@ Returns the underlying pointer.
      Whether the pointer is decorated depends on the value of [code]#DecorateAddress#.

a@
[source]
----
__unspecified__* get_decorated() const
----
   a@ Returns the underlying pointer decorated by the address space that it addresses.
      Note that the support involves implementation-defined device compiler extensions.

a@
[source]
----
std::add_pointer_t<value_type> get_raw() const
----
   a@ Returns the underlying pointer, always undecorated.

a@
[source]
----
void prefetch(size_t numElements) const
----
   a@ Available only when: [code]#Space == access::address_space::global_space#.

Prefetches a number of elements specified by [code]#numElements# into
the <<global-memory>> cache. This operation is an implementation-defined
optimization and does not effect the functional  behavior of the SYCL
kernel function.

|====



[[table.multipointer.hiddenfriendfunctions]]
.Hidden friend functions of the [code]#multi_ptr# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Hidden friend function @ Description
a@
[source]
----
reference operator*(const multi_ptr& mp)
----
   a@ Available only when: [code]#(!std::is_void_v<ElementType>)#.

Operator that returns a reference to the [code]#value_type#
of [code]#mp#.

a@
[source]
----
multi_ptr& operator++(multi_ptr& mp)
----
   a@ Available only when: [code]#(!std::is_void_v<ElementType>)#.

Increments [code]#mp# by [code]#1# and returns  [code]#mp#.

a@
[source]
----
multi_ptr operator++(multi_ptr& mp, int)
----
   a@ Available only when: [code]#(!std::is_void_v<ElementType>)#.

Increments [code]#mp# by [code]#1# and returns a new [code]#multi_ptr#
with the value of the original [code]#mp#.

a@
[source]
----
multi_ptr& operator--(multi_ptr& mp)
----
   a@ Available only when: [code]#(!std::is_void_v<ElementType>)#.

Decrements [code]#mp# by [code]#1# and returns [code]#mp#.

a@
[source]
----
multi_ptr operator--(multi_ptr& mp, int)
----
   a@ Available only when: [code]#(!std::is_void_v<ElementType>)#.

Decrements [code]#mp# by [code]#1# and returns a new [code]#multi_ptr#
with the value of the original [code]#mp#.

a@
[source]
----
multi_ptr& operator+=(multi_ptr& lhs, difference_type r)
----
   a@ Available only when: [code]#(!std::is_void_v<ElementType>)#.

Moves [code]#mp# forward by [code]#r# and returns  [code]#lhs#.

a@
[source]
----
multi_ptr& operator-=(multi_ptr& lhs, difference_type r)
----
   a@ Available only when: [code]#(!std::is_void_v<ElementType>)#.

Moves [code]#mp# backward by [code]#r# and returns  [code]#lhs#.

a@
[source]
----
multi_ptr operator+(const multi_ptr& lhs, difference_type r)
----
   a@ Available only when: [code]#(!std::is_void_v<ElementType>)#.

Creates a new [code]#multi_ptr# that points [code]#r# forward
compared to [code]#lhs#.

a@
[source]
----
multi_ptr operator-(const multi_ptr& lhs, difference_type r)
----
   a@ Available only when: [code]#(!std::is_void_v<ElementType>)#.

Creates a new [code]#multi_ptr# that points [code]#r# backward
compared to [code]#lhs#.

a@
[source]
----
bool operator==(const multi_ptr& lhs, const multi_ptr& rhs)
----
   a@ Comparison operator [code]#==# for [code]#multi_ptr# class.

a@
[source]
----
bool operator!=(const multi_ptr& lhs, const multi_ptr& rhs)
----
   a@ Comparison operator [code]#!=# for [code]#multi_ptr# class.

a@
[source]
----
bool operator<(const multi_ptr& lhs, const multi_ptr& rhs)
----
   a@ Comparison operator [code]#<# for [code]#multi_ptr# class.

a@
[source]
----
bool operator>(const multi_ptr& lhs, const multi_ptr& rhs)
----
   a@ Comparison operator [code]#># for [code]#multi_ptr# class.

a@
[source]
----
bool operator<=(const multi_ptr& lhs, const multi_ptr& rhs)
----
   a@ Comparison operator [code]#+<=+# for [code]#multi_ptr# class.

a@
[source]
----
bool operator>=(const multi_ptr& lhs, const multi_ptr& rhs)
----
   a@ Comparison operator [code]#>=# for [code]#multi_ptr# class.

a@
[source]
----
bool operator==(const multi_ptr& lhs, std::nullptr_t)
----
   a@ Comparison operator [code]#==# for [code]#multi_ptr# class with a
      [code]#std::nullptr_t#.

a@
[source]
----
bool operator!=(const multi_ptr& lhs, std::nullptr_t)
----
   a@ Comparison operator [code]#!=# for [code]#multi_ptr# class with a
      [code]#std::nullptr_t#.

a@
[source]
----
bool operator<(const multi_ptr& lhs, std::nullptr_t)
----
   a@ Comparison operator [code]#<# for [code]#multi_ptr# class with a
      [code]#std::nullptr_t#.

a@
[source]
----
bool operator>(const multi_ptr& lhs, std::nullptr_t)
----
   a@ Comparison operator [code]#># for [code]#multi_ptr# class with a
      [code]#std::nullptr_t#.

a@
[source]
----
bool operator<=(const multi_ptr& lhs, std::nullptr_t)
----
   a@ Comparison operator [code]#+<=+# for [code]#multi_ptr# class with a
      [code]#std::nullptr_t#.

a@
[source]
----
bool operator>=(const multi_ptr& lhs, std::nullptr_t)
----
   a@ Comparison operator [code]#>=# for [code]#multi_ptr# class with a
      [code]#std::nullptr_t#.

a@
[source]
----
bool operator==(std::nullptr_t, const multi_ptr& rhs)
----
   a@ Comparison operator [code]#==# for [code]#multi_ptr# class with a
      [code]#std::nullptr_t#.

a@
[source]
----
bool operator!=(std::nullptr_t, const multi_ptr& rhs)
----
   a@ Comparison operator [code]#!=# for [code]#multi_ptr# class with a
      [code]#std::nullptr_t#.

a@
[source]
----
bool operator<(std::nullptr_t, const multi_ptr& rhs)
----
   a@ Comparison operator [code]#<# for [code]#multi_ptr# class with a
      [code]#std::nullptr_t#.

a@
[source]
----
bool operator>(std::nullptr_t, const multi_ptr& rhs)
----
   a@ Comparison operator [code]#># for [code]#multi_ptr# class with a
      [code]#std::nullptr_t#.

a@
[source]
----
bool operator<=(std::nullptr_t, const multi_ptr& rhs)
----
   a@ Comparison operator [code]#+<=+# for [code]#multi_ptr# class with a
      [code]#std::nullptr_t#.

a@
[source]
----
bool operator>=(std::nullptr_t, const multi_ptr& rhs)
----
   a@ Comparison operator [code]#>=# for [code]#multi_ptr# class with a
      [code]#std::nullptr_t#.

|====


The following is the overview of the legacy interface from 1.2.1 provided
for the [code]#multi_ptr# class.

[source,,linenums]
----
include::{header_dir}/multipointerlegacy.h[lines=4..-1]
----


[[sec:pointerclasses]]
==== Explicit pointer aliases

SYCL provides aliases to the [code]#multi_ptr# class template (see
<<sec:multiptr>>) for each specialization of [code]#access::address_space#.

A synopsis of the SYCL [code]#multi_ptr# class template
aliases is provided below.

// Interface of the explicit pointer classes
[source,,linenums]
----
include::{header_dir}/pointer.h[lines=4..-1]
----

Note that using [code]#global_ptr#, [code]#local_ptr#,
[code]#constant_ptr# or [code]#private_ptr#
without specifying the decoration is deprecated.
The default argument is provided for compatibility with 1.2.1.


[[subsec:samplers]]
=== Image samplers

The SYCL [code]#image_sampler# struct contains a configuration for sampling a
[code]#sampled_image#.  The members of this struct are defined by the following
tables.

// Interface of the sampler class
[source,,linenums]
----
include::{header_dir}/imageSampler.h[lines=4..-1]
----


[[table.addressing.mode.sampler]]
.Addressing modes description
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ addressing_mode @ Description
a@
[source]
----
mirrored_repeat
----
   a@ Out of range coordinates will be flipped at every integer junction. This addressing mode
      can only be used with normalized coordinates. If normalized coordinates are not used, this
      addressing mode may generate image coordinates that are undefined.

a@
[source]
----
repeat
----
   a@ Out of range image coordinates are wrapped to the valid range. This addressing mode can only
      be used with normalized coordinates. If normalized coordinates are not used, this
      addressing mode may generate image coordinates that are undefined.

a@
[source]
----
clamp_to_edge
----
   a@ Out of range image coordinates are clamped to the extent.

a@
[source]
----
clamp
----
   a@ Out of range image coordinates will return a border color.

a@
[source]
----
none
----
   a@ For this addressing mode the programmer guarantees that the image coordinates used to
      sample elements of the image refer to a location inside the image; otherwise the results are
      undefined.

|====



[[table.filtering.mode.sampler]]
.Filtering modes description
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ filtering_mode @ Description
a@
[source]
----
nearest
----
   a@ Chooses a color of nearest pixel.

a@
[source]
----
linear
----
   a@ Performs a linear sampling of adjacent pixels.

|====



[[table.normalization.mode.sampler]]
.Coordinate normalization modes description
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ coordinate_normalization_mode @ Description
a@
[source]
----
normalized
----
   a@ Normalizes image coordinates.

a@
[source]
----
unnormalized
----
   a@ Does not normalize image coordinates.

|====


// \input{usm}

// %%%%%%%%%%%%%%%%%%%%%%%%%%%% begin usm %%%%%%%%%%%%%%%%%%%%%%%%%%%%

[[sec:usm]]
== Unified shared memory (USM)

This section describes properties and routines for pointer-based
memory management interfaces in SYCL.  These routines augment, rather
than replace, the buffer-based interfaces in SYCL.

Unified Shared Memory (<<usm>>) provides a pointer-based alternative to
the buffer programming model. USM enables:

  * Easier integration into existing code bases by representing allocations
    as pointers rather than buffers, with full support for pointer
    arithmetic into allocations.
  * Fine-grain control over ownership and accessibility of allocations, to
    optimally choose between performance and programmer convenience.
  * A simpler programming model, by automatically migrating some allocations
    between SYCL devices and the host.

To show the differences with the example from <<sec:anatomy>>, the
following source code example shows how shared memory can be used
between host and device:

[source,,linenums]
----
include::{code_dir}/usm_shared.cpp[lines=4..-1]
----

By comparison, the following source code example uses less capable
device memory, which requires an explicit copy between the device and the
host:
[source,,linenums]
----
include::{code_dir}/usm_device.cpp[lines=4..-1]
----


=== Unified addressing

Unified Addressing guarantees that all devices will use a unified address
space. Pointer values in the unified address space will always refer to the
same location in memory. The unified address space encompasses the host and
one or more devices. Note that this does not require addresses in the
unified address space to be accessible on all devices, just that pointer
values will be consistent.


=== Kinds of unified shared memory

<<usm>> is a capability that, when available, provides the ability
to create allocations that are visible to both host and device(s).
USM builds upon Unified Addressing to define a shared address space
where pointer values in this space always refer to the same location
in memory.  USM defines three types of memory allocations 
described in <<table.USM.allocation>>.

[[table.USM.allocation]]
.Type of USM allocations
[width="100%",options="header",cols="20%,80%"]
|====
| USM allocation type | Description
| [code]#host#
    | Allocations in host memory that are accessible by a device
| [code]#device#
    | Allocations in device memory that are *not* accessible by the host
| [code]#shared#
    | Allocations in shared memory that are accessible by both host and
      device
|====

The following [code]#enum# is used to refer to the different types of allocations
inside of a SYCL program:

[source,,linenums]
----
namespace sycl {
namespace usm {

enum class alloc : /* unspecified */ {
  host,
  device,
  shared,
  unknown
};

}
}
----

USM is an optional feature which may not be supported by all devices, and
devices that support USM may not support all types of USM allocation. A SYCL
application can use the [code]#device::has()# function to determine the
level of USM support for a device. See <<table.device.aspect>> in
<<sec:device-aspects>> for more details.

The characteristics of USM allocations are summarized in
<<table.USM.allocation.characteristics>>.

[[table.USM.allocation.characteristics]]
.Characteristics of the different kinds of USM allocation
[width="100%",options="header",cols="16%,16%,16%,16%,16%,16%"]
|====
| Allocation Type | Initial Location | Accessible By | | Migratable To |
.3+| [code]#device# .3+| [code]#device# | [code]#host#      | No            | [code]#host#          | No
|                                         [code]#device#    | Yes           | [code]#device#        | N/A
|                                 Another [code]#device#    | Optional (P2P)| Another [code]#device#| No

.2+| [code]#host#    .2+| [code]#host#  | [code]#host#      | Yes           | [code]#host#          | N/A
|                                     Any [code]#device#    | Yes           | [code]#device#        | No

.3+| [code]#shared#  .3+| Unspecified   | [code]#host#      | Yes           | [code]#host#          | Yes
|                                         [code]#device#    | Yes           | [code]#device#        | Yes
|                                 Another [code]#device#    | Optional  | Another [code]#device#| Optional
|====

Each USM allocation has an associated SYCL <<context>>, and any access to that
memory must use the same context.  Specifically, any <<sycl-kernel-function>>
that dereferences a pointer to a USM allocation must be submitted to a
<<queue>> that was constructed with the same context that was used to allocate
that memory.  The explicit memory operation <<command, commands>> that take USM
pointers have a similar restriction.  (See <<subsec:explicitmemory>> for
details.)  Violations of these requirements result in undefined behavior.

[NOTE]
====
There are no similar restrictions for dereferencing a USM pointer in a
<<host-task>>.  This is legal regardless of which <<queue>> the host task was
submitted to so long as the USM pointer is accessible on the host.
====

Each type of USM allocation has different rules for where that memory is
accessible.  Attempting to dereference a USM pointer on the host or on a device
in violation of these rules results in undefined behavior.  Passing a USM
pointer to one of the explicit memory functions where the pointer is not
accessible to the device generally results in undefined behavior.  See
<<subsec:explicitmemory>> for the exact rules.

Device allocations are used for explicitly managing device memory.
Programmers directly allocate device memory and explicitly copy data
between host memory and a device allocation. Device allocations are obtained
through SYCL device USM allocation routines instead of system allocation
routines like [code]#std::malloc# or {cpp} [code]#new#. Device
allocations are not accessible on the host, but the pointer values remain
consistent on account of Unified Addressing.  The size of device allocations
will be limited by the amount of memory in a device.  Support for device
allocations on a specific device can be queried through
[code]#aspect::usm_device_allocations#.

Device allocations must be explicitly copied between the host and a device.
The member functions to copy and initialize data are found in
<<table.members.queue>> and <<table.members.handler.copy>>, and these
functions may be used on device allocations if a device supports
[code]#aspect::usm_device_allocations#.

Host allocations allow devices to directly read and write host memory
inside of a kernel.  This can be useful for several reasons, such as when the
overhead of moving a small amount of data is not worth paying over the cost of a
remote access or when the size of a data set exceeds the size of a device's memory.
Host allocations must also be obtained using SYCL routines instead
of system allocation routines. While a device may remotely read and
write a host allocation, the allocation does not migrate to the device -
it remains in host memory.  Users should take care to properly synchronize
access to host allocations between host execution and kernels. The total
size of host allocations will be limited by the amount of pinnable-memory
on the host on most systems. Support for host allocations on a specific
device can be queried through [code]#aspect::usm_host_allocations#.
Support for atomic modification of host allocations
on a specific device can be queried through
[code]#aspect::usm_atomic_host_allocations#.

Shared allocations implicitly share data between the host
and devices. Data may move to where it is being used without the programmer
explicitly informing the runtime.  It is up to the runtime and backends
to make sure that a shared allocation is available where it is used.
Shared allocations must also be obtained using SYCL allocation routines
instead of the system allocator.  The maximum size of a shared allocation
on a specific device, and the total size of all shared allocations in a
context, are implementation-defined.
Support for shared allocations on a
specific device can be queried through [code]#aspect::usm_shared_allocations#.

Not all devices may support concurrent access of a shared allocation
with the host.  If a device does not support this,
host execution and device code must take turns accessing the allocation, so
the host must not access a shared allocation while a kernel is executing.
Host access to a shared allocation which is also accessed
by an executing kernel on a device that does not support
concurrent access results in undefined behavior.  If a device does
support concurrent access, both the host and and the device may atomically
modify the same data inside an allocation. Allocations, or pieces of allocations,
are now free to migrate to different devices in the same context
that also support this capability.  Additionally, many devices that support
concurrent access may support a working set of shared allocations
larger than device memory.  
Users may query whether a device supports concurrent access with atomic
modification of shared allocations through the aspect
[code]#aspect::usm_atomic_shared_allocations#.
See <<table.device.aspect>> in <<sec:device-aspects>> for more details.

Performance hints for shared allocations may be specified by the user
by enqueueing [code]#prefetch# operations on a device.  These operations
inform the SYCL runtime that the specified shared allocation is
likely to be accessed on the device in the future, and that it is free
to migrate the allocation to the device. 
More about [code]#prefetch# is found in <<table.members.queue>> and
<<table.members.handler.copy>>.  If a device supports concurrent access to
shared allocations, then [code]#prefetch# operations may be overlapped
with kernel execution.

Additionally, users may use the [code]#mem_advise# member function to annotate
shared allocations with [code]#advice#.  Valid [code]#advice# is defined by the
device and its associated backend.  See <<table.members.queue>> and
<<table.members.handler.copy>> for more information.

In the most capable systems, users do not need to use SYCL USM allocation functions
to create shared allocations. The system allocator ([code]#malloc#/[code]#new#) may
instead be used. Likewise, [code]#std::free# and
[code]#delete# are used instead of [code]#sycl::free#. Note that
host and device allocations are unaffected by this
change and must still be allocated using their respective USM functions in
order to guarantee their behavior.  Users may query the device to determine
if system allocations are supported for use on the device, through
[code]#aspect::usm_system_allocations#.


=== USM allocations

USM provides several allocation functions.  These functions accept a
[code]#property_list# parameter, which is provided for future extensibility.
The <<core-spec>> does not yet define any USM allocation properties.

Some of the allocation functions take an explicit alignment parameter.  Like
[code]#std::aligned_alloc#, these functions return [code]#nullptr# if the
alignment is not supported by the implementation.  Some of the allocation
functions are templated on the allocated type [code]#T# and some are not.  The
following table specifies the alignment guarantees for each category.

[[table.usm.alignment]]
.Alignment guarantees of USM allocation functions
[width="100%",options="header",separator="@",cols="45%,55%"]
|====
@ Category @ Alignment guarantee
a@ No alignment parameter +
   Not templated on allocation type
a@ Pointer is suitably aligned for any object with fundamental alignment whose
   size is less than or equal to the requested allocation size.

a@ No alignment parameter +
   Templated on allocation type [code]#T#
a@ Pointer is suitably aligned for an object of type [code]#T#.

a@ Alignment parameter [code]#alignment# specified +
   Not templated on allocation type
a@ Pointer is suitably aligned for any object with fundamental alignment whose
   size is less than or equal to the requested allocation size or it is aligned
   to the specified [code]#alignment#, whichever is greater.

a@ Alignment parameter [code]#alignment# specified +
   Templated on allocation type [code]#T#
a@ Pointer is suitably aligned for an object of type [code]#T# or it is aligned
   to the specified [code]#alignment#, whichever is greater.
|====

==== {cpp} allocator interface

SYCL defines an allocator class named [code]#usm_allocator# that satisfies the
{cpp} named requirement [code]#Allocator#.  The [code]#AllocKind# template
parameter can be either [code]#usm::alloc::host# or [code]#usm::alloc::shared#,
causing the allocator to make either host USM allocations or shared USM
allocations.

[NOTE]
====
There is no specialization for [code]#usm::alloc::device# because an
[code]#Allocator# is required to allocate memory that is accessible on the
host.
====

The [code]#usm_allocator# class has a template argument [code]#Alignment#,
which specifies the minimum alignment for memory that it allocates.  This
alignment is used even if the allocator is rebound to a different type.  Memory
allocated by this allocator is suitably aligned for objects of its underlying
[code]#value_type# or at the alignment specified by [code]#Alignment#,
whichever is greater.

A synopsis of the [code]#usm_allocator# class is provided below.  The
constructors are listed in <<table.constructors.usm-allocator>>.

[source,,linenums]
----
template <typename T, usm::alloc AllocKind, size_t Alignment = 0>
class usm_allocator {
public:
  using value_type = T;
  using propagate_on_container_copy_assignment = std::true_type;
  using propagate_on_container_move_assignment = std::true_type;
  using propagate_on_container_swap = std::true_type;

public:
  template <typename U> struct rebind {
    typedef usm_allocator<U, AllocKind, Alignment> other;
  };

  usm_allocator() = delete;
  usm_allocator(const context& syclContext,
                const device& syclDevice,
                const property_list& propList = {});
  usm_allocator(const queue& syclQueue,
                const property_list& propList = {});
  usm_allocator(const usm_allocator& other);
  usm_allocator(usm_allocator&&) noexcept;
  usm_allocator& operator=(const usm_allocator&);
  usm_allocator& operator=(usm_allocator&&);

  template <class U>
  usm_allocator(usm_allocator<U, AllocKind, Alignment> const&) noexcept;

  /// Allocate memory
  T* allocate(size_t count);

  /// Deallocate memory
  void deallocate(T* Ptr, size_t count);

  /// Equality Comparison
  ///
  /// Allocators only compare equal if they are of the same USM kind, alignment,
  /// context, and device
  template <class U, usm::alloc AllocKindU, size_t AlignmentU>
  friend bool operator==(const usm_allocator<T, AllocKind, Alignment>&,
                         const usm_allocator<U, AllocKindU, AlignmentU>&);

  /// Inequality Comparison
  /// Allocators only compare unequal if they are not of the same USM kind, alignment,
  /// context, or device
  template <class U, usm::alloc AllocKindU, size_t AlignmentU>
  friend bool operator!=(const usm_allocator<T, AllocKind, Alignment>&,
                         const usm_allocator<U, AllocKindU, AlignmentU>&);
};
----

[[table.constructors.usm-allocator]]
.Constructors of the [code]#usm_allocator# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
usm_allocator(const context& syclContext, const device& syclDevice,
              const property_list& propList = {})
----
a@ Constructs a [code]#usm_allocator# instance that allocates USM for the
provided context and device.

If [code]#AllocKind# is [code]#usm::alloc::host#, this constructor throws a
synchronous [code]#exception# with the [code]#errc::feature_not_supported#
error code if no device in [code]#syclContext# has
[code]#aspect::usm_host_allocations#.  The [code]#syclDevice# is ignored for
this allocation kind.

If [code]#AllocKind# is [code]#usm::alloc::shared#, this constructor throws a
synchronous [code]#exception# with the [code]#errc::feature_not_supported#
error code if the [code]#syclDevice# does not have
[code]#aspect::usm_shared_allocations#.  The [code]#syclDevice# must either be
contained by [code]#syclContext# or it must be a <<descendent-device>> of some
device that is contained by that context, otherwise this constructor throws a
synchronous [code]#exception# with the [code]#errc::invalid# error code.

a@
[source]
----
usm_allocator(const queue& syclQueue, const property_list& propList = {})
----
a@ Simplified constructor form where [code]#syclQueue# provides the
[code]#device# and [code]#context#.

|====

==== Device allocation functions

The functions in <<table.usm.device.allocs>> allocate device USM.  On success,
these functions return a pointer to the newly allocated memory, which must
eventually be deallocated with [code]#sycl::free# in order to avoid a memory
leak.  If there are not enough resources to allocate the requested memory,
these functions return [code]#nullptr#.

When the allocation size is zero bytes ([code]#numBytes# or [code]#count# is
zero), these functions behave in a manor consistent with {cpp}
[code]#std::malloc#.  The value returned is unspecified in this case, and the
returned pointer may not be used to access storage.  If this pointer is not
null, it must be passed to [code]#sycl::free# to avoid a memory leak.

[[table.usm.device.allocs]]
.Device USM Allocation Functions
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Function @ Description
a@
[source]
----
void* sycl::malloc_device(size_t numBytes, const device& syclDevice,
                          const context& syclContext,
                          const property_list& propList = {})
----
a@ Returns a pointer to the newly allocated memory, which is allocated on
[code]#syclDevice#.  The allocation size is specified in bytes.  Throws a
synchronous [code]#exception# with the [code]#errc::feature_not_supported#
error code if the [code]#syclDevice# does not have
[code]#aspect::usm_device_allocations#.  The [code]#syclDevice# must either be
contained by [code]#syclContext# or it must be a <<descendent-device>> of some
device that is contained by that context, otherwise this function throws a
synchronous [code]#exception# with the [code]#errc::invalid# error code.

a@
[source]
----
template <typename T>
T* sycl::malloc_device(size_t count, const device& syclDevice,
                       const context& syclContext,
                       const property_list& propList = {})
----
a@  Returns a pointer to the newly allocated memory, which is allocated on
[code]#syclDevice#.  The allocation size is specified in number of elements of
type [code]#T#.  Throws a synchronous [code]#exception# with the
[code]#errc::feature_not_supported# error code if the [code]#syclDevice#
does not have [code]#aspect::usm_device_allocations#.  The [code]#syclDevice#
must either be contained by [code]#syclContext# or it must be a
<<descendent-device>> of some device that is contained by that context,
otherwise this function throws a synchronous [code]#exception# with the
[code]#errc::invalid# error code.

a@
[source]
----
void* sycl::malloc_device(size_t numBytes, const queue& syclQueue,
                          const property_list& propList = {})
----
a@ Simplified form where [code]#syclQueue# provides the [code]#device# and
[code]#context#.

a@
[source]
----
template <typename T>
T* sycl::malloc_device(size_t count, const queue& syclQueue,
                       const property_list& propList = {})
----
a@ Simplified form where [code]#syclQueue# provides the [code]#device# and
[code]#context#.

a@
[source]
----
void* sycl::aligned_alloc_device(size_t alignment, size_t numBytes,
                                 const device& syclDevice,
                                 const context& syclContext,
                                 const property_list& propList = {})
----
a@ Returns a pointer to the newly allocated memory, which is allocated on
[code]#syclDevice#.  The allocation is specified in bytes and aligned according
to [code]#alignment#.  Throws a synchronous [code]#exception# with the
[code]#errc::feature_not_supported# error code if the [code]#syclDevice# does
not have [code]#aspect::usm_device_allocations#.  The [code]#syclDevice# must
either be contained by [code]#syclContext# or it must be a
<<descendent-device>> of some device that is contained by that context,
otherwise this function throws a synchronous [code]#exception# with the
[code]#errc::invalid# error code.

a@
[source]
----
template <typename T>
T* sycl::aligned_alloc_device(size_t alignment, size_t count,
                              const device& syclDevice,
                              const context& syclContext,
                              const property_list& propList = {})
----
a@ Returns a pointer to the newly allocated memory, which is allocated on
[code]#syclDevice#.  The allocation is specified in number of elements of type
[code]#T# and aligned according to [code]#alignment#.  Throws a synchronous
[code]#exception# with the [code]#errc::feature_not_supported# error code if
the [code]#syclDevice# does not have [code]#aspect::usm_device_allocations#.
The [code]#syclDevice# must either be contained by [code]#syclContext# or it
must be a <<descendent-device>> of some device that is contained by that
context, otherwise this function throws a synchronous [code]#exception# with
the [code]#errc::invalid# error code.

a@
[source]
----
void* sycl::aligned_alloc_device(size_t alignment, size_t numBytes,
                                 const queue& syclQueue,
                                 const property_list& propList = {})
----
a@ Simplified form where [code]#syclQueue# provides the [code]#device# and
[code]#context#.

a@
[source]
----
template <typename T>
T* sycl::aligned_alloc_device(size_t alignment, size_t count,
                              const queue& syclQueue,
                              const property_list& propList = {})
----
a@ Simplified form where [code]#syclQueue# provides the [code]#device# and
[code]#context#.

|====

==== Host allocation functions

The functions in <<table.usm.host.allocs>> allocate host USM.  On success,
these functions return a pointer to the newly allocated memory, which must
eventually be deallocated with [code]#sycl::free# in order to avoid a memory
leak.  If there are not enough resources to allocate the requested memory,
these functions return [code]#nullptr#.

[[table.usm.host.allocs]]
.Host USM Allocation Functions
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Function @ Description
a@
[source]
----
void* sycl::malloc_host(size_t numBytes, const context& syclContext,
                        const property_list& propList = {})
----
a@ Returns a pointer to the newly allocated memory.  This allocation is
specified in bytes.  Throws a synchronous [code]#exception# with the
[code]#errc::feature_not_supported# error code if no device in
[code]#syclContext# has [code]#aspect::usm_host_allocations#.

a@
[source]
----
template <typename T>
T* sycl::malloc_host(size_t count, const context& syclContext,
                     const property_list& propList = {})
----
a@ Returns a pointer to the newly allocated memory.  This allocation is
specified in number of elements of type [code]#T#.  Throws a synchronous
[code]#exception# with the [code]#errc::feature_not_supported# error code if no
device in [code]#syclContext# has [code]#aspect::usm_host_allocations#.

a@
[source]
----
void* sycl::malloc_host(size_t numBytes, const queue& syclQueue,
                        const property_list& propList = {})
----
a@ Simplified form where [code]#syclQueue# provides the [code]#context#.

a@
[source]
----
template <typename T>
T* sycl::malloc_host(size_t count, const queue& syclQueue,
                     const property_list& propList = {})
----
a@ Simplified form where [code]#syclQueue# provides the [code]#context#.

a@
[source]
----
void* sycl::aligned_alloc_host(size_t alignment, size_t numBytes,
                               const context& syclContext,
                               const property_list& propList = {})
----
a@ Returns a pointer to the newly allocated memory.  This allocation is
specified in bytes and aligned according to [code]#alignment#.  Throws a
synchronous [code]#exception# with the [code]#errc::feature_not_supported#
error code if no device in [code]#syclContext# has
[code]#aspect::usm_host_allocations#.

a@
[source]
----
template <typename T>
T* sycl::aligned_alloc_host(size_t alignment, size_t count,
                            const context& syclContext,
                            const property_list& propList = {})
----
a@ Returns a pointer to the newly allocated memory.  This allocation is
specified in elements of type [code]#T# and aligned according to
[code]#alignment#.  Throws a synchronous [code]#exception# with the
[code]#errc::feature_not_supported# error code if no device in
[code]#syclContext# has [code]#aspect::usm_host_allocations#.

a@
[source]
----
void* sycl::aligned_alloc_host(size_t alignment, size_t numBytes,
                               const queue& syclQueue,
                               const property_list& propList = {})
----
a@ Simplified form where [code]#syclQueue# provides the [code]#context#.

a@
[source]
----
template <typename T>
void* sycl::aligned_alloc_host(size_t alignment, size_t count,
                               const queue& syclQueue,
                               const property_list& propList = {})
----
a@ Simplified form where [code]#syclQueue# provides the [code]#context#.

|====

==== Shared allocation functions

The functions in <<table.usm.shared.allocs>> allocate shared USM.  On success,
these functions return a pointer to the newly allocated memory, which must
eventually be deallocated with [code]#sycl::free# in order to avoid a memory
leak.  If there are not enough resources to allocate the requested memory,
these functions return [code]#nullptr#.

[[table.usm.shared.allocs]]
.Shared USM Allocation Functions
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Function @ Description
a@
[source]
----
void* sycl::malloc_shared(size_t numBytes, const device& syclDevice,
                          const context& syclContext,
                          const property_list& propList = {})
----
a@ Returns a pointer to the newly allocated memory, which is associated with
[code]#syclDevice#.  This allocation is specified in bytes.  Throws a
synchronous [code]#exception# with the [code]#errc::feature_not_supported#
error code if the [code]#syclDevice# does not have
[code]#aspect::usm_shared_allocations#.  The [code]#syclDevice# must either be
contained by [code]#syclContext# or it must be a <<descendent-device>> of some
device that is contained by that context, otherwise this function throws a
synchronous [code]#exception# with the [code]#errc::invalid# error code.

a@
[source]
----
template <typename T>
T* sycl::malloc_shared(size_t count, const device& syclDevice,
                       const context& syclContext,
                       const property_list& propList = {})
----
a@ Returns a pointer to the newly allocated memory, which is associated with
[code]#syclDevice#.  This allocation is specified in number of elements of
type [code]#T#.  Throws a synchronous [code]#exception# with the
[code]#errc::feature_not_supported# error code if the [code]#syclDevice# does
not have [code]#aspect::usm_shared_allocations#.  The [code]#syclDevice# must
either be contained by [code]#syclContext# or it must be a
<<descendent-device>> of some device that is contained by that context,
otherwise this function throws a synchronous [code]#exception# with the
[code]#errc::invalid# error code.

a@
[source]
----
void* sycl::malloc_shared(size_t numBytes, const queue& syclQueue,
                          const property_list& propList = {})
----
a@ Simplified form where [code]#syclQueue# provides the [code]#device# and
[code]#context#.

a@
[source]
----
template <typename T>
T* sycl::malloc_shared(size_t count, const queue& syclQueue,
                       const property_list& propList = {})
----
a@ Simplified form where [code]#syclQueue# provides the [code]#device# and
[code]#context#.

a@
[source]
----
void* sycl::aligned_alloc_shared(size_t alignment, size_t numBytes,
                                 const device& syclDevice,
                                 const context& syclContext,
                                 const property_list& propList = {})
----
a@ Returns a pointer to the newly allocated memory, which is associated with
[code]#syclDevice#.  This allocation is specified in bytes and aligned
according to [code]#alignment#.  Throws a synchronous [code]#exception# with
the [code]#errc::feature_not_supported# error code if the [code]#syclDevice#
does not have [code]#aspect::usm_shared_allocations#.  The [code]#syclDevice#
must either be contained by [code]#syclContext# or it must be a
<<descendent-device>> of some device that is contained by that context,
otherwise this function throws a synchronous [code]#exception# with the
[code]#errc::invalid# error code.

a@
[source]
----
template <typename T>
T* sycl::aligned_alloc_shared(size_t alignment, size_t count,
                              const device& syclDevice,
                              const context& syclContext,
                              const property_list& propList = {})
----
a@ Returns a pointer to the newly allocated memory, which is associated with
[code]#syclDevice#.  This allocation is specified in number of elements of
type [code]#T# and aligned aligned according to [code]#alignment#.  Throws a
synchronous [code]#exception# with the [code]#errc::feature_not_supported#
error code if the [code]#syclDevice# does not have
[code]#aspect::usm_shared_allocations#.  The [code]#syclDevice# must either be
contained by [code]#syclContext# or it must be a <<descendent-device>> of some
device that is contained by that context, otherwise this function throws a
synchronous [code]#exception# with the [code]#errc::invalid# error code.

a@
[source]
----
void* sycl::aligned_alloc_shared(size_t alignment, size_t numBytes,
                                 const queue& syclQueue,
                                 const property_list& propList = {})
----
a@ Simplified form where [code]#syclQueue# provides the [code]#device# and
[code]#context#.

a@
[source]
----
template <typename T>
T* sycl::aligned_alloc_shared(size_t alignment, size_t count,
                              const queue& syclQueue,
                              const property_list& propList = {})
----
a@ Simplified form where [code]#syclQueue# provides the [code]#device# and
[code]#context#.

|====

==== Parameterized allocation functions

The functions in <<table.usm.param.allocs>> take a [code]#kind# parameter that
specifies the type of USM to allocate.  When [code]#kind# is
[code]#usm::alloc::device#, then the allocation device must have
[code]#aspect::usm_device_allocations#.  When [code]#kind# is
[code]#usm::alloc::host#, at least one device in the allocation context must
have [code]#aspect::usm_host_allocations#.  When [code]#kind# is
[code]#usm::alloc::shared#, the allocation device must have
[code]#aspect::usm_shared_allocations#.  If these requirements are
violated, the allocation function throws a synchronous [code]#exception# with
the [code]#errc::feature_not_supported# error code.

On success, these functions return a pointer to the newly allocated memory,
which must eventually be deallocated with [code]#sycl::free# in order to avoid
a memory leak.  If there are not enough resources to allocate the requested
memory, these functions return [code]#nullptr#.

[[table.usm.param.allocs]]
.Parameterized USM Allocation Functions
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Function @ Description
a@
[source]
----
void* sycl::malloc(size_t numBytes, const device& syclDevice,
                   const context& syclContext, usm::alloc kind,
                   const property_list& propList = {})
----
a@ Returns a pointer to the newly allocated memory of type [code]#kind#.  This
allocation size is specified in bytes.  The [code]#syclDevice# parameter is
ignored if [code]#kind# is [code]#usm::alloc::host#.  If [code]#kind# is not
[code]#usm::alloc::host#, [code]#syclDevice# must either be contained by
[code]#syclContext# or it must be a <<descendent-device>> of some device that
is contained by that context, otherwise this function throws a synchronous
[code]#exception# with the [code]#errc::invalid# error code.

a@
[source]
----
template <typename T>
T* sycl::malloc(size_t count, const device& syclDevice,
                const context& syclContext, usm::alloc kind,
                const property_list& propList = {})
----
a@ Returns a pointer to the newly allocated memory of type [code]#kind#.  This
allocation size is specified in number of elements of type [code]#T#.  The
[code]#syclDevice# parameter is ignored if [code]#kind# is
[code]#usm::alloc::host#.  If [code]#kind# is not [code]#usm::alloc::host#,
[code]#syclDevice# must either be contained by [code]#syclContext# or it must
be a <<descendent-device>> of some device that is contained by that context,
otherwise this function throws a synchronous [code]#exception# with the
[code]#errc::invalid# error code.

a@
[source]
----
void* sycl::malloc(size_t numBytes, const queue& syclQueue, usm::alloc kind,
                   const property_list& propList = {})
----
a@ Simplified form where [code]#syclQueue# provides the [code]#context# and any
necessary [code]#device#.

a@
[source]
----
template <typename T>
T* sycl::malloc(size_t count, const queue& syclQueue, usm::alloc kind,
                const property_list& propList = {})
----
a@ Simplified form where [code]#syclQueue# provides the [code]#context# and any
necessary [code]#device#.

a@
[source]
----
void* sycl::aligned_alloc(size_t alignment, size_t numBytes,
                          const device& syclDevice, const context& syclContext,
                          usm::alloc kind, const property_list& propList = {})
----
a@ Returns a pointer to the newly allocated memory of type [code]#kind#.  This
allocation is specified in bytes and is aligned according to [code]#alignment#.
The [code]#syclDevice# parameter is ignored if [code]#kind# is
[code]#usm::alloc::host#.  If [code]#kind# is not [code]#usm::alloc::host#,
[code]#syclDevice# must either be contained by [code]#syclContext# or it must
be a <<descendent-device>> of some device that is contained by that context,
otherwise this function throws a synchronous [code]#exception# with the
[code]#errc::invalid# error code.

a@
[source]
----
template <typename T>
T* sycl::aligned_alloc(size_t alignment, size_t count, const device& syclDevice,
                       const context& syclContext, usm::alloc kind,
                       const property_list& propList = {})
----
a@ Returns a pointer to the newly allocated memory of type [code]#kind#.  This
allocation is specified in number of elements of type [code]#T# and is aligned
according to [code]#alignment#.  The [code]#syclDevice# parameter is ignored if
[code]#kind# is [code]#usm::alloc::host#.  If [code]#kind# is not
[code]#usm::alloc::host#, [code]#syclDevice# must either be contained by
[code]#syclContext# or it must be a <<descendent-device>> of some device that
is contained by that context, otherwise this function throws a synchronous
[code]#exception# with the [code]#errc::invalid# error code.

a@
[source]
----
void* sycl::aligned_alloc(size_t alignment, size_t numBytes,
                          const queue& syclQueue, usm::alloc kind,
                          const property_list& propList = {})
----
a@ Simplified form where [code]#syclQueue# provides the [code]#context# and any
necessary [code]#device#.

a@
[source]
----
template <typename T>
T* sycl::aligned_alloc(size_t alignment, size_t count, const queue& syclQueue,
                       usm::alloc kind, const property_list& propList = {})
----
a@ Simplified form where [code]#syclQueue# provides the [code]#context# and any
necessary [code]#device#.

|====


==== Memory deallocation functions

[[table.usm.free]]
.USM Deallocation Functions
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Function @ Description
a@
[source]
----
void sycl::free(void* ptr, const context& syclContext)
----
a@ Frees an allocation.  The memory pointed to by [code]#ptr# must have been
allocated using one of the USM allocation routines.  [code]#syclContext# must
be the same [code]#context# that was used to allocate the memory.  The memory
is freed without waiting for <<command, commands>> operating on it to be
completed.  If <<command, commands>> that use this memory are in-progress or
are enqueued the behavior is undefined.

a@
[source]
----
void sycl::free(void* ptr, const queue& syclQueue)
----
a@ Alternate form where [code]#syclQueue# provides the [code]#context#.

|====

=== Unified shared memory pointer queries

Since USM pointers look like raw {cpp} pointers, users cannot deduce what kind of
USM allocation a given pointer may be from examining its type.  However, two
functions are defined that let users query the type of a USM allocation and, if
applicable, the [code]#device# on which it was allocated.  These query functions
are only supported on the host.

[[table.usm.ptr.query]]
.USM Pointer Query Functions
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Function @ Description
a@
[source]
----
usm::alloc get_pointer_type(const void* ptr, const context& syclContext)
----
a@ Returns the USM allocation type for [code]#ptr# if [code]#ptr# falls inside
a valid USM allocation for the context [code]#syclContext#.  Returns
[code]#usm::alloc::unknown# if [code]#ptr# does not point within a valid USM
allocation from [code]#syclContext#.

a@
[source]
----
device get_pointer_device(const void* ptr, const context& syclContext)
----
a@ Returns the [code]#device# associated with the USM allocation.  If
[code]#ptr# points within a device USM allocation or a shared USM allocation
for the context [code]#syclContext#, returns the same device that was passed
when allocating the memory.  If [code]#ptr# points within a host USM allocation
for the context [code]#syclContext#, returns the first device in
[code]#syclContext#.  Throws a synchronous [code]#exception# with the
[code]#errc::invalid# error code if [code]#ptr# does not point within a valid
USM allocation from [code]#syclContext#.

|====

// %%%%%%%%%%%%%%%%%%%%%%%%%%%% begin expressingParallelism %%%%%%%%%%%%%%%%%%%%%%%%%%%%

[[sec:expr-parall-thro]]
== Expressing parallelism through kernels


[[ranges-identifiers]]
=== Ranges and index space identifiers

The data parallelism of the SYCL kernel execution model requires
instantiation of a parallel execution over a
range of iteration space coordinates. To achieve this, SYCL exposes types
to define the range of execution and to identify a given execution
instance's point in the iteration space.

The following types are defined: [code]#range#,
[code]#nd_range#, [code]#id#, [code]#item#, [code]#h_item#,
[code]#nd_item# and [code]#group#.

When constructing multi-dimensional ids or ranges from integers, the elements
are written such that the right-most element varies fastest in a linearization
of the multi-dimensional space (see <<sec:multi-dim-linearization>>).


[[table.id.summary]]
.Summary of types used to identify points in an index space, and ranges over which those points can vary
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Type @ Description
a@
[source]
----
id
----
   a@ A point within a range

a@
[source]
----
range
----
   a@ Bounds over which an [code]#id# may vary

a@
[source]
----
item
----
   a@ Pairing of an [code]#id# (specific point) and the
      [code]#range# that it is bounded by

a@
[source]
----
nd_range
----
   a@ Encapsulates both global and local (work-group size)
      [code]#ranges# over which work-item [code]#ids# will
      vary

a@
[source]
----
nd_item
----
   a@ Encapsulates two [code]#items#, one for global
      [code]#id# and [code]#range#, and one for local [code]#id#
      and [code]#range#

a@
[source]
----
h_item
----
   a@ Index point queries within hierarchical parallelism
      ([code]#parallel_for_work_item)#. Encapsulates physical global and
      local [code]#ids# and [code]#ranges#, as well as a
      logical local [code]#id# and [code]#range# defined by hierarchical
      parallelism

a@
[source]
----
group
----
   a@ Work-group queries within hierarchical parallelism
      ([code]#parallel_for_work_group)#, and exposes the
      [code]#parallel_for_work_item# construct that identifies code to be
      executed by each work-item. Encapsulates work-group [code]#ids#
      and [code]#ranges#

|====



[[range-class]]
==== [code]#range# class

[code]#range<int _Dimensions_>#
is a 1D, 2D or 3D vector that defines
the iteration domain of either a single work-group in a parallel
dispatch, or the overall Dimensions of the dispatch. It can be
constructed from integers.

The SYCL [code]#range# class template provides the common by-value
semantics (see <<sec:byval-semantics>>).

A synopsis of the SYCL [code]#range# class is provided below. The
constructors, member functions and non-member functions of the SYCL
[code]#range# class are listed in
<<table.constructors.range>>, <<table.members.range>> and
<<table.functions.range>> respectively. The additional common
special member functions and common member functions are listed in
<<sec:byval-semantics>> in
<<table.specialmembers.common.byval>> and
<<table.hiddenfriends.common.byval>> respectively.

[source,,linenums]
----
include::{header_dir}/range.h[lines=4..-1]
----


[[table.constructors.range]]
.Constructors of the [code]#range# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
range(size_t dim0)
----
   a@ Construct a 1D range with value dim0.
      Only valid when the template parameter [code]#Dimensions# is equal
      to 1.

a@
[source]
----
range(size_t dim0, size_t dim1)
----
   a@ Construct a 2D range with values dim0 and dim1.
      Only valid when the template parameter [code]#Dimensions# is equal
      to 2.

a@
[source]
----
range(size_t dim0, size_t dim1, size_t dim2)
----
   a@ Construct a 3D range with values dim0, dim1 and dim2.
      Only valid when the template parameter [code]#Dimensions# is equal
      to 3.

|====



[[table.members.range]]
.Member functions of the [code]#range# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
size_t get(int dimension) const
----
   a@ Return the value of the specified dimension of the
      [code]#range#.

a@
[source]
----
size_t& operator[](int dimension)
----
   a@ Return the l-value of the specified dimension of the
      [code]#range#.

a@
[source]
----
size_t operator[](int dimension) const
----
   a@ Return the value of the specified dimension of the
      [code]#range#.

a@
[source]
----
size_t size() const
----
   a@ Return the size of the range computed as dimension0*...*dimensionN.

|====



[[table.functions.range]]
.Hidden friend functions of the SYCL [code]#range# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Hidden friend function @ Description
a@
[source]
----
range operatorOP(const range& lhs, const range& rhs)
----
   a@ Where [code]#OP# is: [code]#pass:[+]#, [code]#-#, [code]#*#,
      [code]#/#, [code]#%#, [code]#<<#, [code]#>>#,
      [code]#&#, [code]#|#, [code]#^#,
      [code]#&&#, [code]#||#,
      [code]#<#, [code]#>#, [code]#+<=+#,
      [code]#>=#.

Constructs and returns a new instance of the SYCL [code]#range# class
template with the same dimensionality as [code]#lhs# [code]#range#,
where each element of the new SYCL [code]#range# instance is the
result of an element-wise [code]#OP# operator between each element of
[code]#lhs# [code]#range# and each element of the [code]#rhs#
[code]#range#. If the operator returns a [code]#bool#, the result
is the cast to [code]#size_t#.

a@
[source]
----
range operatorOP(const range& lhs, const size_t& rhs)
----
   a@ Where [code]#OP# is: [code]#pass:[+]#, [code]#-#, [code]#*#,
      [code]#/#, [code]#%#, [code]#<<#, [code]#>>#,
      [code]#&#, [code]#|#, [code]#^#,
      [code]#&&#, [code]#||#,
      [code]#<#, [code]#>#, [code]#+<=+#,
      [code]#>=#.

Constructs and returns a new instance of the SYCL [code]#range# class
template with the same dimensionality as [code]#lhs# [code]#range#,
where each element of the new SYCL [code]#range# instance is the result
of an element-wise [code]#OP# operator between each element of this
SYCL [code]#range# and the [code]#rhs# [code]#size_t#. If
the operator returns a [code]#bool#, the result is the cast to
[code]#size_t#.

a@
[source]
----
range& operatorOP(range& lhs, const range& rhs)
----
   a@ Where [code]#OP# is: [code]#pass:[+=]#, [code]#-=#,[code]#*=#, [code]#/=#, [code]#%=#, [code]#+<<=+#, [code]#>>=#, [code]#&=#, [code]#|=#, [code]#^=#.

Assigns each element of [code]#lhs# [code]#range# instance with the
result of an element-wise [code]#OP# operator between each element
of [code]#lhs# [code]#range# and each element of the [code]#rhs#
[code]#range# and returns [code]#lhs# [code]#range#. If the operator returns a [code]#bool#, the result is the cast
to [code]#size_t#.

a@
[source]
----
range& operatorOP(range& lhs, const size_t& rhs)
----
   a@ Where [code]#OP# is: [code]#pass:[+=]#, [code]#-=#,[code]#*=#, [code]#/=#, [code]#%=#, [code]#+<<=+#, [code]#>>=#, [code]#&=#, [code]#|=#, [code]#^=#.

Assigns each element of [code]#lhs# [code]#range# instance with the
result of an element-wise [code]#OP# operator between each element
of [code]#lhs# [code]#range# and the [code]#rhs# [code]#size_t# and returns [code]#lhs# [code]#range#. If the
operator returns a [code]#bool#, the result is the cast to
[code]#size_t#.

a@
[source]
----
range operatorOP(const size_t& lhs, const range& rhs)
----
   a@ Where [code]#OP# is: [code]#pass:[+]#, [code]#-#, [code]#*#,
      [code]#/#, [code]#%#, [code]#<<#, [code]#>>#,
      [code]#&#, [code]#|#, [code]#^#,
      [code]#&&#, [code]#||#,
      [code]#<#, [code]#>#, [code]#+<=+#,
      [code]#>=#.

Constructs and returns a new instance of the SYCL [code]#range# class
template with the same dimensionality as the [code]#rhs# SYCL
[code]#range#, where each element of the new SYCL [code]#range#
instance is the result of an element-wise [code]#OP# operator between
the [code]#lhs# [code]#size_t# and each element of the
[code]#rhs# SYCL [code]#range#. If the operator returns a
[code]#bool#, the result is the cast to [code]#size_t#.

a@
[source]
----
range operatorOP(const range& rhs)
----
   a@ Where [code]#OP# is: unary [code]#pass:[+]#, unary [code]#-#.

Constructs and returns a new instance of the SYCL [code]#range# class
template with the same dimensionality as the [code]#rhs# SYCL
[code]#range#, where each element of the new SYCL [code]#range#
instance is the result of an element-wise [code]#OP# operator on
the [code]#rhs# SYCL [code]#range#.

a@
[source]
----
range& operatorOP(range& rhs)
----
   a@ Where [code]#OP# is: prefix [code]#pass:[++]#, prefix [code]#--#.

Assigns each element of the [code]#rhs# [code]#range# instance with the result
of an element-wise [code]#OP# operator on each element of the [code]#rhs#
[code]#range# and returns this [code]#range#.

a@
[source]
----
range operatorOP(range& lhs, int)
----
   a@ Where [code]#OP# is: postfix [code]#pass:[++]#, postfix [code]#--#.

Make a copy of the [code]#lhs# [code]#range#.
Assigns each element of the [code]#lhs# [code]#range# instance with the result
of an element-wise [code]#OP# operator on each element of the [code]#lhs#
[code]#range#.
Then return the initial copy of the [code]#range#.

|====




[[subsubsec:nd-range-class]]
==== [code]#nd_range# class

// Interface for class: nd_range
[source,,linenums]
----
include::{header_dir}/ndRange.h[lines=4..-1]
----

[code]#nd_range<int _Dimensions_>#
defines the iteration domain of both
the work-groups and the overall dispatch. To define this the
[code]#nd_range# comprises two ranges: the whole range over which
the kernel is to be executed, and the range of each work
group.

The SYCL [code]#nd_range# class template provides the common by-value
semantics (see <<sec:byval-semantics>>).

A synopsis of the SYCL [code]#nd_range# class is provided below. The
constructors and member functions of the SYCL [code]#nd_range# class
are listed in <<table.constructors.ndrange>> and
<<table.members.ndrange>> respectively. The additional common special
member functions and common member functions are listed in
<<sec:byval-semantics>> in <<table.specialmembers.common.byval>>
and <<table.hiddenfriends.common.byval>> respectively.


[[table.constructors.ndrange]]
.Constructors of the [code]#nd_range# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
nd_range<Dimensions>(
range<Dimensions> globalSize,
    range<Dimensions> localSize)
    id<Dimensions> offset = id<Dimensions>())
----
   a@ Construct an [code]#nd_range# from the local and global
      constituent ranges. Supplying the option offset is
      deprecated in SYCL 2020.
      If the offset is not provided it will default to no offset.

|====



[[table.members.ndrange]]
.Member functions for the [code]#nd_range# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
range<Dimensions> get_global_range() const
----
   a@ Return the constituent global range.

a@
[source]
----
range<Dimensions> get_local_range() const
----
   a@ Return the constituent local range.

a@
[source]
----
range<Dimensions> get_group_range() const
----
   a@ Return a range representing the number of groups in each
      dimension.  This range would result from
      [code]#globalSize/localSize# as provided on construction.

a@
[source]
----
id<Dimensions> get_offset() const
    // Deprecated in SYCL 2020.
----
   a@ Deprecated in SYCL 2020.
   Return the constituent offset.

|====



[[id-class]]
==== [code]#id# class

[code]#id<int Dimensions># is a vector of Dimensions that is used to
represent an <<id>> into a global or local
[code]#range#. It can be used as an index in an accessor of the
same rank. The subscript operator ([code]#operator[](n)#) returns the component
[code]#n# as a [code]#size_t#.

The SYCL [code]#id# class template provides the common by-value semantics
(see <<sec:byval-semantics>>).

A synopsis of the SYCL [code]#id# class is provided below. The
constructors, member functions and non-member functions of the SYCL
[code]#id# class are listed in <<table.constructors.id>>,
<<table.members.id>> and <<table.functions.id>> respectively. The
additional common special member functions and common member functions are
listed in <<sec:byval-semantics>> in
<<table.specialmembers.common.byval>> and
<<table.hiddenfriends.common.byval>> respectively.

[source,,linenums]
----
include::{header_dir}/id.h[lines=4..-1]
----


[[table.constructors.id]]
.Constructors of the [code]#id# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
id()
----
   a@ Construct a SYCL [code]#id# with the value [code]#0# for each dimension.

a@
[source]
----
id(size_t dim0)
----
   a@ Construct a 1D [code]#id# with value dim0.
      Only valid when the template parameter [code]#Dimensions# is equal
      to 1.

a@
[source]
----
id(size_t dim0, size_t dim1)
----
   a@ Construct a 2D [code]#id# with values dim0, dim1.
      Only valid when the template parameter [code]#Dimensions# is equal
      to 2.

a@
[source]
----
id(size_t dim0, size_t dim1, size_t dim2)
----
   a@ Construct a 3D [code]#id# with values dim0, dim1, dim2.
      Only valid when the template parameter [code]#Dimensions# is equal
      to 3.

a@
[source]
----
id(const range<Dimensions>& range)
----
   a@ Construct an [code]#id# from the dimensions of [code]#range#.

a@
[source]
----
id(const item<Dimensions>& item)
----
   a@ Construct an [code]#id# from [code]#item.get_id()#.

|====



[[table.members.id]]
.Member functions of the [code]#id# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
size_t get(int dimension) const
----
   a@ Return the value of the [code]#id# for dimension
      [code]#Dimension#.

a@
[source]
----
size_t& operator[](int dimension)
----
   a@ Return a reference to the requested dimension of the [code]#id#
      object.

a@
[source]
----
size_t operator[](int dimension) const
----
   a@ Return the value of the requested dimension of the [code]#id#
      object.

a@
[source]
----
operator size_t() const
----
   a@ Available only when: [code]#Dimensions == 1#

Returns the same value as [code]#get(0)#.

|====

[[table.functions.id]]
.Hidden friend functions of the [code]#id# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Hidden friend function @ Description
a@
[source]
----
id operatorOP(const id& lhs, const id& rhs)
----
   a@ Where [code]#OP# is: [code]#pass:[+]#, [code]#-#, [code]#*#, [code]#/#, [code]#%#, [code]#<<#, [code]#>>#,
      [code]#&#, [code]#|#, [code]#^#, [code]#&&#, [code]#||#, [code]#<#, [code]#>#, [code]#+<=+#, [code]#>=#.

Constructs and returns a new instance of the SYCL [code]#id# class
template with the same dimensionality as [code]#lhs# [code]#id#, where
each element of the new SYCL [code]#id# instance is the result of an
element-wise [code]#OP# operator between each element of [code]#lhs#
[code]#id# and each element of the [code]#rhs# [code]#id#.
If the operator returns a [code]#bool# the result is the cast to
[code]#size_t#.

a@
[source]
----
id operatorOP(const id& lhs, const size_t& rhs)
----
   a@ Where [code]#OP# is: [code]#pass:[+]#, [code]#-#, [code]#*#, [code]#/#, [code]#%#, [code]#<<#, [code]#>>#,
      [code]#&#, [code]#|#, [code]#^#, [code]#&&#, [code]#||#, [code]#<#, [code]#>#, [code]#+<=+#, [code]#>=#.

Constructs and returns a new instance of the SYCL [code]#id# class
template with the same dimensionality as [code]#lhs# [code]#id#, where
each element of the new SYCL [code]#id# instance is the result of an
element-wise [code]#OP# operator between each element of [code]#lhs#
[code]#id# and the [code]#rhs# [code]#size_t#. If the
operator returns a [code]#bool# the result is the cast to
[code]#size_t#.

a@
[source]
----
id& operatorOP(id& lhs, const id& rhs)
----
   a@ Where [code]#OP# is: [code]#pass:[+=]#, [code]#-=#,[code]#*=#, [code]#/=#, [code]#%=#,
      [code]#+<<=+#, [code]#>>=#, [code]#&=#, [code]#|=#, [code]#^=#.

Assigns each element of [code]#lhs# [code]#id# instance with the
result of an element-wise [code]#OP# operator between each element
of [code]#lhs# [code]#id# and each element of the [code]#rhs#
[code]#id# and returns [code]#lhs# [code]#id#. If
the operator returns a [code]#bool# the result is the cast to
[code]#size_t#.

a@
[source]
----
id& operatorOP(id& lhs, const size_t& rhs)
----
   a@ Where [code]#OP# is: [code]#pass:[+=]#, [code]#-=#,[code]#*=#, [code]#/=#, [code]#%=#,
      [code]#+<<=+#, [code]#>>=#, [code]#&=#, [code]#|=#, [code]#^=#.

Assigns each element of [code]#lhs# [code]#id# instance with the
result of an element-wise [code]#OP# operator between each element
of [code]#lhs# [code]#id# and the [code]#rhs# [code]#size_t#
and returns [code]#lhs# [code]#id#. If the operator
returns a [code]#bool# the result is the cast to [code]#size_t#.

a@
[source]
----
id operatorOP(const size_t& lhs, const id& rhs)
----
   a@ Where [code]#OP# is: [code]#pass:[+]#, [code]#-#, [code]#*#, [code]#/#, [code]#%#, [code]#<<#, [code]#>>#,
      [code]#&#, [code]#|#, [code]#^#, [code]#&&#, [code]#||#, [code]#<#, [code]#>#, [code]#+<=+#, [code]#>=#.

Constructs and returns a new instance of the SYCL [code]#id# class
template with the same dimensionality as the [code]#rhs# SYCL
[code]#id#, where each element of the new SYCL [code]#id#
instance is the result of an element-wise [code]#OP# operator between
the [code]#lhs# [code]#size_t# and each element of the
[code]#rhs# SYCL [code]#id#. If the operator returns a
[code]#bool# the result is the cast to [code]#size_t#.

a@
[source]
----
id operatorOP(const id& rhs)
----
   a@ Where [code]#OP# is: unary [code]#pass:[+]#, unary [code]#-#.

Constructs and returns a new instance of the SYCL [code]#id# class
template with the same dimensionality as the [code]#rhs# SYCL
[code]#id#, where each element of the new SYCL [code]#id#
instance is the result of an element-wise [code]#OP# operator on
the [code]#rhs# SYCL [code]#id#.

a@
[source]
----
id& operatorOP(id& rhs)
----
   a@ Where [code]#OP# is: prefix [code]#pass:[++]#, prefix [code]#--#.

Assigns each element of the [code]#rhs# [code]#id# instance with the result
of an element-wise [code]#OP# operator on each element of the [code]#rhs#
[code]#id# and returns this [code]#id#.

a@
[source]
----
id operatorOP(id& lhs, int)
----
   a@ Where [code]#OP# is: postfix [code]#pass:[++]#, postfix [code]#--#.

Make a copy of the [code]#lhs# [code]#id#.
Assigns each element of the [code]#lhs# [code]#id# instance with the result
of an element-wise [code]#OP# operator on each element of the [code]#lhs#
[code]#id#.
Then return the initial copy of the [code]#id#.

|====



[[subsec:item.class]]
==== [code]#item# class

<<item>> identifies an instance of the function object
executing at each point in a [code]#range#. It is passed to a
[code]#parallel_for# call or returned by member functions of [code]#h_item#.
It encapsulates enough information to identify the work-item's range
of possible values and its ID in that range. It can optionally carry the offset of the
range if provided to the [code]#parallel_for#; note this is deprecated in SYCL 2020.
Instances of the [code]#item# class are
not user-constructible and are passed by the runtime to each instance
of the function object.

The SYCL [code]#item# class template provides the common by-value semantics
(see <<sec:byval-semantics>>).

A synopsis of the SYCL [code]#item# class is provided below. The member
functions of the SYCL [code]#item# class are listed in
<<table.members.id>>. The additional common special member functions
and common member functions are listed in <<sec:byval-semantics>> in
<<table.specialmembers.common.byval>> and
<<table.hiddenfriends.common.byval>> respectively.

// Interface for class: item
[source,,linenums]
----
include::{header_dir}/item.h[lines=4..-1]
----


[[table.members.item]]
.Member functions for the [code]#item# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
id<Dimensions> get_id() const
----
   a@ Return the constituent [code]#id#
      representing the work-item's position in the iteration space.

a@
[source]
----
size_t get_id(int dimension) const
----
   a@ Return the same value as [code]#get_id()[dimension]#.

a@
[source]
----
size_t operator[](int dimension) const
----
   a@ Return the same value as [code]#get_id(dimension)#.

a@
[source]
----
range<Dimensions> get_range() const
----
   a@ Returns a [code]#range# representing the dimensions of the
      range of possible values of the [code]#item#.

a@
[source]
----
size_t get_range(int dimension) const
----
   a@ Return the same value as [code]#get_range().get(dimension)#.

a@
[source]
----
id<Dimensions> get_offset() const
    // Deprecated in SYCL 2020.
----
   a@ Deprecated in SYCL 2020.
      Returns an [code]#id# representing the _n_-dimensional offset
      provided to the [code]#parallel_for# and that is added by
      the runtime to the global-ID of each work-item, if this item
      represents a global range. For an item converted from an item with
      no offset this will always return an [code]#id# of all 0 values.

This member function is only available if [code]#WithOffset# is [code]#true#.

a@
[source]
----
operator item<Dimensions, true>() const
----
   a@ Available only when: [code]#WithOffset == false#

Returns an [code]#item# representing the same information as the object holds
but also includes the offset set to 0. This conversion allow users to seamlessly
write code that assumes an offset and still provides an offset-less [code]#item#.

a@
[source]
----
operator size_t() const
----
   a@ Available only when: [code]#Dimensions == 1#

Returns the same value as [code]#get_id(0)#.

a@
[source]
----
size_t get_linear_id() const
----
   a@ Return the id as a linear index value. Calculating a linear
      address from the multi-dimensional index follows
      <<sec:multi-dim-linearization>>.

|====



[[nditem-class]]
==== [code]#nd_item# class

[code]#nd_item<int Dimensions># identifies an instance of the function object
executing at each point in an [code]#nd_range<int Dimensions># passed to a
[code]#parallel_for# call. It encapsulates enough
information to identify the <<work-item>>'s local and global <<id,ids>>, the
<<work-group-id>> and also provides access to the [code]#group# and
[code]#sub_group# classes.  Instances of the [code]#nd_item<int Dimensions># class are not user-constructible and are passed by the runtime to
each instance of the function object.

The SYCL [code]#nd_item# class template provides the common by-value
semantics (see <<sec:byval-semantics>>).

A synopsis of the SYCL [code]#nd_item# class is provided below. The
member functions of the SYCL [code]#nd_item# class are listed in
<<table.members.nditem>>. The additional common special member
functions and common member functions are listed in
<<sec:byval-semantics>> in <<table.specialmembers.common.byval>>
and <<table.hiddenfriends.common.byval>> respectively.

% interface for nd_item class
[source,,linenums]
----
include::{header_dir}/nditem.h[lines=4..-1]
----


[[table.members.nditem]]
.Member functions for the [code]#nd_item# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
id<Dimensions> get_global_id() const
----
   a@ Return the constituent <<global-id>> representing the
      work-item's position in the global iteration space.

a@
[source]
----
size_t get_global_id(int dimension) const
----
   a@ Return the constituent element of the <<global-id>>
      representing the work-item's position in the <<nd-range>>
      in the given [code]#Dimension#.

a@
[source]
----
size_t get_global_linear_id() const
----
   a@ Return the constituent <<global-id>> as a linear index value, representing the work-item's
   position in the global iteration space.  The linear address is calculated from the
   multi-dimensional index by first subtracting the offset and then following
   <<sec:multi-dim-linearization>>.

a@
[source]
----
id<Dimensions> get_local_id() const
----
   a@ Return the constituent <<local-id>> representing the
      work-item's position within the current <<work-group>>.

a@
[source]
----
size_t get_local_id(int dimension) const
----
   a@ Return the constituent element of the <<local-id>> representing the
      work-item's position within the current <<work-group>> in the given
      [code]#Dimension#.

a@
[source]
----
size_t get_local_linear_id() const
----
   a@ Return the constituent <<local-id>> as a linear index value, representing the work-item's
   position within the current <<work-group>>.  The linear address is calculated from the
   multi-dimensional index following <<sec:multi-dim-linearization>>.

a@
[source]
----
group<Dimensions> get_group() const
----
   a@ Return the constituent <<work-group>>, [code]#group#
      representing the <<work-group>>'s position within the overall
      <<nd-range>>.

a@
[source]
----
sub_group get_sub_group() const
----
   a@ Return a [code]#sub_group# representing the <<sub-group>> to which the work-item belongs.

a@
[source]
----
size_t get_group(int dimension) const
----
   a@ Return the constituent element of the group [code]#id# representing
      the work-group's position within the overall [code]#nd_range# in the
      given [code]#Dimension#.

a@
[source]
----
size_t get_group_linear_id() const
----
   a@ Return the group id as a linear index value. Calculating a linear address
      from a multi-dimensional index follows <<sec:multi-dim-linearization>>.

a@
[source]
----
range<Dimensions> get_group_range() const
----
   a@ Returns the number of <<work-group,work-groups>> in the iteration space.

a@
[source]
----
size_t get_group_range(int dimension) const
----
   a@ Return the number of <<work-group,work-groups>> for [code]#Dimension# in the
      iteration space.

a@
[source]
----
range<Dimensions> get_global_range() const
----
   a@ Returns a [code]#range# representing the dimensions of the
      global iteration space.

a@
[source]
----
size_t get_global_range(int dimension) const
----
   a@ Return the same value as [code]#get_global_range().get(dimension)#.

a@
[source]
----
range<Dimensions> get_local_range() const
----
   a@ Returns a [code]#range# representing the dimensions of the current
      work-group.

a@
[source]
----
size_t get_local_range(int dimension) const
----
   a@ Return the same value as [code]#get_local_range().get(dimension)#.

a@
[source]
----
id<Dimensions> get_offset() const
    // Deprecated in SYCL 2020.
----
   a@ Deprecated in SYCL 2020.
      Returns an <<id>> representing the n-dimensional offset
      provided to the constructor of the [code]#nd_range# and that
      is added by the runtime to the <<global-id>> of each <<work-item>>.

a@
[source]
----
nd_range<Dimensions> get_nd_range() const
----
   a@ Returns the [code]#nd_range# of the current execution.

a@
[source]
----
template <typename DataT>
device_event async_work_group_copy(local_ptr<DataT> dest,
                                   global_ptr<DataT> src,
                                   size_t numElements) const
----
   a@ Deprecated in SYCL 2020.
      Has the same effect as the overload taking [code]#decorated_local_ptr#
      and [code]#decorated_global_ptr# except that the dest and src parameters
      are [code]#multi_ptr#s with [code]#access::decorated::legacy#.

a@
[source]
----
template <typename DataT>
device_event async_work_group_copy(global_ptr<DataT> dest,
                                   local_ptr<DataT> src,
                                   size_t numElements) const
----
   a@ Deprecated in SYCL 2020.
      Has the same effect as the overload taking [code]#decorated_local_ptr#
      and [code]#decorated_global_ptr# except that the dest and src parameters
      are [code]#multi_ptr#s with [code]#access::decorated::legacy#.

a@
[source]
----
template <typename DataT>
device_event async_work_group_copy(local_ptr<DataT> dest,
                                   global_ptr<DataT> src,
                                   size_t numElements, size_t srcStride) const
----
   a@ Deprecated in SYCL 2020.
      Has the same effect as the overload taking [code]#decorated_local_ptr#
      and [code]#decorated_global_ptr# except that the dest and src parameters
      are [code]#multi_ptr#s with [code]#access::decorated::legacy#.

a@
[source]
----
template <typename DataT>
device_event async_work_group_copy(global_ptr<DataT> dest,
                                   local_ptr<DataT> src,
                                   size_t numElements, size_t destStride) const
----
    a@ Deprecated in SYCL 2020.
      Has the same effect as the overload taking [code]#decorated_local_ptr#
      and [code]#decorated_global_ptr# except that the dest and src parameters
      are [code]#multi_ptr#s with [code]#access::decorated::legacy#.

a@
[source]
----
template <typename DestDataT, typename SrcDataT>
device_event async_work_group_copy(decorated_local_ptr<DestDataT> dest,
                                   decorated_global_ptr<SrcDataT> src,
                                   size_t numElements) const
----
   a@ Available only when: (std::is_same_v<DestDataT,
        std::remove_const_t<SrcDataT>> == true)

Permitted types for [code]#DataT# are all scalar and vector types.
Asynchronously copies a number of elements specified by [code]#numElements#
from the source pointer [code]#src# to destination pointer [code]#dest# and
returns a SYCL [code]#device_event# which can be used to wait on the completion
of the copy.

a@
[source]
----
template <typename DestDataT, typename SrcDataT>
device_event async_work_group_copy(decorated_global_ptr<DestDataT> dest,
                                   decorated_local_ptr<SrcDataT> src,
                                   size_t numElements) const
----
   a@ Available only when: (std::is_same_v<DestDataT,
        std::remove_const_t<SrcDataT>> == true)

Permitted types for [code]#DataT# are all scalar and vector types.
Asynchronously copies a number of elements specified by [code]#numElements#
from the source pointer [code]#src# to destination pointer [code]#dest# and
returns a SYCL [code]#device_event# which can be used to wait on the
completion of the copy.

a@
[source]
----
template <typename DestDataT, typename SrcDataT>
device_event async_work_group_copy(decorated_local_ptr<DestDataT> dest,
                                   decorated_global_ptr<SrcDataT> src,
                                   size_t numElements, size_t srcStride) const
----
   a@ Available only when: (std::is_same_v<DestDataT,
        std::remove_const_t<SrcDataT>> == true)

Permitted types for [code]#DataT# are all scalar and vector types.
Asynchronously copies a number of elements specified by [code]#numElements#
from the source pointer [code]#src# to destination pointer [code]#dest# with a
source stride specified by [code]#srcStride# and returns a SYCL
[code]#device_event# which can be used to wait on the completion of the copy.

a@
[source]
----
template <typename DestDataT, SrcDataT>
device_event async_work_group_copy(decorated_global_ptr<DestDataT> dest,
                                   decorated_local_ptr<SrcDataT> src,
                                   size_t numElements, size_t destStride) const
----
    a@ Available only when: (std::is_same_v<DestDataT,
        std::remove_const_t<SrcDataT>> == true)

Permitted types for [code]#DataT# are all scalar and vector types.
Asynchronously copies a number of elements specified by [code]#numElements#
from the source pointer [code]#src# to destination pointer [code]#dest# with a
destination stride specified by [code]#destStride# and returns a SYCL
[code]#device_event# which can be used to wait on the completion of the copy.

a@
[source]
----
template <typename... EventTN> void wait_for(EventTN... events) const
----
   a@ Permitted type for [code]#EventTN# is [code]#device_event#.
      Waits for the asynchronous operations associated with each [code]#device_event# to complete.

|====



[[hitem-class]]
==== [code]#h_item# class

[code]#h_item<int Dimensions># identifies an instance of a
[code]#group::parallel_for_work_item# function object executing at each
point in a local [code]#range<int Dimensions># passed to a
[code]#parallel_for_work_item# call or to the corresponding
[code]#parallel_for_work_group# call if no [code]#range# is passed
to the [code]#parallel_for_work_item# call. It encapsulates enough
information to identify the <<work-item>>'s local and global <<item,items>>
according to the information given to [code]#parallel_for_work_group#
(physical ids) as well as the <<work-item>>'s logical local <<item,items>>
in the logical local range. All returned <<item,items>> objects are
offset-less. Instances of the [code]#h_item<int Dimensions># class are
not user-constructible and are passed by the runtime to each instance of the
function object.

The SYCL [code]#h_item# class template provides the common by-value
semantics (see <<sec:byval-semantics>>).

A synopsis of the SYCL [code]#h_item# class is provided below. The
member functions of the SYCL [code]#h_item# class are listed in
<<table.members.hitem>>. The additional common special member
functions and common member functions are listed in
<<sec:byval-semantics>> in <<table.specialmembers.common.byval>>
and <<table.hiddenfriends.common.byval>> respectively.

[source,,linenums]
----
include::{header_dir}/hitem.h[lines=4..-1]
----


[[table.members.hitem]]
.Member functions for the [code]#h_item# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
item<Dimensions, false> get_global() const
----
   a@ Return the constituent global <<item>> representing the
      work-item's position in the global iteration space as provided upon kernel invocation.

a@
[source]
----
item<Dimensions, false> get_local() const
----
   a@ Return the same value as [code]#get_logical_local()#.

a@
[source]
----
item<Dimensions, false> get_logical_local() const
----
   a@ Return the constituent element of the logical local <<item>>
      work-item's position in the local iteration space as provided upon the invocation of the
      [code]#group::parallel_for_work_item#.

If the [code]#group::parallel_for_work_item# was called without any logical local range
then the member function returns the physical local <<item>>.

A physical id can be computed from a logical id by getting the remainder of the integer division
of the logical id and the physical range:
[code]#get_logical_local().get() % get_physical_local.get_range() == get_physical_local().get()#.

a@
[source]
----
item<Dimensions, false> get_physical_local() const
----
   a@ Return the constituent element of the physical local <<item>>
      work-item's position in the local iteration space as provided (by the user or the runtime)
      upon the kernel invocation.

a@
[source]
----
range<Dimensions> get_global_range() const
----
   a@ Return the same value as [code]#get_global().get_range()#

a@
[source]
----
size_t get_global_range(int dimension) const
----
   a@ Return the same value as [code]#get_global().get_range(dimension)#

a@
[source]
----
id<Dimensions> get_global_id() const
----
   a@ Return the same value as [code]#get_global().get_id()#

a@
[source]
----
size_t get_global_id(int dimension) const
----
   a@ Return the same value as [code]#get_global().get_id(dimension)#

a@
[source]
----
range<Dimensions> get_local_range() const
----
   a@ Return the same value as [code]#get_local().get_range()#

a@
[source]
----
size_t get_local_range(int dimension) const
----
   a@ Return the same value as [code]#get_local().get_range(dimension)#

a@
[source]
----
id<Dimensions> get_local_id() const
----
   a@ Return the same value as [code]#get_local().get_id()#

a@
[source]
----
size_t get_local_id(int dimension) const
----
   a@ Return the same value as [code]#get_local().get_id(dimension)#

a@
[source]
----
range<Dimensions> get_logical_local_range() const
----
   a@ Return the same value as [code]#get_logical_local().get_range()#

a@
[source]
----
size_t get_logical_local_range(int dimension) const
----
   a@ Return the same value as [code]#get_logical_local().get_range(dimension)#

a@
[source]
----
id<Dimensions> get_logical_local_id() const
----
   a@ Return the same value as [code]#get_logical_local().get_id()#

a@
[source]
----
size_t get_logical_local_id(int dimension) const
----
   a@ Return the same value as [code]#get_logical_local().get_id(dimension)#

a@
[source]
----
range<Dimensions> get_physical_local_range() const
----
   a@ Return the same value as [code]#get_physical_local().get_range()#

a@
[source]
----
size_t get_physical_local_range(int dimension) const
----
   a@ Return the same value as [code]#get_physical_local().get_range(dimension)#

a@
[source]
----
id<Dimensions> get_physical_local_id() const
----
   a@ Return the same value as [code]#get_physical_local().get_id()#

a@
[source]
----
size_t get_physical_local_id(int dimension) const
----
   a@ Return the same value as [code]#get_physical_local().get_id(dimension)#

|====



[[group-class]]
==== [code]#group# class

The [code]#group<int Dimensions># encapsulates all functionality
required to represent a particular <<work-group>> within a
parallel execution. It is not user-constructible.

The local range stored in the group class is provided either by
the programmer, when it is passed as an optional parameter to
[code]#parallel_for_work_group#, or by the runtime system when it
selects the optimal work-group size. This allows the developer to
always know how many work-items are in each executing work-group, even through
the abstracted iteration range of the [code]#parallel_for_work_item# loops.

The SYCL [code]#group# class template provides the common by-value
semantics (see <<sec:byval-semantics>>).

A synopsis of the SYCL [code]#group# class is provided below. The
member functions of the SYCL [code]#group# class are listed in
<<table.members.group>>. The additional common special member
functions and common member functions are listed in
<<sec:byval-semantics>> in <<table.specialmembers.common.byval>>
and <<table.hiddenfriends.common.byval>> respectively.

// Interface for class: group
[source,,linenums]
----
include::{header_dir}/group.h[lines=4..-1]
----

[[table.members.group]]
.Member functions for the [code]#group# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
id<Dimensions> get_group_id() const
----
   a@ Return an <<id>> representing the index of the work-group within the
      global <<nd-range>> for every dimension.  Since the work-items in a
      work-group have a defined position within the global nd-range, the
      returned group id can be used along with the local id to uniquely
      identify the work-item in the global nd-range.

a@
[source]
----
size_t get_group_id(int dimension) const
----
   a@ Return the same value as [code]#get_group_id()[dimension]#.

a@
[source]
----
id<Dimensions> get_local_id() const
----
   a@ Return a SYCL [code]#id# representing the calling work-item's position
      within the <<work-group>>.

It is undefined behavior for this member function to be invoked from within
a [code]#parallel_for_work_item# context.

a@
[source]
----
size_t get_local_id(int dimension) const
----
   a@ Return the same value as [code]#get_local_id()[dimension]#.

It is undefined behavior for this member function to be invoked from within
a [code]#parallel_for_work_item# context.

a@
[source]
----
range<Dimensions> get_local_range() const
----
   a@ Return a SYCL [code]#range# representing all dimensions of the local range.
      This local range may have been provided by the programmer, or chosen by the <<sycl-runtime>>.

a@
[source]
----
size_t get_local_range(int dimension) const
----
   a@ Return the same value as [code]#get_local_range()[dimension]#.

a@
[source]
----
range<Dimensions> get_group_range() const
----
   a@ Return a [code]#range# representing the number of <<work-group,work-groups>> in the [code]#nd_range#.

a@
[source]
----
size_t get_group_range(int dimension) const
----
   a@ Return the same value as [code]#get_group_range()[dimension]#.

a@
[source]
----
size_t operator[](int dimension) const
----
   a@ Return the same value as [code]#get_group_id(dimension)#.

a@
[source]
----
range<Dimensions> get_max_local_range() const
----
   a@ Return a [code]#range# representing the maximum number of work-items in any <<work-group>>
      in the [code]#nd_range#.

a@
[source]
----
size_t get_group_linear_id() const
----
   a@ Get a linearized version of the <<work-group-id>>.
      Calculating a linear <<work-group-id>>
      from a multi-dimensional index follows <<sec:multi-dim-linearization>>.

a@
[source]
----
size_t get_group_linear_range() const
----
   a@ Return the total number of <<work-group,work-groups>> in the [code]#nd_range#.

a@
[source]
----
size_t get_local_linear_id() const
----
   a@ Get a linearized version of the calling work-item's <<local-id>>.
      Calculating a linear <<local-id>>
      from a multi-dimensional index follows <<sec:multi-dim-linearization>>.

It is undefined behavior for this member function to be invoked from within
a [code]#parallel_for_work_item# context.

a@
[source]
----
size_t get_local_linear_range() const
----
   a@ Return the total number of work-items in the <<work-group>>.

a@
[source]
----
bool leader() const
----
   a@ Return true for exactly one work-item in the <<work-group>>, if the
      calling work-item is the leader of the work-group, and false for all
      other work-items in the work-group.

The leader of the work-group is determined during construction of the
work-group, and is invariant for the lifetime of the work-group.  The
leader of the work-group is guaranteed to be the work-item with a
local id of 0.

a@
[source]
----
template <typename WorkItemFunctionT>
void parallel_for_work_item(const WorkItemFunctionT& func) const
----
   a@ Launch the work-items for this work-group.

[code]#func# is a function object type with a public member function
[code]#void F::operator()(h_item<Dimensions>)#
representing the work-item computation.

This member function can only be invoked within a
[code]#parallel_for_work_group# context.  It is
undefined behavior for this member function to be invoked
from within the [code]#parallel_for_work_group# form that
does not define work-group size, because then the number of
work-items that should execute the code is not defined.  It is
expected that this form of [code]#parallel_for_work_item#
is invoked within the [code]#parallel_for_work_group# form
that specifies the size of a work-group.

a@
[source]
----
template <typename WorkItemFunctionT>
void parallel_for_work_item(range<Dimensions> logicalRange,
                            const WorkItemFunctionT& func) const
----
   a@ Launch the work-items for this work-group using a logical local range.
      The function object [code]#func# is executed as if the kernel were
      invoked with [code]#logicalRange# as the local range. This new local
      range is emulated and may not map one-to-one with the physical range.

[code]#logicalRange# is the new local range to be used.
This range can be smaller or larger than the one used to invoke the kernel.
[code]#func# is a function object type with a public member function
[code]#void F::operator()(h_item<Dimensions>)#
representing the work-item computation.

Note that the logical range does not need to be uniform
across all work-groups in a kernel.  For example the logical range may depend on
a work-group varying query (e.g. [code]#group::get_linear_id)#,
such that different work-groups in the same kernel invocation execute
different logical range sizes.

This member function can only be invoked within a
[code]#parallel_for_work_group# context.

a@
[source]
----
template <typename DataT>
device_event async_work_group_copy(local_ptr<DataT> dest,
                                   global_ptr<DataT> src,
                                   size_t numElements) const
----
   a@ Deprecated in SYCL 2020.
      Has the same effect as the overload taking [code]#decorated_local_ptr#
      and [code]#decorated_global_ptr# except that the dest and src parameters
      are [code]#multi_ptr#s with [code]#access::decorated::legacy#.

a@
[source]
----
template <typename DataT>
device_event async_work_group_copy(global_ptr<DataT> dest,
                                   local_ptr<DataT> src,
                                   size_t numElements) const
----
   a@ Deprecated in SYCL 2020.
      Has the same effect as the overload taking [code]#decorated_local_ptr#
      and [code]#decorated_global_ptr# except that the dest and src parameters
      are [code]#multi_ptr#s with [code]#access::decorated::legacy#.

a@
[source]
----
template <typename DataT>
device_event async_work_group_copy(local_ptr<DataT> dest,
                                   global_ptr<DataT> src,
                                   size_t numElements, size_t srcStride) const
----
   a@ Deprecated in SYCL 2020.
      Has the same effect as the overload taking [code]#decorated_local_ptr#
      and [code]#decorated_global_ptr# except that the dest and src parameters
      are [code]#multi_ptr#s with [code]#access::decorated::legacy#.

a@
[source]
----
template <typename DataT>
device_event async_work_group_copy(global_ptr<DataT> dest,
                                   local_ptr<DataT> src,
                                   size_t numElements, size_t destStride) const
----
    a@ Deprecated in SYCL 2020.
      Has the same effect as the overload taking [code]#decorated_local_ptr#
      and [code]#decorated_global_ptr# except that the dest and src parameters
      are [code]#multi_ptr#s with [code]#access::decorated::legacy#.

a@
[source]
----
template <typename DestDataT, typename SrcDataT>
device_event async_work_group_copy(decorated_global_ptr<DestDataT> dest,
                                   decorated_local_ptr<SrcDataT> src,
                                   size_t numElements) const
----
   a@ Available only when: (std::is_same_v<DestDataT,
        std::remove_const_t<SrcDataT>> == true)

Permitted types for [code]#DataT# are all scalar and vector types.
Asynchronously copies a number of elements specified by [code]#numElements#
from the source pointer [code]#src# to destination pointer [code]#dest# and
returns a SYCL [code]#device_event# which can be used to wait on the
completion of the copy.

a@
[source]
----
template <typename DestDataT, typename SrcDataT>
device_event async_work_group_copy(decorated_local_ptr<DestDataT> dest,
                                   decorated_global_ptr<SrcDataT> src,
                                   size_t numElements, size_t srcStride) const
----
   a@ Available only when: (std::is_same_v<DestDataT,
        std::remove_const_t<SrcDataT>> == true)

Permitted types for [code]#DataT# are all scalar and vector types.
Asynchronously copies a number of elements specified by [code]#numElements#
from the source pointer [code]#src# to destination pointer [code]#dest# with a
source stride specified by [code]#srcStride# and returns a SYCL
[code]#device_event# which can be used to wait on the completion of the copy.

a@
[source]
----
template <typename DestDataT, SrcDataT>
device_event async_work_group_copy(decorated_global_ptr<DestDataT> dest,
                                   decorated_local_ptr<SrcDataT> src,
                                   size_t numElements, size_t destStride) const
----
    a@ Available only when: (std::is_same_v<DestDataT,
        std::remove_const_t<SrcDataT>> == true)

Permitted types for [code]#DataT# are all scalar and vector types.
Asynchronously copies a number of elements specified by [code]#numElements#
from the source pointer [code]#src# to destination pointer [code]#dest# with a
destination stride specified by [code]#destStride# and returns a SYCL
[code]#device_event# which can be used to wait on the completion of the copy.

a@
[source]
----
template <typename... EventTN> void wait_for(EventTN... events) const
----
   a@ Permitted type for [code]#EventTN# is [code]#device_event#.
      Waits for the asynchronous operations associated with each [code]#device_event# to complete.

|====



[[sub-group-class]]
==== [code]#sub_group# class

The [code]#sub_group# class encapsulates all functionality
required to represent a particular <<sub-group>> within a
parallel execution. It is not user-constructible.

The SYCL [code]#sub_group# class provides the common by-value
semantics (see <<sec:byval-semantics>>).

A synopsis of the SYCL [code]#sub_group# class is provided below. The
member functions of the SYCL [code]#sub_group# class are listed in
<<table.members.subgroup>>. The additional common special member
functions and common member functions are listed in
<<sec:byval-semantics>> in <<table.specialmembers.common.byval>>
and <<table.hiddenfriends.common.byval>> respectively.

// Interface for class: subgroup
[source,,linenums]
----
include::{header_dir}/subgroup.h[lines=4..-1]
----


[[table.members.subgroup]]
.Member functions for the [code]#sub_group# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
id<1> get_group_id() const
----
   a@ Return an <<id>> representing the index of the sub-group within the
      <<work-group>>.  Since the work-items that compose a sub-group are chosen
      in an implementation defined way, the returned sub-group id cannot be
      used to identify a particular work-item in the global nd-range.  Rather,
      the returned sub-group id is merely an abstract identifier of the
      sub-group containing this work-item.

a@
[source]
----
id<1> get_local_id() const
----
   a@ Return a SYCL [code]#id# representing the calling work-item's position
      within the <<sub-group>>.

a@
[source]
----
range<1> get_local_range() const
----
   a@ Return a [code]#range# representing the size of the <<sub-group>>.
      This size may be less than the value returned by
      [code]#get_max_local_range()#, depending on the position of the
      sub-group within its parent <<work-group>> and the manner in which
      sub-groups are constructed by the implementation.

a@
[source]
----
range<1> get_group_range() const
----
   a@ Return a [code]#range# representing the number of
      <<sub-group,sub-groups>> in the <<work-group>>.

a@
[source]
----
range<1> get_max_local_range() const
----
   a@ Return a [code]#range# representing the maximum number of work-items
      permitted in a <<sub-group>> for the executing kernel.  This value may
      have been chosen by the programmer via an attribute, or chosen by the
      <<device-compiler>>.

a@
[source]
----
uint32_t get_group_linear_id() const
----
   a@ Return the same value as [code]#get_group_id()[0]#.

a@
[source]
----
uint32_t get_group_linear_range() const
----
   a@ Return the same value as [code]#get_group_range()[0]#.

a@
[source]
----
uint32_t get_local_linear_id() const
----
   a@ Return the same value as [code]#get_local_id()[0]#.

a@
[source]
----
uint32_t get_local_linear_range() const
----
   a@ Return the same value as [code]#get_local_range()[0]#.

a@
[source]
----
bool leader() const
----
   a@ Return true for exactly one work-item in the <<sub-group>>, if the
      calling work-item is the leader of the sub-group, and false for all
      other work-items in the sub-group.

The leader of the sub-group is determined during construction of the
sub-group, and is invariant for the lifetime of the sub-group.  The
leader of the sub-group is guaranteed to be the work-item with a
local id of 0.

|====


[[sec:reduction]]
=== Reduction variables

All functionality related to <<reduction,reductions>> is captured by the
[code]#reducer# class and the [code]#reduction# function.

The example below demonstrates how to write a <<reduction>>
kernel that performs two reductions simultaneously on the same input values,
computing both the sum of all values in a buffer and the maximum value in the
buffer.  For each reduction variable passed to [code]#parallel_for#, a
reference to a [code]#reducer# object is passed as a parameter to the kernel
function in the same order.

[source,,linenums]
----
include::{code_dir}/reduction.cpp[lines=4..-1]
----

Reductions are supported for all trivially copyable types (as defined by the
{cpp} core language).  If the reduction operator is non-associative or
non-commutative, the behavior of a reduction may be non-deterministic. If
multiple reductions reference the same reduction variable, or a reduction
variable is accessed directly during the lifetime of a reduction (e.g. via an
[code]#accessor# or USM pointer), the behavior is undefined.

Some of the overloads for the [code]#reduction# function take an identity value
and some do not. An implementation is required to compute a correct reduction
even when the application does not specify an identity value. However, the
implementation may be more efficient when the identity value is either provided
by the application or is known by the implementation. For reductions using
standard binary operators and fundamental types (e.g. [code]#plus# and
arithmetic types), an implementation can determine the correct identity value
automatically in order to avoid performance penalties.

If an implementation can identify an identity value for a given combination of
accumulator type and function object type, the value is defined as a member of
the [code]#known_identity# trait class.  Whether this member value exists can
be tested using the [code]#has_known_identity# trait class.

[source,,linenums]
----
include::{header_dir}/identity.h[lines=4..-1]
----

For each of the partial specializations listed in <<table.identities>>,
[code]#known_identity# exists and has the value shown.

[[table.identities]]
.Known identities.
[width="100%",options="header",separator="@",cols="25%,55%,20%"]
|====
@ Operator @ Available Only When @ Identity

a@
[source]
----
sycl::plus
----
a@
[source]
----
std::is_arithmetic_v<AccumulatorT> ||
    std::is_same_v<std::remove_cv_t<AccumulatorT>, sycl::half>
----
a@
----
AccumulatorT{}
----

a@
[source]
----
sycl::multiplies
----
a@
[source]
----
std::is_arithmetic_v<AccumulatorT> ||
    std::is_same_v<std::remove_cv_t<AccumulatorT>, sycl::half>
----
a@
----
AccumulatorT{1}
----

a@
[source]
----
sycl::bit_and
----
a@
[source]
----
std::is_integral_v<AccumulatorT>
----
a@
----
~AccumulatorT{}
----

a@
[source]
----
sycl::bit_or
----
a@
[source]
----
std::is_integral_v<AccumulatorT>
----
a@
----
AccumulatorT{}
----

a@
[source]
----
sycl::bit_xor
----
a@
[source]
----
std::is_integral_v<AccumulatorT>
----
a@
----
AccumulatorT{}
----

a@
[source]
----
sycl::logical_and
----
a@
[source]
----
std::is_same_v<std::remove_cv_t<AccumulatorT>, bool>
----
a@
----
true
----

a@
[source]
----
sycl::logical_or
----
a@
[source]
----
std::is_same_v<std::remove_cv_t<AccumulatorT>, bool>
----
a@
----
false
----

a@
[source]
----
sycl::minimum
----
a@
[source]
----
std::is_integral_v<AccumulatorT>
----
a@
----
std::numeric_limits<AccumulatorT>::max()
----

a@
[source]
----
sycl::minimum
----
a@
[source]
----
std::is_floating_point_v<AccumulatorT> ||
    std::is_same_v<std::remove_cv_t<AccumulatorT>, sycl::half>
----
a@
----
std::numeric_limits<AccumulatorT>::infinity()
----

a@
[source]
----
sycl::maximum
----
a@
[source]
----
std::is_integral_v<AccumulatorT>
----
a@
----
std::numeric_limits<AccumulatorT>::lowest()
----

a@
[source]
----
sycl::maximum
----
a@
[source]
----
std::is_floating_point_v<AccumulatorT> ||
    std::is_same_v<std::remove_cv_t<AccumulatorT>, sycl::half>
----
a@
----
-std::numeric_limits<AccumulatorT>::infinity()
----

|====

The reduction interface is limited to reduction variables whose size can be
determined at compile-time.  As such, [code]#buffer# and USM pointer arguments
are interpreted by the reduction interface as describing a single variable.
A reduction operation associated with a [code]#span# represents an array
reduction.  An array reduction of size _N_ is functionally equivalent to
specifying _N_ independent scalar reductions.  The combination operations
performed by an array reduction are limited to the extent of a USM allocation
described by a [code]#span#, and access to elements outside of these regions
results in undefined behavior.

[NOTE]
====
Since a [code]#span# is one-dimensional, there is currently no way to describe
an array reduction with more than one dimension.  This is expected to change in
a future version of the SYCL specification, but depends on the introduction of
a multi-dimensional [code]#span#.
====

[[reduction-interface]]
==== [code]#reduction# interface

The [code]#reduction# interface is used to attach <<reduction>> semantics
to a variable, by specifying: the reduction variable, the
reduction operator and an optional identity value associated with the operator.
The overloads of the interface are described in <<table.reduction>>.
The return value of the [code]#reduction# interface is an
implementation-defined object of unspecified type, which is interpreted by
[code]#parallel_for# to construct an appropriate [code]#reducer#
type as detailed in <<reducer-class>>.

An implementation may use an unspecified number of temporary variables inside
of any [code]#reducer# objects it creates. If an identity value is supplied to
a reduction, an implementation will use that value to initialize any such
temporary variables.

[NOTE]
====
Since the number of temporary variables is unspecified, supplying an identity
value different to the identity value associated with the reduction operator
may lead to unexpected results.
====

The initial value of the reduction variable is included
in the reduction operation, unless the [code]#property::reduction::initialize_to_identity#
property was specified when the [code]#reduction# interface was invoked.

The reduction variable
is updated so as to contain the result of the reduction when the kernel finishes
execution.

[source,,linenums]
----
include::{header_dir}/reduction.h[lines=4..-1]
----


[[table.reduction]]
.Overloads of the [code]#reduction# interface
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Function @ Description
a@
[source]
----
reduction<BufferT, BinaryOperation>(BufferT vars, handler& cgh,
                                    BinaryOperation combiner,
                                    const property_list& propList = {})
----
   a@ Construct an unspecified object representing a reduction
      of the variable(s) described by [code]#vars# using the combination
      operation specified by [code]#combiner#. Zero or more properties can be
      provided via an instance of [code]#property_list#.
      Throws an [code]#exception# with the [code]#errc::invalid#
      error code if the range of the [code]#vars# buffer is not 1.

a@
[source]
----
reduction<T, BinaryOperation>(T* var, BinaryOperation combiner,
                              const property_list& propList = {})
----
   a@ Construct an unspecified object representing a reduction
      of the variable described by [code]#var# using the combination
      operation specified by [code]#combiner#. Zero or more properties
      can be provided via an instance of [code]#property_list#.

a@
[source]
----
reduction<T, BinaryOperation>(span<T, Extent> vars, BinaryOperation combiner,
                              const property_list& propList = {})
----
   a@ Available only when [code]#Extent != sycl::dynamic_extent#.
      Construct an unspecified object representing a reduction
      of the variable(s) described by [code]#vars# using the combination
      operation specified by [code]#combiner#. Zero or more properties
      can be provided via an instance of [code]#property_list#.

a@
[source]
----
reduction<BufferT, BinaryOperation>(BufferT vars, handler& cgh,
                                    const BufferT::value_type& identity,
                                    BinaryOperation combiner,
                                    const property_list& propList = {})
----
   a@ Construct an unspecified object representing a reduction
      of the variable(s) described by [code]#vars# using the combination
      operation specified by [code]#combiner#. The value of
      [code]#identity# may be used by the implementation to initialize
      an unspecified number of temporary accumulation variables.  Zero or more
      properties can be provided via an instance of [code]#property_list#.
      Throws an [code]#exception# with the [code]#errc::invalid#
      error code if the range of the [code]#vars# buffer is not 1.

a@
[source]
----
reduction<T, BinaryOperation>(T* var, const T& identity,
                              BinaryOperation combiner,
                              const property_list& propList = {})
----
   a@ Construct an unspecified object representing a reduction
      of the variable described by [code]#var# using the combination
      operation specified by [code]#combiner#. The value of
      [code]#identity# may be used by the implementation to initialize
      an unspecified number of temporary accumulation variables.  Zero or more
      properties can be provided via an instance of [code]#property_list#.

a@
[source]
----
reduction<T, BinaryOperation>(span<T, Extent> vars, const T& identity,
                              BinaryOperation combiner,
                              const property_list& propList = {})
----
   a@ Available only when [code]#Extent != sycl::dynamic_extent#.
      Construct an unspecified object representing a reduction
      of the variable(s) described by [code]#vars# using the combination
      operation specified by [code]#combiner#. The value of
      [code]#identity# may be used by the implementation to initialize
      an unspecified number of temporary accumulation variables.  Zero or more
      properties can be provided via an instance of [code]#property_list#.

|====

[[sec:reduction-properties]]
==== Reduction properties

The properties that can be provided when using the [code]#reduction# interface
are described in <<table.properties.reduction>>.


[[table.properties.reduction]]
.Properties supported by the [code]#reduction# interface
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Property @ Description
a@
[source]
----
property::reduction::initialize_to_identity
----
   a@ The [code]#initialize_to_identity# property adds the requirement that the
      <<sycl-runtime>> must initialize the [code]#reduction# variable to the
      identity value passed to the reduction interface, or to the identity
      value determined by the [code]#known_identity# trait if no identity value
      was specified. If no identity value was specified and an identity value
      cannot be determined by the [code]#known_identity# trait, the compiler
      must raise a diagnostic. When this property is set, the original value of
      the reduction variable is not included in the reduction.

|====


The constructors of the reduction property classes are listed in
<<table.constructors.properties.reduction>>.

[[table.constructors.properties.reduction]]
.Constructors of the [code]#reduction# [code]#property# classes
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
property::reduction::initialize_to_identity::initialize_to_identity()
----
   a@ Constructs an [code]#initialize_to_identity# property instance.

|====


[[reducer-class]]
==== [code]#reducer# class

The [code]#reducer# class defines the interface between a work-item and a
reduction variable during the execution of a SYCL kernel, restricting access to
the underlying reduction variable.  The intermediate values of a reduction
variable cannot be inspected during kernel execution, and the variable cannot
be updated using anything other than the reduction's specified combination
operation.  The combination order of different reducers is unspecified, as are
when and how the value of each reducer is combined with the original reduction
variable.

To enable compile-time specialization of reduction algorithms, the
implementation of the [code]#reducer# class is unspecified,
except for the functions and operators defined in <<table.members.reducer>>
and <<table.operators.reducer>>.  As such, developers should not specify the
template arguments of a [code]#reducer# directly, and should instead employ
generic programming techniques that allow kernel functions to accept a
reference to a variable of any [code]#reducer# type.  Kernels written as
lambdas should employ [code]#auto&# or [code]#+auto&...+#, and kernels written as
function objects should employ template parameters or template parameter packs.

An implementation must guarantee that it is safe for multiple work-items in a
kernel to call the combine function of a [code]#reducer# concurrently. An
implementation is free to re-use reducer variables (e.g. across work-groups
scheduled to the same compute unit) if it can guarantee that it is safe to do
so.

The type aliases and constant static members of the [code]#reducer# class are
listed in <<table.types.reducer>> and its member functions are listed in
<<table.members.reducer>>.  Additional shorthand operators may be made
available for certain combinations of reduction variable type and combination
operation, as described in <<table.operators.reducer>>.

[source,,linenums]
----
include::{header_dir}/reducer.h[lines=4..-1]
----

[[table.types.reducer]]
.Member types and constants of the [code]#reducer# class
[width="100%",options="header",separator="@",cols="50%,50%"]
|====
@ Member @ Description
a@
[source]
----
value_type
----
   a@ The data type of the reduction variable.  If this reducer object was
      created from a buffer type [code]#BufferT#, this type is
      [code]#BufferT::value_type#.  If this reducer object was created from a
      USM pointer [code]#T*# or a span [code]#span<T, Extent>#, this type is
      [code]#T#.

a@
[source]
----
binary_operation
----
   a@ The type of the combiner operator [code]#BinaryOperation# that was
      passed to the reduction function that created this reducer object.

a@
[source]
----
static constexpr int dimensions
----
   a@ The number of dimensions of the reduction variable.  If this reducer
      object was created from a buffer or a USM pointer, the number of
      dimensions is [code]#0#.  If this reducer object was created from a span,
      the number of dimensions is [code]#1#.
|====

[[table.members.reducer]]
.Member functions of the [code]#reducer# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
reducer& combine(const T& partial)
----
   a@ Available only when: [code]#Dimensions == 0#.
      Combine the value of [code]#partial# with the reduction variable
      associated with this [code]#reducer#.
      Returns [code]#*this#.

a@
[source]
----
__unspecified__ operator[](size_t index)
----
   a@ Available only when: [code]#Dimensions > 0#.
      Returns an instance of an undefined intermediate type representing
      a [code]#reducer# of the same type as this [code]#reducer#,
      with the dimensionality [code]#Dimensions-1# and containing an
      implicit SYCL [code]#id# with index [code]#Dimensions# set
      to [code]#index#.  The intermediate type returned must provide
      all member functions and operators defined by the [code]#reducer#
      class that are appropriate for the type it represents (including this
      subscript operator).

a@
[source]
----
T identity() const
----
   a@ Return the identity value of the combination operation associated with
      this [code]#reducer#.  Only available if the identity value is known
      to the implementation.
|====

[[table.operators.reducer]]
.Hidden friend operators of the [code]#reducer# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Operator @ Description
a@
[source]
----
reducer& operator+=(reducer& accum, const T& partial)
----
   a@ Equivalent to calling [code]#accum.combine(partial)#.
      Available only when: [code]#Dimensions == 0 &&
      (std::is_same_v<BinaryOperation, plus<>> || std::is_same_v<BinaryOperation, plus<T>>)#.

a@
[source]
----
reducer& operator*=(reducer& accum, const T& partial)
----
   a@ Equivalent to calling [code]#accum.combine(partial)#.
      Available only when: [code]#Dimensions == 0 &&
      (std::is_same_v<BinaryOperation, multiplies<>> || std::is_same_v<BinaryOperation, multiplies<T>>)#.

a@
[source]
----
reducer& operator&=(reducer& accum, const T& partial)
----
   a@ Equivalent to calling [code]#accum.combine(partial)#.
      Available only when: [code]#Dimensions == 0 && is_integral_v<T> &&
      (std::is_same_v<BinaryOperation, bit_and<>> || std::is_same_v<BinaryOperation, bit_and<T>>)#.

a@
[source]
----
reducer& operator|=(reducer& accum, const T& partial)
----
   a@ Equivalent to calling [code]#accum.combine(partial)#.
      Available only when: [code]#Dimensions == 0 && is_integral_v<T> &&
      (std::is_same_v<BinaryOperation, bit_or<>> || std::is_same_v<BinaryOperation, bit_or<T>>)#.

a@
[source]
----
reducer& operator^=(reducer& accum, const T& partial)
----
   a@ Equivalent to calling [code]#accum.combine(partial)#.
      Available only when: [code]#Dimensions == 0 && is_integral_v<T> &&
      (std::is_same_v<BinaryOperation, bit_xor<>> || std::is_same_v<BinaryOperation, bit_xor<T>>)#.

a@
[source]
----
reducer& operator++(reducer& accum)
----
   a@ Equivalent to calling [code]#accum.combine(1)#.
      Available only when: [code]#Dimensions == 0 && std::is_integral_v<T> && !std::is_same_v<T, bool> &&
      (std::is_same_v<BinaryOperation, plus<>> || std::is_same_v<BinaryOperation, plus<T>>)#.

|====


[[sec:command.group.scope]]
=== Command group scope

A <<command-group-scope>>, as defined in <<sec:executionmodel>>,
may execute a single <<command>> such as invoking a kernel, copying memory,
or executing a host task.  It is legal for a <<command-group-scope>> to
statically contain more than one call to a <<command>> function, but any
single execution of the <<command-group-function-object>> may execute no more
than one <<command>>. If an application fails to do this, the function that
submits the <<command-group-function-object>> (i.e., [code]#queue::submit#)
must throw a synchronous [code]#exception# with the [code]#errc::invalid# error
code. The statements that call <<command, commands>> together with
the statements that define the requirements for a kernel form the
<<command-group-function-object>>.  The command group
function object takes as a parameter an instance of the <<handler>> class which
encapsulates all the member functions executed in the command group scope.
The member functions and objects defined in this scope will define the requirements for the
kernel execution or explicit memory operation, and will be used by the <<sycl-runtime>>
to evaluate if the operation is ready for execution.
Host code within a <<command-group-function-object>> (typically setting up
requirements) is executed once, before the command group submit call returns.
This abstraction of the kernel
execution unifies the data with its processing, and consequently allows more
abstraction and flexibility in the parallel programming models that can be
implemented on top of SYCL.

The <<command-group-function-object>> and the [code]#handler# class
serve as an interface for the encapsulation of <<command-group-scope>>.
A <<sycl-kernel-function>> is defined as a function object. All the device data accesses are
defined inside this group and any transfers are managed by the <<sycl-runtime>>. The
rules for the data transfers regarding device and
host data accesses are better described in <<sec:data.access.and.storage>>,
where buffers (<<subsec:buffers>>) and accessor (<<subsec:accessors>>) classes
are described.  The overall memory model of the SYCL application is described in
<<sub.section.memmodel.app>>.

It is possible for a <<command-group-function-object>> to fail to enqueue to a queue,
or for it to fail to execute correctly. A user can therefore supply a secondary
queue when submitting a command group to the primary queue. If the <<sycl-runtime>>
fails to enqueue or execute a command group on a primary queue, it can attempt
to run the command group on the secondary queue. The circumstances in which it
is, or is not, possible for a <<sycl-runtime>> to fall-back from primary to
secondary queue are unspecified in the specification.  Even if a command group
is run on the secondary queue, the requirement that host code within the command group
is executed exactly once remains, regardless of whether the fallback queue is used for
execution.

The command group [code]#handler# class provides the interface
for all of the member functions that are able to be executed inside the command group
scope, and it is also provided as a scoped object to all of the data access
requests. The <<handler>> class provides the interface
in which every command in the command group scope will be submitted to a queue.


[[sec:handlerClass]]
=== Command group [code]#handler# class

A <<handler>> object can only be constructed by the SYCL
runtime. All of the accessors defined in <<command-group-scope>> take as a
parameter an instance of the <<handler>>, and all the
kernel invocation functions are member functions of this class.

The constructors of the SYCL [code]#handler# class are described in
<<table.constructors.handler>>.

It is disallowed for an instance of the SYCL [code]#handler# class to
be moved or copied.

// Interface for class: handler
[source,,linenums]
----
include::{header_dir}/commandGroupHandler.h[lines=4..-1]
----


[[table.constructors.handler]]
.Constructors of the [code]#handler# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
handler(___unspecified___)
----
   a@ Unspecified implementation-defined constructor.

|====


[[sub.section.requirement]]
==== SYCL functions for adding requirements

When an accessor is created from a <<handler>>, a *requirement* is
implicitly added to the <<command-group>> for the accessor's data.  However,
this does not happen when creating a [keyword]#placeholder# accessor.  In order
to create a *requirement* for a [keyword]#placeholder# accessor, code
must call the [code]#handler::require()# member function.

Note that the default constructed [code]#accessor# is not a placeholder, so it
may be passed to a <<sycl-kernel-function>> without calling
[code]#handler::require()#.  However, this accessor also has no underlying
memory object, so such an accessor does not create any *requirement* for the
command group, and attempting to access data elements from it produces
undefined behavior.

SYCL events may also be used to create requirements for a <<command-group>>.
Such requirements state that the actions represented by the events must
complete before the <<command-group>> may execute.  Such requirements
are added when code calls the [code]#handler::depends_on()# member function.

[[table.members.handler.requirements]]
.Member functions of the [code]#handler# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
template <typename DataT, int Dimensions, access_mode AccessMode,
          target AccessTarget, access::placeholder IsPlaceholder>
void require(
    accessor<DataT, Dimensions, AccessMode, AccessTarget, IsPlaceholder> acc)
----
   a@ Calling this function has no effect unless [code]#acc# is a placeholder
      accessor.  When [code]#acc# is a placeholder accessor, this function
      adds a *requirement* to the handler's <<command-group>> for the memory
      object represented by [code]#acc#.  If the accessor has already been
      registered with the <<command-group>>, calling this function has no
      effect.

a@
[source]
----
void depends_on(event depEvent)
----
a@ The <<command-group>> now has a *requirement* that the action represented
by [code]#depEvent# must complete before executing this
<<command-group, command-group's>> action.

a@
[source]
----
void depends_on(const std::vector<event>& depEvents)
----
a@ The <<command-group>> now has a *requirement* that the actions represented
by each event in [code]#depEvents# must complete before executing this
<<command-group, command-group's>> action.

|====


[[subsec:invokingkernels]]
==== SYCL functions for invoking kernels

<<kernel,Kernels>> can be invoked as [keyword]#single tasks#, basic
[keyword]#data-parallel# <<kernel,kernels>>, <<nd-range>> in
<<work-group,work-groups>>, or [keyword]#hierarchical parallelism#.

Each function takes an optional kernel name template parameter. The user
may optionally provide a <<kernel-name>>, otherwise an implementation-defined name
will be generated for the kernel.

All the functions for invoking kernels are member functions of the command group
[code]#handler# class (<<sec:handlerClass>>), which
is used to encapsulate all the member functions provided in a command group scope.
<<table.members.handler.kernel>> lists all the members of the
[code]#handler# class related to the kernel invocation.


[[table.members.handler.kernel]]
.Member functions of the [code]#handler# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
template <typename T> void set_arg(int argIndex, T&& arg)
----
   a@ This function must only be used to set arguments for a kernel that
      was constructed using a backend specific interoperability function
      or for a device built-in kernel.  Attempting to use this function to set
      arguments for other kernels results in undefined behavior.  The precise
      semantics of this function are defined by each SYCL backend
      specification.

a@
[source]
----
template <typename... Ts> void set_args(Ts&&... args)
----
   a@ Set all arguments for a given kernel, as if each argument in
      [code]#args# was passed to [code]#set_arg# in the same order and
      with an increasing index starting at 0.

a@
[source]
----
template <typename KernelName, typename KernelType>
void single_task(const KernelType& kernelFunc)
----
   a@ Defines and invokes a <<sycl-kernel-function>> as a lambda function
      or a named function object type.
      Specification of a <<kernel-name>> ([code]#typename KernelName#), as
      described in <<subsec:invokingkernels>>, is optional.
      The callable
      [code]#KernelType# can optionally take a [code]#kernel_handler#
      in which case the <<sycl-runtime>> will construct an instance of
      [code]#kernel_handler# and pass it to [code]#KernelType#.

a@
[source]
----
template <typename KernelName, int Dimensions, typename... Rest>
void parallel_for(range<Dimensions> numWorkItems, Rest&&... rest)
----
   a@ Defines and invokes a <<sycl-kernel-function>> as a lambda function
      or a named function object type,
      for the specified range and given an item or integral type (e.g [code]#int#,
      [code]#size_t)#, if range is 1-dimensional, for indexing in the indexing
      space defined by range. Generic kernel functions are permitted,
      in that case the argument type is an [code]#item#.
      Specification of a <<kernel-name>> ([code]#typename KernelName#), as
      described in <<subsec:invokingkernels>>, is optional.
      The [code]#rest# parameter pack consists of 0 or more objects created by
      the [code]#reduction# function, followed by a callable.  For each
      object in [code]#rest#, the kernel function must take an additional
      reference parameter corresponding to that object's [code]#reducer# type,
      in the same order.
      The callable can optionally take a [code]#kernel_handler#
      as its last parameter, in which case the <<sycl-runtime>> will
      construct an instance of [code]#kernel_handler# and pass it to
      the callable.

a@
[source]
----
template <typename KernelName, int Dimensions, typename... Rest>
void parallel_for(range<Dimensions> numWorkItems, id<Dimensions> workItemOffset,
                  const KernelType& kernelFunc)
    // Deprecated in SYCL 2020.
----
   a@ Deprecated in SYCL 2020.
      Defines and invokes a <<sycl-kernel-function>> as a lambda function
      or a named function object type,
      for the specified range and offset and given an item or integral type
      (e.g [code]#int#, [code]#size_t)#, if range is 1-dimensional,
      for indexing in the indexing space defined by range. Generic kernel functions
      are permitted, in that case the argument type is an [code]#item#.
      Specification of a <<kernel-name>> ([code]#typename KernelName#), as
      described in <<subsec:invokingkernels>>, is optional.
      The [code]#rest# parameter pack consists of 0 or more objects created by
      the [code]#reduction# function, followed by a callable.  For each
      object in [code]#rest#, the kernel function must take an additional
      reference parameter corresponding to that object's [code]#reducer# type,
      in the same order.
      The callable can optionally take a [code]#kernel_handler#
      as its last parameter, in which case the <<sycl-runtime>> will
      construct an instance of [code]#kernel_handler# and pass it to
      the callable.
a@
[source]
----
template <typename KernelName, int Dimensions, typename... Rest>
void parallel_for(nd_range<Dimensions> executionRange, Rest&&... rest)
----
   a@ Defines and invokes a <<sycl-kernel-function>> as a lambda function
      or a named function object type,
      for the specified <<nd-range>> and given an <<nd-item>>
      for indexing in the indexing space defined by the <<nd-range>>.
      Generic kernel functions are permitted, in that case the argument type is
      an <<nd-item>>.
      Specification of a <<kernel-name>> ([code]#typename KernelName#), as
      described in <<subsec:invokingkernels>>, is optional.
      The [code]#rest# parameter pack consists of 0 or more objects created by
      the [code]#reduction# function, followed by a callable.  For each
      object in [code]#rest#, the kernel function must take an additional
      reference parameter corresponding to that object's [code]#reducer# type,
      in the same order.
      The callable can optionally take a [code]#kernel_handler#
      as its last parameter, in which case the <<sycl-runtime>> will
      construct an instance of [code]#kernel_handler# and pass it to
      the callable.

Throws an [code]#exception# with the [code]#errc::nd_range# error code if the
global size defined in the associated [code]#executionRange# defines a non-zero
index space which is not evenly divisible by the local size in each dimension.

a@
[source]
----
template <typename KernelName, typename WorkgroupFunctionType, int Dimensions>
void parallel_for_work_group(range<Dimensions> numWorkGroups,
                             const WorkgroupFunctionType& kernelFunc)
----
   a@ Defines and invokes a hierarchical kernel as a lambda function
      or a named function object type,
      encoding the body of each work-group to launch. Generic kernel
      functions are permitted, in that case the argument type is a [code]#group#. May
      contain multiple calls to [code]#parallel_for_work_item(..)# member functions
      representing the execution on each work-item. Launches
      [code]#num_work_groups# work-groups of runtime-defined
      size. Described in detail in <<subsec:invokingkernels>>. The callable
      [code]#WorkgroupFunctionType# can optionally take a
      [code]#kernel_handler# as it's last parameter, in which case the
      <<sycl-runtime>> will construct an instance of
      [code]#kernel_handler# and pass it to [code]#WorkgroupFunctionType#.

a@
[source]
----
template <typename KernelName, typename WorkgroupFunctionType, int Dimensions>
void parallel_for_work_group(range<Dimensions> numWorkGroups,
                             range<Dimensions> workGroupSize,
                             const WorkgroupFunctionType& kernelFunc)
----
   a@ Defines and invokes a hierarchical kernel as a lambda function
      or a named function object type,
      encoding the body of each work-group to launch. Generic kernel
      functions are permitted, in that case the argument type is a [code]#group#.
      May contain multiple calls to [code]#parallel_for_work_item# member functions
      representing the execution on each work-item. Launches
      [code]#num_work_groups# work-groups of
      [code]#work_group_size# work-items each. Described in
      detail in <<subsec:invokingkernels>>. The callable
      [code]#WorkgroupFunctionType# can optionally take a
      [code]#kernel_handler# as it's last parameter, in which case the
      <<sycl-runtime>> will construct an instance of [code]#kernel_handler#
      and pass it to [code]#WorkgroupFunctionType#.

a@
[source]
----
void single_task(const kernel& kernelObject)
----
   a@ This function must only be used to invoke a kernel that was constructed
      using a backend specific interoperability function or to invoke a device
      built-in kernel.  Attempting to use this function to invoke other kernels
      throws a synchronous [code]#exception# with the [code]#errc::invalid#
      error code.  The precise semantics of this function are defined by each
      SYCL backend specification, but the intent is that the kernel should
      execute exactly once.

This invocation function ignores any [code]#kernel_bundle# that was bound to
this command group handler via [code]#handler::use_kernel_bundle()# and instead
implicitly uses the kernel bundle that contains the [code]#kernelObject#.
Throws an [code]#exception# with the [code]#errc::kernel_not_supported# error
code if the [code]#kernelObject# is not compatible with either the device
associated with the primary queue of the <<command-group>> or with the device
associated with the secondary queue (if specified).

a@
[source]
----
template <int Dimensions>
void parallel_for(range<Dimensions> numWorkItems, const kernel& kernelObject)
----
   a@ This function must only be used to invoke a kernel that was constructed
      using a backend specific interoperability function or to invoke a device
      built-in kernel.  Attempting to use this function to invoke other kernels
      throws a synchronous [code]#exception# with the [code]#errc::invalid#
      error code.  The precise semantics of this function are defined by each
      SYCL backend specification, but the intent is that the kernel should be
      invoked for the specified range of index values.

This invocation function ignores any [code]#kernel_bundle# that was bound to
this command group handler via [code]#handler::use_kernel_bundle()# and instead
implicitly uses the kernel bundle that contains the [code]#kernelObject#.
Throws an [code]#exception# with the [code]#errc::kernel_not_supported# error
code if the [code]#kernelObject# is not compatible with either the device
associated with the primary queue of the <<command-group>> or with the device
associated with the secondary queue (if specified).

a@
[source]
----
template <int Dimensions>
void parallel_for(nd_range<Dimensions> executionRange,
                  const kernel& kernelObject)
----
   a@ This function must only be used to invoke a kernel that was constructed
      using a backend specific interoperability function or to invoke a device
      built-in kernel.  Attempting to use this function to invoke other kernels
      throws a synchronous [code]#exception# with the [code]#errc::invalid#
      error code.  The precise semantics of this function are defined by each
      SYCL backend specification, but the intent is that the kernel should be
      invoked for the specified [code]#executionRange#.

Throws an [code]#exception# with the [code]#errc::nd_range# error code if the
global size defined in the associated [code]#executionRange# defines a non-zero
index space which is not evenly divisible by the local size in each dimension.

This invocation function ignores any [code]#kernel_bundle# that was bound to
this command group handler via [code]#handler::use_kernel_bundle()# and instead
implicitly uses the kernel bundle that contains the [code]#kernelObject#.
Throws an [code]#exception# with the [code]#errc::kernel_not_supported# error
code if the [code]#kernelObject# is not compatible with either the device
associated with the primary queue of the <<command-group>> or with the device
associated with the secondary queue (if specified).

|====


// Interface for apis
// include headers/parallelFor.h ?


===== [code]#single_task# invoke

SYCL provides a simple interface to enqueue a kernel that will be
sequentially executed on a device. Only one instance of the
kernel will be executed. This interface is useful as a primitive for more
complicated parallel algorithms, as it can easily create a chain of
sequential tasks on a SYCL device with each of them managing its
own data transfers.

This function can only be called inside a command group using the
[code]#handler# object created by the runtime.
Any accessors that are used in a kernel should be defined inside the
same command group.

Local accessors are disallowed for single task invocations.

[source,,linenums]
----
include::{code_dir}/singletask.cpp[lines=4..-1]
----

For single tasks, the kernel member function takes no parameters, as there
is no need for <<index-space-classes>> in a unary index space.

A [code]#kernel_handler# can optionally be passed as a parameter
to the <<sycl-kernel-function>> that is invoked by
[code]#single_task# for the purpose explained
in <<sec:spec-constants.device-code>>.

[source,,linenums]
----
include::{code_dir}/singleTaskWithKernelHandler.cpp[lines=4..-1]
----


===== [code]#parallel_for# invoke

The [code]#parallel_for# member function of the SYCL
[code]#handler# class provides an interface to define and invoke a SYCL
kernel function in a command group, to execute in parallel execution over a
3 dimensional index space. There are three overloads of the
[code]#parallel_for# member function which provide variations of this
interface, each with a different level of complexity and providing a
different set of features.

For the simplest case, users need only provide the global range (the total
number of work-items in the index space) via a SYCL [code]#range#
parameter. In this case the function object that represents the SYCL kernel
function must take one of:
1) a single SYCL [code]#item# parameter, 2) a single generic parameter
([code]#template# parameter or [code]#auto#) that will be treated as
an [code]#item# parameter, 3) any other type
implicitly converted from SYCL [code]#item#, representing the currently
executing work-item within the range specified by the [code]#range#
parameter.

[NOTE]
====
Case 3) above allows the kernel function to take an argument of type [code]#id#
because [code]#item# is implicitly convertible to [code]#id#.  It also allows
a 1-D kernel function to take an integral argument (e.g. [code]#int# or
[code]#size_t#) because a 1-D [code]#item# is implicitly convertible to these
types.  Finally, it allows the kernel function to take a user-defined argument
type that can be constructed from [code]#item#, enabling users to layer their
own abstractions on top of SYCL.
====

The execution of the kernel function is the same whether the parameter to
the SYCL kernel function is a SYCL [code]#id# or a SYCL
[code]#item#. What differs is the functionality that is available to
the SYCL kernel function via the respective interfaces.

Below is an example of invoking a SYCL kernel function with
[code]#parallel_for# using a lambda function, and passing a SYCL
[code]#id# parameter. In this case, only the global id is available.
This variant of [code]#parallel_for# is designed for when it is not
necessary to query the global range of the index space being executed across.

[source,,linenums]
----
include::{code_dir}/basicparallelfor.cpp[lines=4..-1]
----

Below is an example of invoking a SYCL kernel function with
[code]#parallel_for# using a lambda function and passing a SYCL
[code]#item# parameter. In this case, both the global id and global
range are queryable. This variant of [code]#parallel_for# is designed
for when it is necessary to query the global range of the index space
being executed across.

[source,,linenums]
----
include::{code_dir}/basicParallelForItem.cpp[lines=4..-1]
----

Below is an example of invoking a SYCL kernel function with
[code]#parallel_for# using a lambda function and passing
[code]#auto# parameter, treated as [code]#item#. In this case, both
the global id and global range are queryable. The same effect can be
achieved using class with templatized [code]#operator()#. This variant
of [code]#parallel_for# is designed for when it is necessary to query
the global range within which the global id will vary.

[source,,linenums]
----
include::{code_dir}/basicParallelForGeneric.cpp[lines=4..-1]
----

Below is an example of invoking a SYCL kernel function with
[code]#parallel_for# using a lambda function and passing an integral type
parameter. This example is only valid when calling [code]#parallel_for# with
[code]#range<1>#. In this case only the global id is available. This variant of
[code]#parallel_for# is designed for when it is not necessary to query
the global range of the index space being executed across.

[source,,linenums]
----
include::{code_dir}/basicParallelForIntegral.cpp[lines=4..-1]
----

The [code]#parallel_for# overload without an offset can be called with
either a number or a [code]#braced-init-list# with 1-3 elements. In that
case the following calls are equivalent:

  * [code]#parallel_for(N, some_kernel)# has same effect as
    [code]#parallel_for(range<1>(N), some_kernel)#
  * [code]#parallel_for({N}, some_kernel)# has same effect as
    [code]#parallel_for(range<1>(N), some_kernel)#
  * [code]#parallel_for({N1, N2}, some_kernel)# has same effect as
    [code]#parallel_for(range<2>(N1, N2), some_kernel)#
  * [code]#parallel_for({N1, N2, N3}, some_kernel)# has same effect
    as [code]#parallel_for(range<3>(N1, N2, N3), some_kernel)#

Below is an example of invoking [code]#parallel_for# with a number
instead of an explicit [code]#range# object.

[source,,linenums]
----
include::{code_dir}/basicParallelForNumber.cpp[lines=4..-1]
----

For SYCL kernel functions invoked via the above described overload of the
[code]#parallel_for# member function, it is disallowed to use local
accessors or to use a <<work-group-barrier>>.

The following two examples show how a kernel function object can be launched
over a 3D grid, with 3 elements in each dimension. In the first case
work-item ids range from 0 to 2 inclusive, and in the second case
work-item ids run from 1 to 3.

[source,,linenums]
----
include::{code_dir}/parallelfor.cpp[lines=4..-1]
----

The last case of a [code]#parallel_for# invocation enables low-level functionality
of work-items and work-groups. This becomes valuable when an execution
requires groups of work-items that communicate and synchronize. These are
exposed in SYCL through [code]#+parallel_for (nd_range,...)+# and the
[code]#nd_item# class. In this case, the developer needs to define the
[code]#nd_range# that the kernel will execute on in order to have fine
grained control of the enqueuing of the kernel. This variation of
parallel_for expects an [code]#nd_range#, specifying both local and
global ranges, defining the global number of work-items and the number in
each cooperating work-group. The function object that represents the SYCL
kernel function must take one of:
1) a single SYCL [code]#nd_item# parameter, 2) a single generic parameter
([code]#template# parameter or [code]#auto#) that will be treated as
an [code]#nd_item# parameter, 3) any other type converted
from SYCL [code]#nd_item#, representing the currently executing work-item
within the range specified by the [code]#nd_range# parameter. The
[code]#nd_item# parameter makes all information about the work-item and
its position in the range available, and provides access to functions
enabling the use of a <<work-group-barrier>> to synchronize between the
<<work-item,work-items>> in the <<work-group>>.

[NOTE]
====
Case 3) above includes user-defined types that can be constructed from
[code]#nd_item#, enabling users to layer their own abstractions on top of SYCL.
====

The following example shows how sixty-four work-items may be launched
in a three-dimensional grid with four in each dimension, and divided
into eight work-groups. Each group of work-items synchronizes with a
<<work-group-barrier>>.

[source,,linenums]
----
include::{code_dir}/parallelforbarrier.cpp[lines=4..-1]
----

In all of these cases the underlying <<nd-range>> will be created
and the kernel defined as a function object will be created and enqueued
as part of the command group scope.

Some forms of [code]#parallel_for# accept an offset parameter of type
[code]#id<Dimensions>#, where the number of dimensions of the [code]#id# is the same
as the number of dimensions of the [code]#range# that determines the iteration space.
These forms of [code]#parallel_for# execute the same number of iterations as the form
with no offset.  The difference is that the [code]#id# or [code]#item# parameter passed
to the kernel function has the value of [code]#offset# implicitly added.
This offset parameter is deprecated in SYCL 2020.

An offset can also be passed to the forms of [code]#parallel_for# that accept an
[code]#nd_range# via the third parameter to the [code]#nd_range# constructor.  These
forms of [code]#parallel_for# also execute the same number of iterations as if no offset
was specified.  The difference is that the [code]#nd_item# parameter passed to the kernel
function has the value of the offset implicitly added to the constituent <<global-id>>.
This offset parameter is deprecated in SYCL 2020.


A [code]#kernel_handler# can optionally be passed as a parameter to the
<<sycl-kernel-function>> that is invoked by both variants of
[code]#parallel_for#.

[source,,linenums]
----
include::{code_dir}/parallelForWithKernelHandler.cpp[lines=4..-1]
----


===== Parallel for hierarchical invoke

The hierarchical parallel kernel execution interface provides the same
functionality as is available from the <<nd-range>> interface, but
exposed differently. To execute the same sixty-four work-items in
eight work-groups that we saw in a previous example, we execute an
outer [code]#parallel_for_work_group# call to create the
groups. The member function
[code]#handler::parallel_for_work_group# is parameterized by the
number of work-groups, such that the size of each group is chosen by
the runtime, or by the number of work-groups and number of work-items
for users who need more control.

The body of the outer [code]#parallel_for_work_group# call
consists of a lambda function or function object. The body of this
function object contains code that is executed only once for the
entire work-group. If the code has no side-effects and the compiler
heuristic suggests that it is more efficient to do so, this code will be
executed for each work-item.

Within this region any variable declared will have the semantics of
<<local-memory>>, shared between all <<work-item,work-items>> in the
<<work-group>>. If the
device compiler can prove that an array of such variables is accessed only by
a single work-item throughout the lifetime of the work-group, for
example if access is derived from the id of the work-item with no
transformation, then it can allocate the data in private memory or
registers instead.

To guarantee use of private per-work-item memory, the
[code]#private_memory# class can be used to wrap the data.
This class simply constructs private data for a given group across the
entire group. The id of the current work-item is passed to any access
to grab the correct data.

The [code]#private_memory# class has the following interface:

[[paragraph.private.memory]]
.Private memory class
[source,,linenums]
----
include::{header_dir}/priv.h[lines=4..-1]
----

[[table.constructors.private.memory]]
.Constructor of the [code]#private_memory# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
private_memory(const group<Dimensions>&)
----
   a@ Place an object of type [code]#T# in the underlying private memory of each <<work-item,work-items>>.
      The type [code]#T# must be default constructible.
      The underlying constructor will be called for each <<work-item>>.

|====

[[table.members.private.memory]]
.Member functions of the [code]#private_memory# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member functions @ Description
a@
[source]
----
T& operator()(const h_item<Dimensions>& id)
----
   a@ Retrieve a reference to the object for the <<work-item,work-items>>.

|====

<<private-memory,Private memory>> is allocated per underlying <<work-item>>, not per
iteration of the [code]#parallel_for_work_item# loop. The number
of instances of a private memory object is only under direct control
if a work-group size is passed to the
[code]#parallel_for_work_group# call. If the underlying
work-group size is chosen by the runtime, the number of private memory
instances is opaque to the program. Explicit private memory
declarations should therefore be used with care and with a full
understanding of which instances of a
[code]#parallel_for_work_item# loop will share the same
underlying variable.

Also within the lambda body can be a sequence of calls to
[code]#parallel_for_work_item#. At the edges of these inner parallel
executions the work-group synchronizes. As a result the pair of
[code]#parallel_for_work_item# calls in the code below is equivalent to
the parallel execution with a <<work-group-barrier>> in the earlier
example.

[source,,linenums]
----
include::{code_dir}/parallelforworkgroup.cpp[lines=4..-1]
----

It is valid to use more flexible dimensions of the work-item loops. In
the following example we issue 8 work-groups but let the runtime
choose their size, by not passing a work-group size to the
[code]#parallel_for_work_group# call. The
[code]#parallel_for_work_item# loops may also vary in size, with
their execution ranges unrelated to the dimensions of the work-group,
and the compiler generating an appropriate iteration space to fill the
gap. In this case, the [code]#h_item# provides access to local ids and
ranges that reflect both kernel and [code]#parallel_for_work_item# invocation ranges.

[source,,linenums]
----
include::{code_dir}/parallelforworkgroup2.cpp[lines=4..-1]
----

This interface offers a more intuitive way for tiling parallel
programming paradigms. In summary, the hierarchical model allows a
developer to distinguish the execution at work-group level and at
work-item level using the [code]#parallel_for_work_group# and the nested
[code]#parallel_for_work_item# functions. It also provides this visibility
to the compiler without the need for difficult loop fission such that
host execution may be more efficient.

A [code]#kernel_handler# can optionally be passed as a parameter to the
<<sycl-kernel-function>> that is invoked by any variant of
[code]#parallel_for_work_group#.

[source,,linenums]
----
include::{code_dir}/parallelForWorkGroupWithKernelHandler.cpp[lines=4..-1]
----

// \input{sycl_explicit_memory}

// %%%%%%%%%%%%%%%%%%%%%%%%%%%% begin sycl_explicit_memory %%%%%%%%%%%%%%%%%%%%%%%%%%%%

[[subsec:explicitmemory]]
==== SYCL functions for explicit memory operations

In addition to <<kernel,kernels>>, <<command-group>> objects can also be used to
perform manual operations on host and device memory by using the
[keyword]#copy# API of the <<handler>>.
Manual copy operations can be seen as specialized kernels executing on the
device, except that typically this operations will be implemented using a
host API that exists as part of a backend (e.g, OpenCL enqueue copy operations).

These explicit copy operations have a source and a destination.  When an
accessor is the _source_ of the operation, the destination can be a host
pointer or another accessor.  The _source_ accessor must have either
[code]#access_mode::read# or [code]#access_mode::read_write# access mode.  When
an accessor is the _destination_ of the explicit copy operation, the source can
be a host pointer or another accessor.  The _destination_ accessor must have
either [code]#access_mode::write#, [code]#access_mode::read_write#,
[code]#access_mode::discard_write# or [code]#access_mode::discard_read_write#
access mode.

When an accessor is used as a parameter to one of these explicit copy
operations, the target must be either [code]#target::device# or
[code]#target::constant_buffer#.

When accessors are both the source and the destination,
the operation is executed on objects controlled by the SYCL runtime.
The SYCL runtime is allowed to not perform an explicit in-copy operation
if a different path to update the data is available according to
the SYCL application memory model.

The most recent copy of the memory object may reside on any context controlled
by the SYCL runtime, or on the host in a pointer controlled by the
SYCL runtime.  The SYCL runtime will ensure that data is copied to the destination
once the <<command-group>> has completed execution.

Whenever a host pointer is used as either the source or the destination of these
explicit memory operations, it is the responsibility
of the user for that pointer to have at least as much memory allocated as
the accessor is giving access to, e.g: if an accessor accesses a range
of 10 elements of [code]#int# type, the host pointer must at least have
[code]#10 * sizeof(int)# bytes of memory allocated.

A special case is the [code]#update_host# member function.
This member function only requires an accessor, and instructs the runtime to update
the internal copy of the data in the host, if any. This is particularly
useful when users use manual synchronization with host pointers, e.g.
via mutex objects on the [code]#buffer# constructors.

<<table.members.handler.copy>> describes the interface for the
explicit copy operations.


[[table.members.handler.copy]]
.Member functions of the [code]#handler# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
template <typename SrcT, int SrcDims, access_mode SrcMode, target SrcTgt,
          typename DestT, access::placeholder IsPlaceholder>
void copy(accessor<SrcT, SrcDims, SrcMode, SrcTgt, IsPlaceholder> src,
          std::shared_ptr<DestT> dest)
----
a@ Copies the contents of the memory object accessed by
[code]#src# into the memory pointed to by [code]#dest#.
[code]#dest# must be a host pointer and must have at least
as many bytes as the range accessed by [code]#src#.  The
type [code]#DestT# must be <<device-copyable>>.

a@
[source]
----
template <typename SrcT, typename DestT, int DestDims, access_mode DestMode,
          target DestTgt, access::placeholder IsPlaceholder>
void copy(std::shared_ptr<SrcT> src,
          accessor<DestT, DestDims, DestMode, DestTgt, IsPlaceholder> dest)
----
a@ Copies the contents of the memory pointed to by [code]#src#
into the memory object accessed by [code]#dest#.
[code]#src# must be a host pointer and must have at least
as many bytes as the range accessed by [code]#dest#.  The type
[code]#SrcT# must be <<device-copyable>>.

a@
[source]
----
template <typename SrcT, int SrcDims, access_mode SrcMode, target SrcTgt,
          typename DestT, access::placeholder IsPlaceholder>
void copy(accessor<SrcT, SrcDims, SrcMode, SrcTgt, IsPlaceholder> src,
          DestT* dest)
----
a@ Copies the contents of the memory object accessed by
[code]#src# into the memory pointed to by [code]#dest#.
[code]#dest# must be a host pointer and must have at least
as many bytes as the range accessed by [code]#src#.  The type
[code]#DestT# must be <<device-copyable>>.

a@
[source]
----
template <typename SrcT, typename DestT, int DestDims, access_mode DestMode,
          target DestTgt, access::placeholder IsPlaceholder>
void copy(const SrcT* src,
          accessor<DestT, DestDims, DestMode, DestTgt, IsPlaceholder> dest)
----
a@ Copies the contents of the memory pointed to by [code]#src#
into the memory object accessed by [code]#dest#.
[code]#src# must be a host pointer and must have at least
as many bytes as the range accessed by [code]#dest#.  The type
[code]#SrcT# must be <<device-copyable>>.

a@
[source]
----
template <typename SrcT, int SrcDims, access_mode SrcMode, target SrcTgt,
          access::placeholder IsSrcPlaceholder, typename DestT, int DestDims,
          access_mode DestMode, target DestTgt,
          access::placeholder IsDestPlaceholder>
void copy(accessor<SrcT, SrcDims, SrcMode, SrcTgt, IsSrcPlaceholder> src,
          accessor<DestT, DestDims, DestMode, DestTgt, IsDestPlaceholder> dest)
----
a@ Copies the contents of the memory object accessed by [code]#src#
into the memory object accessed by [code]#dest#.  The size of the [code]#src#
accessor determines the number of bytes that are copied, and [code]#dest# must
have at least this many bytes.  If the size of [code]#dest# is too small, the
implementation throws a synchronous [code]#exception# with the
[code]#errc::invalid# error code.

a@
[source]
----
template <typename T, int Dims, access_mode Mode, target Tgt,
          access::placeholder IsPlaceholder>
void update_host(accessor<T, Dims, Mode, Tgt, IsPlaceholder> acc)
----
a@ The contents of the memory object accessed via [code]#acc#
on the host are guaranteed to be up-to-date after this
<<command-group>> object execution is complete.

a@
[source]
----
template <typename T, int Dims, access_mode Mode, target Tgt,
          access::placeholder IsPlaceholder>
void fill(accessor<T, Dims, Mode, Tgt, IsPlaceholder> dest, const T& src)
----
a@ Replicates the value of [code]#src# into the
memory object accessed by [code]#dest#.

a@
[source]
----
void memcpy(void* dest, const void* src, size_t numBytes)
----
a@ Copies [code]#numBytes# of data from the pointer [code]#src# to the pointer
[code]#dest#.  The [code]#dest# and [code]#src# parameters must each either be
a host pointer or a pointer within a USM allocation that is accessible on the
handler's device.  If a pointer is to a USM allocation, that allocation must
have been created from the same context as the handler's queue.  For more
detail on USM, please see <<sec:usm>>.

a@
[source]
----
template <typename T> void copy(const T* src, T* dest, size_t count)
----
a@ Copies [code]#count# elements of type [code]#T# from the pointer [code]#src#
to the pointer [code]#dest#.  The [code]#dest# and [code]#src# parameters must
each either be a host pointer or a pointer within a USM allocation that is
accessible on the handler's device.  If a pointer is to a USM allocation, that
allocation must have been created from the same context as the handler's queue.
For more detail on USM, please see <<sec:usm>>.

The type [code]#T# must be <<device-copyable>>.

a@
[source]
----
void memset(void* ptr, int value, size_t numBytes)
----
a@ Fills [code]#numBytes# bytes of memory beginning at address [code]#ptr#
with [code]#value#.  The [code]#ptr# must point within a USM allocation from
the same context as the handler's queue, and the pointer must be accessible
from the queue's device.  Note that [code]#value# is interpreted as an
[code]#unsigned char#.  For more detail on USM, please see <<sec:usm>>.

a@
[source]
----
template <typename T> void fill(void* ptr, const T& pattern, size_t count)
----
a@ Replicates the provided [code]#pattern# into the memory at address
[code]#ptr#.  The [code]#ptr# must point within a USM allocation from the same
context as the handler's queue, and the pointer must be accessible from the
queue's device.  The [code]#pattern# is filled [code]#count# times.  For more
detail on USM, please see <<sec:usm>>.

The type [code]#T# must be <<device-copyable>>.

a@
[source]
----
void prefetch(void* ptr, size_t numBytes)
----
a@ Enqueues a prefetch of [code]#num_bytes# of data starting at address
[code]#ptr#.  The [code]#ptr# must point within a USM allocation from the same
context as the handler's queue, and the pointer must be accessible from the
queue's device.  For more detail on USM, please see <<sec:usm>>.

a@
[source]
----
void mem_advise(void* ptr, size_t numBytes, int advice)
----
a@ Enqueues a command that provides information to the implementation about a
region of USM starting at [code]#ptr# and extending for [code]#numBytes# bytes.
The [code]#ptr# must point within a USM allocation from the same context as the
handler's queue, and the pointer must be accessible from the queue's device.
The values for [code]#advice# are vendor- or backend-specific, with the
exception of the value [code]#0# which reverts the advice for [code]#ptr# to
the default behavior.  For more detail on USM, please see <<sec:usm>>.

|====


The listing below illustrates how to use explicit copy
operations in SYCL. The example copies half of the contents of
a [code]#std::vector# into the device, leaving the rest of the
contents of the buffer on the device unchanged.

[source,,linenums]
----
include::{code_dir}/explicitcopy.cpp[lines=4..-1]
----


// %%%%%%%%%%%%%%%%%%%%%%%%%%%% end sycl_explicit_memory %%%%%%%%%%%%%%%%%%%%%%%%%%%%


[[sec:handler.usekernelbundle]]
==== Functions for using a kernel bundle

[source,,linenums]
----
include::{header_dir}/handler/useKernelBundle.h[lines=4..-1]
----

_Effects:_ The <<command-group>> associated with the [code]#handler# will use
<<device-image,device images>> of the [code]#kernel_bundle# [code]#execBundle#
in any of its <<kernel-invocation-command,kernel invocation commands>>.  If the
[code]#kernel_bundle# contains multiple <<device-image,device images>> that are
compatible with the <<device>> to which the kernel is submitted, then the
<<device-image>> chosen is implementation-defined.

If the <<command-group>> attempts to invoke a kernel that is not contained by
a compatible device image in [code]#execBundle#, the
<<kernel-invocation-command>> throws a synchronous [code]#exception# with the
[code]#errc::kernel_not_supported# error code.  If the <<command-group>> has a
secondary queue, then the [code]#execBundle# must contain a kernel that is
compatible with both the primary queue's device and the secondary queue's
device, otherwise the <<kernel-invocation-command>> throws this exception.

Since the handler method for setting specialization constants is incompatible
with the kernel bundle method, applications should not call this function if
[code]#handler::set_specialization_constant()# has been previously called for
this same <<command-group>>.

_Throws:_

  * An [code]#exception# with the [code]#errc::invalid# error code if the
    <<context>> associated with the <<handler>> via its associated primary
    <<queue>> or the <<context>> associated with the secondary <<queue>> (if
    provided) is different from the <<context>> associated with the
    <<kernel-bundle>> specified by [code]#execBundle#.

  * An [code]#exception# with the [code]#errc::invalid# error code if
    [code]#handler::set_specialization_constant()# has been called for this
    <<command-group>>.


=== Specialization constants

Device code can make use of <<specialization-constant,specialization constants>>
which represent constants whose values can be set dynamically during execution
of the <<sycl-application>>.  The values of these constants are fixed when a
<<sycl-kernel-function>> is invoked, and they do not change during the
execution of the kernel.  However, the application is able to set a new value
for a specialization constant each time a kernel is invoked, so the values can
be tuned differently for each invocation.

There are two methods for an application to use specialization constants, one
method requires creating a [code]#kernel_bundle# object and the other does not.
The syntax for both methods is mostly the same.  Both methods declare
specialization constants in the same way, and kernels read their values in the
same way.  The main difference is whether their values are set via
[code]#handler::set_specialization_constant()# or via
[code]#kernel_bundle::set_specialization_constant()#.  These two methods are
incompatible with one another, so they may not both be used by the same
<<command-group>>.

[NOTE]
====
Implementations that support online compilation of kernel bundles will likely
implement both methods of specialization constants using kernel bundles.
Therefore, applications should expect that there is some overhead associated
with invoking a kernel with new values for its specialization constants.  A
typical implementation records the values of specialization constants set via
[code]#handler::set_specialization_constant()# and remembers these values until
a kernel is invoked (e.g. via [code]#parallel_for()#).  At this point, the
implementation determines the bundle that contains the invoked kernel.  If
that bundle has already been compiled for the handler's device and compiled
with the correct values for the specialization constants, the kernel is
scheduled for invocation.  Otherwise, the implementation compiles the
bundle before scheduling the kernel for invocation.  Therefore, applications
that frequently change the values of specialization constants may see an
overhead associated with recompilation of the kernel's bundle.
====


==== Declaring a specialization constant

Specialization constants must be declared using the [code]#specialization_id#
class with the following restrictions:

* the template parameter [code]#T# must be a <<device copyable>> type;
* the [code]#specialization_id# variable must be declared as [code]#constexpr#;
* the [code]#specialization_id# variable must be declared in either namespace
  scope or in class scope;
* if the [code]#specialization_id# variable is declared in class scope, it must
  have public accessibility when referenced from namespace scope;
* the [code]#specialization_id# variable may not be shadowed by another
  identifier [code]#X# which has the same name and is declared in an
  [code]#inline# namespace, such that the [code]#specialization_id# variable is
  no longer accessible after the declaration of [code]#X#;
* if the [code]#specialization_id# variable is declared in a namespace, none of
  the enclosing namespace names [code]#N# may be shadowed by another identifier
  [code]#X# which has the same name as [code]#N# and is declared in an
  [code]#inline# namespace, such that [code]#N# is no longer accessible after
  the declaration of [code]#X#.

[NOTE]
====
The expectation is that some implementations may conceptually insert code at
the end of a translation unit which references each `specialization_id`
variable that is declared in that translation unit.  The restrictions listed
above make this possible by ensuring that these variables are accessible at the
end of the translation unit.
====

The following example illustrates some of these restrictions:

[source,,linenums]
----
include::{code_dir}/specialization_id.cpp[lines=4..-1]
----

A synopsis of this class is shown below.

[source,,linenums]
----
include::{header_dir}/expressingParallelism/classSpecializationId.h[lines=4..-1]
----

===== Constructors

[source]
----
template <class... Args> explicit constexpr specialization_id(Args&&... args);
----

_Constraints:_ Available only when [code]#+std::is_constructible_v<T, Args...>+#
evaluates to [code]#true#.

_Effects:_ Constructs a [code]#specialization_id# containing an instance of
[code]#T# initialized with [code]#+args...+#, which represents the
specialization constant's default value.

===== Special member functions

[source]
----
specialization_id(const specialization_id& rhs) = delete;            // (1)
specialization_id(specialization_id&& rhs) = delete;                 // (2)
specialization_id& operator=(const specialization_id& rhs) = delete; // (3)
specialization_id& operator=(specialization_id&& rhs) = delete;      // (4)
----

  . Deleted copy constructor.
  . Deleted move constructor.
  . Deleted copy assignment operator.
  . Deleted move assignment operator.


==== Setting and getting the value of a specialization constant

If the application uses specialization constants without creating a
[code]#kernel_bundle# object, it can set and get their values from
<<command-group-scope>> by calling member functions of the [code]#handler#
class.  These member functions have a template parameter [code]#SpecName# whose
value must be a reference to a variable of type [code]#specialization_id#,
which defines the type and default value of the specialization constant.

When not using a kernel bundle, the value of a specialization constant that is
used in a kernel invoked from a <<command-group>> is affected by calls to set
its value from that same <<command-group>>, but it is not affected by calls
from other <<command-group,command groups>> even if those calls are from
another invocation of the same <<command-group-function-object>>.

[source]
----
template <auto& SpecName>
void set_specialization_constant(
    typename std::remove_reference_t<decltype(SpecName)>::value_type value);
----

_Effects:_ Sets the value of the specialization constant whose address is
[code]#SpecName# for this handler's <<command-group>>.  If the specialization
constant's value was previously set in this same <<command-group>>, the value
is overwritten.

This function may be called even if the specialization constant
[code]#SpecName# isn't used by the kernel that is invoked by this handler's
<<command-group>>.  Doing so has no effect on the invoked kernel.

_Throws:_

  * An [code]#exception# with the [code]#errc::invalid# error code if
    a kernel bundle has been bound to the [code]#handler# via
    [code]#use_kernel_bundle()#.

[source]
----
template <auto& SpecName>
typename std::remove_reference_t<decltype(SpecName)>::value_type
get_specialization_constant();
----

_Returns:_ The value of the specialization constant whose address is
[code]#SpecName# for this handler's <<command-group>>.  If the value was
previously set in this handler's <<command-group>>, that value is returned.
Otherwise, the specialization constant's default value is returned.

_Throws:_

  * An [code]#exception# with the [code]#errc::invalid# error code if
    a kernel bundle has been bound to the [code]#handler# via
    [code]#use_kernel_bundle()#.


[[sec:spec-constants.device-code]]
==== Reading the value of a specialization constant from device code

In order to read the value of a specialization constant from device code, the
<<sycl-kernel-function>> must be declared to take an object of type
[code]#kernel_handler# as its last parameter.  The <<sycl-runtime>> constructs
this object, which has a member function for reading the specialization
constant's value.  A synopsis of this class is shown below.

[source,,linenums]
----
include::{header_dir}/expressingParallelism/classKernelHandler.h[lines=4..-1]
----


===== Member functions

[source,,linenums]
----
template<auto& SpecName>
typename std::remove_reference_t<decltype(SpecName)>::value_type
get_specialization_constant();
----

_Returns:_ The value of the <<specialization-constant>> whose address is
[code]#SpecName#.  For a kernel invoked from a <<command-group>> that was not
bound to a kernel bundle, the value is the same as what would have been
returned if [code]#handler::get_specialization_constant()# was called
immediately before invoking the kernel.  For a kernel invoked from a
<<command-group>> that was bound to a kernel bundle, the value is the same as
what would be returned if [code]#kernel_bundle::get_specialization_constant()#
was called on the bound bundle.


==== Example usage

The following example performs a convolution and uses
<<specialization-constant,specialization constants>> to set the values of the
coefficients.

[source,,linenums]
----
include::{code_dir}/usingSpecConstants.cpp[lines=4..-1]
----


[[subsec:interfaces.hosttasks]]
== Host tasks


[[sec:interfaces.hosttasks.overview]]
=== Overview

A <<host-task>> is a native {cpp} callable which is scheduled by the
<<sycl-runtime>>. A <<host-task>> is submitted to a <<queue>> via a
<<command-group>> by a <<host-task-command>>.

When a <<host-task-command>> is submitted to a <<queue>> it is scheduled
based on its data dependencies with other <<command,commands>> including
<<kernel-invocation-command,kernel invocation commands>> and asynchronous copies, resolving any
requisites created by <<accessor,accessors>> attached to the <<command-group>> as
defined in <<sub.section.memmodel.app>>.

Since a <<host-task>> is invoked directly by the <<sycl-runtime>> rather
than being compiled as a <<sycl-kernel-function>>, it does not have the same
restrictions as a <<sycl-kernel-function>>, and can therefore contain any
arbitrary {cpp} code.

Capturing <<accessor,accessors>> in a <<host-task>> is allowed, however,
capturing or using any other SYCL class that has reference semantics (see
<<sec:reference-semantics>>) is undefined behavior.

A <<host-task>> can be enqueued on any <<queue>> and the callable will be
invoked directly by the SYCL runtime, regardless of which <<device>> the
<<queue>> is associated with.

A <<host-task>> is enqueued on a <<queue>> via the [code]#host_task#
member function of the [code]#handler# class.
The <<event>> returned by the submission of the associated <<command group>>
enters the completed state (corresponding to a status of
[code]#info::event_command_status::complete#) once the invocation of the
provided {cpp} callable has returned.
Any uncaught exception thrown during the execution of a <<host-task>> will be
turned into an <<async-error>> that can be handled as described in
<<subsubsec:exception.async>>.

A <<host-task>> can optionally be used to interoperate with the
<<native-backend-object,native backend objects>> associated with the <<queue>> executing the
<<host-task>>, the <<context>> that the <<queue>> is associated with, the
<<device>> that the <<queue>> is associated with  and the <<accessor,accessors>>
that have been captured in the callable, via an optional
[code]#interop_handle# parameter.

This allows <<host-task,host tasks>> to be used for two purposes: either as a
task which can perform arbitrary {cpp} code within the scheduling of the
<<sycl-runtime>> or as a task which can perform interoperability at a point
within the scheduling of the <<sycl-runtime>>.

For the former use case, construct a buffer accessor with
[code]#target::host_task# or an image accessor with
[code]#image_target::host_task#.  This makes the buffer or image available
on the host during execution of the <<host-task>>.

For the latter case, construct a buffer accessor with
[code]#target::device# or [code]#target::constant_buffer#, or construct
an image accessor with [code]#image_target::device#.  This makes the buffer or
image available on the device that is associated with the queue used to submit
the <<host-task>>, so that it can be accessed via interoperability member
functions provided by the [code]#interop_handle# class.

Local <<accessor,accessors>> cannot be used within a <<host-task>>.

// TODO: access mode/target resolution rules

[source,,linenums]
----
include::{header_dir}/hostTask/hostTaskSynopsis.h[lines=4..-1]
----


[[subsec:interfaces.hosttasks.interophandle]]
=== Class [code]#interop_handle#

The [code]#interop_handle# class is an abstraction over the <<queue>>
which is being used to invoke the <<host-task>> and its associated
<<device>> and <<context>>. It also represents the state of the
<<sycl-runtime>> dependency model at the point the <<host-task>> is invoked.

The [code]#interop_handle# class provides access to the
<<native-backend-object>> associated with the <<queue>>, <<device>>,
<<context>> and any <<buffer,buffers>> or <<image,images>> that are captured in
the callable being invoked in order to allow a <<host-task>> to be used
for interoperability purposes.

An [code]#interop_handle# cannot be constructed by user-code, only by the
<<sycl-runtime>>.

[source,,linenums]
----
include::{header_dir}/hostTask/classInteropHandle.h[lines=4..-1]
----


[[subsec:interfaces.hosttask.interophandle.ctrs]]
==== Constructors

[source,,linenums]
----
include::{header_dir}/hostTask/classInteropHandle/constructors.h[lines=4..-1]
----

  . Private implementation-defined constructor with unspecified arguments so
    that the <<sycl-runtime>> can construct a [code]#interop_handle#.
  . Explicitly deleted default constructor.

[[subsec:interfaces.hosttask.interophandle.getbackend]]
==== Member functions

[source,,linenums]
----
include::{header_dir}/hostTask/classInteropHandle/getbackend.h[lines=4..-1]
----

  . _Returns:_ Returns a [code]#backend# identifying the <<backend>> associated
      with the <<queue>> associated with this [code]#interop_handle#.

[[subsec:interfaces.hosttask.interophandle.getnative]]
==== Template member functions [code]#get_native_*#

[source,,linenums]
----
include::{header_dir}/hostTask/classInteropHandle/getnativeX.h[lines=4..-1]
----

  . _Constraints:_ Available only if the optional interoperability
    function [code]#get_native# taking a [code]#buffer# is
    available and if [code]#accTarget# is
    [code]#target::device#.
+
--
_Returns:_ The <<native-backend-object>> associated with the underlying
<<buffer>> of <<accessor>> [code]#bufferAcc#.  The <<native-backend-object>>
returned must be in a state where it represents the memory in its current state
within the <<sycl-runtime>> dependency model and is capable of being used in a
way appropriate for the associated <<backend>>. It is undefined behavior to use
the <<native-backend-object>> outside of the scope of the <<host-task>>.

_Throws:_ An [code]#exception# with the [code]#errc::invalid# error code if the
<<accessor>> [code]#bufferAcc# was not registered with the
<<command-group>> which contained the <<host-task>>. Must throw an [code]#exception# with the
[code]#errc::backend_mismatch# error code if [code]#Backend != get_backend()#.
--
  . _Constraints:_ Available only if the optional interoperability
    function [code]#get_native# taking an [code]#unsampled_image#
    is available.
+
--
_Returns:_ The <<native-backend-object>> associated with with the underlying
[code]#unsampled_image# of <<accessor>> [code]#imageAcc#. The
<<native-backend-object>> returned must be in a state where it represents the
memory in its current state within the <<sycl-runtime>> dependency model and is
capable of being used in a way appropriate for the associated <<backend>>. It
is undefined behavior to use the <<native-backend-object>> outside of the scope
of the <<host-task>>.

_Throws:_ An [code]#exception# with the [code]#errc::invalid# error code if the
<<accessor>> [code]#imageAcc# was not registered with the
<<command-group>> which contained the <<host-task>>.
--
  . _Constraints:_ Available only if the optional interoperability
    function [code]#get_native# taking an [code]#sampled_image#
    is available.
+
--
_Returns:_ The <<native-backend-object>> associated with with the underlying
[code]#sampled_image# of <<accessor>> [code]#imageAcc#. The
<<native-backend-object>> returned must be in a state where it represents the
memory in its current state within the <<sycl-runtime>> dependency model and is
capable of being used in a way appropriate for the associated <<backend>>. It
is undefined behavior to use the <<native-backend-object>> outside of the scope
of the <<host-task>>.

_Throws:_ An [code]#exception# with the [code]#errc::invalid# error code if the
<<accessor>> [code]#imageAcc# was not registered with the
<<command-group>> which contained the <<host-task>>. Must throw an [code]#exception# with the
[code]#errc::backend_mismatch# error code if [code]#Backend != get_backend()#.
--
  . _Constraints:_ Available only if the optional interoperability
    function [code]#get_native# taking a [code]#queue# is
    available.
+
--
_Returns:_ The <<native-backend-object>> associated with the <<queue>> that the
<<host-task>> was submitted to. If the <<command-group>> was submitted with a
secondary <<queue>> and the fall-back was triggered, the <<queue>> that is
associated with the [code]#interop_handle# must be the fall-back <<queue>>. The
<<native-backend-object>> returned must be in a state where it is capable of
being used in a way appropriate for the associated <<backend>>. It is undefined
behavior to use the <<native-backend-object>> outside of the scope of the
<<host-task>>.

_Throws:_ Must throw an [code]#exception# with the
[code]#errc::backend_mismatch# error code if [code]#Backend != get_backend()#.
--
  . _Constraints:_ Available only if the optional interoperability
    function [code]#get_native# taking a [code]#device# is
    available.
+
--
_Returns:_ The <<native-backend-object>> associated with the <<device>> that is
associated with the <<queue>> that the <<host-task>> was submitted to.  The
<<native-backend-object>> returned must be in a state where it is capable of
being used in a way appropriate for the associated <<backend>>.  It is
undefined behavior to use the <<native-backend-object>> outside of the scope of
the <<host-task>>.

_Throws:_ Must throw an [code]#exception# with the
[code]#errc::backend_mismatch# error code if [code]#Backend != get_backend()#.
--
  . _Constraints:_ Available only if the optional interoperability
    function [code]#get_native# taking a [code]#context# is
    available.
+
--
_Returns:_ The <<native-backend-object>> associated with the <<context>> that
is associated with the <<queue>> that the <<host-task>> was submitted to.  The
<<native-backend-object>> returned must be in a state where it is capable of
being used in a way appropriate for the associated <<backend>>.  It is
undefined behavior to use the <<native-backend-object>> outside of the scope of
the <<host-task>>.

_Throws:_ Must throw an [code]#exception# with the
[code]#errc::backend_mismatch# error code if [code]#Backend != get_backend()#.
--


[[subsec:interfaces.hosttask.handler]]
=== Additions to the [code]#handler# class

This section describes member functions in the <<handler>> class that are
used with host tasks.

[source,,linenums]
----
include::{header_dir}/hostTask/classHandler/hostTask.h[lines=4..-1]
----

  . _Effects:_ Enqueues an implementation-defined command to the
    <<sycl-runtime>> to invoke [code]#hostTaskCallable# exactly once. The
    scheduling of the invocation of [code]#hostTaskCallable# in relation to
    other <<command,commands>> enqueued to the <<sycl-runtime>> must be in accordance
    with the dependency model described in <<sub.section.memmodel.app>>.
    Initializes an [code]#interop_handle# object and passes it to
    [code]#hostTaskCallable# when it is invoked if
    [code]#std::is_invocable_v<T, interop_handle># evaluates to
    [code]#true#, otherwise invokes [code]#hostTaskCallable# as a
    nullary function.


[[sec:interfaces.bundles]]
== Kernel bundles

Kernel bundles provide several features to a <<sycl-application>>.  For
implementations that support an online compiler, they provide fine grained
control over the online compilation of device code.  For example, an
application can use a kernel bundle to compile its <<kernel,kernels>> at a
specific time during the application's execution (such as during its
initialization), rather than relying on the implementation's default behavior
(which may not compile kernels until they are submitted).

Kernel bundles also provide a way for the application to set the values of
specialization constants in many kernels before any of them are submitted to
a device, which could potentially be more efficient in some cases.

Kernel bundles provide a way for the application to introspect its kernels.
For example, an application can use a bundle to query a kernel's work-group
size when it is run on a specific device.

Finally, kernel bundles provide an extension point to interoperate with backend
and device specific features.  Some examples of this include invocation of
device specific built-in kernels, online compilation of kernel code with vendor
specific options, or interoperation with kernels created with backend APIs.


=== Overview

A kernel bundle is a high-level abstraction which represents a set of
<<kernel,kernels>> that are associated with a <<context>> and can be executed
on a number of <<device,devices>>, where each device is associated with that
same context.  Depending on how a bundle is obtained, it could represent all of
the <<sycl-kernel-function,SYCL kernel functions>> in the <<sycl-application>>,
or a certain subset of them.

A kernel bundle is composed of one or more <<device-image,device images>>,
where each device image is an indivisible unit of compilation and/or linking.
When the <<sycl-runtime>> compiles or links one of the kernels represented by
the device image, it must also compile or link any other kernels the device
image represents.  Once a device image is compiled and linked, any of the other
kernels which that device image represents may be invoked without further
compilation or linking.

Each <<sycl-kernel-function>> a bundle represents must reside in at least one
of the bundle's device images.  However, it is not necessary for each device
image to contain all of the kernel functions that the bundle represents.  The
granularity in which kernel functions are grouped into device images is an
implementation detail.

[NOTE]
====
To illustrate the intent of device images, a hypothetical implementation could
represent an application's kernel functions in both the SPIR-V format and also
in a native device code format.  The implementation's ahead-of-time compiler
in this example produces device images with native code for certain devices and
also produces SPIR-V device images for use with other devices.  Note that in
such an implementation, a particular kernel function could be represented in
more than one device image.

An implementation could choose to have all kernel functions from all
translation units grouped together in a single device image, to have each
kernel function represented in its own device image, or to group kernel
functions in some other way.
====

Each device associated with a kernel bundle must have at least one compatible
device image, meaning that the implementation can either invoke the image's
kernel functions directly on the device or that the implementation can
translate the device image into a format that allows it to invoke the kernel
functions.

An outcome of this definition is that each kernel function in a bundle must be
invocable on at least one of the devices associated with the bundle.  However,
it is not necessary for every kernel function in the bundle to be invocable on
every associated device.

[NOTE]
====
One common reason why a kernel function might not be invocable on every device
associated with a bundle is if the kernel uses optional device features.  It's
possible that these features are available to only some devices in the bundle.

The use of optional device features could affect how the implementation groups
kernels into device images, depending on how these features are represented.
For example, consider an implementation where the optional feature is
represented in SPIR-V but translation of that SPIR-V into native code will fail
if the target device does not support the feature.  In such an implementation,
kernels that use optional features should not be grouped into the same device
image as kernels that do not use these features.  Since a device image is an
indivisible unit of compilation, doing so would cause a compilation failure if
a kernel K1 is invoked on a device D1 if K1 happened to reside in the same
device image as another kernel K2 that used a feature which is not supported on
device D1.

See <<sec:optional-kernel-features>> for more about optional device features.
====

A <<sycl-application>> can obtain a kernel bundle by calling one of the
overloads of the [code]#get_kernel_bundle()# free function.  Certain backends
may provide additional mechanisms for obtaining bundles with other
representations.  If this is supported, the backend specification document will
describe the details.

Once a kernel bundle has been obtained there are a number of free functions for
performing compilation, linking and joining.  Once a bundle is compiled and
linked, the application can invoke kernels from the bundle by calling
[code]#handler::use_kernel_bundle()# as described in
<<sec:handler.usekernelbundle>>.


[[sec:interfaces.bundles.overview.synopsis]]
=== Synopsis

[source,,linenums]
----
include::{header_dir}/bundle/freeFunctions.h[lines=4..-1]
----


=== Fixed-function built-in kernels

SYCL allows a <<backend>> to expose fixed functionality as non-programmable
built-in kernels.  The availability and behavior of these built-in kernels are
backend specific and are not required to follow the SYCL execution and memory
models.  However, the basic interface is common to all backends.


[[sec:interfaces.bundles.bundlestate]]
=== Bundle states

A <<kernel-bundle>> can be in one of three different
<<bundle-state,bundle states>> which are represented by an enum class called
[code]#bundle_state#.  <<table.bundles.states>> describes the semantics of
these three states.

The states form a progression.  A bundle in [code]#bundle_state::input# can
be translated into [code]#bundle_state::object# by online compilation of the
bundle.  A bundle in [code]#bundle_state::object# can be translated into
[code]#bundle_state::executable# by online linking.

[NOTE]
====
Each implementation is free to define the "online compilation" and "online
linking" operations as it sees fit, so long as this progression of bundle
states is preserved and so long as the bundles in each state behave as
specified.
====

There is no requirement that an implementation must expose kernels in
[code]#bundle_state::input# or [code]#bundle_state::object#.  In fact, an
implementation could expose some kernels in these states but not others.  For
example, this behavior could be controlled by implementation specific options
to the ahead-of-time compiler.  Kernels that are not exposed in these states
cannot be online compiled or online linked by the application.

All kernels defined in the <<sycl-application>>, however, must be exposed in
[code]#bundle_state::executable# because this is the only state that allows a
kernel to be invoked on a device.  Device built-in kernels are also exposed
in [code]#bundle_state::executable#.

If an application exposes a bundle in [code]#bundle_state::input# for a device
D, then the implementation must also provide an online compiler for device D.
Therefore, an application need not explicitly test for
[code]#aspect::online_compiler# if it successfully obtains a bundle in
[code]#bundle_state::input# for that device.  Likewise, an implementation must
provide an online linker for device D if it exposes a bundle in
[code]#bundle_state::object# for device D.

[[table.bundles.states]]
.Enumeration of possible bundle states
[width="100%",options="header",separator="@",cols="35%,65%"]
|====
@ Bundle State @ Description
a@
[source]
----
bundle_state::input
----
   a@ The <<device-image,device images>> in the kernel bundle have a format
      that must be compiled and linked before their kernels can be invoked.
      For example, an implementation could use this state for device images
      that are stored in an intermediate language format or for device images
      that are stored as source code strings.

a@
[source]
----
bundle_state::object
----
   a@ The <<device-image,device images>> in the kernel bundle have a format
      that must be linked before their kernels can be invoked.

a@
[source]
----
bundle_state::executable
----
   a@ The <<device-image,device images>> in the kernel bundle are in a format
      that allows them to be invoked on a device.  For example, an
      implementation could use this state for device images that have been
      compiled into the device's native code.

|====


=== Kernel identifiers

Some of the functions related to kernel bundles take an input parameter of type
[code]#kernel_id# which identifies a kernel.  A synopsis of the
[code]#kernel_id# class is shown below along with a description of its member
functions.  Additionally, this class provides the common special member
functions and common member functions that are listed in
<<sec:reference-semantics>> in <<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>>, respectively.

As with all SYCL objects that have the common reference semantics, kernel
identifiers are equality comparable.  Two [code]#kernel_id# objects compare
equal if and only if they refer to the same application kernel or to the same
device built-in kernel.

There is no public default constructor for this class.

[source,,linenums]
----
include::{header_dir}/bundle/kernelIdClass.h[lines=4..-1]
----

[source]
----
const char* get_name() const noexcept;
----

_Returns:_ An implementation-defined null-terminated string containing the
name of the kernel.  There is no guarantee that this name is unique amongst
all the kernels, nor is there a guarantee that the name is stable from one
run of the application to another.  The lifetime of the memory containing the
name is unspecified.

[NOTE]
====
In practice, the lifetime of the memory containing the name will typically
extend until the application terminates, unless the kernel associated with
the name comes from a dynamic library.  In this case, the lifetime of the
memory may end if the dynamic library is unloaded.
====


=== Obtaining a kernel identifier

An application can obtain an identifier for a kernel that is defined in the
application by calling one of the following free functions, or it may obtain an
identifier for a device's built-in kernels by querying the device with
[code]#info::device::built_in_kernel_ids#.

[source]
----
template <typename KernelName> kernel_id get_kernel_id();
----

_Preconditions:_ The template parameter [code]#KernelName# must be the
<<type-kernel-name>> of a kernel that is defined in the <<sycl-application>>.
Since lambda functions have no standard type name, kernels defined as lambda
functions must specify a [code]#KernelName# in their
<<kernel-invocation-command>> in order to obtain their identifier via this
function.  Applications which call [code]#get_kernel_id()# for a
[code]#KernelName# that is not defined are ill formed, and the implementation
must issue a diagnostic in this case.

_Returns:_ The identifier of the kernel associated with [code]#KernelName#.

[source]
----
std::vector<kernel_id> get_kernel_ids();
----

_Returns:_ A vector with the identifiers for all kernels defined in the
<<sycl-application>>.  This does not include identifiers for any device
built-in kernels.


=== Obtaining a kernel bundle

A <<sycl-application>> can obtain a kernel bundle by calling one of the
overloads of the free function [code]#get_kernel_bundle()#.  The implementation
may return a bundle that consists of device images that were created by the
ahead-of-time compiler, or it may call the online compiler or linker to create
the bundle's device images in the requested state.  A bundle may also contain
device images that represent a device's built-in kernels.

When [code]#get_kernel_bundle()# is used to obtain a kernel bundle in
[code]#bundle_state::object# or [code]#bundle_state::executable#, any
specialization constants in the bundle will have their default values.

[source]
----
template <bundle_state State>
kernel_bundle<State> get_kernel_bundle(const context& ctxt,
                                       const std::vector<device>& devs);
----

_Returns:_ A kernel bundle in state [code]#State# which contains all of the
<<kernel,kernels>> in the application which are compatible with at least one of
the devices in [code]#devs#.  This does not include any device built-in kernels.
The bundle's set of associated devices is [code]#devs# (with any duplicate
devices removed).

Since the implementation may not represent all kernels in
[code]#bundle_state::input# or [code]#bundle_state::object#, calling this
function with one of those states may return a bundle that is missing some of
the application's kernels.

_Throws:_

  * An [code]#exception# with the [code]#errc::invalid# error code if any of
    the devices in [code]#devs# is not one of devices contained by the context
    [code]#ctxt# or is not a <<descendent-device>> of some device in
    [code]#ctxt#.
  * An [code]#exception# with the [code]#errc::invalid# error code if the
    [code]#devs# vector is empty.
  * An [code]#exception# with the [code]#errc::invalid# error code if
    [code]#State# is [code]#bundle_state::input# and any device in [code]#devs#
    does not have [code]#aspect::online_compiler#.
  * An [code]#exception# with the [code]#errc::invalid# error code if
    [code]#State# is [code]#bundle_state::object# and any device in [code]#devs#
    does not have [code]#aspect::online_linker#.
  * An [code]#exception# with the [code]#errc::build# error code if
    [code]#State# is [code]#bundle_state::object# or
    [code]#bundle_state::executable#, if the implementation needs to perform an
    online compile or link, and if the online compile or link fails.

[source]
----
template <bundle_state State>
kernel_bundle<State> get_kernel_bundle(const context& ctxt,
                                       const std::vector<device>& devs,
                                       const std::vector<kernel_id>& kernelIds);
----

_Returns:_ A kernel bundle in state [code]#State# which contains all of the
device images that are compatible with at least one of the devices in
[code]#devs#, further filtered to contain only those device images that contain
at least one of the kernels with the given identifiers.  These identifiers may
represent kernels that are defined in the application, device built-in kernels,
or a mixture of the two.  Since the device images may group many kernels
together, the returned bundle may contain additional kernels beyond those that
are requested in [code]#kernelIds#.  The bundle's set of associated devices is
[code]#devs# (with duplicate devices removed).

Since the implementation may not represent all kernels in
[code]#bundle_state::input# or [code]#bundle_state::object#, calling this
function with one of those states may return a bundle that is missing some of
the kernels in [code]#kernelIds#.  The application can test for this via
[code]#kernel_bundle::has_kernel()#.

_Throws:_

  * An [code]#exception# with the [code]#errc::invalid# error code if any of
    the kernels identified by [code]#kernelIds# are incompatible with all
    devices in [code]#devs#.
  * An [code]#exception# with the [code]#errc::invalid# error code if any of
    the devices in [code]#devs# is not one of devices contained by the context
    [code]#ctxt# or is not a <<descendent-device>> of some device in
    [code]#ctxt#.
  * An [code]#exception# with the [code]#errc::invalid# error code if the
    [code]#devs# vector is empty.
  * An [code]#exception# with the [code]#errc::invalid# error code if
    [code]#State# is [code]#bundle_state::input# and any device in [code]#devs#
    does not have [code]#aspect::online_compiler#.
  * An [code]#exception# with the [code]#errc::invalid# error code if
    [code]#State# is [code]#bundle_state::object# and any device in [code]#devs#
    does not have [code]#aspect::online_linker#.
  * An [code]#exception# with the [code]#errc::build# error code if
    [code]#State# is [code]#bundle_state::object# or
    [code]#bundle_state::executable#, if the implementation needs to perform an
    online compile or link, and if the online compile or link fails.

[source]
----
template <bundle_state State, typename Selector>
kernel_bundle<State> get_kernel_bundle(const context& ctxt,
                                       const std::vector<device>& devs,
                                       Selector selector);
----

_Preconditions:_ The [code]#selector# must be a unary predicate whose return
value is convertible to [code]#bool# and whose parameter is
[code]#const device_image<State>&#.

_Effects:_ The predicate function [code]#selector# is called once for every
device image in the application of state [code]#State# which is compatible
with at least one of the devices in [code]#devs#.  The function's return value
determines whether a device image is included in the new kernel bundle.  The
[code]#selector# is called only for device images that contain kernels defined
in the application, not for device images that contain device built-in kernels.

_Returns:_ A kernel bundle in state [code]#State# which contains all of the
device images for which the [code]#selector# returns [code]#true#.  The
bundle's set of associated devices is [code]#devs# (with duplicate devices
removed).

_Throws:_

  * An [code]#exception# with the [code]#errc::invalid# error code if any of
    the devices in [code]#devs# is not one of devices contained by the context
    [code]#ctxt# or is not a <<descendent-device>> of some device in
    [code]#ctxt#.
  * An [code]#exception# with the [code]#errc::invalid# error code if the
    [code]#devs# vector is empty.
  * An [code]#exception# with the [code]#errc::invalid# error code if
    [code]#State# is [code]#bundle_state::input# and any device in [code]#devs#
    does not have [code]#aspect::online_compiler#.
  * An [code]#exception# with the [code]#errc::invalid# error code if
    [code]#State# is [code]#bundle_state::object# and any device in
    [code]#devs# does not have [code]#aspect::online_linker#.

[NOTE]
====
This function is intended to be used in conjunction with backend specific APIs
that allow the application to choose device images based on backend specific
criteria.

This function does not call the online compiler or linker to translate device
images into state [code]#State#.  If the application wants to select specific
device images and also compile or link them into the desired state, it can do
this by calling [code]#compile()# or [code]#link()# and then optionally joining
several bundles together with [code]#join()#.
====

[source]
----
template <bundle_state State> // (1)
kernel_bundle<State> get_kernel_bundle(const context& ctxt);

template <bundle_state State> // (2)
kernel_bundle<State> get_kernel_bundle(const context& ctxt,
                                       const std::vector<kernel_id>& kernelIds);

template <bundle_state State, typename Selector> // (3)
kernel_bundle<State> get_kernel_bundle(const context& ctxt, Selector selector);
----

  . Equivalent to [code]#get_kernel_bundle<State>(ctxt, ctxt.get_devices())#.
  . Equivalent to
    [code]#get_kernel_bundle<State>(ctxt, ctxt.get_devices(), kernelIds)#.
  . Equivalent to
    [code]#get_kernel_bundle<State>(ctxt, ctxt.get_devices(), selector)#.

[source]
----
template <typename KernelName, bundle_state State> // (1)
kernel_bundle<State> get_kernel_bundle(const context& ctxt);

template <typename KernelName, bundle_state State> // (2)
kernel_bundle<State> get_kernel_bundle(const context& ctxt,
                                       const std::vector<device>& devs);
----

_Preconditions:_ The template parameter [code]#KernelName# must be the
<<type-kernel-name>> of a kernel that is defined in the <<sycl-application>>.
Since lambda functions have no standard type name, kernels defined as lambda
functions must specify a [code]#KernelName# in their
<<kernel-invocation-command>> in order to use these functions.  Applications
which call these functions for a [code]#KernelName# that is not defined are ill
formed, and the implementation must issue a diagnostic in this case.

  . Equivalent to
    [code]#get_kernel_bundle<State>(ctxt, ctxt.get_devices(), {get_kernel_id<KernelName>()})#.
  . Equivalent to
    [code]#get_kernel_bundle<State>(ctxt, devs, {get_kernel_id<KernelName>()})#.


=== Querying if a kernel bundle exists

Most overloads of [code]#get_kernel_bundle()# have a matching overload of the
free function [code]#has_kernel_bundle()# which checks to see if a kernel
bundle with the requested characteristics exists.

[source]
----
template <bundle_state State>
bool has_kernel_bundle(const context& ctxt, const std::vector<device>& devs);
----

_Returns:_ [code]#true# only if all of the following are true:

  * The application defines at least one <<kernel>> that is compatible with
    at least one of the devices in [code]#devs#, and that kernel can be
    represented in a device image of state [code]#State#.
  * If [code]#State# is [code]#bundle_state::input#, all devices in
    [code]#devs# have [code]#aspect::online_compiler#.
  * If [code]#State# is [code]#bundle_state::object#, all devices in
    [code]#devs# have [code]#aspect::online_linker#.

_Throws:_

  * An [code]#exception# with the [code]#errc::invalid# error code if any of
    the devices in [code]#devs# is not one of devices contained by the context
    [code]#ctxt# or is not a <<descendent-device>> of some device in
    [code]#ctxt#.
  * An [code]#exception# with the [code]#errc::invalid# error code if the
    [code]#devs# vector is empty.

[source]
----
template <bundle_state State>
bool has_kernel_bundle(const context& ctxt, const std::vector<device>& devs,
                       const std::vector<kernel_id>& kernelIds);
----

_Returns:_ [code]#true# only if all of the following are true:

  * Each of the kernels in [code]#kernelIds# can be represented in a device
    image of state [code]#State#.
  * Each of the kernels in [code]#kernelIds# is compatible with at least one
    of the devices in [code]#devs#.
  * If [code]#State# is [code]#bundle_state::input#, all devices in
    [code]#devs# have [code]#aspect::online_compiler#.
  * If [code]#State# is [code]#bundle_state::object#, all devices in
    [code]#devs# have [code]#aspect::online_linker#.

_Throws:_

  * An [code]#exception# with the [code]#errc::invalid# error code if any of
    the devices in [code]#devs# is not one of devices contained by the context
    [code]#ctxt# or is not a <<descendent-device>> of some device in
    [code]#ctxt#.
  * An [code]#exception# with the [code]#errc::invalid# error code if the
    [code]#devs# vector is empty.

[source]
----
template <bundle_state State> // (1)
bool has_kernel_bundle(const context& ctxt);

template <bundle_state State> // (2)
bool has_kernel_bundle(const context& ctxt,
                       const std::vector<kernel_id>& kernelIds);
----

  . Equivalent to [code]#has_kernel_bundle(ctxt, ctxt.get_devices())#.
  . Equivalent to
    [code]#has_kernel_bundle<State>(ctxt, ctxt.get_devices(), kernelIds)#.

[source]
----
template <typename KernelName, bundle_state State> // (1)
bool has_kernel_bundle(const context& ctxt);

template <typename KernelName, bundle_state State> // (2)
bool has_kernel_bundle(const context& ctxt, const std::vector<device>& devs);
----

_Preconditions:_ The template parameter [code]#KernelName# must be the
<<type-kernel-name>> of a kernel that is defined in the <<sycl-application>>.
Since lambda functions have no standard type name, kernels defined as lambda
functions must specify a [code]#KernelName# in their
<<kernel-invocation-command>> in order to use these functions.  Applications
which call these functions for a [code]#KernelName# that is not defined are ill
formed, and the implementation must issue a diagnostic in this case.

  . Equivalent to
    [code]#has_kernel_bundle<State>(ctxt, {get_kernel_id<KernelName>()})#.
  . Equivalent to
    [code]#has_kernel_bundle<State>(ctxt, devs, {get_kernel_id<KernelName>()})#.


=== Querying if a kernel is compatible with a device

The following free functions allow an application to test whether a particular
kernel is compatible with a device.  A kernel that is defined in the
application is compatible with a device unless:

* It uses optional features which are not supported on the device, as described
  in <<sec:optional-kernel-features>>; or
* It is decorated with a [code]#[[sycl::device_has()]]# {cpp} attribute that
  lists an aspect that is not supported by the device, as described in
  <<sec:kernel.attributes>>; or
* The translation unit containing the kernel was compiled in a compilation
  environment that does not support the device.  Each implementation defines
  the specific criteria for which devices are supported in its compilation
  environment.  For example, this might be dependent on options passed to the
  compiler.

A device built-in kernel is only compatible with the device for which it is
built-in.

[source]
----
bool is_compatible(const std::vector<kernel_id>& kernelIds, const device& dev);
----

_Returns:_ [code]#true# if all of the kernels identified by [code]#kernelIds#
are compatible with the device [code]#dev#.

[source]
----
template <typename KernelName> bool is_compatible(const device& dev);
----

_Preconditions:_ The template parameter [code]#KernelName# must be the
<<type-kernel-name>> of a kernel that is defined in the <<sycl-application>>.
Since lambda functions have no standard type name, kernels defined as lambda
functions must specify a [code]#KernelName# in their
<<kernel-invocation-command>> in order to use this function.  Applications
which call this function for a [code]#KernelName# that is not defined are ill
formed, and the implementation must issue a diagnostic in this case.

Equivalent to
[code]#is_compatible<State>({get_kernel_id<KernelName>()}, dev)#.


=== Joining kernel bundles

Two or more kernel bundles of the same state may be joined together into a
single composite bundle.  Joining bundles together is not the same as online
compiling or linking because it produces a new bundle in the same state as its
inputs.  Rather, joining creates the union of all the devices images from the
input bundles, eliminates duplicate copies of the same device image, and
creates a new bundle from the result.

[source]
----
template <bundle_state State>
kernel_bundle<State> join(const std::vector<kernel_bundle<State>>& bundles);
----

_Returns:_ A new kernel bundle that contains a copy of all the device images in
the input [code]#bundles# with duplicates removed.  The new bundle has the same
associated context and the same set of associated devices as those in
[code]#bundles#.

_Throws:_

  * An [code]#exception# with the [code]#errc::invalid# error code if the
    bundles in [code]#bundles# do not all have the same associated context
    or do not all have the same set of associated devices.


[[sec:bundles.compile-link]]
=== Online compiling and linking

If the implementation provides an online compiler or linker, a
<<sycl-application>> can use the free functions defined in this section to
transform a kernel bundle from [code]#bundle_state::input# into a bundle of
state [code]#bundle_state::object# or to transform a bundle from
[code]#bundle_state::object# into a bundle of state
[code]#bundle_state::executable#.

An application can query whether the implementation provides an online compiler
or linker by querying a device for [code]#aspect::online_compiler# or
[code]#aspect::online_linker#.

All of the functions in this section accept a [code]#property_list# parameter,
which can affect the semantics of the compilation or linking operation.  The
<<core-spec>> does not currently define any such properties, but vendors may
specify these properties as an extension.

[source]
----
kernel_bundle<bundle_state::object>
compile(const kernel_bundle<bundle_state::input>& inputBundle,
        const std::vector<device>& devs, const property_list& propList = {});
----

_Effects:_ The device images from [code]#inputBundle# are translated into one
or more new device images of state [code]#bundle_state::object#, and a new
kernel bundle is created to contain these new device images.  The new bundle
represents all of the <<kernel,kernels>> in [code]#inputBundles# that are
compatible with at least one of the devices in [code]#devs#.  Any remaining
kernels (those that are not compatible with any of the devices [code]#devs#)
are not compiled and not represented in the new kernel bundle.

The new bundle has the same associated context as [code]#inputBundle#, and the
new bundle's set of associated devices is [code]#devs# (with duplicate devices
removed).

_Returns:_ The new kernel bundle.

_Throws:_

  * An [code]#exception# with the [code]#errc::invalid# error code if any of
    the devices in [code]#devs# are not in the set of associated devices for
    [code]#inputBundle# (as defined by [code]#kernel_bundle::get_devices()#) or
    if the [code]#devs# vector is empty.
  * An [code]#exception# with the [code]#errc::build# error code if the online
    compile operation fails.

[source]
----
kernel_bundle<bundle_state::executable>
link(const std::vector<kernel_bundle<bundle_state::object>>& objectBundles,
     const std::vector<device>& devs, const property_list& propList = {});
----

_Effects:_ Duplicate device images from [code]#objectBundles# are eliminated
as though they were joined via [code]#join()#, then the remaining device images
are translated into one or more new device images of state
[code]#bundle_state::executable#, and a new kernel bundle is created to contain
these new device images.  The new bundle represents all of the
<<kernel,kernels>> in [code]#objectBundles# that are compatible with at least
one of the devices in [code]#devs#.  Any remaining kernels (those that are not
compatible with any of the devices in [code]#devs#) are not linked and not
represented in the new bundle.

The new bundle has the same associated context as those in
[code]#objectBundles#, and the new bundle's set of associated devices is
[code]#devs# (with duplicate devices removed).

_Returns:_ The new kernel bundle.

_Throws:_

  * An [code]#exception# with the [code]#errc::invalid# error code if the
    bundles in [code]#objectBundles# do not all have the same associated
    context.
  * An [code]#exception# with the [code]#errc::invalid# error code if any of
    the devices in [code]#devs# are not in the set of associated devices for
    any of the bundles in [code]#objectBundles# (as defined by
    [code]#kernel_bundle::get_devices()#) or if the [code]#devs# vector is
    empty.
  * An [code]#exception# with the [code]#errc::build# error code if the online
    link operation fails.

[source]
----
kernel_bundle<bundle_state::executable>
build(const kernel_bundle<bundle_state::input>& inputBundle,
      const std::vector<device>& devs, const property_list& propList = {});
----

_Effects:_ This function performs both an online compile and link operation,
translating a kernel bundle of state [code]#bundle_state::input# into a bundle
of state [code]#bundle_state::executable#.  The device images from
[code]#inputBundle# are translated into one or more new device images of state
[code]#bundle_state::executable#, and a new bundle is created to contain these
new device images.  The new bundle represents all of the <<kernel,kernels>> in
[code]#inputBundle# that are compatible with at least one of the devices in
[code]#devs#.  Any remaining kernels (those that are not compatible with any of
the devices [code]#devs#) are not compiled or linked and are not represented in
the new bundle.

The new bundle has the same associated context as [code]#inputBundle#, and the
new bundle's set of associated devices is [code]#devs# (with duplicate devices
removed).

_Returns:_ The new kernel bundle.

_Throws:_

  * An [code]#exception# with the [code]#errc::invalid# error code if any of
    the devices in [code]#devs# are not in the set of associated devices for
    [code]#inputBundle# (as defined by [code]#kernel_bundle::get_devices()#) or
    if the [code]#devs# vector is empty.
  * An [code]#exception# with the [code]#errc::build# error code if the online
    compile or link operations fail.

[source]
----
kernel_bundle<bundle_state::object> // (1)
compile(const kernel_bundle<bundle_state::input>& inputBundle,
        const property_list& propList = {});

kernel_bundle<bundle_state::executable> // (2)
link(const kernel_bundle<bundle_state::object>& objectBundle,
     const std::vector<device>& devs, const property_list& propList = {});

kernel_bundle<bundle_state::executable> // (3)
link(const std::vector<kernel_bundle<bundle_state::object>>& objectBundles,
     const property_list& propList = {});

kernel_bundle<bundle_state::executable> // (4)
link(const kernel_bundle<bundle_state::object>& objectBundle,
     const property_list& propList = {});

kernel_bundle<bundle_state::executable> // (5)
build(const kernel_bundle<bundle_state::input>& inputBundle,
      const property_list& propList = {});
----

  . Equivalent to
    [code]#compile(inputBundle, inputBundle.get_devices(), propList)#.

  . Equivalent to [code]#link({objectBundle}, devs, propList)#.

  . Equivalent to [code]#link(objectBundles, devs, propList)#, where
    [code]#devs# is the intersection of associated devices in common for all
    bundles in [code]#objectBundles#.

  . Equivalent to
    [code]#link({objectBundle}, objectBundle.get_devices(), propList)#.

  . Equivalent to
    [code]#build(inputBundle, inputBundle.get_devices(), propList)#.


=== The [code]#kernel_bundle# class

A synopsis of the [code]#kernel_bundle# class is shown below.  Additionally,
this class provides the common special member functions and common member
functions that are listed in <<sec:reference-semantics>> in
<<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>>, respectively.

As with all SYCL objects that have the common reference semantics, kernel
bundles are equality comparable.  Two bundles of the same <<bundle-state>> are
considered to be equal if they are associated with the same context, have the
same set of associated devices, and contain the same set of device images.

There is no public default constructor for this class.

[source,,linenums]
----
include::{header_dir}/bundle/kernelBundleClass.h[lines=4..-1]
----

[[sec:bundles.query]]
==== Queries

The following member functions provide various queries for a <<kernel-bundle>>.

[source]
----
bool empty() const noexcept;
----

_Returns:_ [code]#true# only if the kernel bundle contains no device images.

[source]
----
backend get_backend() const noexcept;
----

_Returns:_ The backend that is associated with the kernel bundle.

[source]
----
context get_context() const noexcept;
----

_Returns:_ The context that is associated with the kernel bundle.

[source]
----
std::vector<device> get_devices() const noexcept;
----

_Returns:_ The set of devices that is associated with the kernel bundle.

[source]
----
bool has_kernel(const kernel_id& kernelId) const noexcept; // (1)
bool has_kernel(const kernel_id& kernelId,
                const device& dev) const noexcept; // (2)
----

  . _Returns:_ [code]#true# only if the kernel bundle contains the kernel
    identified by [code]#kernelId#.
  . _Returns:_ [code]#true# only if the kernel bundle contains the kernel
    identified by [code]#kernelId# and if that kernel is compatible with the
    device [code]#dev#.

[source]
----
template <typename KernelName> bool has_kernel() const noexcept; // (1)

template <typename KernelName>
bool has_kernel(const device& dev) const noexcept; // (2)
----

_Preconditions:_ The template parameter [code]#KernelName# must be the
<<type-kernel-name>> of a kernel that is defined in the <<sycl-application>>.
Since lambda functions have no standard type name, kernels defined as lambda
functions must specify a [code]#KernelName# in their
<<kernel-invocation-command>> in order to use these functions.  Applications
which call these functions for a [code]#KernelName# that is not defined are ill
formed, and the implementation must issue a diagnostic in this case.

  . _Returns:_ [code]#true# only if the kernel bundle contains the kernel
    identified by [code]#KernelName#.
  . _Returns:_ [code]#true# only if the kernel bundle contains the kernel
    identified by [code]#KernelName# and if that kernel is compatible with the
    device [code]#dev#.

[source]
----
std::vector<kernel_id> get_kernel_ids() const;
----

_Returns:_ A vector of the identifiers for all kernels that are contained in
the kernel bundle.

[source]
----
kernel get_kernel(const kernel_id& kernelId) const;
----

_Preconditions:_ This member function is only available if the kernel bundle's
state is [code]#bundle_state::executable#.

_Returns:_ A [code]#kernel# object representing the kernel identified by
[code]#kernelId#, which resides in the bundle.

_Throws:_

  * An [code]#exception# with the [code]#errc::invalid# error code if the
    kernel bundle does not contain the kernel identified by [code]#kernelId#.

[source]
----
template <typename KernelName> kernel get_kernel() const;
----

_Preconditions:_ This member function is only available if the kernel bundle's
state is [code]#bundle_state::executable#.  The template parameter
[code]#KernelName# must be the <<type-kernel-name>> of a kernel that is defined
in the <<sycl-application>>.  Since lambda functions have no standard type
name, kernels defined as lambda functions must specify a [code]#KernelName# in
their <<kernel-invocation-command>> in order to use this function.
Applications which call this function for a [code]#KernelName# that is not
defined are ill formed, and the implementation must issue a diagnostic in this
case.

_Returns:_ A [code]#kernel# object representing the kernel identified by
[code]#KernelName#, which resides in the bundle.

_Throws:_

  * An [code]#exception# with the [code]#errc::invalid# error code if the
    kernel bundle does not contain the kernel identified by [code]#KernelName#.

==== Specialization constant support

The following member functions allow an application to manipulate
<<specialization-constant,specialization constants>> that are used in the
device images of a <<kernel-bundle>>.  Applications can set the value of
specialization constants in a kernel bundle whose state is
[code]#bundle_state::input# and then online compile that bundle into
[code]#bundle_state::object# or [code]#bundle_state::executable#.  The value of
the specialization constants then become fixed in the compiled bundle and
cannot be changed.  Specialization constants that have not had their values set
by the time the bundle is compiled take their default values.

[NOTE]
====
It is expected that many implementations will use an intermediate language
representation for a bundle in state [code]#bundle_state::input# such as
SPIR-V, and the intermediate language will have native support for
specialization constants.  However, implementations that do not have such
native support must still support specialization constants in some other way.
====

[source]
----
bool contains_specialization_constants() const noexcept;
----

_Returns:_ [code]#true# only if the kernel bundle contains at least one device
image which uses a specialization constant.

[source]
----
bool native_specialization_constant() const noexcept;
----

_Returns:_ [code]#true# only if the kernel bundle contains at least one device
image which uses a specialization constant and all specialization constants
used in all of the bundle's device images are
<<native-specialization-constant,native specialization constants>>.

[source]
----
template <auto& SpecName> bool has_specialization_constant() const noexcept;
----

_Returns:_ [code]#true# if any device image in the kernel bundle uses the
specialization constant whose address is [code]#SpecName#.

[source]
----
template <auto& SpecName>
void set_specialization_constant(
    typename std::remove_reference_t<decltype(SpecName)>::value_type value);
----

_Preconditions:_ This member function is only available if the kernel bundle's
state is [code]#bundle_state::input#.

_Effects:_ Sets the value of the <<specialization-constant>> whose address is
[code]#SpecName# for this bundle.  If the specialization constant's value was
previously set in this bundle, the value is overwritten.

The new value applies to all device images in the bundle.  It is allowed to set
the value of a specialization constant even if no device image in the bundle
uses it; doing so has no effect on the execution of kernels from that bundle.

[source]
----
template <auto& SpecName>
typename std::remove_reference_t<decltype(SpecName)>::value_type
get_specialization_constant() const;
----

_Returns:_ The value of the <<specialization-constant>> whose address is
[code]#SpecName# for this kernel bundle.  The value returned is as follows:

* If the value of this specialization constant was previously set in this
  bundle, that value is returned.  Otherwise,

* If this bundle is the result of compiling, linking or joining another
  bundle and this specialization constant was set in that other bundle prior
  to compiling, linking or joining; then that value is returned.  Otherwise,

* The specialization constant's default value is returned.

==== Device image support

The following member type and functions allow iteration over the
<<device-image,device images>> contained by the kernel bundle.

[source]
----
using device_image_iterator = __unspecified__;
----

An iterator type that satisfies the {cpp} requirements of
[code]#LegacyForwardIterator#.  The iterator's referenced type is
[code]#const device_image<State>#, where [code]#State# is the same state as the
containing [code]#kernel_bundle#.

[source]
----
device_image_iterator begin() const; // (1)
device_image_iterator end() const;   // (2)
----

  .  _Returns:_ An iterator to the first <<device-image>> contained by the
     kernel bundle.
  .  _Returns:_ An iterator to one past the last <<device-image>> contained by
     the kernel bundle.


=== The [code]#kernel# class

A synopsis of the [code]#kernel# class is shown below.  Additionally,
this class provides the common special member functions and common member
functions that are listed in <<sec:reference-semantics>> in
<<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>>, respectively.

There is no public default constructor for this class.

[source,,linenums]
----
include::{header_dir}/bundle/kernelClass.h[lines=4..-1]
----

[[sec:kernel.query]]
==== Queries

The following member functions provide various queries for a <<kernel>>.

[source]
----
backend get_backend() const noexcept;
----

_Returns:_ The backend associated with this kernel.

[source]
----
context get_context() const;
----

_Returns:_ The context associated with this kernel.

[source]
----
kernel_bundle<bundle_state::executable> get_kernel_bundle() const;
----

_Returns:_ The kernel bundle that contains this kernel.

[source]
----
template <typename Param> typename Param::return_type get_info() const;
----

_Preconditions:_ The [code]#Param# must be one of the [code]#info::kernel#
descriptors defined in <<table.kernel.info>>, and the type alias
[code]#Param::return_type# must be defined in accordance with that table.

_Returns:_ Information about the kernel that is not specific to the device on
which it is invoked.

[source]
----
template <typename Param>
typename Param::return_type get_info(const device& dev) const;
----

_Preconditions:_ The [code]#Param# must be one of the
[code]#info::kernel_device_specific# descriptors defined in
<<table.kernel.devicespecificinfo>>, and the type alias
[code]#Param::return_type# must be defined in accordance with that table.

_Returns:_ Information about the kernel that applies when the kernel is invoked
on the device [code]#dev#.

_Throws:_

  * An [code]#exception# with the [code]#errc::invalid# error code if the
    kernel is not compatible with device [code]#dev# (as defined by
    [code]#is_compatible()#).

[source]
----
template <typename Param> typename Param::return_type get_backend_info() const;
----

_Preconditions:_ The [code]#Param# must be one of a descriptor defined by a
<<backend>> specification.

_Returns:_ Backend specific information about the kernel that is not specific
to the device on which it is invoked.

_Throws:_

  * An [code]#exception# with the [code]#errc::backend_mismatch# error code if
    the <<backend>> that corresponds with [code]#Param# is different from the
    <<backend>> that is associated with this kernel bundle.

==== Kernel information descriptors

A <<kernel>> can be queried for information using the [code]#get_info()#
member function, specifying one of the info parameters in [code]#info::kernel#.
All info parameters in [code]#info::kernel# are specified in
<<table.kernel.info>> and the synopsis for [code]#info::kernel# is described in
<<appendix.kernel.descriptors>>.

[[table.kernel.info]]
.Kernel class information descriptors
[width="100%",options="header",separator="@",cols="37%,19%,44%"]
|====
@ Kernel Descriptors @ Return type @ Description
a@
[source]
----
info::kernel::num_args
----

    @ [code]#uint32_t#
   a@ This descriptor may only be used to query a kernel that resides in a
      kernel bundle that was constructed using a backend specific
      interoperability function or to query a device built-in kernel, and the
      semantics of this descriptor are defined by each SYCL backend
      specification.

Attempting to use this descriptor for other kernels throws an [code]#exception#
with the [code]#errc::invalid# error code.

a@
[source]
----
info::kernel::attributes
----

    @ [code]#std::string#
   a@ Return any attributes specified on a kernel function (as defined in
      <<sec:device.attributes>>).

|====

A <<kernel>> can also be queried for device specific information using the
[code]#get_info()# member function, specifying one of the info parameters in
[code]#info::kernel_device_specific#.  All info parameters in
[code]#info::kernel_device_specific# are specified in
<<table.kernel.devicespecificinfo>>.  The synopsis for
[code]#info::kernel_device_specific# is described in
<<appendix.kernel.descriptors>>.

[[table.kernel.devicespecificinfo]]
.Device-specific kernel information descriptors
[width="100%",options="header",separator="@",cols="37%,19%,44%"]
|====
@ Device-specific Kernel Information Descriptors @ Return type @ Description
a@
[source]
----
info::kernel_device_specific::global_work_size
----

    @ [code]#range<3>#
   a@ This descriptor may only be used if the device type is
      [code]#device_type::custom# or if the kernel is a built-in kernel.  The
      exact semantics of this descriptor are defined by each SYCL backend
      specification, but the intent is to return the kernel's maximum global
      work size.

Attempting to use this descriptor for other devices or kernels throws an
[code]#exception# with the [code]#errc::invalid# error code.

a@
[source]
----
info::kernel_device_specific::work_group_size
----

    @ [code]#size_t#
   a@ Returns the maximum number of work-items in a work-group that can be used
      to execute a kernel on a specific device.

a@
[source]
----
info::kernel_device_specific::compile_work_group_size
----

    @ [code]#range<3>#
   a@ Returns the work-group size specified by the device compiler if applicable,
      otherwise returns [code]#{0,0,0}#.

a@
[source]
----
info::kernel_device_specific::preferred_work_group_size_multiple
----

    @ [code]#size_t#
   a@ Returns a value, of which work-group size is preferred to be a multiple,
      for executing a kernel on a particular device.  This is a performance
      hint.  The value must be less than or equal to that returned by
      [code]#info::kernel_device_specific::work_group_size#.

a@
[source]
----
info::kernel_device_specific::private_mem_size
----

    @ [code]#size_t#
   a@ Returns the minimum amount of private memory, in bytes, used by each work-item
      in the kernel.  This value may include any private memory needed by an
      implementation to execute the kernel, including that used by the language
      built-ins and variables declared inside the kernel in the private address
      space.

a@
[source]
----
info::kernel_device_specific::max_num_sub_groups
----

    @ [code]#uint32_t#
   a@ Returns the maximum number of sub-groups for this kernel.

a@
[source]
----
info::kernel_device_specific::compile_num_sub_groups
----

    @ [code]#uint32_t#
   a@ Returns the number of sub-groups specified by the kernel, or 0 (if not specified).

a@
[source]
----
info::kernel_device_specific::max_sub_group_size
----

    @ [code]#uint32_t#
   a@ Returns the maximum sub-group size for this kernel.

a@
[source]
----
info::kernel_device_specific::compile_sub_group_size
----

    @ [code]#uint32_t#
   a@ Returns the required sub-group size specified by the kernel, or 0 (if not specified).

|====


=== The [code]#device_image# class

A synopsis of the [code]#device_image# class is shown below.  Additionally,
this class provides the common special member functions and common member
functions that are listed in <<sec:reference-semantics>> in
<<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>>, respectively.

[source,,linenums]
----
include::{header_dir}/bundle/deviceImageClass.h[lines=4..-1]
----

There is no public constructor for this class.

[source]
----
bool has_kernel(const kernel_id& kernelId) const noexcept; // (1)
bool has_kernel(const kernel_id& kernelId,
                const device& dev) const noexcept; // (2)
----

  . _Returns:_ [code]#true# only if the device image contains the kernel
    identified by [code]#kernelId#.
  . _Returns:_ [code]#true# only if the device image contains the kernel
    identified by [code]#kernelId# and if that kernel is compatible with the
    device [code]#dev#.


=== Example usage

This section provides some examples showing typical use cases for kernel
bundles.  These examples are intended to clarify the definition of the kernel
bundle interfaces, but the content of this section is non-normative.

==== Controlling the timing of online compilation

In some cases an application may want to pre-compile its kernels before
submitting them to a device.  This gives the application control over when the
overhead of online compilation happens, rather than relying on the default
behavior (which may cause the online compilation to happen at the point when
the kernel is submitted to a device).  The following example shows how this can
be achieved.

[source,,linenums]
----
include::{code_dir}/bundle-pre-compile.cpp[lines=4..-1]
----

==== Specialization constants

An application can use a kernel bundle to set the values of specialization
constants in several kernels before any of them are submitted for execution.

[source,,linenums]
----
include::{code_dir}/bundle-spec-constants.cpp[lines=4..-1]
----

==== Kernel introspection

Applications can use kernel bundles to introspect its kernels and use that
information to tune the arguments passed when invoking it.

[source,,linenums]
----
include::{code_dir}/bundle-kernel-introspection.cpp[lines=4..-1]
----

==== Invoking a device built-in kernel

An application can use kernel bundles to invoke a device's built-in kernels.

[source,,linenums]
----
include::{code_dir}/bundle-builtin-kernel.cpp[lines=4..-1]
----


== Defining kernels

In SYCL, functions that are executed on a SYCL device are referred to
as <<sycl-kernel-function,SYCL kernel functions>>. A <<kernel>> containing such a
<<sycl-kernel-function>> is enqueued on a device queue in order to
be executed on that particular device.

The return type of the <<sycl-kernel-function>> is [code]#void#, and all memory
accesses between host and device are through <<accessor,accessors>> or through
<<sec:usm, USM pointers>>.

There are two ways of defining kernels: as named function objects or as
lambda functions. A backend may also provide interoperability interfaces for
defining kernels.


[[sec:interfaces.kernels.as.function-objects]]
=== Defining kernels as named function objects

A kernel can be defined as a named function object type. These function objects
provide the same functionality as any {cpp} function object, with the
restriction that they need to follow SYCL rules to be <<device-copyable>>.
The kernel function can be templated via templating the kernel
function object type. For details on restrictions for kernel naming,
please refer to <<sec:naming.kernels>>.

The [code]#operator()# member function must be const-qualified, and it may take
different parameters depending on the data accesses defined for the specific
kernel.  If the [code]#operator()# function writes to any of the member variables,
the behavior is undefined.

The following example defines a <<sycl-kernel-function>>,
_RandomFiller_, which initializes a buffer with a random number. The
random number is generated during the construction of the function object
while processing the command group. The [code]#operator()# member
function of the function object receives an [code]#item# object. This
member function will be called for each work-item of the execution range. The value
of the random number will be assigned to each element of the buffer. In this
case, the accessor and the scalar random number are members of the function
object and therefore will be arguments to the device kernel. Usual
restrictions of passing arguments to kernels apply.

[source,,linenums]
----
include::{code_dir}/myfunctor.cpp[lines=4..-1]
----


[[sec:interfaces.kernels.as.lambdas]]
=== Defining kernels as lambda functions

In {cpp}, function objects can be defined using lambda functions. Kernels may be
defined as lambda functions in SYCL.  The name of a lambda function
in SYCL may optionally be specified by passing it as a template parameter to the invoking
member function, and in that case, the lambda name is a [keyword]#{cpp} typename# which must
be forward declarable at namespace scope. If the lambda
function relies on template arguments, then if specified,
the name of the lambda function must contain those template arguments which must
also be forward declarable at namespace scope. The
class used for the name of a lambda function is only used for naming purposes
and is not required to be defined. For details on restrictions for kernel
naming, please refer to <<sec:naming.kernels>>.

The kernel function for the lambda function is the lambda function itself.
The kernel lambda must use copy for all of its captures (i.e. [code]#[=]#), and
the lambda must not use the [code]#mutable# specifier.

[source,,linenums]
----
include::{code_dir}/mykernel.cpp[lines=4..-1]
----

Explicit lambda naming is shown in the following code example,
including an illegal case that uses a class within the kernel
name which is not forward declarable ([code]#std::complex#).

[source,,linenums]
----
include::{code_dir}/lambdaNameExamples.cpp[lines=4..-1]
----

=== [code]#is_device_copyable# type trait

....
namespace sycl {
    template<typename T>
    struct is_device_copyable;

    template<typename T>
    inline constexpr bool is_device_copyable_v = is_device_copyable<T>::value;
};
....

[code]#is_device_copyable# is a user specializable class template to indicate
that a type [code]#T# is <<device-copyable>>.

  * [code]#is_device_copyable# must meet the Cpp17UnaryTrait requirements.
  * If [code]#is_device_copyable# is specialized such that
    [code]#is_device_copyable_v<T> == true# on a [code]#T# that does not
    satisfy all the requirements of a device copyable type, the results are
    unspecified.

If the application defines a type [code]#UDT# that satisfies the requirements of
a <<device-copyable>> type (as defined in <<sec::device.copyable>>) but the type
is not implicitly device copyable as defined in that section, then the
application must provide a specialization of [code]#is_device_copyable# that
derives from [code]#std:true_type# in order to use that type in a context that
requires a device copyable type.  Such a specialization can be declared like
this:

....
template<>
struct sycl::is_device_copyable<UDT> : std::true_type {};
....

It is legal to provide this specialization even if the implementation does not
define [code]#SYCL_DEVICE_COPYABLE# to [code]#1#, but the type cannot be used
as a device copyable type in that case and the specialization is ignored.


[[sec:kernel.parameter.passing]]
=== Rules for parameter passing to kernels

A SYCL application passes parameters to a kernel in different ways depending on
whether the kernel is a named function object or a lambda function.  If the
kernel is a named function object, the [code]#operator()# member function (or
other member functions that it calls) may reference member variables inside the
same named function object.  Any such member variables become parameters to the
kernel.  If the kernel is a lambda function, any variables captured by the
lambda become parameters to the kernel.

Regardless of how the parameter is passed, the following rules define the
allowable types for a kernel parameter:

* Any <<device-copyable>> type is a legal parameter type.

* The following SYCL types are legal parameter types:
  - [code]#accessor# when templated with [code]#target::device#;
  - [code]#accessor# when templated with any of the deprecated parameters:
    [code]#target::global_buffer#, [code]#target::constant_buffer#, or
    [code]#target::local#;
  - [code]#local_accessor#;
  - [code]#unsampled_image_accessor# when templated with
    [code]#image_target::device#;
  - [code]#sampled_image_accessor# when templated with
    [code]#image_target::device#;
  - [code]#stream#;
  - [code]#id#;
  - [code]#range#;
  - [code]#marray<T, NumElements># when [code]#T# is <<device-copyable>>;
  - [code]#vec<T, NumElements>#.

* An array of element types [code]#T# is a legal parameter type if [code]#T# is
  a legal parameter type.

* A class type [code]#S# with a non-static member variable of type [code]#T# is
  a legal parameter type if [code]#T# is a legal parameter type and if
  [code]#S# would otherwise be a legal parameter type aside from this member
  variable.

* A class type [code]#S# with a non-virtual base class of type [code]#T# is a
  legal parameter type if [code]#T# is a legal parameter type and if [code]#S#
  would otherwise be a legal parameter type aside from this base class.

[NOTE]
====
Pointer types are trivially copyable, so they may be passed as kernel
parameters.  However, only the pointer value itself is passed to the kernel.
Dereferencing the pointer on the kernel results in undefined behavior unless
the pointer points to an address within a <<usm>> memory region that is
accessible on the device.

Reference types are not trivially copyable, so they may not be passed as
kernel parameters.
====

[NOTE]
====
The [code]#reducer# class is a special type of kernel parameter which is passed
to a kernel in a different way.  <<sec:reduction>> describes how this parameter
type is used.
====

// %%%%%%%%%%%%%%%%%%%%%%%%%%%% end expressingParallelism %%%%%%%%%%%%%%%%%%%%%%%%%%%%


[[error-handling]]
== Error handling

=== Error handling rules

Error handling in a SYCL application (host code) uses {cpp} exceptions. If an error
occurs, it will be thrown by the API function call and may be caught by the user
through standard {cpp} exception handling mechanisms.

SYCL applications are asynchronous in the sense that host and device code executions
are decoupled from one another except at specific points. For example, device code
executions often begin when dependencies in the SYCL task graph are satisfied, which
occurs asynchronously from host code execution.  As a result of this the errors
that occur on a device cannot be thrown directly from a host API call, because the call
enqueueing a device action has typically already returned by the time that the error
occurs. Such errors are not detected until the error-causing task executes or tries to
execute, and we refer to these as <<async-error,asynchronous errors>>.


[[subsubsec:exception.async]]
==== Asynchronous error handler

The queue and context classes can optionally take an asynchronous handler object
<<async-handler>> on construction, which is a callable such as a function class
or lambda, with an [code]#exception_list# as a parameter.
Invocation of an <<async-handler>> may be triggered by the queue member functions
[code]#queue::wait_and_throw()# or [code]#queue::throw_asynchronous()#, by
the event member function [code]#event::wait_and_throw()#, or
automatically on destruction of a queue or context that contains unconsumed
asynchronous errors.  When invoked, an <<async-handler>> is called and receives an
[code]#exception_list# argument containing a list of exception objects representing
any unconsumed <<async-error,asynchronous errors>> associated with the queue or context.

When an <<async-error>> instance has been passed to an <<async-handler>>, then
that instance of the error has been consumed for handling and is not reported on
any subsequent invocations of the <<async-handler>>.

The <<async-handler>> may be a named function object type, a lambda
function or a [code]#std::function#. The [code]#exception_list#
object passed to the <<async-handler>> is constructed by the <<sycl-runtime>>.


[[subsubsec:exception.nohandler]]
==== Behavior without an <<async-handler>>

If an asynchronous error occurs in a queue or context that has no user-supplied
asynchronous error handler object <<async-handler>>, then an implementation-defined
default <<async-handler>> is called to handle the error in the same situations that
a user-supplied <<async-handler>> would be, as defined in
<<subsubsec:exception.async>>.  The default <<async-handler>> must in some way
report all errors passed to it, when possible, and must then invoke
[code]#std::terminate# or equivalent.

==== Priorities of <<async-handler,async handlers>>

If the SYCL runtime can associate an <<async-error>> with a specific queue,
then:

  * If the queue was constructed with an <<async-handler>>, that handler
    is invoked to handle the error.
  * Otherwise if the context enclosed by the queue was constructed with an
    <<async-handler>>, that handler is invoked to handle the error.
  * Otherwise when no handler was passed to either queue or context on
    construction, then a default handler is invoked to handle the error, as
    described by <<subsubsec:exception.nohandler>>.
  * All handler invocations in this list occur at times as defined by
    <<subsubsec:exception.async>>.

If the SYCL runtime cannot associate an <<async-error>> with a specific queue,
then:

  * If the context in which the error occurred was constructed with an
    <<async-handler>>, then that handler is invoked to handle the error.
  * Otherwise when no handler was passed to the associated context on
    construction, then a default handler is invoked to handle the error, as
    described by <<subsubsec:exception.nohandler>>.
  * All handler invocations in this list occur at times as defined by
    <<subsubsec:exception.async>>.


==== Asynchronous errors with a secondary queue

If an <<async-error>> occurs when running or enqueuing a command group which has
a secondary queue specified, then the command group may be enqueued
to the secondary queue instead of the primary queue. The error handling in this
case is also configured using the <<async-handler>> provided for both
queues. If there is no <<async-handler>> given on any of the queues,
then the asynchronous error handling proceeds through the contexts
associated with the queues, and if they were also constructed without
<<async-handler>>s, then the default handler will be used.
If the primary queue fails and there is an <<async-handler>> given at
this queue's construction, which populates the [code]#exception_list#
parameter, then any errors will be added and can be thrown whenever the user
chooses to handle those exceptions. Since there were errors on the primary
queue and a secondary queue was given, then the execution of the kernel is
re-scheduled to the secondary queue and any error reporting for the kernel
execution on that queue is done through that queue, in the same way as
described above. The secondary queue may fail as well, and the errors will be
thrown if there is an <<async-handler>> and either
[code]#wait_and_throw()# or [code]#throw()# are called on that queue. If no
<<async-handler>> was specified, then the one associated with the queue's context
will be used and if the context was also constructed without an <<async-handler>>,
then the default handler will be used.
The <<command-group-function-object>> event returned by that function will be
relevant to the queue where the kernel has been enqueued.

Below is an example of catching a SYCL [code]#exception# and printing out
the error message.

[source,,linenums]
----
include::{code_dir}/handlingException.cpp[lines=4..-1]
----

Below is an example of catching a SYCL [code]#exception# with the
[code]#errc::invalid# error code and printing out the error message.

[source,,linenums]
----
include::{code_dir}/handlingErrorCode.cpp[lines=4..-1]
----


[[subsec:exception.class]]
=== Exception class interface

[source,,linenums]
----
include::{header_dir}/exception.h[lines=4..-1]
----

The SYCL [code]#exception_list#
class is also available in order to provide a list of synchronous and
asynchronous exceptions.

Errors can occur both in the SYCL library and SYCL host side, or may come
directly from a <<backend>>. The member functions on these exceptions provide the
corresponding information.
<<backend, SYCL backends>> can provide additional exception class objects as long as they derive
from [code]#sycl::exception# object, or any of its derived classes.

A specialization of [code]#std::is_error_code_enum# must be defined
for [code]#sycl::errc# that inherits from [code]#std::true_type#.


[[table.members.exception]]
.Member functions of the SYCL [code]#exception# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
exception(std::error_code ec, const std::string& what_arg)
----
   a@ Constructs an [code]#exception#. The string returned by [code]#what()# is guaranteed to contain [code]#what_arg# as a substring.

a@
[source]
----
exception(std::error_code ec, const char* what_arg)
----
   a@ Constructs an [code]#exception#. The string returned by [code]#what()# is guaranteed to contain [code]#what_arg# as a substring.

a@
[source]
----
exception(std::error_code ec)
----
   a@ Constructs an [code]#exception#.

a@
[source]
----
exception(int ev, const std::error_category& ecat, const std::string& what_arg)
----
   a@ Constructs an [code]#exception# with the error code ev and the underlying error category [code]#ecat#. The string returned by [code]#what()# is guaranteed to contain [code]#what_arg# as a substring.

a@
[source]
----
exception(int ev, const std::error_category& ecat, const char* what_arg)
----
   a@ Constructs an [code]#exception# with the error code ev and the underlying error category [code]#ecat#. The string returned by [code]#what()# is guaranteed to contain [code]#what_arg# as a substring.

a@
[source]
----
exception(int ev, const std::error_category& ecat)
----
   a@ Constructs an [code]#exception# with the error code ev and the underlying error category [code]#ecat#.

a@
[source]
----
exception(context ctx, std::error_code ec, const std::string& what_arg)
----
   a@ Constructs an [code]#exception# with an associated SYCL context [code]#ctx#. The string returned by [code]#what()# is guaranteed to contain [code]#what_arg# as a substring.

a@
[source]
----
exception(context ctx, std::error_code ec, const char* what_arg)
----
   a@ Constructs an [code]#exception# with an associated SYCL context [code]#ctx#. The string returned by [code]#what()# is guaranteed to contain [code]#what_arg# as a substring.

a@
[source]
----
exception(context ctx, std::error_code ec)
----
   a@ Constructs an [code]#exception# with an associated SYCL context [code]#ctx#.

a@
[source]
----
exception(context ctx, int ev, const std::error_category& ecat,
          const std::string& what_arg)
----
   a@ Constructs an [code]#exception# with an associated SYCL context [code]#ctx#, the error code ev and the underlying error category [code]#ecat#. The string returned by [code]#what()# is guaranteed to contain [code]#what_arg# as a substring.

a@
[source]
----
exception(context ctx, int ev, const std::error_category& ecat,
          const char* what_arg)
----
   a@ Constructs an [code]#exception# with an associated SYCL context [code]#ctx#, the error code ev and the underlying error category [code]#ecat#. The string returned by [code]#what()# is guaranteed to contain [code]#what_arg# as a substring.

a@
[source]
----
exception(context ctx, int ev, const std::error_category& ecat)
----
   a@ Constructs an [code]#exception# with an associated SYCL context [code]#ctx#, the error code ev and the underlying error category [code]#ecat#.

a@
[source]
----
const std::error_code& code() const noexcept
----
   a@ Returns the error code stored inside the exception.

a@
[source]
----
const std::error_category& category() const noexcept
----
   a@ Returns the error category of the error code stored inside the exception.

a@
[source]
----
const char* what() const
----
   a@ Returns an implementation-defined non-null constant C-style string that describes the error that triggered the exception.

a@
[source]
----
bool has_context() const noexcept
----
   a@ Returns [code]#true# if this SYCL [code]#exception# has an associated SYCL [code]#context# and [code]#false# if it does not.

a@
[source]
----
context get_context() const
----
   a@ Returns the SYCL [code]#context# that is associated with this SYCL [code]#exception# if one is available. Must throw an [code]#exception# with the [code]#errc::invalid# error code if this SYCL [code]#exception# does not have a SYCL [code]#context#.

|====



[[table.members.exceptionlist]]
.Member functions of the [code]#exception_list#
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
size_t size() const
----
   a@ Returns the size of the list

a@
[source]
----
iterator begin() const
----
   a@ Returns an iterator to the beginning of the list of asynchronous exceptions.

a@
[source]
----
iterator end() const
----
   a@ Returns an iterator to the end of the list of asynchronous exceptions.

|====



[[table.errc.values]]
.Values of the SYCL [code]#errc# enum
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Standard SYCL Error Codes @ Description
a@
[source]
----
success
----
   a@ The implementation never throws an exception with this error code, but it
      is defined to ensure that no other error code has the value zero.  An
      application can construct an [code]#std::error_code# with this code to
      indicate "not an error".

a@
[source]
----
runtime
----
   a@ Generic runtime error.

a@
[source]
----
kernel
----
   a@ Error that occurred before or while enqueuing the SYCL kernel.

a@
[source]
----
nd_range
----
   a@ Error regarding the SYCL [code]#nd_range# specified for the SYCL kernel

a@
[source]
----
accessor
----
   a@ Error regarding the SYCL <<accessor>> objects defined.

a@
[source]
----
event
----
   a@ Error regarding associated SYCL [code]#event# objects.

a@
[source]
----
kernel_argument
----
   a@ The application has passed an invalid argument to a
      <<sycl-kernel-function>>.  This includes captured variables if the
      <<sycl-kernel-function>> is a lambda function.

a@
[source]
----
build
----
   a@ Error from an online compile or link operation when compiling, linking,
      or building a kernel bundle for a device.

a@
[source]
----
invalid
----
   a@ A catchall error which is used when the application passes an invalid
      value as a parameter to a SYCL API function or calls a SYCL API function
      in some invalid way.

a@
[source]
----
memory_allocation
----
   a@ Error on memory allocation on the SYCL device for a SYCL kernel.

a@
[source]
----
platform
----
   a@ The SYCL platform will trigger this exception on error.

a@
[source]
----
profiling
----
   a@ The <<sycl-runtime>> will trigger this error if there is an error when profiling info
      is enabled.

a@
[source]
----
feature_not_supported
----
   a@ Exception thrown when host code uses an optional feature that is not
      supported by a device.

a@
[source]
----
kernel_not_supported
----
   a@ Exception thrown when a kernel uses an optional feature that is not
      supported on the device to which it is enqueued.  This exception is also
      thrown if a <<command-group>> is bound to a <<kernel-bundle>>, and the
      bundle does not contain the kernel invoked by the command group.

a@
[source]
----
backend_mismatch
----
   a@ The application has called a backend interoperability function with
      mismatched backend information.  For example, requesting information
      specific to backend A from a SYCL object that comes from backend B causes
      this error.

|====

[[table.error.helpers]]
.SYCL error code helper functions
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ SYCL Error Code Helpers @ Description
a@
[source]
----
const std::error_category& sycl_category() noexcept;
----
   a@ Obtains a reference to the static error category object for SYCL errors.
      This object overrides the virtual function [code]#error_category::name()#
      to return a pointer to the string [code]#"sycl"#.  When the
      implementation throws an [code]#sycl::exception# object [code]#ex# with
      this category, the error code value contained by the exception
      ([code]#ex.code().value()#) is one of the enumerated values in
      [code]#sycl::errc#.

a@
[source]
----
std::error_code make_error_code(errc e) noexcept;
----
   a@ Constructs an error code using [code]#e# and [code]#sycl_category()#.

|====



== Data types

SYCL as a {cpp} programming model supports the {cpp} core language data types,
and it also provides the ability for all SYCL applications to be executed on SYCL
compatible devices. The scalar and vector data types that
are supported by the SYCL system are defined below. More details about the SYCL
device compiler support for fundamental and backend interoperability types are found
in <<subsec:scalartypes>>.


=== Scalar data types

The fundamental {cpp} data types which are supported in SYCL are described in
<<table.types.fundamental>>. Note these types are fundamental and therefore
do not exist within the [code]#sycl# namespace.

Additional scalar data types which are supported by SYCL within the
[code]#sycl# namespace are described in
<<table.types.additional>>.


[[table.types.additional]]
.Additional scalar data types supported by SYCL
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Scalar data type @ Description
a@
[source]
----
byte
----
   a@ An unsigned 8-bit integer. This is deprecated in SYCL 2020 since {cpp17}
      [code]#std::byte# can be used instead.

a@
[source]
----
half
----
   a@ A 16-bit floating-point. The half data type must conform to the IEEE
      754-2008 half precision storage format. This type is only supported
      on devices that have [code]#aspect::fp16#. [code]#std::numeric_limits#
      must be specialized for the half data type.

|====


// \input{vec_class}

// %%%%%%%%%%%%%%%%%%%%%%%%%%%% begin vec_class %%%%%%%%%%%%%%%%%%%%%%%%%%%%

[[sec:vector.type]]
=== Vector types

SYCL provides a cross-platform class template that works
efficiently on SYCL devices as well as in host {cpp} code. This type
allows sharing of vectors between the host and its SYCL devices. The
vector supports member functions that allow construction of a new vector from a
swizzled set of component elements.

[code]#vec<typename _DataT_, int _NumElements_>#
is a vector type
that compiles down to a <<backend>> built-in vector types on SYCL devices,
where possible, and provides compatible support on the host or when it is
not possible. The [code]#vec# class is templated on its number of
elements and its element type. The number of elements parameter,
_NumElements_, can be one of: 1, 2, 3, 4, 8 or 16. Any other value shall
produce a compilation failure. The element type parameter, _DataT_, must
be one of the basic scalar types supported in device code.

The SYCL [code]#vec# class template provides interoperability with the
underlying vector type defined by [code]#vector_t# which is
available only when compiled for the device. The SYCL [code]#vec# class can
be constructed from an instance of [code]#vector_t# and can implicitly
convert to an instance of [code]#vector_t# in order to support
interoperability with native <<backend>> functions from a SYCL kernel function.

An instance of the SYCL [code]#vec# class template can also be
implicitly converted to an instance of the data type when the number of
elements is [code]#1# in order to allow single element vectors and
scalars to be convertible with each other.

==== Vec interface

The constructors, member functions and non-member functions of the SYCL
[code]#vec# class template are listed in
<<table.constructors.vec>>, <<table.members.vec>> and
<<table.functions.vec>> respectively.

// Interface for class: vec
[source,,linenums]
----
include::{header_dir}/vec.h[lines=4..-1]
----


[[table.constructors.vec]]
.Constructors of the SYCL [code]#vec# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
vec()
----
   a@ Default construct a vector with element type [code]#DataT# and
      with [code]#NumElements# dimensions by default construction of
      each of its elements.

a@
[source]
----
explicit constexpr vec(const DataT& arg)
----
   a@ Construct a vector of element type [code]#DataT# and
      [code]#NumElements# dimensions by setting each value to [code]#arg# by
      assignment.

a@
[source]
----
template <typename... ArgTN> constexpr vec(const ArgTN&... args)
----
   a@ Construct a SYCL [code]#vec# instance from any combination of scalar and SYCL [code]#vec# parameters of the same element type, providing the total number of elements for all parameters sum to [code]#NumElements# of this [code]#vec# specialization.

a@
[source]
----
constexpr vec(const vec<DataT, NumElements>& rhs)
----
   a@ Construct a vector of element type [code]#DataT# and number of elements [code]#NumElements# by copy from another similar vector.

a@
[source]
----
vec(vector_t nativeVector)
----
   a@ Available only when: compiled for the device.

Constructs a SYCL [code]#vec# instance from an instance of the underlying backend-native vector type defined by [code]#vector_t#.

|====



[[table.members.vec]]
.Member functions for the SYCL [code]#vec# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
operator vector_t() const
----
   a@ Available only when: compiled for the device.

Converts this SYCL [code]#vec# instance to the underlying backend-native vector type
defined by [code]#vector_t#.

a@
[source]
----
operator DataT() const
----
   a@ Available only when: [code]#NumElements == 1#.

Converts this SYCL [code]#vec# instance to an instance of [code]#DataT# with
the value of the single element in this SYCL [code]#vec# instance.

The SYCL [code]#vec# instance shall be implicitly convertible to the same data types,
to which [code]#DataT# is implicitly convertible.
Note that conversion operator shall not be templated
to allow standard conversion sequence for implicit conversion.

a@
[source]
----
static constexpr size_t size() noexcept
----
   a@ Returns the number of elements of this SYCL [code]#vec#.
a@
[source]
----
size_t get_count() const
----
   a@ Returns the same value as [code]#size()#. Deprecated.
a@
[source]
----
static constexpr size_t byte_size() noexcept
----
   a@ Returns the size of this SYCL [code]#vec# in bytes.

3-element vector size matches 4-element vector size to provide
interoperability with OpenCL vector types. The same rule applies to vector
alignment as described in <<memory-layout-and-alignment>>.
a@
[source]
----
size_t get_size() const
----
   a@ Returns the same value as [code]#byte_size()#. Deprecated.
a@
[source]
----
template <typename ConvertT,
          rounding_mode RoundingMode = rounding_mode::automatic>
vec<ConvertT, NumElements> convert() const
----
   a@ Converts this SYCL [code]#vec# to a SYCL [code]#vec# of a different element type specified by [code]#ConvertT# using the rounding mode specified by [code]#RoundingMode#. The new SYCL [code]#vec# type must have the same number of elements as this SYCL [code]#vec#. The different rounding modes are described in <<table.vec.roundingmodes>>.

a@
[source]
----
template <typename asT> asT as() const
----
   a@ Bitwise reinterprets this SYCL [code]#vec# as a SYCL [code]#vec# of a different element type and number of elements specified by [code]#asT#. The new SYCL [code]#vec# type must have the same storage size in bytes as this SYCL [code]#vec#.

a@
[source]
----
template <int... swizzleIndexes> __swizzled_vec__ swizzle() const
----
   a@ Return an instance of the implementation-defined intermediate class template [code]#+__swizzled_vec__+# representing an index sequence which can be used to apply the swizzle in a valid expression as described in <<swizzled-vec-class>>.

a@
[source]
----
__swizzled_vec__ XYZW_ACCESS() const
----
   a@ Available only when: [code]#+NumElements <= 4+#.

Returns an instance of the implementation-defined intermediate class template [code]#+__swizzled_vec__+# representing an index sequence which can be used to apply the swizzle in a valid expression as described in <<swizzled-vec-class>>.

Where [code]#XYZW_ACCESS# is: [code]#x# for [code]#NumElements == 1#,
[code]#x, y# for
[code]#NumElements == 2#,
[code]#x, y, z# for
[code]#NumElements == 3# and
[code]#x, y, z, w# for
[code]#NumElements == 4#.

a@
[source]
----
__swizzled_vec__ RGBA_ACCESS() const
----
   a@ Available only when: [code]#NumElements == 4#.

Returns an instance of the implementation-defined intermediate class template [code]#+__swizzled_vec__+# representing an index sequence which can be used to apply the swizzle in a valid expression as described in <<swizzled-vec-class>>.

Where [code]#RGBA_ACCESS# is: [code]#r, g, b, a#.

a@
[source]
----
__swizzled_vec__ INDEX_ACCESS() const
----
   a@ Returns an instance of the implementation-defined intermediate class template [code]#+__swizzled_vec__+# representing an index sequence which can be used to apply the swizzle in a valid expression as described in <<swizzled-vec-class>>.

Where [code]#INDEX_ACCESS# is: [code]#s0# for [code]#NumElements == 1#,
[code]#s0, s1# for
[code]#NumElements == 2#,
[code]#s0, s1, s2# for
[code]#NumElements == 3#,
[code]#s0, s1, s2, s3# for
[code]#NumElements == 4#,
[code]#s0, s1, s2, s3, s4, s5, s6, s7, s8# for
[code]#NumElements == 8# and
[code]#s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, sA, sB, sC, sD, sE, sF# for
[code]#NumElements == 16#.

a@
[source]
----
__swizzled_vec__ XYZW_SWIZZLE() const
----
   a@ Available only when: [code]#+NumElements <= 4+#, and when the macro [code]#SYCL_SIMPLE_SWIZZLES# is defined before including [code]#<sycl/sycl.hpp>#.

Returns an instance of the implementation-defined intermediate class template [code]#+__swizzled_vec__+# representing an index sequence which can be used to apply the swizzle in a valid expression as described in <<swizzled-vec-class>>.

Where XYZW_SWIZZLE is all permutations with repetition, of any subset with length greater than [code]#1#, of [code]#x, y# for
[code]#NumElements == 2#,
[code]#x, y, z# for
[code]#NumElements == 3# and
[code]#x, y, z, w# for
[code]#NumElements == 4#. For example a four element [code]#vec# provides permutations including [code]#xzyw#, [code]#xyyy# and [code]#xz#.

a@
[source]
----
__swizzled_vec__ RGBA_SWIZZLE() const
----
   a@ Available only when: [code]#NumElements == 4#, and when the macro [code]#SYCL_SIMPLE_SWIZZLES# is defined before including [code]#<sycl/sycl.hpp>#.

Returns an instance of the implementation-defined intermediate class template [code]#+__swizzled_vec__+# representing an index sequence which can be used to apply the swizzle in a valid expression as described in <<swizzled-vec-class>>.

Where RGBA_SWIZZLE is all permutations with repetition, of any subset with length greater than [code]#1#, of [code]#r, g, b, a#.
For example a four element [code]#vec# provides permutations including [code]#rbga#, [code]#rggg# and [code]#rb#.

a@
[source]
----
__swizzled_vec__ lo() const
----
   a@ Available only when: [code]#NumElements > 1#.

Return an instance of the implementation-defined intermediate class template [code]#+__swizzled_vec__+# representing an index sequence made up of the lower half of this SYCL vec which can be used to apply the swizzle in a valid expression as described in <<swizzled-vec-class>>. When [code]#NumElements == 3#, this SYCL [code]#vec# is treated as though
[code]#NumElements == 4# with the fourth element undefined.

a@
[source]
----
__swizzled_vec__ hi() const
----
   a@ Available only when: [code]#NumElements > 1#.

Return an instance of the implementation-defined intermediate class template [code]#+__swizzled_vec__+# representing an index sequence made up of the upper half of this SYCL vec which can be used to apply the swizzle in a valid expression as described in <<swizzled-vec-class>>. When [code]#NumElements == 3#, this SYCL [code]#vec# is treated as though
[code]#NumElements == 4# with the fourth element undefined.

a@
[source]
----
__swizzled_vec__ odd() const
----
   a@ Available only when: [code]#NumElements > 1#.

Return an instance of the implementation-defined intermediate class template [code]#+__swizzled_vec__+# representing an index sequence made up of the odd indexes of this SYCL vec which can be used to apply the swizzle in a valid expression as described in <<swizzled-vec-class>>. When [code]#NumElements == 3#, this SYCL [code]#vec# is treated as though
[code]#NumElements == 4# with the fourth element undefined.


a@
[source]
----
__swizzled_vec__ even() const
----
   a@ Available only when: [code]#NumElements > 1#.

Return an instance of the implementation-defined intermediate class template [code]#+__swizzled_vec__+# representing an index sequence made up of the even indexes of this SYCL vec which can be used to apply the swizzle in a valid expression as described in <<swizzled-vec-class>>. When [code]#NumElements == 3#, this SYCL [code]#vec# is treated as though
[code]#NumElements == 4# with the fourth element undefined.

a@
[source]
----
template <access::address_space AddressSpace, access::decorated IsDecorated>
void load(size_t offset, multi_ptr<const DataT, AddressSpace, IsDecorated> ptr)
----
   a@ Loads the values at the address of [code]#ptr# offset in elements of type [code]#DataT# by [code]#NumElements * offset#, into the components of this SYCL [code]#vec#.

a@
[source]
----
template <access::address_space AddressSpace, access::decorated IsDecorated>
void store(size_t offset, multi_ptr<DataT, AddressSpace, IsDecorated> ptr) const
----
   a@ Stores the components of this SYCL [code]#vec# into the values at the address of [code]#ptr# offset in elements of type [code]#DataT# by [code]#NumElements * offset#.

a@
[source]
----
DataT& operator[](int index)
----
   a@ Returns a reference to the element stored within this SYCL [code]#vec# at the index specified by [code]#index#.

a@
[source]
----
const DataT& operator[](int index) const
----
   a@ Returns a const reference to the element stored within this SYCL [code]#vec# at the index specified by [code]#index#.

a@
[source]
----
vec& operator=(const vec& rhs)
----
   a@ Assign each element of the [code]#rhs# SYCL [code]#vec# to each element of this SYCL [code]#vec# and return a reference to this SYCL [code]#vec#.

a@
[source]
----
vec& operator=(const DataT& rhs)
----
   a@ Assign each element of the [code]#rhs# scalar to each element of this SYCL [code]#vec# and return a reference to this SYCL [code]#vec#.

|====



[[table.functions.vec]]
.Hidden friend functions of the [code]#vec# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Hidden friend function @ Description
a@
[source]
----
vec operatorOP(const vec& lhs, const vec& rhs)
----
   a@ If [code]#OP# is [code]#%#, available only when: [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#vec# class template with the same template parameters as [code]#lhs# [code]#vec# with each element of the new SYCL [code]#vec# instance the result of an element-wise [code]#OP# arithmetic operation between each element of [code]#lhs# [code]#vec# and each element of the [code]#rhs# SYCL [code]#vec#.

Where [code]#OP# is: [code]#pass:[+]#, [code]#-#, [code]#*#, [code]#/#, [code]#%#.

a@
[source]
----
vec operatorOP(const vec& lhs, const DataT& rhs)
----
   a@ If [code]#OP# is [code]#%#, available only when: [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#vec# class template with the same template parameters as [code]#lhs# [code]#vec# with each element of the new SYCL [code]#vec# instance the result of an element-wise [code]#OP# arithmetic operation between each element of [code]#lhs# [code]#vec# and the [code]#rhs# scalar.

Where [code]#OP# is: [code]#pass:[+]#, [code]#-#, [code]#*#, [code]#/#, [code]#%#.

a@
[source]
----
vec& operatorOP(vec& lhs, const vec& rhs)
----
   a@ If [code]#OP# is [code]#%=#, available only when: [code]#DataT != float && DataT != double && DataT != half#.

Perform an in-place element-wise [code]#OP# arithmetic operation between each element of [code]#lhs# [code]#vec# and each element of the [code]#rhs# SYCL [code]#vec# and return [code]#lhs# [code]#vec#.

Where [code]#OP# is: [code]#pass:[+=]#, [code]#-=#, [code]#*=#, [code]#/=#, [code]#%=#.

a@
[source]
----
vec& operatorOP(vec& lhs, const DataT& rhs)
----
   a@ If [code]#OP# is [code]#%=#, available only when: [code]#DataT != float && DataT != double && DataT != half#.

Perform an in-place element-wise [code]#OP# arithmetic operation between each element of [code]#lhs# [code]#vec# and [code]#rhs# scalar and return [code]#lhs# [code]#vec#.

Where [code]#OP# is: [code]#pass:[+=]#, [code]#-=#, [code]#*=#, [code]#/=#, [code]#%=#.

a@
[source]
----
vec& operatorOP(vec& v)
----
   a@ Available only when: [code]#DataT != bool#.

Perform an in-place element-wise [code]#OP# prefix arithmetic operation on each element of [code]#lhs# [code]#vec#, assigning the result of each element to the corresponding element of [code]#lhs# [code]#vec# and return [code]#lhs# [code]#vec#.

Where [code]#OP# is: [code]#pass:[++]#, [code]#--#.

a@
[source]
----
vec operatorOP(vec& v, int)
----
   a@ Available only when: [code]#DataT != bool#.

Perform an in-place element-wise [code]#OP# postfix arithmetic operation on each element of [code]#lhs# [code]#vec#, assigning the result of each element to the corresponding element of [code]#lhs# [code]#vec# and returns a copy of [code]#lhs# [code]#vec# before the operation is performed.

Where [code]#OP# is: [code]#pass:[++]#, [code]#--#.

a@
[source]
----
vec operatorOP(const vec& v)
----
   a@ Construct a new instance of the SYCL [code]#vec# class template with the same template parameters as this SYCL [code]#vec# with each element of the new SYCL [code]#vec# instance the result of an element-wise [code]#OP# unary arithmetic operation on each element of this SYCL [code]#vec#.

Where [code]#OP# is: [code]#pass:[+]#, [code]#-#.

a@
[source]
----
vec operatorOP(const vec& lhs, const vec& rhs)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#vec# class template with the same template parameters as [code]#lhs# [code]#vec# with each element of the new SYCL [code]#vec# instance the result of an element-wise [code]#OP# bitwise operation between each element of [code]#lhs# [code]#vec# and each element of the [code]#rhs# SYCL [code]#vec#.

Where [code]#OP# is: [code]#&#, [code]#|#, [code]#^#.

a@
[source]
----
vec operatorOP(const vec& lhs, const DataT& rhs)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#vec# class template with the same template parameters as [code]#lhs# [code]#vec# with each element of the new SYCL [code]#vec# instance the result of an element-wise [code]#OP# bitwise operation between each element of [code]#lhs# [code]#vec# and the [code]#rhs# scalar.

Where [code]#OP# is: [code]#&#, [code]#|#, [code]#^#.

a@
[source]
----
vec& operatorOP(vec& lhs, const vec& rhs)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Perform an in-place element-wise [code]#OP# bitwise operation between each element of [code]#lhs# [code]#vec# and the [code]#rhs# SYCL [code]#vec# and return [code]#lhs# [code]#vec#.

Where [code]#OP# is: [code]#&=#, [code]#|=#, [code]#^=#.

a@
[source]
----
vec& operatorOP(vec& lhs, const DataT& rhs)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Perform an in-place element-wise [code]#OP# bitwise operation between each element of [code]#lhs# [code]#vec# and the [code]#rhs# scalar and return a [code]#lhs# [code]#vec#.

Where [code]#OP# is: [code]#&=#, [code]#|=#, [code]#^=#.

a@
[source]
----
vec<RET, NumElements> operatorOP(const vec& lhs, const vec& rhs)
----
   a@ Construct a new instance of the SYCL [code]#vec# class template with the same template parameters as [code]#lhs# [code]#vec# with each element of the new SYCL [code]#vec# instance the result of an element-wise [code]#OP# logical operation between each element of [code]#lhs# [code]#vec# and each element of the [code]#rhs# SYCL [code]#vec#.

The [code]#DataT# template parameter of the constructed SYCL [code]#vec#, [code]#RET#, varies depending on the [code]#DataT# template parameter of this SYCL [code]#vec#. For a SYCL [code]#vec# with [code]#DataT# of type [code]#int8_t# or [code]#uint8_t# [code]#RET# must be [code]#int8_t#. For a SYCL [code]#vec# with [code]#DataT# of type [code]#int16_t#, [code]#uint16_t# or [code]#half# [code]#RET# must be [code]#int16_t#. For a SYCL [code]#vec# with [code]#DataT# of type [code]#int32_t#, [code]#uint32_t# or [code]#float# [code]#RET# must be [code]#int32_t#. For a SYCL [code]#vec# with [code]#DataT# of type [code]#int64_t#, [code]#uint64_t# or [code]#double# [code]#RET# must be [code]#int64_t#.

Where [code]#OP# is: [code]#&&#, [code]#||#.

a@
[source]
----
vec<RET, NumElements> operatorOP(const vec& lhs, const DataT& rhs)
----
   a@ Construct a new instance of the SYCL [code]#vec# class template with the same template parameters as this SYCL [code]#vec# with each element of the new SYCL [code]#vec# instance the result of an element-wise [code]#OP# logical operation between each element of [code]#lhs# [code]#vec# and the [code]#rhs# scalar.

The [code]#DataT# template parameter of the constructed SYCL [code]#vec#, [code]#RET#, varies depending on the [code]#DataT# template parameter of this SYCL [code]#vec#. For a SYCL [code]#vec# with [code]#DataT# of type [code]#int8_t# or [code]#uint8_t# [code]#RET# must be [code]#int8_t#. For a SYCL [code]#vec# with [code]#DataT# of type [code]#int16_t#, [code]#uint16_t# or [code]#half# [code]#RET# must be [code]#int16_t#. For a SYCL [code]#vec# with [code]#DataT# of type [code]#int32_t#, [code]#uint32_t# or [code]#float# [code]#RET# must be [code]#int32_t#. For a SYCL [code]#vec# with [code]#DataT# of type [code]#int64_t#, [code]#uint64_t# or [code]#double# [code]#RET# must be [code]#uint64_t#.

Where [code]#OP# is: [code]#&&#, [code]#||#.

a@
[source]
----
vec operatorOP(const vec& lhs, const vec& rhs)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#vec# class template with the same template parameters as [code]#lhs# [code]#vec# with each element of the new SYCL [code]#vec# instance the result of an element-wise [code]#OP# bitshift operation between each element of [code]#lhs# [code]#vec# and each element of the [code]#rhs# SYCL [code]#vec#. If [code]#OP# is [code]#>>#, [code]#DataT# is a signed type and [code]#lhs# [code]#vec# has a negative value any vacated bits viewed as an unsigned integer must be assigned the value [code]#1#, otherwise any vacated bits viewed as an unsigned integer must be assigned the value [code]#0#.

Where [code]#OP# is: [code]#<<#, [code]#>>#.

a@
[source]
----
vec operatorOP(const vec& lhs, const DataT& rhs)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#vec# class template with the same template parameters as [code]#lhs# [code]#vec# with each element of the new SYCL [code]#vec# instance the result of an element-wise [code]#OP# bitshift operation between each element of [code]#lhs# [code]#vec# and the [code]#rhs# scalar. If [code]#OP# is [code]#>>#, [code]#DataT# is a signed type and [code]#lhs# [code]#vec# has a negative value any vacated bits viewed as an unsigned integer must be assigned the value [code]#1#, otherwise any vacated bits viewed as an unsigned integer must be assigned the value [code]#0#.

Where [code]#OP# is: [code]#<<#, [code]#>>#.

a@
[source]
----
vec& operatorOP(vec& lhs, const vec& rhs)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Perform an in-place element-wise [code]#OP# bitshift operation between each element of [code]#lhs# [code]#vec# and the [code]#rhs# SYCL [code]#vec# and returns [code]#lhs# [code]#vec#. If [code]#OP# is [code]#>>=#, [code]#DataT# is a signed type and [code]#lhs# [code]#vec# has a negative value any vacated bits viewed as an unsigned integer must be assigned the value [code]#1#, otherwise any vacated bits viewed as an unsigned integer must be assigned the value [code]#0#.

Where [code]#OP# is: [code]#+<<=+#, [code]#>>=#.

a@
[source]
----
vec& operatorOP(vec& lhs, const DataT& rhs)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Perform an in-place element-wise [code]#OP# bitshift operation between each element of [code]#lhs# [code]#vec# and the [code]#rhs# scalar and returns a reference to this SYCL [code]#vec#. If [code]#OP# is [code]#>>=#, [code]#DataT# is a signed type and [code]#lhs# [code]#vec# has a negative value any vacated bits viewed as an unsigned integer must be assigned the value [code]#1#, otherwise any vacated bits viewed as an unsigned integer must be assigned the value [code]#0#.

Where [code]#OP# is: [code]#+<<=+#, [code]#>>=#.

a@
[source]
----
vec<RET, NumElements> operatorOP(const vec& lhs, const vec& rhs)
----
   a@ Construct a new instance of the SYCL [code]#vec# class template with the element type [code]#RET# with each element of the new SYCL [code]#vec# instance the result of an element-wise [code]#OP# relational operation between each element of [code]#lhs# [code]#vec# and each element of the [code]#rhs# SYCL [code]#vec#. Each element of the SYCL [code]#vec# that is returned must be [code]#-1# if the operation results in [code]#true# and [code]#0# if the operation results in [code]#false#.  The [code]#==#, [code]#<#, [code]#>#, [code]#+<=+# and [code]#>=# operations result in [code]#false# if either the [code]#lhs# element or the [code]#rhs# element is a NaN.  The [code]#!=# operation results in [code]#true# if either the [code]#lhs# element or the [code]#rhs# element is a NaN.

The [code]#DataT# template parameter of the constructed SYCL [code]#vec#, [code]#RET#, varies depending on the [code]#DataT# template parameter of this SYCL [code]#vec#. For a SYCL [code]#vec# with [code]#DataT# of type [code]#int8_t# or [code]#uint8_t# [code]#RET# must be [code]#int8_t#. For a SYCL [code]#vec# with [code]#DataT# of type [code]#int16_t#, [code]#uint16_t# or [code]#half# [code]#RET# must be [code]#int16_t#. For a SYCL [code]#vec# with [code]#DataT# of type [code]#int32_t#, [code]#uint32_t# or [code]#float# [code]#RET# must be [code]#int32_t#. For a SYCL [code]#vec# with [code]#DataT# of type [code]#int64_t#, [code]#uint64_t# or [code]#double# [code]#RET# must be [code]#uint64_t#.

Where [code]#OP# is: [code]#==#, [code]#!=#, [code]#<#, [code]#>#, [code]#+<=+#, [code]#>=#.

a@
[source]
----
vec<RET, NumElements> operatorOP(const vec& lhs, const DataT& rhs)
----
   a@ Construct a new instance of the SYCL [code]#vec# class template with the [code]#DataT# parameter of [code]#RET# with each element of the new SYCL [code]#vec# instance the result of an element-wise [code]#OP# relational operation between each element of [code]#lhs# [code]#vec# and the [code]#rhs# scalar. Each element of the SYCL [code]#vec# that is returned must be [code]#-1# if the operation results in [code]#true# and [code]#0# if the operation results in [code]#false#.  The [code]#==#, [code]#<#, [code]#>#, [code]#+<=+# and [code]#>=# operations result in [code]#false# if either the [code]#lhs# element or the [code]#rhs# is a NaN.  The [code]#!=# operation results in [code]#true# if either the [code]#lhs# element or the [code]#rhs# is a NaN.

The [code]#DataT# template parameter of the constructed SYCL [code]#vec#, [code]#RET#, varies depending on the [code]#DataT# template parameter of this SYCL [code]#vec#. For a SYCL [code]#vec# with [code]#DataT# of type [code]#int8_t# or [code]#uint8_t# [code]#RET# must be [code]#int8_t#. For a SYCL [code]#vec# with [code]#DataT# of type [code]#int16_t#, [code]#uint16_t# or [code]#half# [code]#RET# must be [code]#int16_t#. For a SYCL [code]#vec# with [code]#DataT# of type [code]#int32_t#, [code]#uint32_t# or [code]#float# [code]#RET# must be [code]#int32_t#. For a SYCL [code]#vec# with [code]#DataT# of type [code]#int64_t#, [code]#uint64_t# or [code]#double# [code]#RET# must be [code]#uint64_t#.

Where [code]#OP# is: [code]#==#, [code]#!=#, [code]#<#, [code]#>#, [code]#+<=+#, [code]#>=#.

a@
[source]
----
vec operatorOP(const DataT& lhs, const vec& rhs)
----
   a@ If [code]#OP# is [code]#%#, available only when: [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#vec# class template with
the same template parameters as the [code]#rhs# SYCL [code]#vec#
with each element of the new SYCL [code]#vec# instance the result of
an element-wise [code]#OP# arithmetic operation between the
[code]#lhs# scalar and each element of the [code]#rhs# SYCL
[code]#vec#.

Where [code]#OP# is: [code]#pass:[+]#, [code]#-#, [code]#*#,
[code]#/#, [code]#%#.

a@
[source]
----
vec operatorOP(const DataT& lhs, const vec& rhs)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#vec# class template with
the same template parameters as the [code]#rhs# SYCL [code]#vec#
with each element of the new SYCL [code]#vec# instance the result of
an element-wise [code]#OP# bitwise operation between the [code]#lhs# scalar and each element of the [code]#rhs# SYCL [code]#vec#.

Where [code]#OP# is: [code]#&#, [code]#|#, [code]#^#.

a@
[source]
----
vec<RET, NumElements> operatorOP(const DataT& lhs, const vec& rhs)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#vec# class template with
the same template parameters as the [code]#rhs# SYCL [code]#vec#
with each element of the new SYCL [code]#vec# instance the result of
an element-wise [code]#OP# logical operation between the [code]#lhs# scalar and each element of the [code]#rhs# SYCL [code]#vec#.

The [code]#DataT# template parameter of the constructed SYCL [code]#vec#, [code]#RET#, varies depending on the [code]#DataT# template parameter of this SYCL [code]#vec#. For a SYCL [code]#vec# with [code]#DataT# of type [code]#int8_t# or [code]#uint8_t# [code]#RET# must be [code]#int8_t#. For a SYCL [code]#vec# with [code]#DataT# of type [code]#int16_t#, [code]#uint16_t# or [code]#half# [code]#RET# must be [code]#int16_t#. For a SYCL [code]#vec# with [code]#DataT# of type [code]#int32_t#, [code]#uint32_t# or [code]#float# [code]#RET# must be [code]#int32_t#. For a SYCL [code]#vec# with [code]#DataT# of type [code]#int64_t#, [code]#uint64_t# or [code]#double# [code]#RET# must be [code]#int64_t#.

Where [code]#OP# is: [code]#&&#, [code]#||#.

a@
[source]
----
vec operatorOP(const DataT& lhs, const vec& rhs)
----
   a@ Construct a new instance of the SYCL [code]#vec# class template with
      the same template parameters as the [code]#rhs# SYCL [code]#vec#
      with each element of the new SYCL [code]#vec# instance the result of
      an element-wise [code]#OP# bitshift operation between the [code]#lhs# scalar and each element of the [code]#rhs# SYCL [code]#vec#.
      If [code]#OP# is [code]#>>#, [code]#DataT# is a signed type
      and this SYCL [code]#vec# has a negative value any vacated bits viewed
      as an unsigned integer must be assigned the value [code]#1#, otherwise
      any vacated bits viewed as an unsigned integer must be assigned the value
      [code]#0#.

Where [code]#OP# is: [code]#<<#, [code]#>>#.

a@
[source]
----
vec<RET, NumElements> operatorOP(const DataT& lhs, const vec& rhs)
----
   a@ Construct a new instance of the SYCL [code]#vec# class template with
      the element type [code]#RET# with each element of the new SYCL
      [code]#vec# instance the result of an element-wise [code]#OP#
      relational operation between the [code]#lhs# scalar and each element
      of the [code]#rhs# SYCL [code]#vec#. Each element of the SYCL
      [code]#vec# that is returned must be [code]#-1# if the operation
      results in [code]#true# and [code]#0# if the operation results
      in [code]#false#. The [code]#==#, [code]#<#, [code]#>#, [code]#+<=+#
      and [code]#>=# operations result in [code]#false# if either the
      [code]#lhs# or the [code]#rhs# element is a NaN. The [code]#!=#
      operation results in [code]#true# if either the [code]#lhs# or the
      [code]#rhs# element is a NaN.

The [code]#DataT# template parameter of the constructed SYCL
[code]#vec#, [code]#RET#, varies depending on the [code]#DataT# template parameter of this SYCL [code]#vec#. For a SYCL
[code]#vec# with [code]#DataT# of type [code]#int8_t# or
[code]#uint8_t# [code]#RET# must be [code]#int8_t#. For a
SYCL [code]#vec# with [code]#DataT# of type [code]#int16_t#, [code]#uint16_t# or [code]#half# [code]#RET#
must be [code]#int16_t#. For a SYCL [code]#vec# with
[code]#DataT# of type [code]#int32_t#, [code]#uint32_t# or
[code]#float# [code]#RET# must be [code]#int32_t#. For a
SYCL [code]#vec# with [code]#DataT# of type [code]#int64_t#, [code]#uint64_t# or [code]#double# [code]#RET#
must be [code]#int64_t#.

Where [code]#OP# is: [code]#==#, [code]#!=#, [code]#<#, [code]#>#, [code]#+<=+#, [code]#>=#.

a@
[source]
----
vec& operator~(const vec& v)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#vec# class template with the same template parameters as [code]#v# [code]#vec# with each element of the new SYCL [code]#vec# instance the result of an element-wise [code]#OP# bitwise operation on each element of [code]#v# [code]#vec#.

a@
[source]
----
vec<RET, NumElements> operator!(const vec& v)
----
   a@ Construct a new instance of the SYCL [code]#vec# class template with the same template parameters as [code]#v# [code]#vec# with each element of the new SYCL [code]#vec# instance the result of an element-wise [code]#OP# logical operation on each element of [code]#v# [code]#vec#. Each element of the SYCL [code]#vec# that is returned must be [code]#-1# if the operation results in [code]#true# and [code]#0# if the operation results in [code]#false# or this SYCL [code]#vec# is a NaN.

The [code]#DataT# template parameter of the constructed SYCL [code]#vec#, [code]#RET#, varies depending on the [code]#DataT# template parameter of this SYCL [code]#vec#. For a SYCL [code]#vec# with [code]#DataT# of type [code]#int8_t# or [code]#uint8_t# [code]#RET# must be [code]#int8_t#. For a SYCL [code]#vec# with [code]#DataT# of type [code]#int16_t#, [code]#uint16_t# or [code]#half# [code]#RET# must be [code]#int16_t#. For a SYCL [code]#vec# with [code]#DataT# of type [code]#int32_t#, [code]#uint32_t# or [code]#float# [code]#RET# must be [code]#int32_t#. For a SYCL [code]#vec# with [code]#DataT# of type [code]#int64_t#, [code]#uint64_t# or [code]#double# [code]#RET# must be [code]#int64_t#.

|====


==== Aliases

The SYCL programming API provides all permutations of the type alias:

[code]#+using <type><elems> = vec<<storage-type>, <elems>>+#

where [code]#<elems># is [code]#2#, [code]#3#, [code]#4#,
[code]#8# and [code]#16#, and pairings of [code]#<type># and
[code]#<storage-type># for integral types are [code]#char# and
[code]#int8_t#, [code]#uchar# and [code]#uint8_t#,
[code]#short# and [code]#int16_t#, [code]#ushort# and
[code]#uint16_t#, [code]#int# and [code]#int32_t#,
[code]#uint# and [code]#uint32_t#, [code]#long# and
[code]#int64_t#, [code]#ulong# and [code]#uint64_t#, and for
floating point types are both [code]#half#, [code]#float# and
[code]#double#.

For example [code]#uint4# is the alias to [code]#vec<uint32_t, 4>#
and [code]#float16# is the alias to [code]#vec<float, 16>#.

==== Swizzles

Swizzle operations can be performed in two ways. Firstly by calling the
[code]#swizzle# member function template, which takes a variadic number
of integer template arguments between [code]#0# and
[code]#NumElements-1#, specifying swizzle indexes. Secondly by calling
one of the simple swizzle member functions defined in
<<table.members.vec>> as [code]#XYZW_SWIZZLE# and
[code]#RGBA_SWIZZLE#. Note that the simple swizzle functions are only
available for up to 4 element vectors and are only available when the macro
[code]#SYCL_SIMPLE_SWIZZLES# is defined before including
[code]#<sycl/sycl.hpp>#.

In both cases the return type is always an instance of
[code]#+__swizzled_vec__+#, an implementation-defined temporary class
representing a swizzle of the original SYCL [code]#vec# instance. Both
kinds of swizzle member functions must not perform the swizzle operation
themselves, instead the swizzle operation must be performed by the returned
instance of [code]#+__swizzled_vec__+# when used within an expression,
meaning if the returned [code]#+__swizzled_vec__+# is never used in an
expression no swizzle operation is performed.

Both the [code]#swizzle# member function template and the simple
swizzle member functions allow swizzle indexes to be repeated.

A series of static constexpr values are provided within the
[code]#elem# struct to allow specifying named swizzle indexes when
calling the [code]#swizzle# member function template.


[[swizzled-vec-class]]
==== Swizzled [code]#vec# class

The [code]#+__swizzled_vec__+# class must define an unspecified
temporary which provides the entire interface of the SYCL [code]#vec#
class template, including swizzled member functions, with the additions and
alterations described below:

  * The [code]#+__swizzled_vec__+# class template must be readable as an
    r-value reference on the RHS of an expression. In this case the swizzle
    operation is performed on the RHS of the expression and then the result
    is applied to the LHS of the expression.
  * The [code]#+__swizzled_vec__+# class template must be assignable as
    an l-value reference on the LHS of an expression. In this case the RHS
    of the expression is applied to the original SYCL [code]#vec# which
    the [code]#+__swizzled_vec__+# represents via the swizzle operation.
    Note that a [code]#+__swizzled_vec__+# that is used in an l-value
    expression may not contain any repeated element indexes.
+
For example: [code]#f4.xxxx() = fx.wzyx()# would not be valid.
  * The [code]#+__swizzled_vec__+# class template must be convertible to
    an instance of SYCL [code]#vec# with the type [code]#DataT#
    and number of elements specified by the swizzle member function, if
    [code]#NumElements > 1#, and must be convertible to an instance of
    type [code]#DataT#, if [code]#NumElements == 1#.
  * The [code]#+__swizzled_vec__+# class template must be non-copyable,
    non-moveable, non-user constructible and may not be bound to a l-value
    or escape the expression it was constructed in. For example
    [code]#auto x = f4.x()# would not be valid.
  * The [code]#+__swizzled_vec__+# class template should return
    [code]#+__swizzled_vec__&+# for each operator inherited from the
    [code]#vec# class template interface which would return
    [code]#vec<DataT, NumElements>&#.


==== Rounding modes

The various rounding modes that can be used in the [code]#as# member
function template are described in <<table.vec.roundingmodes>>.


[[table.vec.roundingmodes]]
.Rounding modes for the SYCL [code]#vec# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Rounding mode @ Description
a@
[source]
----
automatic
----
   a@ Default rounding mode for the SYCL [code]#vec# class element type. [code]#rtz# (round toward zero) for integer types and [code]#rte# (round to nearest even) for floating-point types.

a@
[source]
----
rte
----
   a@ Round to nearest even.

a@
[source]
----
rtz
----
   a@ Round toward zero.

a@
[source]
----
rtp
----
   a@ Round toward positive infinity.

a@
[source]
----
rtn
----
   a@ Round toward negative infinity.

|====



[[memory-layout-and-alignment]]
==== Memory layout and alignment

The elements of an instance of the SYCL [code]#vec# class template are
stored in memory sequentially and contiguously and are aligned to the size
of the element type in bytes multiplied by the number of elements:

[[vec-memory-alignment]]
[latexmath]
++++
\texttt{sizeof}(\texttt{DataT}) \cdot \texttt{NumElements}
++++

The exception to this is when the number of element is three in which case
the SYCL [code]#vec# is aligned to the size of the element type in
bytes multiplied by four:

[[vec3-memory-alignment]]
[latexmath]
++++
\texttt{sizeof}(\texttt{DataT}) \cdot 4
++++

This is true for both host and device code in order to allow for instances
of the [code]#vec# class template to be passed to SYCL kernel
functions.


==== Performance note

The usage of the subscript [code]#operator[]# may not be efficient on some devices.

// %%%%%%%%%%%%%%%%%%%%%%%%%%%% end vec_class %%%%%%%%%%%%%%%%%%%%%%%%%%%%

// \input{marray_class}

// %%%%%%%%%%%%%%%%%%%%%%%%%%%% begin marray_class %%%%%%%%%%%%%%%%%%%%%%%%%%%%

[[sec:marray.type]]
=== Math array types

SYCL provides an [code]#marray<typename DataT, std::size_t NumElements># class
template to represent a contiguous fixed-size container.  This type allows
sharing of containers between the host and its SYCL devices.

The [code]#marray# class is templated on its element type and number of
elements. The number of elements parameter, [code]#NumElements#, is a positive
value of the [code]#std::size_t# type. The element type parameter, [code]#DataT#,
must be a _numeric type_ as it is defined by {cpp} standard.

An instance of the [code]#marray# class template can also be
implicitly converted to an instance of the data type when the number of
elements is [code]#1# in order to allow single element arrays and
scalars to be convertible with each other.

Logical and comparison operators for [code]#marray# class template
return [code]#marray<bool, NumElements>#.


==== Math array interface

The constructors, member functions and non-member functions of the SYCL
[code]#marray# class template are listed in
<<table.constructors.marray>>, <<table.members.marray>> and
<<table.functions.marray>> respectively.

// Interface for class: vec
[source,,linenums]
----
include::{header_dir}/marray.h[lines=4..-1]
----


[[table.constructors.marray]]
.Constructors of the SYCL [code]#marray# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
marray()
----
   a@ Default construct an array with element type [code]#DataT# and
      with [code]#NumElements# dimensions by default construction of
      each of its elements.

a@
[source]
----
explicit constexpr marray(const DataT& arg)
----
   a@ Construct an array of element type [code]#DataT# and
      [code]#NumElements# dimensions by setting each value to [code]#arg# by
      assignment.

a@
[source]
----
template <typename... ArgTN> constexpr marray(const ArgTN&... args)
----
   a@ Construct a SYCL [code]#marray# instance from any combination of scalar and SYCL [code]#marray# parameters of the same element type, providing the total number of elements for all parameters sum to [code]#NumElements# of this [code]#marray# specialization.

a@
[source]
----
constexpr marray(const marray<DataT, NumElements>& rhs)
----
   a@ Construct an array of element type [code]#DataT# and number of elements [code]#NumElements# by copy from another similar vector.

a@
[source]
----
constexpr marray(marray<DataT, NumElements>&& rhs)
----
   a@ Construct an array of element type [code]#DataT# and number of elements
      [code]#NumElements# by moving from another similar vector.

|====



[[table.members.marray]]
.Member functions for the SYCL [code]#marray# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
operator DataT() const
----
   a@ Available only when: [code]#NumElements == 1#.

Converts this SYCL [code]#marray# instance to an instance of [code]#DataT# with
the value of the single element in this SYCL [code]#marray# instance.

The SYCL [code]#marray# instance shall be implicitly convertible to the same data types,
to which [code]#DataT# is implicitly convertible.
Note that conversion operator shall not be templated
to allow standard conversion sequence for implicit conversion.

a@
[source]
----
static constexpr std::size_t size() noexcept
----
   a@ Returns the size of this SYCL [code]#marray# in bytes.

a@
[source]
----
DataT& operator[](std::size_t index)
----
   a@ Returns a reference to the element stored within this SYCL [code]#marray# at the index specified by [code]#index#.

a@
[source]
----
const DataT& operator[](std::size_t index) const
----
   a@ Returns a const reference to the element stored within this SYCL [code]#marray# at the index specified by [code]#index#.

a@
[source]
----
marray& operator=(const marray& rhs)
----
   a@ Assign each element of the [code]#rhs# SYCL [code]#marray# to each element of this SYCL [code]#marray# and return a reference to this SYCL [code]#marray#.

a@
[source]
----
marray& operator=(const DataT& rhs)
----
   a@ Assign each element of the [code]#rhs# scalar to each element of this SYCL [code]#marray# and return a reference to this SYCL [code]#marray#.

a@
[source]
----
iterator begin()
----
   a@ Returns an iterator referring to the first element stored within the [code]#v# [code]#marray#.

a@
[source]
----
const_iterator begin() const
----
   a@ Returns a const iterator referring to the first element stored within the [code]#v# [code]#marray#.

a@
[source]
----
iterator end()
----
   a@ Returns an iterator referring to the one past the last element stored within the [code]#v# [code]#marray#.

a@
[source]
----
const_iterator end() const
----
   a@ Returns a const iterator referring to the one past the last
      element stored within the [code]#v# [code]#marray#.

|====



[[table.functions.marray]]
.Hidden friend functions of the [code]#marray# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Hidden friend function @ Description
a@
[source]
----
marray operatorOP(const marray& lhs, const marray& rhs)
----
   a@ If [code]#OP# is [code]#%#, available only when: [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#marray# class template with the same template parameters as [code]#lhs# [code]#marray# with each element of the new SYCL [code]#marray# instance the result of an element-wise [code]#OP# arithmetic operation between each element of [code]#lhs# [code]#marray# and each element of the [code]#rhs# SYCL [code]#marray#.

Where [code]#OP# is: [code]#pass:[+]#, [code]#-#, [code]#*#, [code]#/#, [code]#%#.

a@
[source]
----
marray operatorOP(const marray& lhs, const DataT& rhs)
----
   a@ If [code]#OP# is [code]#%#, available only when: [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#marray# class template with the same template parameters as [code]#lhs# [code]#marray# with each element of the new SYCL [code]#marray# instance the result of an element-wise [code]#OP# arithmetic operation between each element of [code]#lhs# [code]#marray# and the [code]#rhs# scalar.

Where [code]#OP# is: [code]#pass:[+]#, [code]#-#, [code]#*#, [code]#/#, [code]#%#.

a@
[source]
----
marray& operatorOP(marray& lhs, const marray& rhs)
----
   a@ If [code]#OP# is [code]#%=#, available only when: [code]#DataT != float && DataT != double && DataT != half#.

Perform an in-place element-wise [code]#OP# arithmetic operation between each element of [code]#lhs# [code]#marray# and each element of the [code]#rhs# SYCL [code]#marray# and return [code]#lhs# [code]#marray#.

Where [code]#OP# is: [code]#pass:[+=]#, [code]#-=#, [code]#*=#, [code]#/=#, [code]#%=#.

a@
[source]
----
marray& operatorOP(marray& lhs, const DataT& rhs)
----
   a@ If [code]#OP# is [code]#%=#, available only when: [code]#DataT != float && DataT != double && DataT != half#.

Perform an in-place element-wise [code]#OP# arithmetic operation between each element of [code]#lhs# [code]#marray# and [code]#rhs# scalar and return [code]#lhs# [code]#marray#.

Where [code]#OP# is: [code]#pass:[+=]#, [code]#-=#, [code]#*=#, [code]#/=#, [code]#%=#.

a@
[source]
----
marray& operatorOP(marray& v)
----
   a@ Perform an in-place element-wise [code]#OP# prefix arithmetic operation on each element of [code]#v# [code]#marray#, assigning the result of each element to the corresponding element of [code]#v# [code]#marray# and return [code]#v# [code]#marray#.

Where [code]#OP# is: [code]#pass:[++]#, [code]#--#.

a@
[source]
----
marray operatorOP(marray& v, int)
----
   a@ Perform an in-place element-wise [code]#OP# postfix arithmetic operation on each element of [code]#v# [code]#marray#, assigning the result of each element to the corresponding element of [code]#v# [code]#marray# and returns a copy of [code]#v# [code]#marray# before the operation is performed.

Where [code]#OP# is: [code]#pass:[++]#, [code]#--#.

a@
[source]
----
marray operatorOP(marray& v)
----
   a@ Construct a new instance of the SYCL [code]#marray# class template with the same template parameters as this SYCL [code]#marray# with each element of the new SYCL [code]#marray# instance the result of an element-wise [code]#OP# unary arithmetic operation on each element of this SYCL [code]#marray#.

Where [code]#OP# is: [code]#pass:[+]#, [code]#-#.

a@
[source]
----
marray operatorOP(const marray& lhs, const marray& rhs)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#marray# class template with the same template parameters as [code]#lhs# [code]#marray# with each element of the new SYCL [code]#marray# instance the result of an element-wise [code]#OP# bitwise operation between each element of [code]#lhs# [code]#marray# and each element of the [code]#rhs# SYCL [code]#marray#.

Where [code]#OP# is: [code]#&#, [code]#|#, [code]#^#.

a@
[source]
----
marray operatorOP(const marray& lhs, const DataT& rhs)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#marray# class template with the same template parameters as [code]#lhs# [code]#marray# with each element of the new SYCL [code]#marray# instance the result of an element-wise [code]#OP# bitwise operation between each element of [code]#lhs# [code]#marray# and the [code]#rhs# scalar.

Where [code]#OP# is: [code]#&#, [code]#|#, [code]#^#.

a@
[source]
----
marray& operatorOP(marray& lhs, const marray& rhs)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Perform an in-place element-wise [code]#OP# bitwise operation between each element of [code]#lhs# [code]#marray# and the [code]#rhs# SYCL [code]#marray# and return [code]#lhs# [code]#marray#.

Where [code]#OP# is: [code]#&=#, [code]#|=#, [code]#^=#.

a@
[source]
----
marray& operatorOP(marray& lhs, const DataT& rhs)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Perform an in-place element-wise [code]#OP# bitwise operation between each element of [code]#lhs# [code]#marray# and the [code]#rhs# scalar and return a [code]#lhs# [code]#marray#.

Where [code]#OP# is: [code]#&=#, [code]#|=#, [code]#^=#.

a@
[source]
----
marray<bool, NumElements> operatorOP(const marray& lhs, const marray& rhs)
----
   a@ Construct a new instance of the [code]#marray# class template with [code]#DataT = bool# and same NumElements as [code]#lhs# [code]#marray# with each element of the new [code]#marray# instance the result of an element-wise [code]#OP# logical operation between each element of [code]#lhs# [code]#marray# and each element of the [code]#rhs# [code]#marray#.

Where [code]#OP# is: [code]#&&#, [code]#||#.

a@
[source]
----
marray<bool, NumElements> operatorOP(const marray& lhs, const DataT& rhs)
----
   a@ Construct a new instance of the [code]#marray# class template with [code]#DataT = bool# and same NumElements as [code]#lhs# [code]#marray# with each element of the new [code]#marray# instance the result of an element-wise [code]#OP# logical operation between each element of [code]#lhs# [code]#marray# and the [code]#rhs# scalar.

Where [code]#OP# is: [code]#&&#, [code]#||#.

a@
[source]
----
marray operatorOP(const marray& lhs, const marray& rhs)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#marray# class template with the same template parameters as [code]#lhs# [code]#marray# with each element of the new SYCL [code]#marray# instance the result of an element-wise [code]#OP# bitshift operation between each element of [code]#lhs# [code]#marray# and each element of the [code]#rhs# SYCL [code]#marray#. If [code]#OP# is [code]#>>#, [code]#DataT# is a signed type and [code]#lhs# [code]#marray# has a negative value any vacated bits viewed as an unsigned integer must be assigned the value [code]#1#, otherwise any vacated bits viewed as an unsigned integer must be assigned the value [code]#0#.

Where [code]#OP# is: [code]#<<#, [code]#>>#.

a@
[source]
----
marray operatorOP(const marray& lhs, const DataT& rhs)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#marray# class template with the same template parameters as [code]#lhs# [code]#marray# with each element of the new SYCL [code]#marray# instance the result of an element-wise [code]#OP# bitshift operation between each element of [code]#lhs# [code]#marray# and the [code]#rhs# scalar. If [code]#OP# is [code]#>>#, [code]#DataT# is a signed type and [code]#lhs# [code]#marray# has a negative value any vacated bits viewed as an unsigned integer must be assigned the value [code]#1#, otherwise any vacated bits viewed as an unsigned integer must be assigned the value [code]#0#.

Where [code]#OP# is: [code]#<<#, [code]#>>#.

a@
[source]
----
marray& operatorOP(marray& lhs, const marray& rhs)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Perform an in-place element-wise [code]#OP# bitshift operation between each element of [code]#lhs# [code]#marray# and the [code]#rhs# SYCL [code]#marray# and returns [code]#lhs# [code]#marray#. If [code]#OP# is [code]#>>=#, [code]#DataT# is a signed type and [code]#lhs# [code]#marray# has a negative value any vacated bits viewed as an unsigned integer must be assigned the value [code]#1#, otherwise any vacated bits viewed as an unsigned integer must be assigned the value [code]#0#.

Where [code]#OP# is: [code]#+<<=+#, [code]#>>=#.

a@
[source]
----
marray& operatorOP(marray& lhs, const DataT& rhs)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Perform an in-place element-wise [code]#OP# bitshift operation between each element of [code]#lhs# [code]#marray# and the [code]#rhs# scalar and returns a reference to this SYCL [code]#marray#. If [code]#OP# is [code]#>>=#, [code]#DataT# is a signed type and [code]#lhs# [code]#marray# has a negative value any vacated bits viewed as an unsigned integer must be assigned the value [code]#1#, otherwise any vacated bits viewed as an unsigned integer must be assigned the value [code]#0#.

Where [code]#OP# is: [code]#+<<=+#, [code]#>>=#.

a@
[source]
----
marray<bool, NumElements> operatorOP(const marray& lhs, const marray& rhs)
----
   a@ Construct a new instance of the [code]#marray# class template with [code]#DataT = bool# and same NumElements as [code]#lhs# [code]#marray#
      with each element of the new [code]#marray# instance is the result of an element-wise [code]#OP# relational operation between each element of [code]#lhs# [code]#marray#
      and each element of the [code]#rhs# [code]#marray#.
      The [code]#==#, [code]#<#, [code]#>#, [code]#+<=+# and [code]#>=#
      operations result in [code]#false# if either the [code]#lhs# element or
      the [code]#rhs# element is a NaN.  The [code]#!=# operation results in
      [code]#true# if either the [code]#lhs# element or the [code]#rhs# element
      is a NaN.

Where [code]#OP# is: [code]#==#, [code]#!=#, [code]#<#, [code]#>#, [code]#+<=+#, [code]#>=#.

a@
[source]
----
marray<bool, NumElements> operatorOP(const marray& lhs, const DataT& rhs)
----
   a@ Construct a new instance of the [code]#marray# class template with [code]#DataT = bool# and same NumElements as [code]#lhs# [code]#marray#
      with each element of the new [code]#marray# instance the result of an element-wise [code]#OP# relational operation between each element of [code]#lhs# [code]#marray#
      and the [code]#rhs# scalar.
      The [code]#==#, [code]#<#, [code]#>#, [code]#+<=+# and [code]#>=#
      operations result in [code]#false# if either the [code]#lhs# element or
      the [code]#rhs# is a NaN.  The [code]#!=# operation results in
      [code]#true# if either the [code]#lhs# element or the [code]#rhs# is a
      NaN.

Where [code]#OP# is: [code]#==#, [code]#!=#, [code]#<#, [code]#>#, [code]#+<=+#, [code]#>=#.

a@
[source]
----
marray operatorOP(const DataT& lhs, const marray& rhs)
----
   a@ If [code]#OP# is [code]#%#, available only when: [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#marray# class template with
the same template parameters as the [code]#rhs# SYCL [code]#marray#
with each element of the new SYCL [code]#marray# instance the result of
an element-wise [code]#OP# arithmetic operation between the
[code]#lhs# scalar and each element of the [code]#rhs# SYCL
[code]#marray#.

Where [code]#OP# is: [code]#pass:[+]#, [code]#-#, [code]#*#,
[code]#/#, [code]#%#.

a@
[source]
----
marray operatorOP(const DataT& lhs, const marray& rhs)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#marray# class template with
the same template parameters as the [code]#rhs# SYCL [code]#marray#
with each element of the new SYCL [code]#marray# instance the result of
an element-wise [code]#OP# bitwise operation between the [code]#lhs# scalar and each element of the [code]#rhs# SYCL [code]#marray#.

Where [code]#OP# is: [code]#&#, [code]#|#, [code]#^#.

a@
[source]
----
marray<bool, NumElements> operatorOP(const DataT& lhs, const marray& rhs)
----
   a@ Construct a new instance of the [code]#marray# class template with [code]#DataT = bool# and
same NumElements as [code]#rhs# [code]#marray# with each element of the new [code]#marray# instance
the result of an element-wise [code]#OP# logical operation between the [code]#lhs#
scalar and each element of the [code]#rhs# [code]#marray#.

Where [code]#OP# is: [code]#&&#, [code]#||#.

a@
[source]
----
marray operatorOP(const DataT& lhs, const marray& rhs)
----
   a@ Construct a new instance of the SYCL [code]#marray# class template with
      the same template parameters as the [code]#rhs# SYCL [code]#marray#
      with each element of the new SYCL [code]#marray# instance the result of
      an element-wise [code]#OP# bitshift operation between the [code]#lhs# scalar and each element of the [code]#rhs# SYCL [code]#marray#.
      If [code]#OP# is [code]#>>#, [code]#DataT# is a signed type
      and this SYCL [code]#marray# has a negative value any vacated bits viewed
      as an unsigned integer must be assigned the value [code]#1#, otherwise
      any vacated bits viewed as an unsigned integer must be assigned the value
      [code]#0#.

Where [code]#OP# is: [code]#<<#, [code]#>>#.

a@
[source]
----
marray<bool, NumElements> operatorOP(const DataT& lhs, const marray& rhs)
----
   a@ Construct a new instance of the [code]#marray# class template with
      [code]#DataT = bool# and same NumElements as [code]#rhs# [code]#marray#
      with each element of the new SYCL [code]#marray# instance the result of
      an element-wise [code]#OP# relational operation between the [code]#lhs#
      scalar and each element of the [code]#rhs# [code]#marray#.  The
      [code]#==#, [code]#<#, [code]#>#, [code]#+<=+# and [code]#>=# operations
      result in [code]#false# if either the [code]#lhs# or the [code]#rhs#
      element is a NaN.  The [code]#!=# operation results in [code]#true# if
      either the [code]#lhs# or the [code]#rhs# element is a NaN.

Where [code]#OP# is: [code]#==#, [code]#!=#, [code]#<#, [code]#>#, [code]#+<=+#, [code]#>=#.

a@
[source]
----
marray& operator~(const marray& v)
----
   a@ Available only when: [code]#DataT != float && DataT != double && DataT != half#.

Construct a new instance of the SYCL [code]#marray# class template with the same template parameters as [code]#v# [code]#marray# with each element of the new SYCL [code]#marray# instance the result of an element-wise [code]#OP# bitwise operation on each element of [code]#v# [code]#marray#.

a@
[source]
----
marray<bool, NumElements> operator!(const marray& v)
----
   a@ Construct a new instance of the [code]#marray# class template with [code]#DataT = bool# and same NumElements as [code]#v# [code]#marray#
      with each element of the new [code]#marray# instance the result of an element-wise logical [code]#!# operation on each element of [code]#v# [code]#marray#.

|====



==== Aliases

The SYCL programming API provides all permutations of the type alias:

[code]#+using m<type><elems> = marray<<storage-type>, <elems>>+#

where [code]#<elems># is [code]#2#, [code]#3#, [code]#4#,
[code]#8# and [code]#16#, and pairings of [code]#<type># and
[code]#<storage-type># for integral types are [code]#char# and
[code]#int8_t#, [code]#uchar# and [code]#uint8_t#,
[code]#short# and [code]#int16_t#, [code]#ushort# and
[code]#uint16_t#, [code]#int# and [code]#int32_t#,
[code]#uint# and [code]#uint32_t#, [code]#long# and
[code]#int64_t#, [code]#ulong# and [code]#uint64_t#, for
floating point types are both [code]#half#, [code]#float# and
[code]#double#, and for boolean type [code]#bool#.

For example [code]#muint4# is the alias to [code]#marray<uint32_t, 4>#
and [code]#mfloat16# is the alias to [code]#marray<float, 16>#.


[[memory-layout-and-alignment.marray]]
==== Memory layout and alignment

The elements of an instance of the [code]#marray# class template as if
stored in [code]#std::array<DataT, NumElements>#.

// %%%%%%%%%%%%%%%%%%%%%%%%%%%% end marray_class %%%%%%%%%%%%%%%%%%%%%%%%%%%%


== Synchronization and atomics

The available features are:

  * Accessor classes: Accessor classes specify acquisition and release of
    buffer and image data structures to provide points at which underlying
    queue synchronization primitives must be generated.
  * Atomic operations: SYCL devices support a restricted subset of {cpp}
    atomics and SYCL uses the library syntax from the next {cpp} specification
    to make this available.
  * Fences: Fence primitives are made available to order loads and stores.
    They are exposed through the [code]#atomic_fence# function. Fences
    can have acquire semantics, release semantics or both.
  * Barriers: Barrier primitives are made available to synchronize sets of
    work-items within individual <<group,groups>>. They are exposed through the
    [code]#group_barrier# function.
  * Hierarchical parallel dispatch: In the hierarchical parallelism model of
    describing computations, synchronization within the work-group is made
    explicit through multiple instances of the
    [code]#parallel_for_work_item# function call, rather than through
    the use of explicit <<work-group-barrier>> operations.
  * Device event: they are used inside SYCL kernel functions to wait for
    asynchronous operations within a SYCL kernel function to complete.


[[sec:barriers-fences]]
=== Barriers and fences

A <<group-barrier>> or <<mem-fence>> provides memory ordering semantics
over both the local address space and global address space.  A
<<mem-fence>> provides control over the re-ordering of memory load and
store operations, subject to the associated memory [code]#order# and memory
[code]#scope#, when paired with synchronization through an atomic object.

[source,,linenums]
----
include::{header_dir}/synchronization.h[lines=4..-1]
----

The effects of a call to [code]#atomic_fence# depend on the value of
the [code]#order# parameter:

  * [code]#memory_order::relaxed:# No effect
  * [code]#memory_order::acquire:# Acquire fence
  * [code]#memory_order::release:# Release fence
  * [code]#memory_order::acq_rel:# Both an acquire fence and a release
    fence
  * [code]#memory_order::seq_cst:# A sequentially consistent acquire
    and release fence

A <<group-barrier>> acts as both an acquire fence and a release fence: all
work-items in the group execute a release fence prior to synchronizing at
the barrier, and all work-items in the group execute an acquire fence
afterwards.  A <<group-barrier>> provides implicit atomic synchronization
as if through an internal atomic object, such that the acquire and release fences
associated with the barrier synchronize with each other, without an explicit
atomic operation being required on an atomic object to synchronize the fences.


[[device-event-class]]
=== [code]#device_event# class

The SYCL [code]#device_event# class encapsulates a single SYCL device event
which is available only within SYCL kernel functions and can be used to wait for
asynchronous operations within a SYCL kernel function to complete.

All member functions of the [code]#device_event# class must not throw a
SYCL exception.

A synopsis of the SYCL [code]#device_event# class is provided below. The
constructors and member functions of the SYCL [code]#device_event# class
are listed in <<table.constructors.device-event>> and
<<table.members.device-event>> respectively.

// Interface of device event class
[source,,linenums]
----
include::{header_dir}/deviceEvent.h[lines=4..-1]
----

[[table.members.device-event]]
.Member functions of the SYCL [code]#device_event# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
void wait() noexcept
----
   a@ Waits for the asynchronous operation associated with this SYCL
      [code]#device_event# to complete.

|====

[[table.constructors.device-event]]
.Constructors of the [code]#device_event# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
device_event(___unspecified___)
----
   a@ Unspecified implementation-defined constructor.

|====


[[sec:atomic-references]]
=== Atomic references

The [code]#sycl::atomic_ref# class provides the ability to perform atomic
operations in device code with a syntax similar to the {cpp} standard
[code]#std::atomic_ref#.  The [code]#sycl::atomic_ref# class must not be used
in host code.

Unlike [code]#std::atomic_ref#, [code]#sycl::atomic_ref# does not provide a
default memory ordering for its operations.  Instead, the application must
specify a default ordering via the [code]#DefaultOrder# template parameter.
This ordering is used as a default for most of the atomic operations, but
most member functions also provide an optional parameter that allows the
application to override this default.  The set of supported orderings is
specific to a device, but every device is guaranteed to support at least
[code]#memory_order::relaxed#.  If the default order is set to
[code]#memory_order::relaxed#, all memory order arguments default to
[code]#memory_order::relaxed#.  If the default order is set to
[code]#memory_order::acq_rel#, memory order arguments default to
[code]#memory_order::acquire# for load operations,
[code]#memory_order::release# for store operations and
[code]#memory_order::acq_rel# for read-modify-write operations.  If the
default order is set to [code]#memory_order::seq_cst#, all memory order
arguments default to [code]#memory_order::seq_cst#.

The [code]#sycl::atomic_ref# class has a template parameter
[code]#DefaultScope#, which allows the application to define a default memory
scope for the atomic operations.  Most member functions also provide an
optional parameter that allows the application to override this default.

The [code]#sycl::atomic_ref# class also has a template parameter
[code]#AddressSpace#, which allows the application to make an assertion about
the address space of the object of type [code]#T# that it references.  The
default value for this parameter is
[code]#access::address_space::generic_space#, which indicates that the object
could be in either the global or local address spaces.  If the application
knows the address space, it can set this template parameter to either
[code]#access::address_space::global_space# or
[code]#access::address_space::local_space# as an assertion to the
implementation.  Specifying the address space via this template parameter may
allow the implementation to perform certain optimizations.  Specifying an
address space that does not match the object's actual address space results in
undefined behavior.

The template parameter [code]#T# must be one of the following types:

* [code]#int#,
* [code]#unsigned int#,
* [code]#long#,
* [code]#unsigned long#,
* [code]#long long#,
* [code]#unsigned long long#,
* [code]#float#, or
* [code]#double#.

In addition, the type [code]#T# must satisfy one of the following conditions:

* [code]#sizeof(T) == 4#, or
* [code]#sizeof(T) == 8# and the code containing this [code]#atomic_ref# was
  submitted to a device that has [code]#aspect::atomic64#.

For floating-point types, the member functions of the [code]#atomic_ref# class
may be emulated, and they may use a different floating-point environment from
those defined by [code]#info::device::single_fp_config# and
[code]#info::device::double_fp_config# (i.e. floating-point atomics may use
different rounding modes and may have different exception behavior).

The atomic types are defined as follows.

[source,,linenums]
----
include::{header_dir}/atomicref.h[lines=4..-1]
----

The constructors and member functions for instances of the SYCL
[code]#atomic_ref# class using any compatible type are listed in
<<table.atomic-refs.constructors>>
and <<table.atomic-refs.members.common>> respectively. Additional member
functions for integral, floating-point and pointer types are listed in
<<table.atomic-refs.members.integral>>,
<<table.atomic-refs.members.floating>>
and <<table.atomic-refs.members.pointer>> respectively.

The static member [code]#required_alignment# describes the minimum
required alignment in bytes of an object that can be referenced by an
[code]#atomic_ref<T>#, which must be at least [code]#alignof(T)#.

The static member [code]#is_always_lock_free# is true if all atomic
operations for type [code]#T# are always lock-free. A SYCL
implementation is not guaranteed to support atomic operations that are not
lock-free.

The static members [code]#default_read_order#, [code]#default_write_order# and
[code]#default_read_modify_write_order# reflect the default memory order values for
each type of atomic operation, consistent with the [code]#DefaultOrder# template.

The atomic operations and member functions behave as described in the {cpp}
specification, barring the restrictions discussed above.

[NOTE]
====
Care must be taken when using atomics for work-item coordination, because
work-items are not required to provide stronger than weakly parallel forward
progress guarantees. Operations that block a work-item, such as continuously
checking the value of an atomic variable until some condition holds, or using
atomic operations that are not lock-free, may prevent overall progress.
====

[[table.atomic-refs.constructors]]
.Constructors of the SYCL [code]#atomic_ref# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
atomic_ref(T& ref)
----
   a@ Constructs an instance of SYCL [code]#atomic_ref# which is associated
      with the reference [code]#ref#.

|====



[[table.atomic-refs.members.common]]
.Member functions available on any object of type [code]#atomic_ref<T>#
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
bool is_lock_free() const
----
   a@ Return [code]#true# if the atomic operations provided by this
      [code]#atomic_ref# are lock-free.

a@
[source]
----
void store(T operand, memory_order order = default_write_order,
           memory_scope scope = default_scope) const
----
   a@ Atomically stores [code]#operand# to the object referenced by
      this [code]#atomic_ref#.  The memory order of this atomic operation
      must be [code]#memory_order::relaxed#,
      [code]#memory_order::release# or [code]#memory_order::seq_cst#.
      This function is only supported for 64-bit data types on devices that have
      [code]#aspect::atomic64#.

a@
[source]
----
T operator=(T desired) const
----
   a@ Equivalent to [code]#store(desired)#.  Returns [code]#desired#.

a@
[source]
----
T load(memory_order order = default_read_order memory_scope scope =
           default_scope) const
----
   a@ Atomically loads the value of the object referenced by this
      [code]#atomic_ref#.  The memory order of this atomic operation must be
      [code]#memory_order::relaxed#, [code]#memory_order::acquire#,
      or [code]#memory_order::seq_cst#.  This function is only supported for
      64-bit data types on devices that have [code]#aspect::atomic64#.

a@
[source]
----
operator T() const
----
   a@ Equivalent to [code]#load()#.

a@
[source]
----
T exchange(T operand, memory_order order = default_read_modify_write_order,
           memory_scope scope = default_scope) const
----
   a@ Atomically replaces the value of the object referenced by this
      [code]#atomic_ref# with value [code]#operand# and
      returns the original value of the referenced object.
      This function is only supported for 64-bit data types on devices that have
      [code]#aspect::atomic64#.

a@
[source]
----
bool compare_exchange_weak(T& expected, T desired, memory_order success,
                           memory_order failure,
                           memory_scope scope = default_scope) const
----
   a@ Atomically compares the value of the object referenced by this [code]#atomic_ref#
      against the value of [code]#expected#. If the values are
      equal, attempts to
      replace the value of the referenced object with the value of
      [code]#desired#;
      otherwise assigns the original value of the referenced object to [code]#expected#.

Returns [code]#true# if the comparison operation and replacement operation were
successful. The [code]#failure# memory order of this atomic operation must be
[code]#memory_order::relaxed#, [code]#memory_order::acquire# or
[code]#memory_order::seq_cst#.

This function is only supported for 64-bit data types on devices that have
[code]#aspect::atomic64#.

a@
[source]
----
bool compare_exchange_weak(T& expected, T desired,
                           memory_order order = default_read_modify_write_order,
                           memory_scope scope = default_scope) const
----
   a@ Equivalent to [code]#compare_exchange_weak(expected, desired, order, order, scope)#.

a@
[source]
----
bool compare_exchange_strong(T& expected, T desired, memory_order success,
                             memory_order failure,
                             memory_scope scope = default_scope) const
----
   a@ Atomically compares the value of the object referenced by this [code]#atomic_ref#
      against the value of [code]#expected#. If the values are equal,
      replaces the value of the referenced object with the value of
      [code]#desired#;
      otherwise assigns the original value of the referenced object to [code]#expected#.

Returns [code]#true# if the comparison operation was
successful. The [code]#failure# memory order of this atomic operation must be
[code]#memory_order::relaxed#, [code]#memory_order::acquire# or
[code]#memory_order::seq_cst#.

This function is only supported for 64-bit data types on devices that have
[code]#aspect::atomic64#.

a@
[source]
----
bool compare_exchange_strong(
    T& expected, T desired,
    memory_order order = default_read_modify_write_order) const
----
   a@ Equivalent to [code]#compare_exchange_strong(expected, desired, order, order, scope)#.

|====



[[table.atomic-refs.members.integral]]
.Additional member functions available on an object of type [code]#atomic_ref<T># for integral [code]#T#
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
T fetch_add(T operand, memory_order order = default_read_modify_write_order,
            memory_scope scope = default_scope) const
----
   a@ Atomically adds [code]#operand# to the value
      of the object referenced by this [code]#atomic_ref# and assigns
      the result to the value of the referenced object.  Returns the original
      value of the referenced object.  This function is only supported for 64-bit
      data types on devices that have [code]#aspect::atomic64#.

a@
[source]
----
T operator+=(T operand) const
----
   a@ Equivalent to [code]#fetch_add(operand) pass:[+] operand#.

a@
[source]
----
T operator++(int) const
----
   a@ Equivalent to [code]#fetch_add(1)#.

a@
[source]
----
T operator++() const
----
   a@ Equivalent to [code]#fetch_add(1) pass:[+] 1#.

a@
[source]
----
T fetch_sub(T operand, memory_order order = default_read_modify_write_order,
            memory_scope scope = default_scope) const
----
   a@ Atomically subtracts [code]#operand# from the value
      of the object referenced by this [code]#atomic_ref# and assigns
      the result to the value of the referenced object.  Returns the original
      value of the referenced object.  This function is only supported for 64-bit
      data types on devices that have [code]#aspect::atomic64#.

a@
[source]
----
T operator-=(T operand) const
----
   a@ Equivalent to [code]#fetch_sub(operand) - operand#.

a@
[source]
----
T operator--(int) const
----
   a@ Equivalent to [code]#fetch_sub(1)#.

a@
[source]
----
T operator--() const
----
   a@ Equivalent to [code]#fetch_sub(1) - 1#.

a@
[source]
----
T fetch_and(T operand, memory_order order = default_read_modify_write_order,
            memory_scope scope = default_scope) const
----
   a@ Atomically performs a bitwise AND between [code]#operand#
      and the value of the object referenced by this [code]#atomic_ref#,
      and assigns the result to the value of the referenced object. Returns the
      original value of the referenced object.  This function is only supported
      for 64-bit data types on devices that have
      [code]#aspect::atomic64#.

a@
[source]
----
T operator&=(T operand) const
----
   a@ Equivalent to [code]#fetch_and(operand) & operand#.

a@
[source]
----
T fetch_or(T operand, memory_order order = default_read_modify_write_order,
           memory_scope scope = default_scope) const
----
   a@ Atomically performs a bitwise OR between [code]#operand#
      and the value of the object referenced by this [code]#atomic_ref#,
      and assigns the result to the value of the referenced object. Returns the
      original value of the referenced object.  This function is only supported
      for 64-bit data types on devices that have
      [code]#aspect::atomic64#.

a@
[source]
----
T operator|=(T operand) const
----
   a@ Equivalent to [code]#fetch_or(operand) | operand#.

a@
[source]
----
T fetch_xor(T operand, memory_order order = default_read_modify_write_order,
            memory_scope scope = default_scope) const
----
   a@ Atomically performs a bitwise XOR between [code]#operand#
      and the value of the object referenced by this [code]#atomic_ref#,
      and assigns the result to the value of the referenced object. Returns the
      original value of the referenced object.  This function is only supported
      for 64-bit data types on devices that have
      [code]#aspect::atomic64#.

a@
[source]
----
T operator^=(T operand) const
----
   a@ Equivalent to [code]#fetch_xor(operand) ^ operand#.

a@
[source]
----
T fetch_min(T operand, memory_order order = default_read_modify_write_order,
            memory_scope scope = default_scope) const
----
   a@ Atomically computes the minimum of [code]#operand#
      and the value of the object referenced by this [code]#atomic_ref#,
      and assigns the result to the value of the referenced object. Returns the
      original value of the referenced object.  This function is only supported
      for 64-bit data types on devices that have
      [code]#aspect::atomic64#.

a@
[source]
----
T fetch_max(T operand, memory_order order = default_read_modify_write_order,
            memory_scope scope = default_scope) const
----
   a@ Atomically computes the maximum of [code]#operand#
      and the value of the object referenced by this [code]#atomic_ref#,
      and assigns the result to the value of the referenced object. Returns the
      original value of the referenced object.  This function is only supported
      for 64-bit data types on devices that have
      [code]#aspect::atomic64#.

|====



[[table.atomic-refs.members.floating]]
.Additional member functions available on an object of type [code]#atomic_ref<T># for floating-point [code]#T#
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
T fetch_add(T operand, memory_order order = default_read_modify_write_order,
            memory_scope scope = default_scope) const
----
   a@ Atomically adds [code]#operand# to the value
      of the object referenced by this [code]#atomic_ref# and assigns
      the result to the value of the referenced object.  Returns the original
      value of the referenced object.  This function is only supported for 64-bit
      data types on devices that have [code]#aspect::atomic64#.

a@
[source]
----
T operator+=(T operand) const
----
   a@ Equivalent to [code]#fetch_add(operand) pass:[+] operand#.

a@
[source]
----
T fetch_sub(T operand, memory_order order = default_read_modify_write_order,
            memory_scope scope = default_scope) const
----
   a@ Atomically subtracts [code]#operand# from the value
      of the object referenced by this [code]#atomic_ref# and assigns
      the result to the value of the referenced object.  Returns the original
      value of the referenced object.  This function is only supported for 64-bit
      data types on devices that have [code]#aspect::atomic64#.

a@
[source]
----
T operator-=(T operand) const
----
   a@ Equivalent to [code]#fetch_sub(operand) - operand#.

a@
[source]
----
T fetch_min(T operand, memory_order order = default_read_modify_write_order,
            memory_scope scope = default_scope) const
----
   a@ Atomically computes the minimum of [code]#operand#
      and the value of the object referenced by this [code]#atomic_ref#,
      and assigns the result to the value of the referenced object. Returns the
      original value of the referenced object.  This function is only supported for
      64-bit data types on devices that have [code]#aspect::atomic64#.

a@
[source]
----
T fetch_max(T operand, memory_order order = default_read_modify_write_order,
            memory_scope scope = default_scope) const
----
   a@ Atomically computes the maximum of [code]#operand#
      and the value of the object referenced by this [code]#atomic_ref#,
      and assigns the result to the value of the referenced object. Returns the
      original value of the referenced object.  This function is only supported for
      64-bit data types on devices that have [code]#aspect::atomic64#.

|====



[[table.atomic-refs.members.pointer]]
.Additional member functions available on an object of type [code]#atomic_ref<T*>#
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
T* fetch_add(ptrdiff_t operand,
             memory_order order = default_read_modify_write_order,
             memory_scope scope = default_scope) const
----
   a@ Atomically adds [code]#operand# to the value
      of the object referenced by this [code]#atomic_ref# and assigns
      the result to the value of the referenced object.  Returns the original
      value of the referenced object.  This function is only supported for 64-bit
      pointers on devices that have [code]#aspect::atomic64#.

a@
[source]
----
T* operator+=(ptrdiff_t operand) const
----
   a@ Equivalent to [code]#fetch_add(operand) pass:[+] operand#.

a@
[source]
----
T* operator++(int) const
----
   a@ Equivalent to [code]#fetch_add(1)#.

a@
[source]
----
T* operator++() const
----
   a@ Equivalent to [code]#fetch_add(1) pass:[+] 1#.

a@
[source]
----
T* fetch_sub(ptrdiff_t operand,
             memory_order order = default_read_modify_write_order,
             memory_scope scope = default_scope) const
----
   a@ Atomically subtracts [code]#operand# from the value
      of the object referenced by this [code]#atomic_ref# and assigns
      the result to the value of the referenced object.  Returns the original
      value of the referenced object.  This function is only supported for 64-bit
      pointers on devices that have [code]#aspect::atomic64#.

a@
[source]
----
T* operator-=(ptrdiff_t operand) const
----
   a@ Equivalent to [code]#fetch_sub(operand) - operand#.

a@
[source]
----
T* operator--(int) const
----
   a@ Equivalent to [code]#fetch_sub(1)#.

a@
[source]
----
T* operator--() const
----
   a@ Equivalent to [code]#fetch_sub(1) - 1#.

|====



[[sec:atom-types-depr]]
=== Atomic types (deprecated)

// Deprecated atomics from SYCL 1.2.1

The atomic types and operations on atomic types provided by SYCL 1.2.1 are
deprecated in SYCL 2020, and will be removed in a future version of SYCL.  The
types and operations are made available in the [code]#cl::sycl::#
namespace for backwards compatibility.

The constructors and member functions for the [code]#cl::sycl::atomic#
class are listed in <<table.atomics.constructors>>
and <<table.atomics.members>> respectively.

[source,,linenums]
----
include::{header_dir}/atomic.h[lines=4..-1]
----

The global functions are as follows and described in
<<table.atomics.functions>>.

[source,,linenums]
----
include::{header_dir}/atomicoperations.h[lines=4..-1]
----


[[table.atomics.constructors]]
.Constructors of the [code]#cl::sycl::atomic# class template
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
template <typename pointerT> atomic(multi_ptr<pointerT, AddressSpace> ptr)
----
   a@ Deprecated in SYCL 2020.

Permitted data types for [code]#pointerT# are any valid scalar data
type which is the same size in bytes as [code]#T#. Constructs an
instance of SYCL [code]#atomic# which is associated with the pointer
[code]#ptr#, converted to a pointer of data type [code]#T#.

|====



[[table.atomics.members]]
.Member functions available on an object of type [code]#cl::sycl::atomic<T>#
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
void store(T operand, memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Atomically stores the value [code]#operand# at the address of the
[code]#multi_ptr# associated with this SYCL [code]#atomic#. The
memory order of this atomic operation must be [code]#memory_order::relaxed#. This function is only supported for 64-bit data
types on devices that have [code]#aspect::atomic64#.

a@
[source]
----
T load(memory_order memoryOrder = memory_order::relaxed) const
----
   a@ Deprecated in SYCL 2020.

Atomically loads the value at the address of the [code]#multi_ptr#
associated with this SYCL [code]#atomic#. Returns the value at the
address of the [code]#multi_ptr# associated with this SYCL
[code]#atomic# before the call. The memory order of this atomic
operation must be [code]#memory_order::relaxed#. This function is
only supported for 64-bit data types on devices that have
[code]#aspect::atomic64#.

a@
[source]
----
T exchange(T operand, memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Atomically replaces the value at the address of the [code]#multi_ptr#
associated with this SYCL [code]#atomic# with value [code]#operand# and returns the value at the address of the [code]#multi_ptr# associated with this SYCL [code]#atomic# before the call.
The memory order of this atomic operation must be [code]#memory_order::relaxed#. This function is only supported for 64-bit data
types on devices that have [code]#aspect::atomic64#.

a@
[source]
----
bool compare_exchange_strong(
    T& expected, T desired,
    memory_order successMemoryOrder = memory_order::relaxed,
    memory_order failMemoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Available only when: [code]#T != float#.

Atomically compares the value at the address of the [code]#multi_ptr#
associated with this SYCL [code]#atomic# against the value of
[code]#expected#. If the values are equal, replaces value at address
of the [code]#multi_ptr# associated with this SYCL
[code]#atomic# with the value of [code]#desired#; otherwise assigns the
original value at the address of the [code]#multi_ptr# associated
with this SYCL [code]#atomic# to [code]#expected#. Returns
[code]#true# if the comparison operation was successful. The memory
order of this atomic operation must be [code]#memory_order::relaxed# for both success and fail.  This function is only
supported for 64-bit data types on devices that have
[code]#aspect::atomic64#.

a@
[source]
----
T fetch_add(T operand, memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Available only when: [code]#T != float#.

Atomically adds the value [code]#operand# to the value at the address
of the [code]#multi_ptr# associated with this SYCL [code]#atomic# and assigns the result to the value at the address of the
[code]#multi_ptr# associated with this SYCL [code]#atomic#.
Returns the value at the address of the [code]#multi_ptr# associated
with this SYCL [code]#atomic# before the call. The memory order of
this atomic operation must be [code]#memory_order::relaxed#. This
function is only supported for 64-bit data types on devices that have
[code]#aspect::atomic64#.

a@
[source]
----
T fetch_sub(T operand, memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Available only when: [code]#T != float#.

Atomically subtracts the value [code]#operand# to the value at the
address of the [code]#multi_ptr# associated with this SYCL
[code]#atomic# and assigns the result to the value at the address of
the [code]#multi_ptr# associated with this SYCL [code]#atomic#.
Returns the value at the address of the [code]#multi_ptr# associated
with this SYCL [code]#atomic# before the call. The memory order of
this atomic operation must be [code]#memory_order::relaxed#. This
function is only supported for 64-bit data types on devices that have
[code]#aspect::atomic64#.

a@
[source]
----
T fetch_and(T operand, memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Available only when: [code]#T != float#.

Atomically performs a bitwise AND between the value [code]#operand#
and the value at the address of the [code]#multi_ptr# associated with
this SYCL [code]#atomic# and assigns the result to the value at the
address of the [code]#multi_ptr# associated with this SYCL
[code]#atomic#. Returns the value at the address of the [code]#multi_ptr# associated with this SYCL [code]#atomic# before the call.
The memory order of this atomic operation must be [code]#memory_order::relaxed#. This function is only supported for 64-bit data
types on devices that have [code]#aspect::atomic64#.

a@
[source]
----
T fetch_or(T operand, memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Available only when: [code]#T != float#.

Atomically performs a bitwise OR between the value [code]#operand#
and the value at the address of the [code]#multi_ptr# associated with
this SYCL [code]#atomic# and assigns the result to the value at the
address of the [code]#multi_ptr# associated with this SYCL
[code]#atomic#. Returns the value at the address of the [code]#multi_ptr# associated with this SYCL [code]#atomic# before the call.
The memory order of this atomic operation must be [code]#memory_order::relaxed#. This function is only supported for 64-bit data
types on devices that have [code]#aspect::atomic64#.

a@
[source]
----
T fetch_xor(T operand, memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Available only when: [code]#T != float#.

Atomically performs a bitwise XOR between the value [code]#operand#
and the value at the address of the [code]#multi_ptr# associated with
this SYCL [code]#atomic# and assigns the result to the value at the
address of the [code]#multi_ptr# associated with this SYCL
[code]#atomic#. Returns the value at the address of the [code]#multi_ptr# associated with this SYCL [code]#atomic# before the call.
The memory order of this atomic operation must be [code]#memory_order::relaxed#. This function is only supported for 64-bit data
types on devices that have [code]#aspect::atomic64#.

a@
[source]
----
T fetch_min(T operand, memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Available only when: [code]#T != float#.

Atomically computes the minimum of the value [code]#operand# and the
value at the address of the [code]#multi_ptr# associated with this
SYCL [code]#atomic# and assigns the result to the value at the address
of the [code]#multi_ptr# associated with this SYCL [code]#atomic#. Returns the value at the address of the [code]#multi_ptr#
associated with this SYCL [code]#atomic# before the call. The memory
order of this atomic operation must be [code]#memory_order::relaxed#.
This function is only supported for 64-bit data types on devices that have
[code]#aspect::atomic64#.

a@
[source]
----
T fetch_max(T operand, memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Available only when: [code]#T != float#.

Atomically computes the maximum of the value [code]#operand# and the
value at the address of the [code]#multi_ptr# associated with this
SYCL [code]#atomic# and assigns the result to the value at the address
of the [code]#multi_ptr# associated with this SYCL [code]#atomic#. Returns the value at the address of the [code]#multi_ptr#
associated with this SYCL [code]#atomic# before the call. The memory
order of this atomic operation must be [code]#memory_order::relaxed#.
This function is only supported for 64-bit data types on devices that have
[code]#aspect::atomic64#.

|====



[[table.atomics.functions]]
.Global functions available on atomic types
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Functions @ Description
a@
[source]
----
template <typename T, access::address_space AddressSpace>
T atomic_load(atomic<T, AddressSpace> object,
              memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Equivalent to calling [code]#object.load(memoryOrder)#.

a@
[source]
----
template <typename T, access::address_space AddressSpace>
void atomic_store(atomic<T, AddressSpace> object, T operand,
                  memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Equivalent to calling [code]#object.store(operand, memoryOrder)#.

a@
[source]
----
template <typename T, access::address_space AddressSpace>
T atomic_exchange(atomic<T, AddressSpace> object, T operand,
                  memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Equivalent to calling [code]#object.exchange(operand, memoryOrder)#.

a@
[source]
----
template <typename T, access::address_space AddressSpace>
bool atomic_compare_exchange_strong(
    atomic<T, AddressSpace> object, T& expected, T desired,
    memory_order successMemoryOrder = memory_order::relaxed memory_order
        failMemoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Equivalent to calling [code]#object.compare_exchange_strong(expected, desired, successMemoryOrder, failMemoryOrders)#.

a@
[source]
----
template <typename T, access::address_space AddressSpace>
T atomic_fetch_add(atomic<T, AddressSpace> object, T operand,
                   memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Equivalent to calling [code]#object.fetch_add(operand, memoryOrder)#.

a@
[source]
----
template <typename T, access::address_space AddressSpace>
T atomic_fetch_sub(atomic<T, AddressSpace> object, T operand,
                   memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Equivalent to calling [code]#object.fetch_sub(operand, memoryOrder)#.

a@
[source]
----
template <typename T, access::address_space AddressSpace>
T atomic_fetch_and(atomic<T> operand, T object,
                   memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Equivalent to calling [code]#object.fetch_add(operand, memoryOrder)#.

a@
[source]
----
template <typename T, access::address_space AddressSpace>
T atomic_fetch_or(atomic<T, AddressSpace> object, T operand,
                  memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Equivalent to calling [code]#object.fetch_or(operand, memoryOrder)#.

a@
[source]
----
template <typename T, access::address_space AddressSpace>
T atomic_fetch_xor(atomic<T, AddressSpace> object, T operand,
                   memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Equivalent to calling [code]#object.fetch_xor(operand, memoryOrder)#.

a@
[source]
----
template <typename T, access::address_space AddressSpace>
T atomic_fetch_min(atomic<T, AddressSpace> object, T operand,
                   memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Equivalent to calling [code]#object.fetch_min(operand, memoryOrder)#.

a@
[source]
----
template <typename T, access::address_space AddressSpace>
T atomic_fetch_max(atomic<T, AddressSpace> object, T operand,
                   memory_order memoryOrder = memory_order::relaxed)
----
   a@ Deprecated in SYCL 2020.

Equivalent to calling [code]#object.fetch_max(operand, memoryOrder)#.

|====


=== Interaction with host code

When a kernel runs on a device that has either
[code]#aspect::usm_atomic_host_allocations# or
[code]#aspect::usm_atomic_shared_allocations#, the device code and the host
code can concurrently access the same memory.  This has a ramification on the
atomic operations because it is possible for device code and host code to
perform atomic operations on the same object _M_ in this shared memory.  It
also has a ramification on the fence operations because the {cpp} core language
defines the semantics of these fence operations in relation to atomic
operations on some shared object _M_.  The following paragraphs specify the
guarantees that the SYCL implementation provides when the application performs
atomic or fence operations in device code using the memory scope
[code]#memory_scope::system#.

Atomic operations in device code using [code]#sycl::atomic_ref# on an object
_M_ are guaranteed to be atomic with respect to atomic operations in host code
using [code]#std::atomic_ref# on that same object _M_.

Fence operations in device code using [code]#sycl::atomic_fence# synchronize
with fence operations in host code using [code]#std::atomic_thread_fence# if
the fence operations shared the same atomic object _M_ and follow the rules for
fence synchronization defined in the {cpp} core language.

Fence operations in device code using [code]#sycl::atomic_fence# synchronize
with atomic operations in host code using [code]#std::atomic_ref# if the
operations share the same atomic object _M_ and follow the rules for fence
synchronization defined in the {cpp} core language.

Atomic operations in device code using [code]#sycl::atomic_ref# synchronize
with fence operations in host code using [code]#std::atomic_thread_fence# if
the operations share the same atomic object _M_ and follow the rules for fence
synchronization defined in the {cpp} core language.


[[subsec:stream]]
== Stream class

The SYCL [code]#stream# class is a buffered output stream that allows
outputting the values of built-in, vector and SYCL types to the console. The
implementation of how values are streamed to the console is left as an
implementation detail.

The way in which values are output by an instance of the SYCL
[code]#stream# class can also be altered using a range of manipulators.

There are two limits that are relevant for the [code]#stream# class.  The
[code]#totalBufferSize# limit specifies the maximum size of the overall
character stream that can be output during a kernel invocation, and the
[code]#workItemBufferSize# limit specifies the maximum size of the
character stream that can be output within a work-item before a flush must be
performed.  Both of these limits are specified in bytes.  The
[code]#totalBufferSize# limit must be sufficient to contain the characters
output by all stream statements during execution of a kernel invocation (the
aggregate of outputs from all work-items), and the
[code]#workItemBufferSize# limit must be sufficient to contain the
characters output within a work-item between stream flush operations.

If the [code]#totalBufferSize# or [code]#workItemBufferSize#
limits are exceeded, it is implementation-defined whether the streamed
characters exceeding the limit are output, or silently ignored/discarded,
and if output it is implementation-defined whether those extra characters
exceeding the [code]#workItemBufferSize# limit count toward the
[code]#totalBufferSize# limit. Regardless of this implementation
defined behavior of output exceeding the limits, no undefined or erroneous
behavior is permitted of an implementation when the limits are exceeded.
Unused characters within [code]#workItemBufferSize# (any portion of the
[code]#workItemBufferSize# capacity that has not been used at the time
of a stream flush) do not count toward the [code]#totalBufferSize#
limit, in that only characters flushed count toward the
[code]#totalBufferSize# limit.

The SYCL [code]#stream# class provides the common reference semantics
(see <<sec:reference-semantics>>).


=== Stream class interface

The constructors and member functions of the SYCL [code]#stream# class
are listed in <<table.constructors.stream>>,
<<table.members.stream>>, and <<table.globals.stream>> respectively. The
additional common special member functions and common member functions are
listed in <<table.specialmembers.common.reference>> and
<<table.hiddenfriends.common.reference>>, respectively.

The operand types that are supported by the SYCL [code]#stream# class
[code]#operator<<()# operator are listed in
<<table.operands.stream>>.

The manipulators that are supported by the SYCL [code]#stream# class
[code]#operator<<()# operator are listed in
<<table.manipulators.stream>>.

// Interface of the device class
[source,,linenums]
----
include::{header_dir}/stream.h[lines=4..-1]
----


[[table.operands.stream]]
.Operand types supported by the [code]#stream# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Stream operand type @ Description
a@
[source]
----
char, signed char, unsigned char, int, unsigned int, short, unsigned short,
long int, unsigned long int, long long int, unsigned long long int
----
   a@ Outputs the value as a stream of characters.

a@
[source]
----
float, double, half
----
   a@ Outputs the value according to the precision of the current statement as a stream of characters.

a@
[source]
----
char*, const char*
----
   a@ Outputs the string.

a@
[source]
----
T*, const T*, multi_ptr
----
   a@ Outputs the address of the pointer as a stream of characters.

a@
[source]
----
vec
----
   a@ Outputs the value of each component of the vector as a stream of characters.

a@
[source]
----
id, range, item, nd_item, group, nd_range, h_item
----
   a@ Outputs the value of each component of each id or range as a stream of characters.

|====



[[table.manipulators.stream]]
.Manipulators supported by the [code]#stream# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Stream manipulator @ Description
a@
[source]
----
flush
----
   a@ Triggers a flush operation, which synchronizes the work-item stream buffer
      with the global stream buffer, and then empties the work-item stream
      buffer. After a flush, the full [code]#workItemBufferSize# is
      available again for subsequent streaming within the work-item.

a@
[source]
----
endl
----
   a@ Outputs a new-line character and then triggers a flush operation.

a@
[source]
----
dec
----
   a@ Outputs any subsequent values in the current statement in decimal base.

a@
[source]
----
hex
----
   a@ Outputs any subsequent values in the current statement in hexadecimal base.

a@
[source]
----
oct
----
   a@ Outputs any subsequent values in the current statement in octal base.

a@
[source]
----
noshowbase
----
   a@ Outputs any subsequent values without the base prefix.

a@
[source]
----
showbase
----
   a@ Outputs any subsequent values with the base prefix.

a@
[source]
----
noshowpos
----
   a@ Outputs any subsequent values without a plus sign if the value is positive.

a@
[source]
----
showpos
----
   a@ Outputs any subsequent values with a plus sign if the value is positive.

a@
[source]
----
setw(int)
----
   a@ Sets the field width of any subsequent values in the current statement.

a@
[source]
----
setprecision(int)
----
   a@ Sets the precision of any subsequent values in the current statement.

a@
[source]
----
fixed
----
   a@ Outputs any subsequent floating-point values in the current statement in fixed notation.

a@
[source]
----
scientific
----
   a@ Outputs any subsequent floating-point values in the current statement in scientific notation.

a@
[source]
----
hexfloat
----
   a@ Outputs any subsequent floating-point values in the current statement in hexadecimal notation.

a@
[source]
----
defaultfloat
----
   a@ Outputs any subsequent floating-point values in the current statement in the default notation.

|====



[[table.constructors.stream]]
.Constructors of the [code]#stream# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Constructor @ Description
a@
[source]
----
stream(size_t totalBufferSize, size_t workItemBufferSize, handler& cgh,
       const property_list& propList = {})
----
   a@ Constructs a SYCL [code]#stream# instance associated with the command group
      specified by [code]#cgh#, with a maximum buffer size in bytes per kernel
      invocation specified by the parameter [code]#totalBufferSize#, and a maximum
      stream size that can be buffered by a work-item between stream flushes
      specified by the parameter [code]#workItemBufferSize#.
      Zero or more properties can be provided to the constructed SYCL
      [code]#stream# via an instance of [code]#property_list#.

|====



[[table.members.stream]]
.Member functions of the [code]#stream# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
size_t size() const noexcept
----
   a@ Returns the total buffer size, in bytes.
a@
[source]
----
size_t get_size() const
----
   a@ Returns the same value as [code]#size()#. Deprecated.
a@
[source]
----
size_t get_work_item_buffer_size() const
----
   a@ Returns the buffer size per work-item, in bytes.

a@
[source]
----
size_t get_max_statement_size() const
----
   a@ Deprecated query with same functionality as [code]#get_work_item_buffer_size()#.

|====



[[table.globals.stream]]
.Global functions of the [code]#stream# class
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Global function @ Description
a@
[source]
----
template <typename T> const stream& operator<<(const stream& os, const T& rhs)
----
   a@ Outputs any valid values (see <<table.operands.stream>>) as a stream of characters and applies any valid manipulator (see <<table.manipulators.stream>>) to the current stream.

|====



=== Synchronization

An instance of the SYCL [code]#stream# class is required to synchronize with the host, and must output
everything that is streamed to it via the [code]#operator<<()# operator before a flush operation (that
doesn't exceed the [code]#workItemBufferSize# or [code]#totalBufferSize# limits) within a SYCL
kernel function by the time that the event associated with a command group submission enters the completed
state. The point at which this synchronization occurs and the member function by which this synchronization is
performed are implementation-defined. For example it is valid for an implementation to use
[code]#printf()#.

The SYCL [code]#stream# class is required to output the content of each stream, between flushes (up to
[code]#workItemBufferSize)#, without mixing with content from the same stream in other work-items.
There are no other output order guarantees between work-items or between streams.  The stream flush
operation therefore delimits the unit of output that is guaranteed to be displayed without mixing with
other work-items, with respect to a single stream.


=== Implicit flush

There is guaranteed to be an implicit flush of each stream used by a
kernel, at the end of kernel execution, from the perspective of each
work-item.  There is also an implicit flush when the endl stream
manipulator is executed.  No other implicit flushes are permitted in
an implementation.


=== Performance note

The usage of the [code]#stream# class is designed for debugging purposes and is therefore not recommended for performance critical applications.

// \input{builtin_functions}

// %%%%%%%%%%%%%%%%%%%%%%%%%%%% begin builtin_functions %%%%%%%%%%%%%%%%%%%%%%%%%%%%


[[sycl:builtins]]
== SYCL built-in functions for SYCL host and device

// Intentional OpenCL reference
SYCL kernels may execute on any SYCL device, which requires the functions
used in the kernels to be compiled and linked for both device and host. In
the SYCL programming model, the built-ins are available for the entire SYCL
application within the [code]#sycl# namespace, although their semantics
may be different. This section follows the OpenCL 1.2 specification document
<<opencl12, ch. 6.12>> - except that for SYCL, all functions are located
within the [code]#sycl# namespace - and describes the behavior of these
functions for SYCL host and device. The expected precision and any other
semantic requirements are defined in the backend specification.

The SYCL built-in functions are available throughout the SYCL application,
and depending on where they execute, they are either implemented using their
host implementation or the device implementation. The SYCL system guarantees
that all of the built-in functions fulfill the same requirements for both
host and device.


[[sec:function-objects]]
=== Function objects

SYCL provides a number of function objects in the [code]#sycl# namespace
on host and device.  All function objects obey {cpp} conversion and promotion
rules.  Each function object is additionally specialized for [code]#void#
as a _transparent_ function object that deduces its parameter types
and return type.

[source,,linenums]
----
include::{header_dir}/functional.h[lines=4..-1]
----

[[table.function.objects.plus]]
.Member functions for the [code]#plus# function object
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
T operator()(const T& x, const T& y) const
----
   a@ Returns the sum of its arguments, equivalent to [code]#pass:[x + y]#.

|====

[[table.function.objects.multiplies]]
.Member functions for the [code]#multiplies# function object
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
T operator()(const T& x, const T& y) const
----
   a@ Returns the product of its arguments, equivalent to [code]#x * y#.

|====

[[table.function.objects.bit-and]]
.Member functions for the [code]#bit_and# function object
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
T operator()(const T& x, const T& y) const
----
   a@ Returns the bitwise AND of its arguments, equivalent to [code]#x & y#.

|====

[[table.function.objects.bit-or]]
.Member functions for the [code]#bit_or# function object
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
T operator()(const T& x, const T& y) const
----
   a@ Returns the bitwise OR of its arguments, equivalent to [code]#x | y#.

|====

[[table.function.objects.bit-xor]]
.Member functions for the [code]#bit_xor# function object
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
T operator()(const T& x, const T& y) const
----
   a@ Returns the bitwise XOR of its arguments, equivalent to [code]#x ^ y#.

|====

[[table.function.objects.logical-and]]
.Member functions for the [code]#logical_and# function object
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
T operator()(const T& x, const T& y) const
----
   a@ Returns the logical AND of its arguments, equivalent to [code]#x && y#.

|====

[[table.function.objects.logical-or]]
.Member functions for the [code]#logical_or# function object
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
T operator()(const T& x, const T& y) const
----
   a@ Returns the logical OR of its arguments, equivalent to [code]#x || y#.

|====

[[table.function.objects.minimum]]
.Member functions for the [code]#minimum# function object
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
T operator()(const T& x, const T& y) const
----
   a@ Returns the smaller value. Returns the first argument when the arguments
      are equivalent.

|====

[[table.function.objects.maximum]]
.Member functions for the [code]#maximum# function object
[width="100%",options="header",separator="@",cols="65%,35%"]
|====
@ Member function @ Description
a@
[source]
----
T operator()(const T& x, const T& y) const
----
   a@ Returns the larger value. Returns the first argument when the arguments
      are equivalent.

|====

[[sec:group-functions]]
=== Group functions

SYCL provides a number of functions that expose functionality tied to groups of
work-items (such as <<group-barrier,group barriers>> and collective operations).
These group functions act as synchronization points and must be encountered in
converged <<control flow>> by all work-items in the group.  If one work-item in
a group calls a group function, then all work-items in that group must call
exactly the same function under the same set of conditions --- calling the same
function under different conditions (e.g. in different iterations of a loop, or
different branches of a conditional statement) results in undefined behavior.
Additionally, restrictions may be placed on the arguments passed to each
function in order to ensure that all work-items in the group agree on the
operation that is being performed.  Any such restrictions on the arguments
passed to a function are defined within the descriptions of those functions.
Violating these restrictions results in undefined behavior.

All group functions are supported for the fundamental scalar types supported by
SYCL (see <<table.types.fundamental>>) and instances of the SYCL
[code]#vec# and [code]#marray# classes.

Using a group function inside of a kernel may introduce additional
limits on the resources available to user code inside the same kernel.  The
behavior of these limits is implementation-defined, but must be reflected by
calls to kernel querying functions (such as
[code]#kernel::get_info#) as described in <<sec:kernel.query>>.

It is undefined behavior for any group function to be invoked within a
[code]#parallel_for_work_group# or [code]#parallel_for_work_item#
context.

==== Group type trait

[source,,linenums]
----
include::{header_dir}/algorithms/is_group.h[lines=4..-1]
----

The [code]#is_group# type trait is used to determine which types of groups are
supported by group functions, and to control when group functions participate
in overload resolution.

[code]#is_group<T># inherits from [code]#std::true_type# if [code]#T# is the
type of a standard SYCL group ([code]#group# or [code]#sub_group#) and it
inherits from [code]#std::false_type# otherwise.  A SYCL implementation may
introduce additional specializations of [code]#is_group<T># for
implementation-defined group types, if the interface of those types supports all
member functions and static members common to the [code]#group# and
[code]#sub_group# classes.

==== [code]#group_broadcast#

The [code]#group_broadcast# function communicates a value held by one
work-item to all other work-items in the group.

[source,,linenums]
----
include::{header_dir}/groups/broadcast.h[lines=4..-1]
----

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true and [code]#T# is a
    trivially copyable type.
+
--
_Returns:_ The value of [code]#x# from the work-item with the smallest linear
id within group [code]#g#.
--

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true and [code]#T# is a
    trivially copyable type.
+
--
_Preconditions:_ [code]#local_linear_id# must be the same for all work-items in
the group and must be in the range [code]#[0, get_local_linear_range())#.

_Returns:_ The value of [code]#x# from the work-item with the specified linear
id within group [code]#g#.
--

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true and [code]#T# is a
    trivially copyable type.
+
--
_Preconditions:_ [code]#local_id# must be the same for all work-items in the
group, and its dimensionality must match the dimensionality of the group.
The value of [code]#local_id# in each dimension must be greater than or equal
to 0 and less than the value of [code]#get_local_range()# in the same
dimension.

_Returns:_ The value of [code]#x# from the work-item with the specified id
within group [code]#g#.
--

==== [code]#group_barrier#

The [code]#group_barrier# function synchronizes all work-items in a group,
using a <<group-barrier>>.

[source,,linenums]
----
include::{header_dir}/groups/barrier.h[lines=4..-1]
----

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true.
+
--
_Effects:_ Synchronizes all work-items in group [code]#g#. The current
work-item will wait at the barrier until all work-items in group [code]#g# have
reached the barrier. In addition, the barrier performs <<mem-fence>> operations ensuring that
memory accesses issued before the barrier are not re-ordered with those issued
after the barrier: all work-items in group [code]#g# execute a release fence
prior to synchronizing at the barrier, all work-items in group [code]#g#
execute an acquire fence afterwards, and there is an implicit synchronization
of these fences as if provided by an explicit atomic operation on an atomic
object.

By default, the scope of these fences is set to the narrowest
scope including all work-items in group [code]#g# (as reported by
[code]#Group::fence_scope#).  This scope may be optionally overridden
with a wider scope, specified by the [code]#fence_scope# argument.
--

[[sec:algorithms]]
=== Group algorithms library

SYCL provides an algorithms library based on the functions described
in Section 28 of the {cpp17} specification.  The first argument to each function
is a <<group>>, and data ranges can be described using pointers, iterators or
instances of the [code]#multi_ptr# class.  The functions defined in this
section are free functions available in the [code]#sycl# namespace.

Any restrictions from the standard algorithms library apply.  Some of the
functions in the SYCL algorithms library introduce additional restrictions
in order to maximize portability across different devices and to minimize
the chances of encountering unexpected behavior.

All algorithms are supported for the fundamental scalar types supported by SYCL
(see <<table.types.fundamental>>) and instances of the SYCL
[code]#vec# and [code]#marray# classes.

The <<group>> argument to a SYCL algorithm denotes that it should be performed
collaboratively by the work-items in the specified group.  All algorithms
act as group functions (as defined in <<sec:group-functions>>), inheriting all
restrictions of group functions.  Unless the description of a function says
otherwise, how the elements of a range are processed by the work-items in a
group is undefined.

SYCL provides separate functions for algorithms which use the work-items in a
group to execute an operation over a range of iterators and algorithms which
are applied to data held directly by the work-items in a group.  An example
of the usage of these functions is given below:

[[listing.group.algorithms]]
.Using the group algorithms library to perform a work-group reduce
[source,,linenums]
----
include::{code_dir}/algorithms.cpp[lines=4..-1]
----

==== [code]#any_of#, [code]#all_of# and [code]#none_of#

The [code]#any_of#, [code]#all_of# and [code]#none_of# functions from standard
{cpp} test whether Boolean conditions hold for any of, all of or none of the
values in a range, respectively.

SYCL provides two sets of similar algorithms:

. [code]#joint_any_of#, [code]#joint_all_of# and [code]#joint_none_of# use the
work-items in a group to execute the corresponding algorithm in parallel.

. [code]#any_of_group#, [code]#all_of_group# and [code]#none_of_group# test
Boolean conditions applied to data held directly by the work-items in a group.

[source,,linenums]
----
include::{header_dir}/algorithms/any_of.h[lines=4..-1]
----

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true and [code]#Ptr# is a
    pointer.
+
--
_Preconditions:_ [code]#first# and [code]#last# must be the same for all
work-items in group [code]#g#, and [code]#pred# must be an immutable callable
with the same type and state for all work-items in group [code]#g#.

_Returns:_ true if [code]#pred# returns true when applied to the result of
dereferencing any iterator in the range [code]#[first, last)#.
--

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true.
+
--
_Preconditions:_ [code]#pred# must be an immutable callable with the same type
and state for all work-items in group [code]#g#.

_Returns:_ true if [code]#pred(x)# returns true for any work-item in group
[code]#g#.
--

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true.
+
--
_Returns:_ true if [code]#pred# is true for any work-item in group [code]#g#.
--

[source,,linenums]
----
include::{header_dir}/algorithms/all_of.h[lines=4..-1]
----

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true and [code]#Ptr# is a
    pointer.
+
--
_Preconditions:_ [code]#first# and [code]#last# must be the same for all
work-items in group [code]#g#, and [code]#pred# must be an immutable callable
with the same type and state for all work-items in group [code]#g#.

_Returns:_ true if [code]#pred# returns true when applied to the result of
dereferencing all iterators in the range [code]#[first, last)#.
--

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true.
+
--
_Preconditions:_ [code]#pred# must be an immutable callable with the same type
and state for all work-items in group [code]#g#.

_Returns:_ true if [code]#pred(x)# returns true for all work-items in group
[code]#g#.
--

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true.
+
--
_Returns:_ true if [code]#pred# is true for all work-items in group [code]#g#.
--

[source,,linenums]
----
include::{header_dir}/algorithms/none_of.h[lines=4..-1]
----

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true and [code]#Ptr# is a
    pointer.
+
--
_Preconditions:_ [code]#first# and [code]#last# must be the same for all
work-items in group [code]#g#, and [code]#pred# must be an immutable callable
with the same type and state for all work-items in group [code]#g#.

_Returns:_ true if [code]#pred# returns false when applied to the result of
dereferencing all iterators in the range [code]#[first, last)#.
--

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true.
+
--
_Preconditions:_ [code]#pred# must be an immutable callable with the same type
and state for all work-items in group [code]#g#.

_Returns:_ true if [code]#pred(x)# returns false for all work-items in group
[code]#g#.
--

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true.
+
--
_Returns:_ true if [code]#pred# is false for all work-items in group [code]#g#.
--

==== [code]#shift_left# and [code]#shift_right#

The [code]#shift_left# and [code]#shift_right# functions from standard {cpp}
move values in a range down (to the left) or up (to the right) respectively.

SYCL provides similar algorithms compatible with the [code]#sub_group# class:

. [code]#shift_group_left# and [code]#shift_group_right# move values held by
the work-items in a group directly to another work-item in group [code]#g#, by
shifting values a fixed number of work-items to the left or right.

[source,,linenums]
----
include::{header_dir}/algorithms/shift.h[lines=4..-1]
----

  . _Constraints:_ Available only if
    [code]#std::is_same_v<std::decay_t<Group>, sub_group># is true and
    [code]#T# is a trivially copyable type.
+
--
_Preconditions:_ [code]#delta# must be the same for all work-items in the
group.

_Returns:_ the value of [code]#x# from the work-item whose group local id
([code]#id#) is [code]#delta# larger than that of the calling work-item.
[code]#pass:[id + delta]# may be greater than or equal to the group's linear
size, but the value returned in this case is unspecified.
--

  . _Constraints:_ Available only if
    [code]#std::is_same_v<std::decay_t<Group>, sub_group># is true and
    [code]#T# is a trivially copyable type.
+
--
_Preconditions:_ [code]#delta# must be the same for all work-items in the
group.

_Returns:_ the value of [code]#x# from the work-item whose group local id
([code]#id#) is [code]#delta# smaller than that of the calling work-item.
[code]#id - delta# may be less than 0, but the value returned in this case
is unspecified.
--

==== [code]#permute#

SYCL provides an algorithm to permute the values held by work-items in a
sub-group:

. [code]#permute_group_by_xor# permutes values by exchanging values held by pairs
of work-items identified by computing the bitwise exclusive OR of the work-item
id and some fixed mask.

[source,,linenums]
----
include::{header_dir}/algorithms/permute.h[lines=4..-1]
----

  . _Constraints:_ Available only if
    [code]#std::is_same_v<std::decay_t<Group>, sub_group># is true and
    [code]#T# is a trivially copyable type.
+
--
_Preconditions:_ [code]#mask# must be the same for all work-items in the
group.

_Returns:_ the value of [code]#x# from the work-item whose group local id
is equal to the bitwise exclusive OR of the calling work-item's group local id
and [code]#mask#.  The result of the exclusive OR may be greater than or equal to
the group's linear size, but the value returned in this case is unspecified.
--

==== [code]#select#

SYCL provides an algorithm to directly exchange the values held by work-items in
a sub-group:

. [code]#select_from_group# allows work-items to obtain a copy of a value held
by any other work-item in group [code]#g#.

[source,,linenums]
----
include::{header_dir}/algorithms/select.h[lines=4..-1]
----

  . _Constraints:_ Available only if
    [code]#std::is_same_v<std::decay_t<Group>, sub_group># is true and
    [code]#T# is a trivially copyable type.
+
--
_Returns:_ the value of [code]#x# from the work-item with the group local id
specified by [code]#remote_local_id#.  The value of [code]#remote_local_id# may
be outside of the group, but the value returned in this case is unspecified.
--

==== [code]#reduce#

The [code]#reduce# function from standard {cpp} combines the values in a range in
an unspecified order using a binary operator.

SYCL provides two similar algorithms that compute the same generalized sum as
defined by standard {cpp}:

. [code]#joint_reduce# uses the work-items in a group to execute a
[code]#reduce# operation in parallel.

. [code]#reduce_over_group# combines values held directly by the work-items in
a group.

The result of a call to these functions is non-deterministic if the binary
operator is not commutative and associative. Only the binary operators defined
in <<sec:function-objects>> are supported by the [code]#reduce# functions in
SYCL 2020, but the standard {cpp} syntax is used for forward compatibility with
future SYCL versions.

[source,,linenums]
----
include::{header_dir}/algorithms/reduce.h[lines=4..-1]
----

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true, [code]#Ptr# is a
    pointer to a fundamental type, and [code]#BinaryOperation# is a SYCL
    function object type.
+
--
_Mandates:_ [code]#binary_op(*first, *first)# must return a value of type
[code]#std::iterator_traits<Ptr>::value_type#.

_Preconditions:_ [code]#first#, [code]#last# and the type of [code]#binary_op#
must be the same for all work-items in group [code]#g#. [code]#binary_op# must
be an instance of a SYCL function object.

_Returns:_ The result of combining the values resulting from dereferencing all
iterators in the range [code]#[first, last)# using the operator
[code]#binary_op#, where the values are combined according to the generalized
sum defined in standard {cpp}.
--

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true, [code]#Ptr# is a
    pointer to a fundamental type, [code]#T# is a fundamental type, and
    [code]#BinaryOperation# is a SYCL function object type.
+
--
_Mandates:_ [code]#binary_op(init, *first)# must return a value of type
[code]#T#.

_Preconditions:_ [code]#first#, [code]#last#, [code]#init# and the type of
[code]#binary_op# must be the same for all work-items in group [code]#g#.
[code]#binary_op# must be an instance of a SYCL function object.

_Returns:_ The result of combining the values resulting from dereferencing all
iterators in the range [code]#[first, last)# and the initial value
[code]#init# using the operator [code]#binary_op#, where the values are combined
according to the generalized sum defined in standard {cpp}.
--

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true, [code]#T# is a
    fundamental type and [code]#BinaryOperation# is a SYCL function object
    type.
+
--
_Mandates:_ [code]#binary_op(x, x)# must return a value of type [code]#T#.

_Preconditions:_ [code]#binary_op# must be an instance of a SYCL function
object.

_Returns:_ The result of combining all the values of [code]#x# specified by
each work-item in group [code]#g# using the operator [code]#binary_op#, where
the values are combined according to the generalized sum defined in standard {cpp}.
--

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true, [code]#V# and
    [code]#T# are fundamental types, and [code]#BinaryOperation# is a SYCL
    function object type.
+
--
_Mandates:_ [code]#binary_op(init, x)# must return a value of type [code]#T#.

_Preconditions:_ [code]#binary_op# must be an instance of a SYCL function
object.

_Returns:_ The result of combining all the values of [code]#x# specified by
each work-item in group [code]#g# and the initial value [code]#init# using the
operator [code]#binary_op#, where the values are combined according to the
generalized sum defined in standard {cpp}.
--

==== [code]#exclusive_scan# and [code]#inclusive_scan#

The [code]#exclusive_scan# and [code]#inclusive_scan# functions in standard
{cpp} compute a prefix sum using a binary operator.  For a scan of elements
_[x~0~, {ldots}, x~n~]_, the _i_ th result in an exclusive scan is the
generalized noncommutative sum of all elements preceding _x~i~_ (excluding
_x~i~_ itself), whereas the _i_ th result in an inclusive scan is the
generalized noncommutative sum of all elements preceding _x~i~_ (including
_x~i~_ itself).

SYCL provides two similar sets of algorithms that compute the same prefix sums
using the generalized noncommutative sum as defined by standard {cpp}:

. [code]#joint_exclusive_scan# and [code]#joint_inclusive_scan# use the
work-items in a group to execute the corresponding algorithm in parallel, and
intermediate partial prefix sums are written to memory as in standard {cpp}.

. [code]#exclusive_scan_over_group# and [code]#inclusive_scan_over_group#
perform a scan over values held directly by the work-items in a group, and the
result returned to each work-item represents a partial prefix sum.

The result of a call to a scan is non-deterministic if the binary operator is not
associative.  Only the binary operators defined in <<sec:function-objects>> are
supported by the scan functions in SYCL 2020, but the standard {cpp} syntax is
used for forward compatibility with future SYCL versions.

[source,,linenums]
----
include::{header_dir}/algorithms/exclusive_scan.h[lines=4..-1]
----

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true, [code]#InPtr# and
    [code]#OutPtr# are pointers to fundamental types, and
    [code]#BinaryOperation# is a SYCL function object type.
+
--
_Mandates:_ [code]#binary_op(*first, *first)# must return a value of type
[code]#std::iterator_traits<OutPtr>::value_type#.

_Preconditions:_ [code]#first#, [code]#last#, [code]#result# and the type of
[code]#binary_op# must be the same for all work-items in group [code]#g#.
[code]#binary_op# must be an instance of a SYCL function object. 

[NOTE]
====
Note that [code]#first# may be equal to [code]#result#.
====

_Effects:_ The value written to [code]#result# + _i_ is the exclusive scan of
the values resulting from dereferencing the first _i_ values in the range
[code]#[first, last)# and the identity value of [code]#binary_op# (as
identified by [code]#sycl::known_identity#), using the operator
[code]#binary_op#.  The scan is computed using a generalized noncommutative sum
as defined in standard {cpp}.

_Returns:_ A pointer to the end of the output range.
--

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true, [code]#InPtr# and
    [code]#OutPtr# are pointers to fundamental types, [code]#T# is a
    fundamental type, and [code]#BinaryOperation# is a SYCL function object
    type.
+
--
_Mandates:_ [code]#binary_op(init, *first)# must return a value of type
[code]#T#.

_Preconditions:_ [code]#first#, [code]#last#, [code]#result#, [code]#init# and the
type of [code]#binary_op# must be the same for all work-items in group
[code]#g#. [code]#binary_op# must be an instance of a SYCL function object. 

[NOTE]
====
Note that [code]#first# may be equal to [code]#result#.
====

_Effects:_ The value written to [code]#result# + _i_ is the exclusive scan of
the values resulting from dereferencing the first _i_ values in the range
[code]#[first, last)# and an initial value specified by [code]#init#, using
the operator [code]#binary_op#.  The scan is computed using a generalized
noncommutative sum as defined in standard {cpp}.

_Returns:_ A pointer to the end of the output range.
--

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true, [code]#T# is a
    fundamental type, and [code]#BinaryOperation# is a SYCL function object
    type.
+
--
_Mandates:_ [code]#binary_op(x, x)# must return a value of type [code]#T#.

_Preconditions:_ [code]#binary_op# must be an instance of a SYCL function
object.

_Returns:_ The value returned on work-item _i_ is the exclusive scan of
the first _i_ values in group [code]#g# and the identity value of
[code]#binary_op# (as identified by [code]#sycl::known_identity#), using the
operator [code]#binary_op#.  The scan is computed using a generalized
noncommutative sum as defined in standard {cpp}.  For multi-dimensional groups,
the order of work-items in group [code]#g# is determined by their linear id.
--

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true, [code]#V# and
    [code]#T# are fundamental types, and [code]#BinaryOperation# is a SYCL
    function object type.
+
--
_Mandates:_ [code]#binary_op(init, x)# must return a value of type [code]#T#.

_Preconditions:_ [code]#binary_op# must be an instance of a SYCL function
object.

_Returns:_ The value returned on work-item _i_ is the exclusive scan of
the first _i_ values in group [code]#g# and an initial value specified by
[code]#init#, using the operator [code]#binary_op#.  The scan is computed using
a generalized noncommutative sum as defined in standard {cpp}.  For
multi-dimensional groups, the order of work-items in group [code]#g# is
determined by their linear id.
--

[source,,linenums]
----
include::{header_dir}/algorithms/inclusive_scan.h[lines=4..-1]
----

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true, [code]#InPtr# and
    [code]#OutPtr# are pointers to fundamental types, and
    [code]#BinaryOperation# is a SYCL function object type.
+
--
_Mandates:_ [code]#binary_op(*first, *first)# must return a value of type
[code]#std::iterator_traits<OutPtr>::value_type#.

_Preconditions:_ [code]#first#, [code]#last#, [code]#result# and the type of
[code]#binary_op# must be the same for all work-items in group [code]#g#.
[code]#binary_op# must be an instance of a SYCL function object. 

[NOTE]
====
Note that [code]#first# may be equal to [code]#result#.
====

_Effects:_ The value written to [code]#result# + _i_ is the inclusive scan of
the values resulting from dereferencing the first _i_ values in the range
[code]#[first, last)#, using the operator [code]#binary_op#.  The scan is
computed using a generalized noncommutative sum as defined in standard {cpp}.

_Returns:_ A pointer to the end of the output range.
--

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true, [code]#InPtr# and
    [code]#OutPtr# are pointers to fundamental types, [code]#BinaryOperation#
    is a SYCL function object type, and [code]#T# is a fundamental type.
+
--
_Mandates:_ [code]#binary_op(init, *first)# must return a value of type
[code]#T#.

_Preconditions:_ [code]#first#, [code]#last#, [code]#result#, [code]#init# and the
type of [code]#binary_op# must be the same for all work-items in group
[code]#g#. [code]#binary_op# must be an instance of a SYCL function object. 

[NOTE]
====
Note that [code]#first# may be equal to [code]#result#.
====

_Effects:_ The value written to [code]#result# + _i_ is the inclusive scan of
the values resulting from dereferencing the first _i_ values in the range
[code]#[first, last)# and an initial value specified by
[code]#init#, using the operator [code]#binary_op#.  The scan is computed using
a generalized noncommutative sum as defined in standard {cpp}.

_Returns:_ A pointer to the end of the output range.
--

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true, [code]#T# is a
    fundamental type, and [code]#BinaryOperation# is a SYCL function object
    type.
+
--
_Mandates:_ [code]#binary_op(x, x)# must return a value of type [code]#T#.

_Preconditions:_ [code]#binary_op# must be an instance of a SYCL function
object.

_Returns:_ The value returned on work-item _i_ is the inclusive scan of
the first _i_ values in group [code]#g#, using the operator [code]#binary_op#.
The scan is computed using a generalized noncommutative sum as defined in
standard {cpp}.  For multi-dimensional groups, the order of work-items in group
[code]#g# is determined by their linear id.
--

  . _Constraints:_ Available only if
    [code]#sycl::is_group_v<std::decay_t<Group>># is true, [code]#V# is a
    fundamental type, [code]#BinaryOperation# is a SYCL function object type,
    and [code]#T# is a fundamental type.
+
--
_Mandates:_ [code]#binary_op(init, x)# must return a value of type [code]#T#.

_Preconditions:_ [code]#binary_op# must be an instance of a SYCL function
object.

_Returns:_ The value returned on work-item _i_ is the inclusive scan of
the first _i_ values in group [code]#g# and an initial value specified by
[code]#init#, using the operator [code]#binary_op#.  The scan is computed using
a generalized noncommutative sum as defined in standard {cpp}.  For
multi-dimensional groups, the order of work-items in group [code]#g# is
determined by their linear id.
--


=== Math functions

In SYCL the OpenCL math functions are available in the namespace
[code]#sycl# on host and device with the same precision
guarantees as defined in the OpenCL 1.2 specification document
<<opencl12, ch. 7>> for host and device. For a SYCL platform the
numerical requirements for host need to match the numerical
requirements of the OpenCL math built-in functions.

The built-in functions available for SYCL host and device, with the same
precision requirements for both host and device, are described in
<<table.math.functions>>.

The function descriptions in this section use the term _writeable address
space_ to represent the following address spaces:

* [code]#access::address_space::global_space#
* [code]#access::address_space::local_space#
* [code]#access::address_space::private_space#
* [code]#access::address_space::generic_space#

[[table.math.functions]]
.Math functions
[separator="@"]
|====
a@
[frame=all,grid=none]
!====
a!
[source]
----
float acos(float x)                (1)
double acos(double x)              (2)
half acos(half x)                  (3)

template<typename NonScalar>       (4)
/*return-type*/ acos(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The inverse cosine of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the inverse cosine of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float acosh(float x)                (1)
double acosh(double x)              (2)
half acosh(half x)                  (3)

template<typename NonScalar>        (4)
/*return-type*/ acosh(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The inverse hyperbolic cosine of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the inverse hyperbolic cosine of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float acospi(float x)                (1)
double acospi(double x)              (2)
half acospi(half x)                  (3)

template<typename NonScalar>         (4)
/*return-type*/ acospi(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value [code]#acos(x) / {pi}#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the value
[code]#acos(x[i]) / {pi}#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float asin(float x)                (1)
double asin(double x)              (2)
half asin(half x)                  (3)

template<typename NonScalar>       (4)
/*return-type*/ asin(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The inverse sine of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the inverse sine of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float asinh(float x)                (1)
double asinh(double x)              (2)
half asinh(half x)                  (3)

template<typename NonScalar>        (4)
/*return-type*/ asinh(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The inverse hyperbolic sine of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the inverse hyperbolic sine of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float asinpi(float x)                (1)
double asinpi(double x)              (2)
half asinpi(half x)                  (3)

template<typename NonScalar>         (4)
/*return-type*/ asinpi(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value [code]#asin(x) / {pi}#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the value [code]#asin(x[i]) / {pi}#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float atan(float y_over_x)                (1)
double atan(double y_over_x)              (2)
half atan(half y_over_x)                  (3)

template<typename NonScalar>              (4)
/*return-type*/ atan(NonScalar y_over_x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The inverse tangent of the input.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of the input, the inverse tangent of the element.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float atan2(float y, float x)                       (1)
double atan2(double y, double x)                    (2)
half atan2(half y, half x)                          (3)

template<typename NonScalar1, typename NonScalar2>  (4)
/*return-type*/ atan2(NonScalar1 y, NonScalar2 x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The arc tangent of [code]#y / x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzled_vec__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements;
* [code]#NonScalar1# and [code]#NonScalar2# have the same element type; and
* The element type of [code]#NonScalar1# and [code]#NonScalar2# is
  [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x# and [code]#y#, the arc tangent of
[code]#y[i] / x[i]#.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float atanh(float x)                (1)
double atanh(double x)              (2)
half atanh(half x)                  (3)

template<typename NonScalar>        (4)
/*return-type*/ atanh(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The hyperbolic inverse tangent of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the hyperbolic inverse tangent of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float atanpi(float x)                (1)
double atanpi(double x)              (2)
half atanpi(half x)                  (3)

template<typename NonScalar>         (4)
/*return-type*/ atanpi(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value [code]#atan(x) / {pi}#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the value [code]#atan(x[i]) / {pi}#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float atan2pi(float y, float x)                      (1)
double atan2pi(double y, double x)                   (2)
half atan2pi(half y, half x)                         (3)

template<typename NonScalar1, typename NonScalar2>   (4)
/*return-type*/ atan2pi(NonScalar1 y, NonScalar2 x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value [code]#atan2(y, x) / {pi}#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzled_vec__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements;
* [code]#NonScalar1# and [code]#NonScalar2# have the same element type; and
* The element type of [code]#NonScalar1# and [code]#NonScalar2# is
  [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x# and [code]#y#, the value
[code]#atan2(y[i], x[i]) / {pi}#.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float cbrt(float x)                (1)
double cbrt(double x)              (2)
half cbrt(half x)                  (3)

template<typename NonScalar>       (4)
/*return-type*/ cbrt(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The cube-root of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the cube-root of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float ceil(float x)                (1)
double ceil(double x)              (2)
half ceil(half x)                  (3)

template<typename NonScalar>       (4)
/*return-type*/ ceil(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value [code]#x# rounded to an integral value using the round to
positive infinity rounding mode.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the value [code]#x[i]# rounded to an
integral value using the round to positive infinity rounding mode.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float copysign(float x, float y)                      (1)
double copysign(double x, double y)                   (2)
half copysign(half x, half y)                         (3)

template<typename NonScalar1, typename NonScalar2>    (4)
/*return-type*/ copysign(NonScalar1 x, NonScalar2 y)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value of [code]#x# with its sign changed to match
the sign of [code]#y#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzled_vec__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements;
* [code]#NonScalar1# and [code]#NonScalar2# have the same element type; and
* The element type of [code]#NonScalar1# and [code]#NonScalar2# is
  [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x# and [code]#y#, the value of
[code]#x[i]# with its sign changed to match the sign of [code]#y[i]#.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float cos(float x)                (1)
double cos(double x)              (2)
half cos(half x)                  (3)

template<typename NonScalar>      (4)
/*return-type*/ cos(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The cosine of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the cosine of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float cosh(float x)                (1)
double cosh(double x)              (2)
half cosh(half x)                  (3)

template<typename NonScalar>       (4)
/*return-type*/ cosh(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The hyperbolic cosine of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the hyperbolic cosine of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float cospi(float x)                (1)
double cospi(double x)              (2)
half cospi(half x)                  (3)

template<typename NonScalar>         (4)
/*return-type*/ cospi(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value [code]#cos({pi} * x)#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the value [code]#cos({pi} * x[i])#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float erfc(float x)                (1)
double erfc(double x)              (2)
half erfc(half x)                  (3)

template<typename NonScalar>       (4)
/*return-type*/ erfc(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The complementary error function of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the complementary error function of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float erf(float x)                (1)
double erf(double x)              (2)
half erf(half x)                  (3)

template<typename NonScalar>      (4)
/*return-type*/ erf(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The error function of [code]#x# (encountered in integrating the
normal distribution).

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the error function of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float exp(float x)                (1)
double exp(double x)              (2)
half exp(half x)                  (3)

template<typename NonScalar>      (4)
/*return-type*/ exp(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The base-_e_ exponential of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the base-_e_ exponential of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float exp2(float x)                (1)
double exp2(double x)              (2)
half exp2(half x)                  (3)

template<typename NonScalar>       (4)
/*return-type*/ exp2(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The base-2 exponential of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the base-2 exponential of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float exp10(float x)                (1)
double exp10(double x)              (2)
half exp10(half x)                  (3)

template<typename NonScalar>        (4)
/*return-type*/ exp10(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The base-10 exponential of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the base-10 exponential of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float expm1(float x)                (1)
double expm1(double x)              (2)
half expm1(half x)                  (3)

template<typename NonScalar>        (4)
/*return-type*/ expm1(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value [code]#e^x^-1.0#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the value [code]#e^x[i]^-1.0#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float fabs(float x)                (1)
double fabs(double x)              (2)
half fabs(half x)                  (3)

template<typename NonScalar>       (4)
/*return-type*/ fabs(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The absolute value of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the absolute value of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float fdim(float x, float y)                        (1)
double fdim(double x, double y)                     (2)
half fdim(half x, half y)                           (3)

template<typename NonScalar1, typename NonScalar2>  (4)
/*return-type*/ fdim(NonScalar1 x, NonScalar2 y)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value [code]#x - y# if [code]#x > y#, otherwise +0.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzled_vec__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements;
* [code]#NonScalar1# and [code]#NonScalar2# have the same element type; and
* The element type of [code]#NonScalar1# and [code]#NonScalar2# is
  [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x# and [code]#y#, the value
[code]#x[i] - y[i]# if [code]#x[i] > y[i]#, otherwise +0.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float floor(float x)                (1)
double floor(double x)              (2)
half floor(half x)                  (3)

template<typename NonScalar>        (4)
/*return-type*/ floor(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value [code]#x# rounded to an integral value using the round to
negative infinity rounding mode.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the value [code]#x[i]# rounded to an
integral value using the round to negative infinity rounding mode.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float fma(float a, float b, float c)                                     (1)
double fma(double a, double b, double c)                                 (2)
half fma(half a, half b, half c)                                         (3)

template<typename NonScalar1, typename NonScalar2, typename NonScalar3>  (4)
/*return-type*/ fma(NonScalar1 a, NonScalar2 b, NonScalar3 c)
----
!====

*Overloads (1) - (3):*

_Returns:_ The correctly rounded floating-point representation of the sum of
[code]#c# with the infinitely precise product of [code]#a# and [code]#b#.
Rounding of intermediate products shall not occur. Edge case behavior is per
the IEEE 754-2008 standard.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1#,
  [code]#NonScalar2#, and [code]#NonScalar3#:
** [code]#NonScalar1#, [code]#NonScalar2#, and [code]#NonScalar3# are each
   [code]#marray#; or
** [code]#NonScalar1#, [code]#NonScalar2#, and [code]#NonScalar3# are any
   combination of [code]#vec# and the [code]#+__swizzled_vec__+# type;
* [code]#NonScalar1#, [code]#NonScalar2#, and [code]#NonScalar3# have the same
  number of elements;
* [code]#NonScalar1#, [code]#NonScalar2#, and [code]#NonScalar3# have the same
  element type; and
* The element type of [code]#NonScalar1#, [code]#NonScalar2#, and
  [code]#NonScalar3# is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#a#, [code]#b#, and [ode]#c#; the
correctly rounded floating-point representation of the sum of [code]#c[i]# with
the infinitely precise product of [code]#a[i]# and [code]#b[i]#.  Rounding of
intermediate products shall not occur. Edge case behavior is per the IEEE
754-2008 standard.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float fmax(float x, float y)                                (1)
double fmax(double x, double y)                             (2)
half fmax(half x, half y)                                   (3)

template<typename NonScalar1, typename NonScalar2>          (4)
/*return-type*/ fmax(NonScalar1 x, NonScalar2 y)

template<typename NonScalar>                                (5)
/*return-type*/ fmax(NonScalar x, NonScalar::value_type y)
----
!====

*Overloads (1) - (3):*

_Returns:_ [code]#y# if [code]#x < y#, otherwise [code]#x#. If one argument is
a NaN, returns the other argument. If both arguments are NaNs, returns a NaN.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzled_vec__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements;
* [code]#NonScalar1# and [code]#NonScalar2# have the same element type; and
* The element type of [code]#NonScalar1# and [code]#NonScalar2# is
  [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x# and [code]#y#, the value [code]#y[i]#
if [code]#x[i] < y[i]#, otherwise [code]#x[i]#. If one element is a NaN, the
result is the other element. If both elements are NaNs, the result is NaN.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

*Overload (5):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the value [code]#y# if
[code]#x[i] < y#, otherwise [code]#x[i]#. If one value is a NaN, the result is
the other value. If both value are NaNs, the result is a NaN.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float fmin(float x, float y)                                (1)
double fmin(double x, double y)                             (2)
half fmin(half x, half y)                                   (3)

template<typename NonScalar1, typename NonScalar2>          (4)
/*return-type*/ fmin(NonScalar1 x, NonScalar2 y)

template<typename NonScalar>                                (5)
/*return-type*/ fmin(NonScalar x, NonScalar::value_type y)
----
!====

*Overloads (1) - (3):*

_Returns:_ [code]#y# if [code]#y < x#, otherwise [code]#x#. If one argument is
a NaN, returns the other argument. If both arguments are NaNs, returns a NaN.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzled_vec__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements;
* [code]#NonScalar1# and [code]#NonScalar2# have the same element type; and
* The element type of [code]#NonScalar1# and [code]#NonScalar2# is
  [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x# and [code]#y#, the value [code]#y[i]#
if [code]#y[i] < x[i]#, otherwise [code]#x[i]#. If one element is a NaN, the
result is the other element. If both elements are NaNs, the result is NaN.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

*Overload (5):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the value [code]#y# if
[code]#y < x[i]#, otherwise [code]#x[i]#. If one value is a NaN, the result is
the other value. If both value are NaNs, the result is a NaN.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float fmod(float x, float y)                        (1)
double fmod(double x, double y)                     (2)
half fmod(half x, half y)                           (3)

template<typename NonScalar1, typename NonScalar2>  (4)
/*return-type*/ fmod(NonScalar1 x, NonScalar2 y)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value [code]#x - y * trunc(x/y)#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzled_vec__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements;
* [code]#NonScalar1# and [code]#NonScalar2# have the same element type; and
* The element type of [code]#NonScalar1# and [code]#NonScalar2# is
  [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x# and [code]#y#, the value
[code]#x[i] - y[i] * trunc(x[i]/y[i])#.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename Ptr>                        (1)
float fract(float x, Ptr iptr)

template<typename Ptr>                        (2)
double fract(double x, Ptr iptr)

template<typename Ptr>                        (3)
half fract(half x, Ptr iptr)

template<typename NonScalar, typename Ptr>    (4)
/*return-type*/ fract(NonScalar x, Ptr iptr)
----
!====

*Overloads (1) - (3):*

_Constraints:_ Available only if [code]#Ptr# is [code]#multi_ptr# with
[code]#ElementType# equal to the same type as [code]#x# and with [code]#Space#
equal to one of the _writeable address spaces_ as defined above.

_Effects:_ Writes the value [code]#floor(x)# to [code]#iptr#.

_Returns:_ The value [code]#fmin(x - floor(x), nextafter(T{1.0}, T{0.0}) )#,
where [code]#T# is the type of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type with element type [code]#float#,
  [code]#double#, or [code]#half#;
* [code]#Ptr# is [code]#multi_ptr# with [code]#ElementType# equal to
  [code]#NonScalar#, unless [code]#NonScalar# is the [code]#+__swizzled_vec__+#
  type, in which case the [code]#ElementType# is the corresponding
  [code]#vec#; and
* [code]#Ptr# is [code]#multi_ptr# with [code]#Space# equal to one of the
  _writeable address spaces_ as defined above.

_Effects:_ Writes the value [code]#floor(x)# to [code]#iptr#.

_Returns:_ For each element of [code]#x#, the value
[code]#fmin(x[i] - floor(x[i]), nextafter(T{1.0}, T{0.0}) )#, where
[code]#T# is the element type of [code]#x#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename Ptr>                        (1)
float frexp(float x, Ptr exp)

template<typename Ptr>                        (2)
double frexp(double x, Ptr exp)

template<typename Ptr>                        (3)
half frexp(half x, Ptr exp)

template<typename NonScalar, typename Ptr>    (4)
/*return-type*/ frexp(NonScalar x, Ptr exp)
----
!====

*Overloads (1) - (3):*

_Constraints:_ Available only if [code]#Ptr# is [code]#multi_ptr# with
[code]#ElementType# of [code]#int# and with [code]#Space# equal to one of the
_writeable address spaces_ as defined above.

_Effects:_ Extracts the mantissa and exponent from [code]#x#.  The mantissa is
a floating point number whose magnitude is in the interval +[0.5, 1)+ or 0.  The
extracted mantissa and exponent are such that mantissa * 2^exp^ equals
[code]#x#.  The exponent is written to [code]#exp#.

_Returns:_ The mantissa of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type with element type [code]#float#,
  [code]#double#, or [code]#half#;
* [code]#Ptr# is [code]#multi_ptr# with the following [code]#ElementType#:
** If [code]#NonScalar# is [code]#marray#, [code]#ElementType# is
   [code]#marray# of [code]#int# with the same number of elements as
   [code]#NonScalar#;
** If [code]#NonScalar# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
   [code]#ElementType# is [code]#vec# of [code]#int32_t# with the same number
   of elements as [code]#NonScalar#;
* [code]#Ptr# is [code]#multi_ptr# with [code]#Space# equal to one of the
  _writeable address spaces_ as defined above.

_Effects:_ Extracts the mantissa and exponent from each element of [code]#x#.
Each mantissa is a floating point number whose magnitude is in the interval
+[0.5, 1)+ or 0.  Each extracted mantissa and exponent are such that
mantissa * 2^exp^ equals [code]#x[i]#.  The exponent of each element of
[code]#x# is written to [code]#exp#.

_Returns:_ For each element of [code]#x#, the mantissa of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float hypot(float x, float y)                       (1)
double hypot(double x, double y)                    (2)
half hypot(half x, half y)                          (3)

template<typename NonScalar1, typename NonScalar2>  (4)
/*return-type*/ hypot(NonScalar1 x, NonScalar2 y)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value of the square root of x^2^ + y^2^ without undue overflow
or underflow.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzled_vec__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements;
* [code]#NonScalar1# and [code]#NonScalar2# have the same element type; and
* The element type of [code]#NonScalar1# and [code]#NonScalar2# is
  [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x# and [code]#y#, the value of the square
root of +x[i]+^2^ + +y[i]+^2^ without undue overflow or underflow.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
int ilogb(float x)                  (1)
int ilogb(double x)                 (2)
int ilogb(half x)                   (3)

template<typename NonScalar>        (4)
/*return-type*/ ilogb(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ Compute the integral part of log~r~|x| and return the result as an
integer, where r is the value returned by
[code]#std::numeric_limits<decltype(x)>::radix#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, compute the integral part of
log~r~|x[i]| and return the result as an integer, where r is the value returned
by [code]#std::numeric_limits<NonScalar::value_type)>::radix#.

The return type depends on [code]#NonScalar#.  If [code]#NonScalar# is
[code]#marray#, the return type is [code]#marray# of [code]#int# with the same
number of element as [code]#NonScalar#.  If [code]#NonScalar# is [code]#vec# or
the [code]#+__swizzled_vec__+# type, the return type is [code]#vec# of
[code]#int32_t# with the same number of elements as [code]#NonScalar#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float ldexp(float x, int k)                         (1)
double ldexp(double x, int k)                       (2)
half ldexp(half x, int k)                           (3)

template<typename NonScalar1, typename NonScalar2>  (4)
/*return-type*/ ldexp(NonScalar1 x, NonScalar2 k)

template<typename NonScalar>                        (5)
/*return-type*/ ldexp(NonScalar x, int k)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value [code]#x# multiplied by 2^k^.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar1# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type;
* The element type of [code]#NonScalar1# is [code]#float#, [code]#double#, or
  [code]#half#;
* If [code]#NonScalar1# is [code]#marray#, [code]#NonScalar2# is [code]#marray#
  of [code]#int# with the same number of elements as [code]#NonScalar1#; and
* If [code]#NonScalar1# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
  [code]#NonScalar2# is [code]#vec# or the [code]#+__swizzled_vec__+# type of
  [code]#int32_t# with the same number of elements as [code]#NonScalar1#.

_Returns:_ For each element of [code]#x# and [code]#k#, the value
[code]#x[i]# multiplied by 2^k[i]^.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

*Overload (5):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type of [code]#NonScalar# is [code]#float#, [code]#double#, or
  [code]#half#.

_Returns:_ For each element of [code]#x#, the value [code]#x[i]# multiplied by
2^k^.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float lgamma(float x)                (1)
double lgamma(double x)              (2)
half lgamma(half x)                  (3)

template<typename NonScalar>         (4)
/*return-type*/ lgamma(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The natural logarithm of the absolute value of the gamma function of
[code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the natural logarithm of the absolute
value of the gamma function of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename Ptr>                        (1)
float lgamma_r(float x, Ptr signp)

template<typename Ptr>                        (2)
double lgamma_r(double x, Ptr signp)

template<typename Ptr>                        (3)
half lgamma_r(half x, Ptr signp)

template<typename NonScalar, typename Ptr>    (4)
/*return-type*/ lgamma_r(NonScalar x, Ptr signp)
----
!====

*Overloads (1) - (3):*

_Constraints:_ Available only if [code]#Ptr# is [code]#multi_ptr# with
[code]#ElementType# of [code]#int# and with [code]#Space# equal to one of the
_writeable address spaces_ as defined above.

_Effects:_ Writes the sign of the gamma function of [code]#x# to [code]#signp#.

_Returns:_ The natural logarithm of the absolute value of the gamma function of
[code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type with element type [code]#float#,
  [code]#double#, or [code]#half#;
* [code]#Ptr# is [code]#multi_ptr# with the following [code]#ElementType#:
** If [code]#NonScalar# is [code]#marray#, [code]#ElementType# is
   [code]#marray# of [code]#int# with the same number of elements as
   [code]#NonScalar#;
** If [code]#NonScalar# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
   [code]#ElementType# is [code]#vec# of [code]#int32_t# with the same number
   of elements as [code]#NonScalar#;
* [code]#Ptr# is [code]#multi_ptr# with [code]#Space# equal to one of the
  _writeable address spaces_ as defined above.

_Effects:_ Computes the gamma function for each element of [code]#x# and writes
the sign for each of these values to [code]#signp#.

_Returns:_ For each element of [code]#x#, the natural logarithm of the absolute
value of the gamma function of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float log(float x)                (1)
double log(double x)              (2)
half log(half x)                  (3)

template<typename NonScalar>      (4)
/*return-type*/ log(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The natural logarithm of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the natural logarithm of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float log2(float x)                (1)
double log2(double x)              (2)
half log2(half x)                  (3)

template<typename NonScalar>       (4)
/*return-type*/ log2(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The base 2 logarithm of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the base 2 logarithm of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float log10(float x)                (1)
double log10(double x)              (2)
half log10(half x)                  (3)

template<typename NonScalar>        (4)
/*return-type*/ log10(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The base 10 logarithm of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the base 10 logarithm of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float log1p(float x)                (1)
double log1p(double x)              (2)
half log1p(half x)                  (3)

template<typename NonScalar>        (4)
/*return-type*/ log1p(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value [code]#log(1.0 + x)#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the value [code]#log(1.0 + x[i])#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float logb(float x)                (1)
double logb(double x)              (2)
half logb(half x)                  (3)

template<typename NonScalar>       (4)
/*return-type*/ logb(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The integral part of log~r~|x|, where r is the value returned by
[code]#std::numeric_limits<decltype(x)>::radix#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the integral part of log~r~|x[i]|,
where r is the value returned by
[code]#std::numeric_limits<NonScalar::value_type>::radix#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float mad(float a, float b, float c)                                     (1)
double mad(double a, double b, double c)                                 (2)
half mad(half a, half b, half c)                                         (3)

template<typename NonScalar1, typename NonScalar2, typename NonScalar3>  (4)
/*return-type*/ mad(NonScalar1 a, NonScalar2 b, NonScalar3 c)
----
!====

*Overloads (1) - (3):*

_Effects_: Computes the approximate value of [code]#a * b + c#.  Whether or how
the product of [code]#a * b# is rounded and how supernormal or subnormal
intermediate products are handled is not defined.  The [code]#mad# function is
intended to be used where speed is preferred over accuracy.

_Returns:_ The approximate value of [code]#a * b + c#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1#,
  [code]#NonScalar2#, and [code]#NonScalar3#:
** [code]#NonScalar1#, [code]#NonScalar2#, and [code]#NonScalar3# are each
   [code]#marray#; or
** [code]#NonScalar1#, [code]#NonScalar2#, and [code]#NonScalar3# are any
   combination of [code]#vec# and the [code]#+__swizzled_vec__+# type;
* [code]#NonScalar1#, [code]#NonScalar2#, and [code]#NonScalar3# have the same
  number of elements;
* [code]#NonScalar1#, [code]#NonScalar2#, and [code]#NonScalar3# have the same
  element type; and
* The element type of [code]#NonScalar1#, [code]#NonScalar2#, and
  [code]#NonScalar3# is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#a#, [code]#b#, and [ode]#c#; the
The approximate value of [code]#a[i] * b[i] + c[i]#.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float maxmag(float x, float y)                      (1)
double maxmag(double x, double y)                   (2)
half maxmag(half x, half y)                         (3)

template<typename NonScalar1, typename NonScalar2>  (4)
/*return-type*/ maxmag(NonScalar1 x, NonScalar2 y)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value [code]#x# if |x| > |y|, [code]#y# if |y| > |x|, otherwise
[code]#fmax(x, y)#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzled_vec__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements;
* [code]#NonScalar1# and [code]#NonScalar2# have the same element type; and
* The element type of [code]#NonScalar1# and [code]#NonScalar2# is
  [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x# and [code]#y#, the value [code]#x[i]#
if |x[i]| > |y[i]|, [code]#y[i]# if |y[i]| > |x[i]|, otherwise
[code]#fmax(x[i], y[i])#.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float minmag(float x, float y)                      (1)
double minmag(double x, double y)                   (2)
half minmag(half x, half y)                         (3)

template<typename NonScalar1, typename NonScalar2>  (4)
/*return-type*/ minmag(NonScalar1 x, NonScalar2 y)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value [code]#x# if |x| < |y|, [code]#y# if |y| < |x|, otherwise
[code]#fmin(x, y)#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzled_vec__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements;
* [code]#NonScalar1# and [code]#NonScalar2# have the same element type; and
* The element type of [code]#NonScalar1# and [code]#NonScalar2# is
  [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x# and [code]#y#, the value [code]#x[i]#
if |x[i]| < |y[i]|, [code]#y[i]# if |y[i]| < |x[i]|, otherwise
[code]#fmin(x[i], y[i])#.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename Ptr>                        (1)
float modf(float x, Ptr iptr)

template<typename Ptr>                        (2)
double modf(double x, Ptr iptr)

template<typename Ptr>                        (3)
half modf(half x, Ptr iptr)

template<typename NonScalar, typename Ptr>    (4)
/*return-type*/ modf(NonScalar x, Ptr iptr)
----
!====

*Overloads (1) - (3):*

_Constraints:_ Available only if [code]#Ptr# is [code]#multi_ptr# with
[code]#ElementType# equal to the same type as [code]#x# and with [code]#Space#
equal to one of the _writeable address spaces_ as defined above.

_Effects:_ The [code]#modf# function breaks the argument [code]#x# into
integral and fractional parts, each of which has the same sign as the argument.
It stores the integral part to the object pointed to by [code]#iptr#.

_Returns:_ The fractional part of the argument [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type with element type [code]#float#,
  [code]#double#, or [code]#half#;
* [code]#Ptr# is [code]#multi_ptr# with [code]#ElementType# equal to
  [code]#NonScalar#, unless [code]#NonScalar# is the [code]#+__swizzled_vec__+#
  type, in which case the [code]#ElementType# is the corresponding
  [code]#vec#; and
* [code]#Ptr# is [code]#multi_ptr# with [code]#Space# equal to one of the
  _writeable address spaces_ as defined above.

_Effects:_ The [code]#modf# function breaks each element of the argument
[code]#x# into integral and fractional parts, each of which has the same sign
as the element.  It stores the integral parts of each element to the object
pointed to by [code]#iptr#.

_Returns:_ The fractional parts of each element of the argument [code]#x#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float nan(unsigned int nancode)         (1)
double nan(unsigned long nancode)       (2)
half nan(unsigned short nancode)        (3)

template<typename NonScalar>            (4)
/*return-type*/ nan(NonScalar nancode)
----
!====

*Overloads (1) - (3):*

_Returns:_ A quiet NaN. The [code]#nancode# may be placed
in the significand of the resulting NaN.

*Overload (4):*

_Constraints:_ Available only if one of the following conditions is met:

* [code]#NonScalar# is [code]#marray# and the element type is
  [code]#unsigned int#, [code]#unsigned long#, or [code]#unsigned short#; or
* [code]#NonScalar# is [code]#vec# or the [code]#+__swizzled_vec__+# type and
  the element type is [code]#uint32_t#, [code]#uint64_t#, or [code]#uint16_t#.

_Returns:_ A quiet NaN for each element of [code]#nancode#.  Each
[code]#nancode[i]# may be placed in the significand of the resulting NaN.

The return type depends on [code]#NonScalar#:
[options="header",cols="70%,30%"]
!====
!NonScalar ! Return Type
![code]#marray<unsigned int, N># ![code]#marray<float, N>#
![code]#marray<unsigned long, N># ![code]#marray<double, N>#
![code]#marray<unsigned short, N># ![code]#marray<half, N>#

![code]#vec<uint32_t, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<uint32_t, N>#
![code]#vec<float, N>#

![code]#vec<uint64_t, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<uint64_t, N>#
![code]#vec<double, N>#

![code]#vec<uint16_t, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<uint16_t, N>#
![code]#vec<half, N>#
!====

a@
[frame=all,grid=none]
!====
a!
[source]
----
float nextafter(float x, float y)                      (1)
double nextafter(double x, double y)                   (2)
half nextafter(half x, half y)                         (3)

template<typename NonScalar1, typename NonScalar2>     (4)
/*return-type*/ nextafter(NonScalar1 x, NonScalar2 y)
----
!====

*Overloads (1) - (3):*

_Returns:_ The next representable single-precision floating-point value
following [code]#x# in the direction of [code]#y#.  Thus, if [code]#y# is less
than [code]#x#, [code]#nextafter# returns the largest representable
floating-point number less than [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzled_vec__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements;
* [code]#NonScalar1# and [code]#NonScalar2# have the same element type; and
* The element type of [code]#NonScalar1# and [code]#NonScalar2# is
  [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x# and [code]#y#, the
next representable single-precision floating-point value following [code]#x[i]#
in the direction of [code]#y[i]#.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float pow(float x, float y)                         (1)
double pow(double x, double y)                      (2)
half pow(half x, half y)                            (3)

template<typename NonScalar1, typename NonScalar2>  (4)
/*return-type*/ pow(NonScalar1 x, NonScalar2 y)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value of [code]#x# raised to the power [code]#y#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzled_vec__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements;
* [code]#NonScalar1# and [code]#NonScalar2# have the same element type; and
* The element type of [code]#NonScalar1# and [code]#NonScalar2# is
  [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x# and [code]#y#, the value of
[code]#x[i]# raised to the power [code]#y[i]#.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float pown(float x, int y)                          (1)
double pown(double x, int y)                        (2)
half pown(half x, int y)                            (3)

template<typename NonScalar1, typename NonScalar2>  (4)
/*return-type*/ pown(NonScalar1 x, NonScalar2 y)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value of [code]#x# raised to the power [code]#y#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar1# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type;
* The element type of [code]#NonScalar1# is [code]#float#, [code]#double#, or
  [code]#half#;
* If [code]#NonScalar1# is [code]#marray#, [code]#NonScalar2# is [code]#marray#
  of [code]#int# with the same number of elements as [code]#NonScalar1#; and
* If [code]#NonScalar1# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
  [code]#NonScalar2# is [code]#vec# or the [code]#+__swizzled_vec__+# type of
  [code]#int32_t# with the same number of elements as [code]#NonScalar1#.

_Returns:_ For each element of [code]#x# and [code]#y#, the value of
[code]#x[i]# raised to the power [code]#y[i]#.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float powr(float x, float y)                        (1)
double powr(double x, double y)                     (2)
half powr(half x, half y)                           (3)

template<typename NonScalar1, typename NonScalar2>  (4)
/*return-type*/ powr(NonScalar1 x, NonScalar2 y)
----
!====

*Overloads (1) - (3):*

_Preconditions:_ The value of [code]#x# must be greater than or equal to zero.

_Returns:_ The value of [code]#x# raised to the power [code]#y#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzled_vec__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements;
* [code]#NonScalar1# and [code]#NonScalar2# have the same element type; and
* The element type of [code]#NonScalar1# and [code]#NonScalar2# is
  [code]#float#, [code]#double#, or [code]#half#.

_Preconditions:_ Each element of [code]#x# must be greater than or equal to
zero.

_Returns:_ For each element of [code]#x# and [code]#y#, the value of
[code]#x[i]# raised to the power [code]#y[i]#.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float remainder(float x, float y)                      (1)
double remainder(double x, double y)                   (2)
half remainder(half x, half y)                         (3)

template<typename NonScalar1, typename NonScalar2>     (4)
/*return-type*/ remainder(NonScalar1 x, NonScalar2 y)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value [code]#r# such that [code]#r = x - n*y#, where [code]#n#
is the integer nearest the exact value of [code]#x/y#.  If there are two
integers closest to [code]#x/y#, [code]#n# shall be the even one.  If [code]#r#
is zero, it is given the same sign as [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzled_vec__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements;
* [code]#NonScalar1# and [code]#NonScalar2# have the same element type; and
* The element type of [code]#NonScalar1# and [code]#NonScalar2# is
  [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x# and [code]#y#, the value [code]#r#
such that [code]#r = x[i] - n*y[i]#, where [code]#n# is the integer nearest the
exact value of [code]#x[i]/y[i]#.  If there are two integers closest to
[code]#x[i]/y[i]#, [code]#n# shall be the even one.  If [code]#r# is zero, it
is given the same sign as [code]#x[i]#.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename Ptr>                                            (1)
float remquo(float x, float y, Ptr quo)

template<typename Ptr>                                            (2)
double remquo(double x, double y, Ptr quo)

template<typename Ptr>                                            (3)
half remquo(half x, half y, Ptr quo)

template<typename NonScalar1, typename NonScalar2, typename Ptr>  (4)
/*return-type*/ remquo(NonScalar1 x, NonScalar2 y, Ptr quo)
----
!====

*Overloads (1) - (3):*

_Constraints:_ Available only if [code]#Ptr# is [code]#multi_ptr# with
[code]#ElementType# of [code]#int# and with [code]#Space# equal to one of the
_writeable address spaces_ as defined above.

_Effects:_ Computes the value [code]#r# such that [code]#r = x - k*y#, where
[code]#k# is the integer nearest the exact value of [code]#x/y#.  If there are
two integers closest to [code]#x/y#, [code]#k# shall be the even one.  If
[code]#r# is zero, it is given the same sign as [code]#x#.  This is the same
value that is returned by the [code]#remainder# function.  The [code]#remquo#
function also calculates the lower seven bits of the integral quotient
[code]#x/y# and gives that value the same sign as [code]#x/y#.  It stores this
signed value to the object pointed to by [code]#quo#.

_Returns:_ The value [code]#r# defined above.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzled_vec__+# type;
* [code]#Ptr# is [code]#multi_ptr# with the following [code]#ElementType#:
** If [code]#NonScalar1# is [code]#marray#, [code]#ElementType# is
   [code]#marray# of [code]#int# with the same number of elements as
   [code]#NonScalar1#;
** If [code]#NonScalar1# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
   [code]#ElementType# is [code]#vec# of [code]#int32_t# with the same number
   of elements as [code]#NonScalar1#;
* [code]#Ptr# is [code]#multi_ptr# with [code]#Space# equal to one of the
  _writeable address spaces_ as defined above.

_Effects:_ Computes the value [code]#r# for each element of [code]#x# and
[code]#y# such that [code]#r = x[i] - k*y[i]#, where [code]#k# is the integer
nearest the exact value of [code]#x[i]/y[i]#.  If there are two integers
closest to [code]#x[i]/y[i]#, [code]#k# shall be the even one.  If [code]#r# is
zero, it is given the same sign as [code]#x[i]#.  This is the same value that
is returned by the [code]#remainder# function.  The [code]#remquo# function
also calculates the lower seven bits of the integral quotient
[code]#x[i]/y[i]# and gives that value the same sign as [code]#x[i]/y[i]#.
It stores these signed values to the object pointed to by [code]#quo#.

_Returns:_ The values of [code]#r# defined above.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float rint(float x)                (1)
double rint(double x)              (2)
half rint(half x)                  (3)

template<typename NonScalar>       (4)
/*return-type*/ rint(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value [code]#x# rounded to an integral value (using round to
nearest even rounding mode) in floating-point format.  Refer to <<opencl12,
section 7.1 of the OpenCL 1.2 specification document>> for a description of the
rounding modes.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the value [code]#x[i]# rounded to an
integral value (using round to nearest even rounding mode) in floating-point
format.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float rootn(float x, int y)                         (1)
double rootn(double x, int y)                       (2)
half rootn(half x, int y)                           (3)

template<typename NonScalar1, typename NonScalar2>  (4)
/*return-type*/ rootn(NonScalar1 x, NonScalar2 y)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value of [code]#x# raised to the power [code]#1/y#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar1# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type;
* The element type of [code]#NonScalar1# is [code]#float#, [code]#double#, or
  [code]#half#;
* If [code]#NonScalar1# is [code]#marray#, [code]#NonScalar2# is [code]#marray#
  of [code]#int# with the same number of elements as [code]#NonScalar1#; and
* If [code]#NonScalar1# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
  [code]#NonScalar2# is [code]#vec# or the [code]#+__swizzled_vec__+# type of
  [code]#int32_t# with the same number of elements as [code]#NonScalar1#.

_Returns:_ For each element of [code]#x# and [code]#y#, the value of
[code]#x[i]# raised to the power [code]#1/y[i]#.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float round(float x)                (1)
double round(double x)              (2)
half round(half x)                  (3)

template<typename NonScalar>        (4)
/*return-type*/ round(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The integral value nearest to [code]#x# rounding halfway cases away
from zero, regardless of the current rounding direction.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the integral value nearest to
[code]#x[i]# rounding halfway cases away from zero, regardless of the current
rounding direction.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float rsqrt(float x)                (1)
double rsqrt(double x)              (2)
half rsqrt(half x)                  (3)

template<typename NonScalar>        (4)
/*return-type*/ rsqrt(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The inverse square root of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the inverse square root of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float sin(float x)                (1)
double sin(double x)              (2)
half sin(half x)                  (3)

template<typename NonScalar>      (4)
/*return-type*/ sin(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The sine of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the sine of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename Ptr>                           (1)
float sincos(float x, Ptr cosval)

template<typename Ptr>                           (2)
double sincos(double x, Ptr cosval)

template<typename Ptr>                           (3)
half sincos(half x, Ptr cosval)

template<typename NonScalar, typename Ptr>       (4)
/*return-type*/ sincos(NonScalar x, Ptr cosval)
----
!====

*Overloads (1) - (3):*

_Constraints:_ Available only if [code]#Ptr# is [code]#multi_ptr# with
[code]#ElementType# equal to the same type as [code]#x# and with [code]#Space#
equal to one of the _writeable address spaces_ as defined above.

_Effects:_ Compute the sine and cosine of [code]#x#.  The computed cosine is
written to [code]#cosval#.

_Returns:_ The sine of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type with element type [code]#float#,
  [code]#double#, or [code]#half#;
* [code]#Ptr# is [code]#multi_ptr# with [code]#ElementType# equal to
  [code]#NonScalar#, unless [code]#NonScalar# is the [code]#+__swizzled_vec__+#
  type, in which case the [code]#ElementType# is the corresponding
  [code]#vec#; and
* [code]#Ptr# is [code]#multi_ptr# with [code]#Space# equal to one of the
  _writeable address spaces_ as defined above.

_Effects:_ Compute the sine and cosine of each element of [code]#x#.  The
computed cosine values are written to [code]#cosval#.

_Returns:_ The sine of each element of [code]#x#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float sinh(float x)                (1)
double sinh(double x)              (2)
half sinh(half x)                  (3)

template<typename NonScalar>       (4)
/*return-type*/ sinh(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The hyperbolic sine of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the hyperbolic sine of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float sinpi(float x)                (1)
double sinpi(double x)              (2)
half sinpi(half x)                  (3)

template<typename NonScalar>        (4)
/*return-type*/ sinpi(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value [code]#sin({pi} * x)#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the value [code]#sin({pi} * x[i])#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float sqrt(float x)                (1)
double sqrt(double x)              (2)
half sqrt(half x)                  (3)

template<typename NonScalar>       (4)
/*return-type*/ sqrt(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The square root of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the square root of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float tan(float x)                (1)
double tan(double x)              (2)
half tan(half x)                  (3)

template<typename NonScalar>      (4)
/*return-type*/ tan(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The tangent of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the tangent of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float tanh(float x)                (1)
double tanh(double x)              (2)
half tanh(half x)                  (3)

template<typename NonScalar>       (4)
/*return-type*/ tanh(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The hyperbolic tangent of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the hyperbolic tangent of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float tanpi(float x)                (1)
double tanpi(double x)              (2)
half tanpi(half x)                  (3)

template<typename NonScalar>        (4)
/*return-type*/ tanpi(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value [code]#tan({pi} * x)#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the value [code]#tan({pi} * x[i])#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float tgamma(float x)                (1)
double tgamma(double x)              (2)
half tgamma(half x)                  (3)

template<typename NonScalar>         (4)
/*return-type*/ tgamma(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The gamma function of [code]#x#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the gamma function of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float trunc(float x)                (1)
double trunc(double x)              (2)
half trunc(half x)                  (3)

template<typename NonScalar>        (4)
/*return-type*/ trunc(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value [code]#x# rounded to an integral value using the round to
zero rounding mode.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ For each element of [code]#x#, the value [code]#x[i]# rounded to an
integral value using the round to zero rounding mode.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.
|====


=== Native precision math functions

In SYCL the implementation-defined precision math functions are
defined in the namespace [code]#sycl::native#.  The functions
that are available within this namespace are specified in
<<table.native.math.functions>>.

The range of valid input values and the maximum error for these functions is
implementation defined.

[[table.native.math.functions]]
.Native precision math functions
[separator="@"]
|====
a@
[frame=all,grid=none]
!====
a!
[source]
----
float cos(float x)                (1)

template<typename NonScalar>      (2)
/*return-type*/ cos(NonScalar x)
----
!====

*Overload (1):*

_Returns:_ The cosine of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the cosine of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float divide(float x, float y)                      (1)

template<typename NonScalar1, typename NonScalar2>  (2)
/*return-type*/ divide(NonScalar1 x, NonScalar2 y)
----
!====

*Overload (1):*

_Returns:_ The value [code]#x / y#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x# and [code]#y#, the value
[code]#x[i] / y[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float exp(float x)                (1)

template<typename NonScalar>      (2)
/*return-type*/ exp(NonScalar x)
----
!====

*Overload (1):*

_Returns:_ The base-_e_ exponential of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the base-_e_ exponential of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float exp2(float x)                (1)

template<typename NonScalar>       (2)
/*return-type*/ exp2(NonScalar x)
----
!====

*Overload (1):*

_Returns:_ The base-2 exponential of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the base-2 exponential of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float exp10(float x)                (1)

template<typename NonScalar>        (2)
/*return-type*/ exp10(NonScalar x)
----
!====

*Overload (1):*

_Returns:_ The base-10 exponential of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the base-10 exponential of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float log(float x)                (1)

template<typename NonScalar>      (2)
/*return-type*/ log(NonScalar x)
----
!====

*Overload (1):*

_Returns:_ The natural logarithm of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the natural logarithm of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float log2(float x)                (1)

template<typename NonScalar>       (2)
/*return-type*/ log2(NonScalar x)
----
!====

*Overload (1):*

_Returns:_ The base 2 logarithm of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the base 2 logarithm of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float log10(float x)                (1)

template<typename NonScalar>        (2)
/*return-type*/ log10(NonScalar x)
----
!====

*Overload (1):*

_Returns:_ The base 10 logarithm of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the base 10 logarithm of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float powr(float x, float y)                        (1)

template<typename NonScalar1, typename NonScalar2>  (2)
/*return-type*/ powr(NonScalar1 x, NonScalar2 y)
----
!====

*Overload (1):*

_Preconditions:_ The value of [code]#x# must be greater than or equal to zero.

_Returns:_ The value of [code]#x# raised to the power [code]#y#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#.

_Preconditions:_ Each element of [code]#x# must be greater than or equal to
zero.

_Returns:_ For each element of [code]#x# and [code]#y#, the value of
[code]#x[i]# raised to the power [code]#y[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float recip(float x)                (1)

template<typename NonScalar>        (2)
/*return-type*/ recip(NonScalar x)
----
!====

*Overload (1):*

_Returns:_ The reciprocal of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the reciprocal of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float rsqrt(float x)                (1)

template<typename NonScalar>        (2)
/*return-type*/ rsqrt(NonScalar x)
----
!====

*Overload (1):*

_Returns:_ The inverse square root of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the inverse square root of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float sin(float x)                (1)

template<typename NonScalar>      (2)
/*return-type*/ sin(NonScalar x)
----
!====

*Overload (1):*

_Returns:_ The sine of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the sine of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float sqrt(float x)                (1)

template<typename NonScalar>       (2)
/*return-type*/ sqrt(NonScalar x)
----
!====

*Overload (1):*

_Returns:_ The square root of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the square root of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float tan(float x)                (1)

template<typename NonScalar>      (2)
/*return-type*/ tan(NonScalar x)
----
!====

*Overload (1):*

_Returns:_ The tangent of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the tangent of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.
|====


=== Half precision math functions

In SYCL the half precision math functions are defined in
the namespace [code]#sycl::half_precision#. The functions that are
available within this namespace are specified in
<<table.half.math.functions>>. These functions are
implemented with a minimum of 10-bits of accuracy i.e. the maximum error is
less than or equal to 8192 ulp.

[[table.half.math.functions]]
.Half precision math functions
[separator="@"]
|====
a@
[frame=all,grid=none]
!====
a!
[source]
----
float cos(float x)                (1)

template<typename NonScalar>      (2)
/*return-type*/ cos(NonScalar x)
----
!====

*Overload (1):*

_Preconditions:_ The value of [code]#x# must be in the range -216 to +216.

_Returns:_ The cosine of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#.

_Preconditions:_ The value of each element of [code]#x# must be in the range
-216 to +216.

_Returns:_ For each element of [code]#x#, the cosine of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float divide(float x, float y)                      (1)

template<typename NonScalar1, typename NonScalar2>  (2)
/*return-type*/ divide(NonScalar1 x, NonScalar2 y)
----
!====

*Overload (1):*

_Returns:_ The value [code]#x / y#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x# and [code]#y#, the value
[code]#x[i] / y[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float exp(float x)                (1)

template<typename NonScalar>      (2)
/*return-type*/ exp(NonScalar x)
----
!====

*Overload (1):*

_Returns:_ The base-_e_ exponential of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the base-_e_ exponential of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float exp2(float x)                (1)

template<typename NonScalar>       (2)
/*return-type*/ exp2(NonScalar x)
----
!====

*Overload (1):*

_Returns:_ The base-2 exponential of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the base-2 exponential of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float exp10(float x)                (1)

template<typename NonScalar>        (2)
/*return-type*/ exp10(NonScalar x)
----
!====

*Overload (1):*

_Returns:_ The base-10 exponential of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the base-10 exponential of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float log(float x)                (1)

template<typename NonScalar>      (2)
/*return-type*/ log(NonScalar x)
----
!====

*Overload (1):*

_Returns:_ The natural logarithm of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the natural logarithm of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float log2(float x)                (1)

template<typename NonScalar>       (2)
/*return-type*/ log2(NonScalar x)
----
!====

*Overload (1):*

_Returns:_ The base 2 logarithm of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the base 2 logarithm of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float log10(float x)                (1)

template<typename NonScalar>        (2)
/*return-type*/ log10(NonScalar x)
----
!====

*Overload (1):*

_Returns:_ The base 10 logarithm of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the base 10 logarithm of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float powr(float x, float y)                        (1)

template<typename NonScalar1, typename NonScalar2>  (2)
/*return-type*/ powr(NonScalar1 x, NonScalar2 y)
----
!====

*Overload (1):*

_Preconditions:_ The value of [code]#x# must be greater than or equal to zero.

_Returns:_ The value of [code]#x# raised to the power [code]#y#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#.

_Preconditions:_ Each element of [code]#x# must be greater than or equal to
zero.

_Returns:_ For each element of [code]#x# and [code]#y#, the value of
[code]#x[i]# raised to the power [code]#y[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float recip(float x)                (1)

template<typename NonScalar>        (2)
/*return-type*/ recip(NonScalar x)
----
!====

*Overload (1):*

_Returns:_ The reciprocal of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the reciprocal of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float rsqrt(float x)                (1)

template<typename NonScalar>        (2)
/*return-type*/ rsqrt(NonScalar x)
----
!====

*Overload (1):*

_Returns:_ The inverse square root of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the inverse square root of
[code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float sin(float x)                (1)

template<typename NonScalar>      (2)
/*return-type*/ sin(NonScalar x)
----
!====

*Overload (1):*

_Preconditions:_ The value of [code]#x# must be in the range -216 to +216.

_Returns:_ The sine of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#.

_Preconditions:_ The value of each element of [code]#x# must be in the range
-216 to +216.

_Returns:_ For each element of [code]#x#, the sine of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float sqrt(float x)                (1)

template<typename NonScalar>       (2)
/*return-type*/ sqrt(NonScalar x)
----
!====

*Overload (1):*

_Returns:_ The square root of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#.

_Returns:_ For each element of [code]#x#, the square root of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
float tan(float x)                (1)

template<typename NonScalar>      (2)
/*return-type*/ tan(NonScalar x)
----
!====

*Overload (1):*

_Preconditions:_ The value of [code]#x# must be in the range -216 to +216.

_Returns:_ The tangent of [code]#x#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#.

_Preconditions:_ The value of each element of [code]#x# must be in the range
-216 to +216.

_Returns:_ For each element of [code]#x#, the tangent of [code]#x[i]#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.
|====


=== Integer functions

<<table.integer.functions>> describes the integer math functions that are
available in the [code]#sycl# namespace in both host and device code.

The function descriptions in this section use the term _generic integer type_
to represent the following types:

* [code]#char#
* [code]#signed char#
* [code]#short#
* [code]#int#
* [code]#long#
* [code]#long long#
* [code]#unsigned char#
* [code]#unsigned short#
* [code]#unsigned int#
* [code]#unsigned long#
* [code]#unsigned long long#
* [code]#marray<char, N>#
* [code]#marray<signed char, N>#
* [code]#marray<short, N>#
* [code]#marray<int, N>#
* [code]#marray<long, N>#
* [code]#marray<long long, N>#
* [code]#marray<unsigned char, N>#
* [code]#marray<unsigned short, N>#
* [code]#marray<unsigned int, N>#
* [code]#marray<unsigned long, N>#
* [code]#marray<unsigned long long, N>#
* [code]#vec<int8_t, N>#
* [code]#vec<int16_t, N>#
* [code]#vec<int32_t, N>#
* [code]#vec<int64_t, N>#
* [code]#vec<uint8_t, N>#
* [code]#vec<uint16_t, N>#
* [code]#vec<uint32_t, N>#
* [code]#vec<uint64_t, N>#
* [code]#+__swizzled_vec__+# that is convertible to [code]#vec<int8_t, N>#
* [code]#+__swizzled_vec__+# that is convertible to [code]#vec<int16_t, N>#
* [code]#+__swizzled_vec__+# that is convertible to [code]#vec<int32_t, N>#
* [code]#+__swizzled_vec__+# that is convertible to [code]#vec<int64_t, N>#
* [code]#+__swizzled_vec__+# that is convertible to [code]#vec<uint8_t, N>#
* [code]#+__swizzled_vec__+# that is convertible to [code]#vec<uint16_t, N>#
* [code]#+__swizzled_vec__+# that is convertible to [code]#vec<uint32_t, N>#
* [code]#+__swizzled_vec__+# that is convertible to [code]#vec<uint64_t, N>#

[[table.integer.functions]]
.Integer functions
[separator="@"]
|====
a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename GenInt>
/*return-type*/ abs(GenInt x)
----
!====

_Constraints:_ Available only if [code]#GenInt# is a _generic integer type_ as
defined above.

_Returns:_ When the input is a scalar, returns |x|.  Otherwise, returns |x[i]|
for each element of [code]#x#.  The behavior is undefined if the result cannot
be represented by the return type.

The return type is [code]#GenInt# unless [code]#GenInt# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename GenInt1, typename GenInt2>
/*return-type*/ abs_diff(GenInt1 x, GenInt2 y)
----
!====

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenInt1# is a _generic integer type_ as defined above;
* If [code]#GenInt1# is not [code]#vec# or the [code]#+__swizzled_vec__+# type,
  then [code]#GenInt2# must be the same as [code]#GenInt1#; and
* If [code]#GenInt1# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
  then [code]#GenInt2# must also be [code]#vec# or the
  [code]#+__swizzled_vec__+# type, and both must have the same element type and
  the same number of elements.

_Returns:_ When the inputs are scalars, returns |x - y|.  Otherwise, returns
|x[i] - y[i]| for each element of [code]#x# and [code]#y#.  The subtraction is
done without modulo overflow.

When [code]#GenInt1# is scalar, the return type is the unsigned equivalent of
[code]#GenInt1# (when [code]#GenInt1# is signed).  When [code]#GenInt1# is
[code]#marray# or [code]#vec#, the return type is [code]#marray# or [code]#vec#
with the equivalent unsigned element type.  When [code]#GenInt1# is the
[code]#+__swizzled_vec__+# type, the return type is the corresponding
[code]#vec# with the equivalent unsigned element type.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename GenInt1, typename GenInt2>
/*return-type*/ add_sat(GenInt1 x, GenInt2 y)
----
!====

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenInt1# is a _generic integer type_ as defined above;
* If [code]#GenInt1# is not [code]#vec# or the [code]#+__swizzled_vec__+# type,
  then [code]#GenInt2# must be the same as [code]#GenInt1#; and
* If [code]#GenInt1# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
  then [code]#GenInt2# must also be [code]#vec# or the
  [code]#+__swizzled_vec__+# type, and both must have the same element type and
  the same number of elements.

_Returns:_ When the inputs are scalars, returns [code]#x + y#.  Otherwise,
returns [code]#x[i] + y[i]# for each element of [code]#x# and [code]#y#.  The
addition operation saturates the result.

The return type is [code]#GenInt1# unless [code]#GenInt1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename GenInt1, typename GenInt2>
/*return-type*/ hadd(GenInt1 x, GenInt2 y)
----
!====

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenInt1# is a _generic integer type_ as defined above;
* If [code]#GenInt1# is not [code]#vec# or the [code]#+__swizzled_vec__+# type,
  then [code]#GenInt2# must be the same as [code]#GenInt1#; and
* If [code]#GenInt1# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
  then [code]#GenInt2# must also be [code]#vec# or the
  [code]#+__swizzled_vec__+# type, and both must have the same element type and
  the same number of elements.

_Returns:_ When the inputs are scalars, returns [code]#(x + y) >> 1#.
Otherwise, returns [code]#(x[i] + y[i]) >> 1# for each element of [code]#x# and
[code]#y#.  The intermediate sum does not modulo overflow.

The return type is [code]#GenInt1# unless [code]#GenInt1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename GenInt1, typename GenInt2>
/*return-type*/ rhadd(GenInt1 x, GenInt2 y)
----
!====

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenInt1# is a _generic integer type_ as defined above;
* If [code]#GenInt1# is not [code]#vec# or the [code]#+__swizzled_vec__+# type,
  then [code]#GenInt2# must be the same as [code]#GenInt1#; and
* If [code]#GenInt1# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
  then [code]#GenInt2# must also be [code]#vec# or the
  [code]#+__swizzled_vec__+# type, and both must have the same element type and
  the same number of elements.

_Returns:_ When the inputs are scalars, returns [code]#(x + y + 1) >> 1#.
Otherwise, returns [code]#(x[i] + y[i] + 1) >> 1# for each element of [code]#x#
and [code]#y#.  The intermediate sum does not modulo overflow.

The return type is [code]#GenInt1# unless [code]#GenInt1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename GenInt1, typename GenInt2, typename GenInt3>    (1)
/*return-type*/ clamp(GenInt1 x, GenInt2 minval, GenInt3 maxval)

template<typename NonScalar>                                      (2)
/*return-type*/ clamp(NonScalar x, NonScalar::value_type minval,
                      NonScalar::value_type maxval)
----
!====

*Overload (1):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenInt1# is a _generic integer type_ as defined above;
* If [code]#GenInt1# is not [code]#vec# or the [code]#+__swizzled_vec__+# type,
  then [code]#GenInt2# and [code]#GenInt3# must be the same as [code]#GenInt1#;
  and
* If [code]#GenInt1# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
  then [code]#GenInt2# and [code]#GenInt3# must also be [code]#vec# or the
  [code]#+__swizzled_vec__+# type, and all three must have the same element
  type and the same number of elements.

_Preconditions:_ If the inputs are scalars, the value of [code]#minval# must be
less than or equal to the value of [code]#maxval#.  If the inputs are not
scalars, each [code]#minval# must be less than or equal to the corresponding
[code]#maxval# value.

_Returns:_ When the inputs are scalars, returns
[code]#min(max(x, minval), maxval)#.  Otherwise, returns
[code]#min(max(x[i], minval[i]), maxval[i])# for each element of [code]#x#,
[code]#minval#, and [code]#maxval#.

The return type is [code]#GenInt1# unless [code]#GenInt1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

*Overload (2):*

_Constraints:_ Available only if [code]#NonScalar# is [code]#marray#,
[code]#vec#, or the [code]#+__swizzled_vec__+# type and is a _generic integer
type_ as defined above.

_Preconditions:_ The value of [code]#minval# must be less than or equal to the
value of [code]#maxval#.

_Returns:_ [code]#min(max(x[i], minval), maxval)# for each element of
[code]#x#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename GenInt>
/*return-type*/ clz(GenInt x)
----
!====

_Constraints:_ Available only if [code]#GenInt# is a _generic integer type_ as
defined above.

_Returns:_ When the input is a scalar, returns the number of leading 0-bits in
[code]#x#, starting at the most significant bit position.  Otherwise, returns
the number of leading 0-bits in each element of [code]#x#.  When a value is 0,
the computed count is the size in bits of that value.

The return type is [code]#GenInt# unless [code]#GenInt# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename GenInt>
/*return-type*/ ctz(GenInt x)
----
!====

_Constraints:_ Available only if [code]#GenInt# is a _generic integer type_ as
defined above.

_Returns:_ When the input is a scalar, returns the number of trailing 0-bits in
[code]#x#.  Otherwise, returns the number of trailing 0-bits in each element of
[code]#x#.  When a value is 0, the computed count is the size in bits of that
value.

The return type is [code]#GenInt# unless [code]#GenInt# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename GenInt1, typename GenInt2, typename GenInt3>
/*return-type*/ mad_hi(GenInt1 a, GenInt2 b, GenInt3 c)
----
!====

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenInt1# is a _generic integer type_ as defined above;
* If [code]#GenInt1# is not [code]#vec# or the [code]#+__swizzled_vec__+# type,
  then [code]#GenInt2# and [code]#GenInt3# must be the same as [code]#GenInt1#;
  and
* If [code]#GenInt1# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
  then [code]#GenInt2# and [code]#GenInt3# must also be [code]#vec# or the
  [code]#+__swizzled_vec__+# type, and all three must have the same element
  type and the same number of elements.

_Returns:_ When the inputs are scalars, returns [code]#mul_hi(a, b)+c#.
Otherwise, returns [code]#mul_hi(a[i], b[i])+c[i]# for each element of
[code]#a#, [code]#b#, and [code]#c#.

The return type is [code]#GenInt1# unless [code]#GenInt1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename GenInt1, typename GenInt2, typename GenInt3>
/*return-type*/ mad_sat(GenInt1 a, GenInt2 b, GenInt3 c)
----
!====

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenInt1# is a _generic integer type_ as defined above;
* If [code]#GenInt1# is not [code]#vec# or the [code]#+__swizzled_vec__+# type,
  then [code]#GenInt2# and [code]#GenInt3# must be the same as [code]#GenInt1#;
  and
* If [code]#GenInt1# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
  then [code]#GenInt2# and [code]#GenInt3# must also be [code]#vec# or the
  [code]#+__swizzled_vec__+# type, and all three must have the same element
  type and the same number of elements.

_Returns:_ When the inputs are scalars, returns [code]#a * b + c#.  Otherwise,
returns [code]#a[i] * b[i] + c[i]# for each element of [code]#a#, [code]#b#,
and [code]#c#.  The operation saturates the result.

The return type is [code]#GenInt1# unless [code]#GenInt1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename GenInt1, typename GenInt2>               (1)
/*return-type*/ max(GenInt1 x, GenInt2 y)

template<typename NonScalar>                               (2)
/*return-type*/ max(NonScalar x, NonScalar::value_type y)
----
!====

*Overload (1):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenInt1# is a _generic integer type_ as defined above;
* If [code]#GenInt1# is not [code]#vec# or the [code]#+__swizzled_vec__+# type,
  then [code]#GenInt2# must be the same as [code]#GenInt1#; and
* If [code]#GenInt1# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
  then [code]#GenInt2# must also be [code]#vec# or the
  [code]#+__swizzled_vec__+# type, and both must have the same element type and
  the same number of elements.

_Returns:_ When the inputs are scalars, returns [code]#y# if [code]#x < y#
otherwise [code]#x#.  When the inputs are not scalars, returns [code]#y[i]# if
[code]#x[i] < y[i]# otherwise [code]#x[i]# for each element of [code]#x# and
[code]#y#.

The return type is [code]#GenInt1# unless [code]#GenInt1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

*Overload (2):*

_Constraints:_ Available only if [code]#NonScalar# is [code]#marray#,
[code]#vec#, or the [code]#+__swizzled_vec__+# type and is a _generic integer
type_ as defined above.

_Returns:_ [code]#y# if [code]#x[i] < y# otherwise [code]#x[i]# for each
element of [code]#x#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename GenInt1, typename GenInt2>               (1)
/*return-type*/ min(GenInt1 x, GenInt2 y)

template<typename NonScalar>                               (2)
/*return-type*/ min(NonScalar x, NonScalar::value_type y)
----
!====

*Overload (1):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenInt1# is a _generic integer type_ as defined above;
* If [code]#GenInt1# is not [code]#vec# or the [code]#+__swizzled_vec__+# type,
  then [code]#GenInt2# must be the same as [code]#GenInt1#; and
* If [code]#GenInt1# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
  then [code]#GenInt2# must also be [code]#vec# or the
  [code]#+__swizzled_vec__+# type, and both must have the same element type and
  the same number of elements.

_Returns:_ When the inputs are scalars, returns [code]#y# if [code]#y < x#
otherwise [code]#x#.  When the inputs are not scalars, returns [code]#y[i]# if
[code]#y[i] < x[i]# otherwise [code]#x[i]# for each element of [code]#x# and
[code]#y#.

The return type is [code]#GenInt1# unless [code]#GenInt1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

*Overload (2):*

_Constraints:_ Available only if [code]#NonScalar# is [code]#marray#,
[code]#vec#, or the [code]#+__swizzled_vec__+# type and is a _generic integer
type_ as defined above.

_Returns:_ [code]#y# if [code]#y < x[i]# otherwise [code]#x[i]# for each
element of [code]#x#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename GenInt1, typename GenInt2>
/*return-type*/ mul_hi(GenInt1 x, GenInt2 y)
----
!====

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenInt1# is a _generic integer type_ as defined above;
* If [code]#GenInt1# is not [code]#vec# or the [code]#+__swizzled_vec__+# type,
  then [code]#GenInt2# must be the same as [code]#GenInt1#; and
* If [code]#GenInt1# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
  then [code]#GenInt2# must also be [code]#vec# or the
  [code]#+__swizzled_vec__+# type, and both must have the same element type and
  the same number of elements.

_Effects:_ Computes [code]#x * y# and returns the high half of the product of
[code]#x# and [code]#y#.

_Returns:_ When the inputs are scalars, returns the high half of the product of
[code]#x * y#.  Otherwise, returns the high half of the product of
[code]#x[i] * y[i]# for each element of [code]#x# and [code]#y#.

The return type is [code]#GenInt1# unless [code]#GenInt1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename GenInt1, typename GenInt2>
/*return-type*/ rotate(GenInt1 v, GenInt2 count)
----
!====

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenInt1# is a _generic integer type_ as defined above;
* If [code]#GenInt1# is not [code]#vec# or the [code]#+__swizzled_vec__+# type,
  then [code]#GenInt2# must be the same as [code]#GenInt1#; and
* If [code]#GenInt1# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
  then [code]#GenInt2# must also be [code]#vec# or the
  [code]#+__swizzled_vec__+# type, and both must have the same element type and
  the same number of elements.

_Effects:_ For each element in [code]#v#, the bits are shifted left by the
number of bits given by the corresponding element in [code]#count# (subject to
usual shift modulo rules described in the OpenCL 1.2 specification
<<opencl12, section 6.3>>).  Bits shifted off the left side of the element are
shifted back in from the right.

_Returns:_ When the inputs are scalars, the result of rotating [code]#v# by
[code]#count# as described above.  Otherwise, the result of rotating
[code]#v[i]# by [code]#count[i]# for each element of [code]#v# and
[code]#count#.

The return type is [code]#GenInt1# unless [code]#GenInt1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename GenInt1, typename GenInt2>
/*return-type*/ sub_sat(GenInt1 x, GenInt2 y)
----
!====

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenInt1# is a _generic integer type_ as defined above;
* If [code]#GenInt1# is not [code]#vec# or the [code]#+__swizzled_vec__+# type,
  then [code]#GenInt2# must be the same as [code]#GenInt1#; and
* If [code]#GenInt1# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
  then [code]#GenInt2# must also be [code]#vec# or the
  [code]#+__swizzled_vec__+# type, and both must have the same element type and
  the same number of elements.

_Returns:_ When the inputs are scalars, returns [code]#x - y#.  Otherwise, returns
[code]#x[i] - y[i]# for each element of [code]#x# and [code]#y#.  The subtraction
operation saturates the result.

The return type is [code]#GenInt1# unless [code]#GenInt1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename UInt8Bit1, typename UInt8Bit2>
/*return-type*/ upsample(UInt8Bit1 hi, UInt8Bit2 lo)
----
!====

_Constraints:_ Available only if one of the following conditions is met:

* [code]#UInt8Bit1# and [code]#UInt8Bit2# are both [code]#uint8_t#;
* [code]#UInt8Bit1# and [code]#UInt8Bit2# are both [code]#marray# with element
  type [code]#uint8_t# and the same number of elements; or
* [code]#UInt8Bit1# and [code]#UInt8Bit2# are any combination of [code]#vec# or
  the [code]#+__swizzled_vec__+# type with element type [code]#uint8_t# and the
  same number of elements.

_Returns:_ When the inputs are scalars, returns
[code]#((uint16_t)hi << 8) | lo#.  Otherwise, returns
[code]#((uint16_t)hi[i] << 8) | lo[i]# for each element of [code]#hi# and
[code]#lo#.

The return type is [code]#uint16_t# when the inputs are scalar.  When the
inputs are [code]#marray#, the return type is [code]#marray# with element
type [code]#uint16_t# and the same number of elements as the inputs.
Otherwise, the return type is [code]#vec# with element type [code]#uint16_t#
and the same number of elements as the inputs.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename Int8Bit, typename UInt8Bit>
/*return-type*/ upsample(Int8Bit hi, UInt8Bit lo)
----
!====

_Constraints:_ Available only if one of the following conditions is met:

* [code]#Int8Bit# is [code]#int8_t# and [code]#UInt8Bit# is [code]#uint8_t#;
* [code]#Int8Bit# is [code]#marray# with element type [code]#int8_t# and
  [code]#UInt8Bit# is [code]#marray# with element type [code]#uint8_t# and
  both have the same number of elements; or
* [code]#Int8Bit# is [code]#vec# or the [code]#+__swizzled_vec__+# type with
  element type [code]#int8_t# and [code]#UInt8Bit# is [code]#vec# or the
  [code]#+__swizzled_vec__+# type with element type [code]#uint8_t# and both
  have the same number of elements.

_Returns:_ When the inputs are scalars, returns
[code]#((int16_t)hi << 8) | lo#.  Otherwise, returns
[code]#((int16_t)hi[i] << 8) | lo[i]# for each element of [code]#hi# and
[code]#lo#.

The return type is [code]#int16_t# when the inputs are scalar.  When the
inputs are [code]#marray#, the return type is [code]#marray# with element
type [code]#int16_t# and the same number of elements as the inputs.
Otherwise, the return type is [code]#vec# with element type [code]#int16_t#
and the same number of elements as the inputs.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename UInt16Bit1, typename UInt16Bit2>
/*return-type*/ upsample(UInt16Bit1 hi, UInt16Bit2 lo)
----
!====

_Constraints:_ Available only if one of the following conditions is met:

* [code]#UInt16Bit1# and [code]#UInt16Bit2# are both [code]#uint16_t#;
* [code]#UInt16Bit1# and [code]#UInt16Bit2# are both [code]#marray# with
  element type [code]#uint16_t# and the same number of elements; or
* [code]#UInt16Bit1# and [code]#UInt16Bit2# are any combination of [code]#vec#
  or the [code]#+__swizzled_vec__+# type with element type [code]#uint16_t# and
  the same number of elements.

_Returns:_ When the inputs are scalars, returns
[code]#((uint32_t)hi << 16) | lo#.  Otherwise, returns
[code]#((uint32_t)hi[i] << 16) | lo[i]# for each element of [code]#hi# and
[code]#lo#.

The return type is [code]#uint32_t# when the inputs are scalar.  When the
inputs are [code]#marray#, the return type is [code]#marray# with element
type [code]#uint32_t# and the same number of elements as the inputs.
Otherwise, the return type is [code]#vec# with element type [code]#uint32_t#
and the same number of elements as the inputs.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename Int16Bit, typename UInt16Bit>
/*return-type*/ upsample(Int16Bit hi, UInt16Bit lo)
----
!====

_Constraints:_ Available only if one of the following conditions is met:

* [code]#Int16Bit# is [code]#int16_t# and [code]#UInt16Bit# is
  [code]#uint16_t#;
* [code]#Int16Bit# is [code]#marray# with element type [code]#int16_t# and
  [code]#UInt16Bit# is [code]#marray# with element type [code]#uint16_t# and
  both have the same number of elements; or
* [code]#Int16Bit# is [code]#vec# or the [code]#+__swizzled_vec__+# type with
  element type [code]#int16_t# and [code]#UInt16Bit# is [code]#vec# or the
  [code]#+__swizzled_vec__+# type with element type [code]#uint16_t# and both
  have the same number of elements.

_Returns:_ When the inputs are scalars, returns
[code]#((int32_t)hi << 16) | lo#.  Otherwise, returns
[code]#((int32_t)hi[i] << 16) | lo[i]# for each element of [code]#hi# and
[code]#lo#.

The return type is [code]#int32_t# when the inputs are scalar.  When the
inputs are [code]#marray#, the return type is [code]#marray# with element
type [code]#int32_t# and the same number of elements as the inputs.
Otherwise, the return type is [code]#vec# with element type [code]#int32_t#
and the same number of elements as the inputs.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename UInt32Bit1, typename UInt32Bit2>
/*return-type*/ upsample(UInt32Bit1 hi, UInt32Bit2 lo)
----
!====

_Constraints:_ Available only if one of the following conditions is met:

* [code]#UInt32Bit1# and [code]#UInt32Bit2# are both [code]#uint32_t#;
* [code]#UInt32Bit1# and [code]#UInt32Bit2# are both [code]#marray# with
  element type [code]#uint32_t# and the same number of elements; or
* [code]#UInt32Bit1# and [code]#UInt32Bit2# are any combination of [code]#vec#
  or the [code]#+__swizzled_vec__+# type with element type [code]#uint32_t# and
  the same number of elements.

_Returns:_ When the inputs are scalars, returns
[code]#((uint64_t)hi << 32) | lo#.  Otherwise, returns
[code]#((uint64_t)hi[i] << 32) | lo[i]# for each element of [code]#hi# and
[code]#lo#.

The return type is [code]#uint64_t# when the inputs are scalar.  When the
inputs are [code]#marray#, the return type is [code]#marray# with element
type [code]#uint64_t# and the same number of elements as the inputs.
Otherwise, the return type is [code]#vec# with element type [code]#uint64_t#
and the same number of elements as the inputs.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename Int32Bit, typename UInt32Bit>
/*return-type*/ upsample(Int32Bit hi, UInt32Bit lo)
----
!====

_Constraints:_ Available only if one of the following conditions is met:

* [code]#Int32Bit# is [code]#int32_t# and [code]#UInt32Bit# is
  [code]#uint32_t#;
* [code]#Int32Bit# is [code]#marray# with element type [code]#int32_t# and
  [code]#UInt32Bit# is [code]#marray# with element type [code]#uint32_t# and
  both have the same number of elements; or
* [code]#Int32Bit# is [code]#vec# or the [code]#+__swizzled_vec__+# type with
  element type [code]#int32_t# and [code]#UInt32Bit# is [code]#vec# or the
  [code]#+__swizzled_vec__+# type with element type [code]#uint32_t# and both
  have the same number of elements.

_Returns:_ When the inputs are scalars, returns
[code]#((int64_t)hi << 32) | lo#.  Otherwise, returns
[code]#((int64_t)hi[i] << 32) | lo[i]# for each element of [code]#hi# and
[code]#lo#.

The return type is [code]#int64_t# when the inputs are scalar.  When the
inputs are [code]#marray#, the return type is [code]#marray# with element
type [code]#int64_t# and the same number of elements as the inputs.
Otherwise, the return type is [code]#vec# with element type [code]#int64_t#
and the same number of elements as the inputs.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename GenInt>
/*return-type*/ popcount(GenInt x)
----
!====

_Constraints:_ Available only if [code]#GenInt# is a _generic integer type_ as
defined above.

_Returns:_ When the input is a scalar, returns the number of non-zero bits in
[code]#x#.  Otherwise, returns the number of non-zero bits in [code]#x[i]# for
each element of [code]#x#.

The return type is [code]#GenInt# unless [code]#GenInt# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename Int32Bit1, typename Int32Bit2, typename Int32Bit3>
/*return-type*/ mad24(Int32Bit1 x, Int32Bit2 y, Int32Bit3 z)
----
!====

_Constraints:_ Available only if all of the following conditions are met:

* [code]#Int32Bit1# is one of the following types:
** [code]#int32_t#
** [code]#uint32_t#
** [code]#marray<int32_t, N>#
** [code]#marray<uint32_t, N>#
** [code]#vec<int32_t, N>#
** [code]#vec<uint32_t, N>#
** [code]#+__swizzled_vec__+# that is convertible to [code]#vec<int32_t, N>#
** [code]#+__swizzled_vec__+# that is convertible to [code]#vec<uint32_t, N>#
* If [code]#Int32Bit1# is not [code]#vec# or the [code]#+__swizzled_vec__+#
  type, then [code]#Int32Bit2# and [code]#Int32Bit# must be the same as
  [code]#Int32Bit1#; and
* If [code]#Int32Bit1# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
  then [code]#Int32Bit2# and [code]#Int32Bit3# must also be [code]#vec# or the
  [code]#+__swizzled_vec__+# type, and all three must have the same element
  type and the same number of elements.

_Preconditions:_  If the inputs are signed scalars, the values of [code]#x# and
[code]#y# must be in the range [-2^23^, 2^23^-1].  If the inputs are unsigned
scalars, the values of [code]#x# and [code]#y# must be in the range
[0, 2^24^-1].  If the inputs are not scalars, each element of [code]#x# and
[code]#y# must be in these ranges.

_Returns:_ When the inputs are scalars, returns [code]#x * y + z#.  Otherwise,
returns [code]#x[i] * y[i] + z[i]# for each element of [code]#x#, [code]#y#,
and [code]#z#.

The return type is [code]#Int32Bit1# unless [code]#Int32Bit1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename Int32Bit1, typename Int32Bit2>
/*return-type*/ mul24(Int32Bit1 x, Int32Bit2 y)
----
!====

_Constraints:_ Available only if all of the following conditions are met:

* [code]#Int32Bit1# is one of the following types:
** [code]#int32_t#
** [code]#uint32_t#
** [code]#marray<int32_t, N>#
** [code]#marray<uint32_t, N>#
** [code]#vec<int32_t, N>#
** [code]#vec<uint32_t, N>#
** [code]#+__swizzled_vec__+# that is convertible to [code]#vec<int32_t, N>#
** [code]#+__swizzled_vec__+# that is convertible to [code]#vec<uint32_t, N>#
* If [code]#Int32Bit1# is not [code]#vec# or the [code]#+__swizzled_vec__+#
  type, then [code]#Int32Bit2# must be the same as [code]#Int32Bit1#; and
* If [code]#Int32Bit1# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
  then [code]#Int32Bit2# must also be [code]#vec# or the
  [code]#+__swizzled_vec__+# type, and both must have the same element type and
  the same number of elements.

_Preconditions:_  If the inputs are signed scalars, the values of [code]#x# and
[code]#y# must be in the range [-2^23^, 2^23^-1].  If the inputs are unsigned
scalars, the values of [code]#x# and [code]#y# must be in the range
[0, 2^24^-1].  If the inputs are not scalars, each element of [code]#x# and
[code]#y# must be in these ranges.

_Returns:_ When the inputs are scalars, returns [code]#x * y#.  Otherwise,
returns [code]#x[i] * y[i]# for each element of [code]#x# and [code]#y#.

The return type is [code]#Int32Bit1# unless [code]#Int32Bit1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.
|====


=== Common functions

In SYCL the OpenCL [keyword]#common functions# are available in the
namespace [code]#sycl# on host and device as defined in the
OpenCL 1.2 specification document <<opencl12, par. 6.12.4>>. They
are described here in <<table.common.functions>>.

The function descriptions in this section use the term _generic floating point
type_ to represent the following types:

* [code]#float#
* [code]#double#
* [code]#half#
* [code]#marray<float, N>#
* [code]#marray<double, N>#
* [code]#marray<half, N>#
* [code]#vec<float, N>#
* [code]#vec<double, N>#
* [code]#vec<half, N>#
* [code]#+__swizzled_vec__+# that is convertible to [code]#vec<float, N>#
* [code]#+__swizzled_vec__+# that is convertible to [code]#vec<double, N>#
* [code]#+__swizzled_vec__+# that is convertible to [code]#vec<half, N>#

[[table.common.functions]]
.Common functions
[separator="@"]
|====
a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename GenFloat1, typename GenFloat2, typename GenFloat3>    (1)
/*return-type*/ clamp(GenFloat1 x, GenFloat2 minval, GenFloat3 maxval)

template<typename NonScalar>                                            (2)
/*return-type*/ clamp(NonScalar x, NonScalar::value_type minval,
                      NonScalar::value_type maxval)
----
!====

*Overload (1):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenFloat1# is a _generic floating point type_ as defined above;
* If [code]#GenFloat1# is not [code]#vec# or the [code]#+__swizzled_vec__+#
  type, then [code]#GenFloat2# and [code]#GenFloat3# must be the same as
  [code]#GenFloat1#; and
* If [code]#GenFloat1# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
  then [code]#GenFloat2# and [code]#GenFloat3# must also be [code]#vec# or the
  [code]#+__swizzled_vec__+# type, and all three must have the same element
  type and the same number of elements.

_Preconditions:_ If the inputs are scalars, the value of [code]#minval# must be
less than or equal to the value of [code]#maxval#.  If the inputs are not
scalars, each element of [code]#minval# must be less than or equal to the
corresponding element of [code]#maxval#.

_Returns:_ When the inputs are scalars, returns
[code]#fmin(fmax(x, minval), maxval)#.  Otherwise, returns
[code]#fmin(fmax(x[i], minval[i]), maxval[i])# for each element of [code]#x#,
[code]#minval#, and [code]#maxval#.

The return type is [code]#GenFloat1# unless [code]#GenFloat1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

*Overload (2):*

_Constraints:_ Available only if [code]#NonScalar# is [code]#marray#,
[code]#vec#, or the [code]#+__swizzled_vec__+# type and is a _generic floating
point type_ as defined above.

_Preconditions:_ The value of [code]#minval# must be less than or equal to the
value of [code]#maxval#.

_Returns:_ [code]#fmin(fmax(x[i], minval), maxval)# for each element of
[code]#x#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename GenFloat>
/*return-type*/ degrees(GenFloat radians)
----
!====

_Constraints:_ Available only if [code]#GenFloat# is a _generic floating point
type_ as defined above.

_Effects:_ Converts radians to degrees.

_Returns:_ When the inputs are scalars, returns [code]#(180 / {pi}) * radians#.
Otherwise, returns [code]#(180 / {pi}) * radians[i]# for each element of
[code]#radians#.

The return type is [code]#GenFloat# unless [code]#GenFloat# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename GenFloat1, typename GenFloat2>           (1)
/*return-type*/ max(GenFloat1 x, GenFloat2 y)

template<typename NonScalar>                               (2)
/*return-type*/ max(NonScalar x, NonScalar::value_type y)
----
!====

*Overload (1):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenFloat1# is a _generic floating point type_ as defined above;
* If [code]#GenFloat1# is not [code]#vec# or the [code]#+__swizzled_vec__+#
  type, then [code]#GenFloat2# must be the same as [code]#GenFloat1#; and
* If [code]#GenFloat1# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
  then [code]#GenFloat2# must also be [code]#vec# or the
  [code]#+__swizzled_vec__+# type, and both must have the same element type and
  the same number of elements.

_Preconditions:_ When the inputs are scalars, [code]#x# and [code]#y# must not
be infinite or NaN.  When the inputs are not scalars, no element of [code]#x#
or [code]#y# may be infinite or NaN.

_Returns:_ When the inputs are scalars, returns [code]#y# if [code]#x < y#
otherwise [code]#x#.  When the inputs are not scalars, returns [code]#y[i]# if
[code]#x[i] < y[i]# otherwise [code]#x[i]# for each element of [code]#x# and
[code]#y#.

The return type is [code]#GenFloat1# unless [code]#GenFloat1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

*Overload (2):*

_Constraints:_ Available only if [code]#NonScalar# is [code]#marray#,
[code]#vec#, or the [code]#+__swizzled_vec__+# type and is a _generic floating
point type_ as defined above.

_Preconditions:_ No element of [code]#x# may be infinite or NaN.  The value of
[code]#y# must not be infinite or NaN.

_Returns:_ [code]#y# if [code]#x[i] < y# otherwise [code]#x[i]# for each
element of [code]#x#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename GenFloat1, typename GenFloat2>           (1)
/*return-type*/ min(GenFloat1 x, GenFloat2 y)

template<typename NonScalar>                               (2)
/*return-type*/ min(NonScalar x, NonScalar::value_type y)
----
!====

*Overload (1):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenFloat1# is a _generic floating point type_ as defined above;
* If [code]#GenFloat1# is not [code]#vec# or the [code]#+__swizzled_vec__+#
  type, then [code]#GenFloat2# must be the same as [code]#GenFloat1#; and
* If [code]#GenFloat1# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
  then [code]#GenFloat2# must also be [code]#vec# or the
  [code]#+__swizzled_vec__+# type, and both must have the same element type and
  the same number of elements.

_Preconditions:_ When the inputs are scalars, [code]#x# and [code]#y# must not
be infinite or NaN.  When the inputs are not scalars, no element of [code]#x#
or [code]#y# may be infinite or NaN.

_Returns:_ When the inputs are scalars, returns [code]#y# if [code]#y < x#
otherwise [code]#x#.  When the inputs are not scalars, returns [code]#y[i]# if
[code]#y[i] < x[i]# otherwise [code]#x[i]# for each element of [code]#x# and
[code]#y#.

The return type is [code]#GenFloat1# unless [code]#GenFloat1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

*Overload (2):*

_Constraints:_ Available only if [code]#NonScalar# is [code]#marray#,
[code]#vec#, or the [code]#+__swizzled_vec__+# type and is a _generic floating
point type_ as defined above.

_Preconditions:_ No element of [code]#x# may be infinite or NaN.  The value of
[code]#y# must not be infinite or NaN.

_Returns:_ [code]#y# if [code]#y < x[i]# otherwise [code]#x[i]# for each
element of [code]#x#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename GenFloat1, typename GenFloat2, typename GenFloat3>       (1)
/*return-type*/ mix(GenFloat1 x, GenFloat2 y, GenFloat3 a)

template<typename NonScalar1, typename NonScalar2>                         (2)
/*return-type*/ mix(NonScalar1 x, NonScalar2 y, NonScalar1::value_type a)
----
!====

*Overload (1):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenFloat1# is a _generic floating point type_ as defined above;
* If [code]#GenFloat1# is not [code]#vec# or the [code]#+__swizzled_vec__+#
  type, then [code]#GenFloat2# and [code]#GenFloat3# must be the same as
  [code]#GenFloat1#; and
* If [code]#GenFloat1# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
  then [code]#GenFloat2# and [code]#GenFloat3# must also be [code]#vec# or the
  [code]#+__swizzled_vec__+# type, and all three must have the same element
  type and the same number of elements.

_Preconditions:_ If the inputs are scalars, the value of [code]#a# must be
in the range [0.0, 1.0].  If the inputs are not scalars, each element of
[code]#a# must be in the range [0.0, 1.0].

_Returns:_ The linear blend of [code]#x# and [code]#y#.  When the inputs are
scalars, returns [code]#x + (y - x) * a#.  Otherwise, returns
[code]#x[i] + (y[i] - x[i]) * a[i]# for each element of [code]#x#, [code]#y#,
and [code]#a#.

The return type is [code]#GenFloat1# unless [code]#GenFloat1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

*Overload (2):*

_Constraints:_ Available only if [code]#NonScalar# is [code]#marray#,
[code]#vec#, or the [code]#+__swizzled_vec__+# type and is a _generic floating
point type_ as defined above.

_Preconditions:_ The value of [code]#a# must be in the range [0.0, 1.0].

_Returns:_ The linear blend of [code]#x# and [code]#y#, computed as
[code]#x[i] + (y[i] - x[i]) * a# for each element of [code]#x# and [code]#y#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename GenFloat>
/*return-type*/ radians(GenFloat degrees)
----
!====

_Constraints:_ Available only if [code]#GenFloat# is a _generic floating point
type_ as defined above.

_Effects:_ Converts degrees to radians.

_Returns:_ When the inputs are scalars, returns [code]#({pi} / 180) * degrees#.
Otherwise, returns [code]#({pi} / 180) * degrees[i]# for each element of
[code]#degrees#.

The return type is [code]#GenFloat# unless [code]#GenFloat# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename GenFloat1, typename GenFloat2>               (1)
/*return-type*/ step(GenFloat1 edge, GenFloat2 x)

template<typename NonScalar>                                   (2)
/*return-type*/ step(NonScalar::value_type edge, NonScalar x)
----
!====

*Overload (1):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenFloat1# is a _generic floating point type_ as defined above;
* If [code]#GenFloat1# is not [code]#vec# or the [code]#+__swizzled_vec__+#
  type, then [code]#GenFloat2# must be the same as [code]#GenFloat1#; and
* If [code]#GenFloat1# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
  then [code]#GenFloat2# must also be [code]#vec# or the
  [code]#+__swizzled_vec__+# type, and both must have the same element type and
  the same number of elements.

_Returns:_ When the inputs are scalars, returns the value
[code]#(x < edge) ? 0.0 : 1.0#.  When the inputs are not scalars, returns
the value [code]#(x[i] < edge[i]) ? 0.0 : 1.0# for each element of [code]#x#
and [code]#edge#.

The return type is [code]#GenFloat1# unless [code]#GenFloat1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

*Overload (2):*

_Constraints:_ Available only if [code]#NonScalar# is [code]#marray#,
[code]#vec#, or the [code]#+__swizzled_vec__+# type and is a _generic floating
point type_ as defined above.

_Returns:_ The value [code]#(x[i] < edge) ? 0.0 : 1.0# for each element of
[code]#x#.

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename GenFloat1, typename GenFloat2, typename GenFloat3>       (1)
/*return-type*/ smoothstep(GenFloat1 edge0, GenFloat2 edge1, GenFloat3 x)
----
!====

*Overload (1):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenFloat1# is a _generic floating point type_ as defined above;
* If [code]#GenFloat1# is not [code]#vec# or the [code]#+__swizzled_vec__+#
  type, then [code]#GenFloat2# and [code]#GenFloat3# must be the same as
  [code]#GenFloat1#; and
* If [code]#GenFloat1# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
  then [code]#GenFloat2# and [code]#GenFloat3# must also be [code]#vec# or the
  [code]#+__swizzled_vec__+# type, and all three must have the same element
  type and the same number of elements.

_Preconditions:_ If the inputs are scalar, [code]#edge0# must be less than
[code]#edge1# and none of [code]#edge0#, [code]#edge1#, or [code]#x# may be
NaN.  If the inputs are not scalar, each element of [code]#edge0# must be less
than the corresponding element of [code]#edge1# and no element of
[code]#edge0#, [code]#edge1#, or [code]#x# may be NaN.

_Returns:_ When the inputs are scalars, returns 0.0 if [code]#+x <= edge0+# and
1.0 if [code]#x >= edge1# and performs smooth Hermite interpolation between 0
and 1 when [code]#edge0 < x < edge1#.  This is useful in cases where you would
want a threshold function with a smooth transition.  This is equivalent to:

[source]
----
GenFloat1 t;
t = clamp((x - edge0) / (edge1 - edge0), 0, 1);
return t * t * (3 - 2 * t);
----

When the inputs are not scalars, returns the following value for each element
of [code]#edge0#, [code]#edge1#, and [code]#x#:

[source]
----
GenFloat1::value_type t;
t = clamp((x[i] - edge0[i]) / (edge1[i] - edge0[i]), 0, 1);
return t * t * (3 - 2 * t);
----

The return type is [code]#GenFloat1# unless [code]#GenFloat1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename NonScalar>                                                          (2)
/*return-type*/ smoothstep(NonScalar::value_type edge0, NonScalar::value_type edge1,
                           NonScalar x)
----
!====

*Overload (2):*

_Constraints:_ Available only if [code]#NonScalar# is [code]#marray#,
[code]#vec#, or the [code]#+__swizzled_vec__+# type and is a _generic floating
point type_ as defined above.

_Preconditions:_ The value of [code]#edge0# must be less than [code]#edge1# and
neither [code]#edge0# nor [code]#edge1# may be NaN.  No element of [code]#x#
may be NaN.

_Returns:_ The following value for each element of [code]#x#:

[source]
----
NonScalar::value_type t;
t = clamp((x[i] - edge0) / (edge1 - edge0), 0, 1);
return t * t * (3 - 2 * t);
----

The return type is [code]#NonScalar# unless [code]#NonScalar# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename GenFloat>
/*return-type*/ sign(GenFloat x)
----
!====

_Constraints:_ Available only if [code]#GenFloat# is a _generic floating point
type_ as defined above.

_Returns:_ When the input is scalar, returns 1.0 if [code]#x > 0#, -0.0 if
[code]#x == -0.0#, +0.0 if [code]#x == +0.0#, -1.0 if [code]#x < 0#, or 0.0 if
[code]#x# is a NaN.  When the input is not scalar, returns these values for
each element of [code]#x#.

The return type is [code]#GenFloat# unless [code]#GenFloat# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.
|====


=== Geometric functions

In SYCL the OpenCL [keyword]#geometric functions# are available in the
namespace [code]#sycl# on host and device as defined in the OpenCL 1.2
specification document <<opencl12, par. 6.12.5>>.  On the host the
vector types use the [code]#vec# class and on an SYCL device use the
corresponding native <<backend>> vector types. All of the geometric functions
use round-to-nearest-even rounding mode.
<<table.geometric.functions>> contains the definitions of supported
geometric functions.

The function descriptions in this section use two terms that refer to a
specific list of types.  The term _generic geometric type_ represents the
following types:

* [code]#float#
* [code]#double#
* [code]#marray<float, N>#, where [code]#N# is 2, 3, or 4
* [code]#marray<double, N>#, where [code]#N# is 2, 3, or 4
* [code]#vec<float, N>#, where [code]#N# is 2, 3, or 4
* [code]#vec<double, N>#, where [code]#N# is 2, 3, or 4
* [code]#+__swizzled_vec__+# that is convertible to [code]#vec<float, N>#,
  where [code]#N# is 2, 3, or 4
* [code]#+__swizzled_vec__+# that is convertible to [code]#vec<double, N>#,
  where [code]#N# is 2, 3, or 4

The term _float geometric type_ represents these types:

* [code]#float#
* [code]#marray<float, N>#, where [code]#N# is 2, 3, or 4
* [code]#vec<float, N>#, where [code]#N# is 2, 3, or 4
* [code]#+__swizzled_vec__+# that is convertible to [code]#vec<float, N>#,
  where [code]#N# is 2, 3, or 4

[[table.geometric.functions]]
.Geometric functions
[separator="@"]
|====
a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename Geo3or4Float1, typename Geo3or4Float2>
/*return-type*/ cross(Geo3or4Float1 p0, Geo3or4Float2 p1)
----
!====

_Constraints:_ Available only if all of the following conditions are met:

* [code]#Geo3or4Float1# is one of the following types:
** [code]#marray<float, 3>#
** [code]#marray<double, 3>#
** [code]#marray<float, 4>#
** [code]#marray<double, 4>#
** [code]#vec<float, 3>#
** [code]#vec<double, 3>#
** [code]#vec<float, 4>#
** [code]#vec<double, 4>#
** [code]#+__swizzled_vec__+# that is convertible to [code]#vec<float, 3>#
** [code]#+__swizzled_vec__+# that is convertible to [code]#vec<double, 3>#
** [code]#+__swizzled_vec__+# that is convertible to [code]#vec<float, 4>#
** [code]#+__swizzled_vec__+# that is convertible to [code]#vec<double, 4>#
* If [code]#Geo3or4Float1# is [code]#marray#, then [code]#Geo3or4Float2# must
  be the same as [code]#Geo3or4Float1#; and
* If [code]#Geo3or4Float1# is [code]#vec# or the [code]#+__swizzled_vec__+#
  type, then [code]#Geo3or4Float2# must also be [code]#vec# or the
  [code]#+__swizzled_vec__+# type, and both must have the same element type and
  the same number of elements.

_Returns:_ The cross product of first 3 components of [code]#p0# and [code]#p1#.
When the inputs have 4 components, the 4th component of the result is 0.0.

The return type is [code]#Geo3or4Float1# unless [code]#Geo3or4Float1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename GeoFloat1, typename GeoFloat2>
/*return-type*/ dot(GeoFloat1 p0, GeoFloat2 p1)
----
!====

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GeoFloat1# is a _generic geometric type_ as defined above;
* If [code]#GeoFloat1# is not [code]#vec# or the [code]#+__swizzled_vec__+#
  type, then [code]#GeoFloat2# must be the same as [code]#GeoFloat1#; and
* If [code]#GeoFloat1# is [code]#vec# or the [code]#+__swizzled_vec__+#
  type, then [code]#GeoFloat2# must also be [code]#vec# or the
  [code]#+__swizzled_vec__+# type, and both must have the same element type and
  the same number of elements.

_Returns:_ The dot product of [code]#p0# and [code]#p1#.

The return type is [code]#GeoFloat1# if the input types are scalar.  Otherwise,
the return type is [code]#GeoFloat1::value_type#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename GeoFloat1, typename GeoFloat2>
/*return-type*/ distance(GeoFloat1 p0, GeoFloat2 p1)
----
!====

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GeoFloat1# is a _generic geometric type_ as defined above;
* If [code]#GeoFloat1# is not [code]#vec# or the [code]#+__swizzled_vec__+#
  type, then [code]#GeoFloat2# must be the same as [code]#GeoFloat1#; and
* If [code]#GeoFloat1# is [code]#vec# or the [code]#+__swizzled_vec__+#
  type, then [code]#GeoFloat2# must also be [code]#vec# or the
  [code]#+__swizzled_vec__+# type, and both must have the same element type and
  the same number of elements.

_Returns:_ The distance between [code]#p0# and [code]#p1#. This is calculated
as [code]#length(p0 - p1)#.

The return type is [code]#GeoFloat1# if the input types are scalar.  Otherwise,
the return type is [code]#GeoFloat1::value_type#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename GeoFloat>
/*return-type*/ length(GeoFloat p)
----
!====

_Constraints:_ Available only if [code]#GeoFloat# is a _generic geometric type_
as defined above.

_Returns:_ The length of vector [code]#p#, i.e.,
[code]#+sqrt(pow(p[0],2) + pow(p[1],2) + ...)+#.

The return type is [code]#GeoFloat# if the input type is scalar.  Otherwise,
the return type is [code]#GeoFloat::value_type#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename GeoFloat>
/*return-type*/ normalize(GeoFloat p)
----
!====

_Constraints:_ Available only if [code]#GeoFloat# is a _generic geometric type_
as defined above.

_Returns:_ A vector in the same direction as [code]#p# but with a length of 1.

The return type is [code]#GeoFloat# unless [code]#GeoFloat# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename GeoFloat1, typename GeoFloat2>
/*return-type*/ fast_distance(GeoFloat1 p0, GeoFloat2 p1)
----
!====

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GeoFloat1# is a _float geometric type_ as defined above;
* If [code]#GeoFloat1# is not [code]#vec# or the [code]#+__swizzled_vec__+#
  type, then [code]#GeoFloat2# must be the same as [code]#GeoFloat1#; and
* If [code]#GeoFloat1# is [code]#vec# or the [code]#+__swizzled_vec__+#
  type, then [code]#GeoFloat2# must also be [code]#vec# or the
  [code]#+__swizzled_vec__+# type, and both must have the same number of
  elements.

_Returns:_ The value [code]#fast_length(p0 - p1)#.

The return type is [code]#GeoFloat1# if the input type is scalar.  Otherwise,
the return type is [code]#GeoFloat1::value_type#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename GeoFloat>
/*return-type*/ fast_length(GeoFloat p)
----
!====

_Constraints:_ Available only if [code]#GeoFloat# is a _float geometric type_
as defined above.

_Returns:_ The length of vector [code]#p# computed as:
[code]#+sqrt((half)(pow(p[0],2) + pow(p[1],2) + ...))+#.

The return type is [code]#GeoFloat# if the input type is scalar.  Otherwise,
the return type is [code]#GeoFloat::value_type#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename GeoFloat>
/*return-type*/ fast_normalize(GeoFloat p)
----
!====

_Constraints:_ Available only if [code]#GeoFloat# is a _float geometric type_
as defined above.

_Returns:_ A vector in the same direction as [code]#p# but with a length of 1
computed as [code]#+p*rsqrt((half)(pow(p[0],2) + pow(p[1],2) + ... ))+#.

The result shall be within 8192 ulps error from the infinitely precise result
of

[source]
----
if (all(p == 0.0f))
  result = p;
else
  result = p / sqrt(pow(p[0], 2) + pow(p[1], 2) + ...);
----

with the following exceptions:

--
  . If the sum of squares is greater than [code]#FLT_MAX# then the
    value of the floating-point values in the result vector are undefined.
  . If the sum of squares is less than [code]#FLT_MIN# then the
    implementation may return back [code]#p#.
  . If the device is in "`denorms are flushed to zero`" mode, individual
    operand elements with magnitude less than [code]#sqrt(FLT_MIN)# may
    be flushed to zero before proceeding with the calculation.
--

The return type is [code]#GeoFloat# unless [code]#GeoFloat# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.
|====


=== Relational functions

The functions in <<table.relational.functions>> are defined in the [code]#sycl#
namespace and are available on both host and device.  These functions perform
various relational comparisons on [code]#vec#, [code]#marray#, and scalar
types.

The comparisons performed by [code]#isequal#, [code]#isgreater#,
[code]#isgreaterequal#, [code]#isless#, [code]#islessequal#, and
[code]#islessgreater# are false when one or both operands are NaN.  The
comparison performed by [code]#isnotequal# is true when one or both operands
are NaN.

The function descriptions in this section use two terms that refer to a
specific list of types.  The term _generic scalar type_ represents the
following types:

* [code]#char#
* [code]#signed char#
* [code]#short#
* [code]#int#
* [code]#long#
* [code]#long long#
* [code]#unsigned char#
* [code]#unsigned short#
* [code]#unsigned int#
* [code]#unsigned long#
* [code]#unsigned long long#
* [code]#float#
* [code]#double#
* [code]#half#

The term _vector element type_ represents these types:

* [code]#int8_t#
* [code]#int16_t#
* [code]#int32_t#
* [code]#int64_t#
* [code]#uint8_t#
* [code]#uint16_t#
* [code]#uint32_t#
* [code]#uint64_t#
* [code]#float#
* [code]#double#
* [code]#half#

[[table.relational.functions]]
.Relational functions
[separator="@"]
|====
a@
[frame=all,grid=none]
!====
a!
[source]
----
bool isequal(float x, float y)                       (1)
bool isequal(double x, double y)                     (2)
bool isequal(half x, half y)                         (3)

template<typename NonScalar1, typename NonScalar2>   (4)
/*return-type*/ isequal(NonScalar1 x, NonScalar2 y)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value [code]#(x == y)#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzled_vec__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements
  and the same element type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ If [code]#NonScalar1# is [code]#marray#, the value
[code]#(x[i] == y[i])# for each element of [code]#x# and [code]#y#.  If
[code]#NonScalar1# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
returns the value [code]#((x[i] == y[i]) ? -1 : 0)# for each element of
[code]#x# and [code]#y#.

The return type depends on [code]#NonScalar1#:
[options="header",cols="70%,30%"]
!====
!NonScalar1 ! Return Type
![code]#marray<float, N># +
 [code]#marray<double, N># +
 [code]#marray<half, N>#
![code]#marray<bool, N>#

![code]#vec<float, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<float, N>#
![code]#vec<int32_t, N>#

![code]#vec<double, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<double, N>#
![code]#vec<int64_t, N>#

![code]#vec<half, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<half, N>#
![code]#vec<int16_t, N>#
!====

a@
[frame=all,grid=none]
!====
a!
[source]
----
bool isnotequal(float x, float y)                       (1)
bool isnotequal(double x, double y)                     (2)
bool isnotequal(half x, half y)                         (3)

template<typename NonScalar1, typename NonScalar2>      (4)
/*return-type*/ isnotequal(NonScalar1 x, NonScalar2 y)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value [code]#(x != y)#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzled_vec__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements
  and the same element type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ If [code]#NonScalar1# is [code]#marray#, the value
[code]#(x[i] != y[i])# for each element of [code]#x# and [code]#y#.
If [code]#NonScalar1# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
returns the value [code]#((x[i] != y[i]) ? -1 : 0)# for each element of
[code]#x# and [code]#y#.

The return type depends on [code]#NonScalar1#:
[options="header",cols="70%,30%"]
!====
!NonScalar1 ! Return Type
![code]#marray<float, N># +
 [code]#marray<double, N># +
 [code]#marray<half, N>#
![code]#marray<bool, N>#

![code]#vec<float, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<float, N>#
![code]#vec<int32_t, N>#

![code]#vec<double, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<double, N>#
![code]#vec<int64_t, N>#

![code]#vec<half, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<half, N>#
![code]#vec<int16_t, N>#
!====

a@
[frame=all,grid=none]
!====
a!
[source]
----
bool isgreater(float x, float y)                       (1)
bool isgreater(double x, double y)                     (2)
bool isgreater(half x, half y)                         (3)

template<typename NonScalar1, typename NonScalar2>     (4)
/*return-type*/ isgreater(NonScalar1 x, NonScalar2 y)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value [code]#(x > y)#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzled_vec__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements
  and the same element type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ If [code]#NonScalar1# is [code]#marray#, the value
[code]#(x[i] > y[i])# for each element of [code]#x# and [code]#y#.  If
[code]#NonScalar1# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
returns the value [code]#((x[i] > y[i]) ? -1 : 0)# for each element
of [code]#x# and [code]#y#.

The return type depends on [code]#NonScalar1#:
[options="header",cols="70%,30%"]
!====
!NonScalar1 ! Return Type
![code]#marray<float, N># +
 [code]#marray<double, N># +
 [code]#marray<half, N>#
![code]#marray<bool, N>#

![code]#vec<float, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<float, N>#
![code]#vec<int32_t, N>#

![code]#vec<double, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<double, N>#
![code]#vec<int64_t, N>#

![code]#vec<half, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<half, N>#
![code]#vec<int16_t, N>#
!====

a@
[frame=all,grid=none]
!====
a!
[source]
----
bool isgreaterequal(float x, float y)                       (1)
bool isgreaterequal(double x, double y)                     (2)
bool isgreaterequal(half x, half y)                         (3)

template<typename NonScalar1, typename NonScalar2>          (4)
/*return-type*/ isgreaterequal(NonScalar1 x, NonScalar2 y)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value [code]#(x >= y)#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzled_vec__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements
  and the same element type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ If [code]#NonScalar1# is [code]#marray#, the value
[code]#(x[i] >= y[i])# for each element of [code]#x# and [code]#y#.  If
[code]#NonScalar1# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
returns the value [code]#((x[i] >= y[i]) ? -1 : 0)# for each element of
[code]#x# and [code]#y#.

The return type depends on [code]#NonScalar1#:
[options="header",cols="70%,30%"]
!====
!NonScalar1 ! Return Type
![code]#marray<float, N># +
 [code]#marray<double, N># +
 [code]#marray<half, N>#
![code]#marray<bool, N>#

![code]#vec<float, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<float, N>#
![code]#vec<int32_t, N>#

![code]#vec<double, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<double, N>#
![code]#vec<int64_t, N>#

![code]#vec<half, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<half, N>#
![code]#vec<int16_t, N>#
!====

a@
[frame=all,grid=none]
!====
a!
[source]
----
bool isless(float x, float y)                       (1)
bool isless(double x, double y)                     (2)
bool isless(half x, half y)                         (3)

template<typename NonScalar1, typename NonScalar2>  (4)
/*return-type*/ isless(NonScalar1 x, NonScalar2 y)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value [code]#(x < y)#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzled_vec__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements
  and the same element type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ If [code]#NonScalar1# is [code]#marray#, the value
[code]#(x[i] < y[i])# for each element of [code]#x# and [code]#y#.  If
[code]#NonScalar1# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
returns the value [code]#((x[i] < y[i]) ? -1 : 0)# for each element of
[code]#x# and [code]#y#.

The return type depends on [code]#NonScalar1#:
[options="header",cols="70%,30%"]
!====
!NonScalar1 ! Return Type
![code]#marray<float, N># +
 [code]#marray<double, N># +
 [code]#marray<half, N>#
![code]#marray<bool, N>#

![code]#vec<float, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<float, N>#
![code]#vec<int32_t, N>#

![code]#vec<double, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<double, N>#
![code]#vec<int64_t, N>#

![code]#vec<half, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<half, N>#
![code]#vec<int16_t, N>#
!====

a@
[frame=all,grid=none]
!====
a!
[source]
----
bool islessequal(float x, float y)                       (1)
bool islessequal(double x, double y)                     (2)
bool islessequal(half x, half y)                         (3)

template<typename NonScalar1, typename NonScalar2>       (4)
/*return-type*/ islessequal(NonScalar1 x, NonScalar2 y)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value [code]#+(x <= y)+#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzled_vec__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements
  and the same element type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ If [code]#NonScalar1# is [code]#marray#, the value
[code]#+(x[i] <= y[i])+# for each element of [code]#x# and [code]#y#.  If
[code]#NonScalar1# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
returns the value [code]#+((x[i] <= y[i]) ? -1 : 0)+# for each element of
[code]#x# and [code]#y#.

The return type depends on [code]#NonScalar1#:
[options="header",cols="70%,30%"]
!====
!NonScalar1 ! Return Type
![code]#marray<float, N># +
 [code]#marray<double, N># +
 [code]#marray<half, N>#
![code]#marray<bool, N>#

![code]#vec<float, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<float, N>#
![code]#vec<int32_t, N>#

![code]#vec<double, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<double, N>#
![code]#vec<int64_t, N>#

![code]#vec<half, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<half, N>#
![code]#vec<int16_t, N>#
!====

a@
[frame=all,grid=none]
!====
a!
[source]
----
bool islessgreater(float x, float y)                       (1)
bool islessgreater(double x, double y)                     (2)
bool islessgreater(half x, half y)                         (3)

template<typename NonScalar1, typename NonScalar2>         (4)
/*return-type*/ islessgreater(NonScalar1 x, NonScalar2 y)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value [code]#(x < y) || (x > y)#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzled_vec__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements
  and the same element type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ If [code]#NonScalar1# is [code]#marray#, the value
[code]#(x[i] < y[i] || x[i] > y[i])# for each element of [code]#x# and
[code]#y#.  If [code]#NonScalar1# is [code]#vec# or the
[code]#+__swizzled_vec__+# type, returns the value
[code]#((x[i] < y[i] || x[i] > y[i]) ? -1 : 0)# for each element of [code]#x#
and [code]#y#.

The return type depends on [code]#NonScalar1#:
[options="header",cols="70%,30%"]
!====
!NonScalar1 ! Return Type
![code]#marray<float, N># +
 [code]#marray<double, N># +
 [code]#marray<half, N>#
![code]#marray<bool, N>#

![code]#vec<float, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<float, N>#
![code]#vec<int32_t, N>#

![code]#vec<double, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<double, N>#
![code]#vec<int64_t, N>#

![code]#vec<half, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<half, N>#
![code]#vec<int16_t, N>#
!====

a@
[frame=all,grid=none]
!====
a!
[source]
----
bool isfinite(float x)                 (1)
bool isfinite(double x)                (2)
bool isfinite(half x)                  (3)

template<typename NonScalar>           (4)
/*return-type*/ isfinite(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value [code]#true# only if [code]#x# has finite value.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ If [code]#NonScalar# is [code]#marray#, returns true for each
element of [code]#x# only if [code]#x[i]# is a finite value.  If
[code]#NonScalar# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
returns -1 for each element of [code]#x# if [code]#x[i]# is a finite value and
returns 0 otherwise.

The return type depends on [code]#NonScalar#:
[options="header",cols="70%,30%"]
!====
!NonScalar ! Return Type
![code]#marray<float, N># +
 [code]#marray<double, N># +
 [code]#marray<half, N>#
![code]#marray<bool, N>#

![code]#vec<float, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<float, N>#
![code]#vec<int32_t, N>#

![code]#vec<double, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<double, N>#
![code]#vec<int64_t, N>#

![code]#vec<half, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<half, N>#
![code]#vec<int16_t, N>#
!====

a@
[frame=all,grid=none]
!====
a!
[source]
----
bool isinf(float x)                 (1)
bool isinf(double x)                (2)
bool isinf(half x)                  (3)

template<typename NonScalar>        (4)
/*return-type*/ isinf(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value [code]#true# only if [code]#x# has an infinity value
(either positive or negative).

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ If [code]#NonScalar# is [code]#marray#, returns true for each
element of [code]#x# only if [code]#x[i]# has an infinity value.  If
[code]#NonScalar# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
returns -1 for each element of [code]#x# if [code]#x[i]# has an infinity
value and returns 0 otherwise.

The return type depends on [code]#NonScalar#:
[options="header",cols="70%,30%"]
!====
!NonScalar ! Return Type
![code]#marray<float, N># +
 [code]#marray<double, N># +
 [code]#marray<half, N>#
![code]#marray<bool, N>#

![code]#vec<float, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<float, N>#
![code]#vec<int32_t, N>#

![code]#vec<double, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<double, N>#
![code]#vec<int64_t, N>#

![code]#vec<half, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<half, N>#
![code]#vec<int16_t, N>#
!====

a@
[frame=all,grid=none]
!====
a!
[source]
----
bool isnan(float x)                 (1)
bool isnan(double x)                (2)
bool isnan(half x)                  (3)

template<typename NonScalar>        (4)
/*return-type*/ isnan(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value [code]#true# only if [code]#x# has a NaN value.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ If [code]#NonScalar# is [code]#marray#, returns true for each
element of [code]#x# only if [code]#x[i]# has a NaN value.  If
[code]#NonScalar# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
returns -1 for each element of [code]#x# if [code]#x[i]# has a NaN value and
returns 0 otherwise.

The return type depends on [code]#NonScalar#:
[options="header",cols="70%,30%"]
!====
!NonScalar ! Return Type
![code]#marray<float, N># +
 [code]#marray<double, N># +
 [code]#marray<half, N>#
![code]#marray<bool, N>#

![code]#vec<float, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<float, N>#
![code]#vec<int32_t, N>#

![code]#vec<double, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<double, N>#
![code]#vec<int64_t, N>#

![code]#vec<half, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<half, N>#
![code]#vec<int16_t, N>#
!====

a@
[frame=all,grid=none]
!====
a!
[source]
----
bool isnormal(float x)                 (1)
bool isnormal(double x)                (2)
bool isnormal(half x)                  (3)

template<typename NonScalar>           (4)
/*return-type*/ isnormal(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value [code]#true# only if [code]#x# has a normal value.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ If [code]#NonScalar# is [code]#marray#, returns true for each
element of [code]#x# only if [code]#x[i]# has a normal value.  If
[code]#NonScalar# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
returns -1 for each element of [code]#x# if [code]#x[i]# has a normal value and
returns 0 otherwise.

The return type depends on [code]#NonScalar#:
[options="header",cols="70%,30%"]
!====
!NonScalar ! Return Type
![code]#marray<float, N># +
 [code]#marray<double, N># +
 [code]#marray<half, N>#
![code]#marray<bool, N>#

![code]#vec<float, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<float, N>#
![code]#vec<int32_t, N>#

![code]#vec<double, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<double, N>#
![code]#vec<int64_t, N>#

![code]#vec<half, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<half, N>#
![code]#vec<int16_t, N>#
!====

a@
[frame=all,grid=none]
!====
a!
[source]
----
bool isordered(float x, float y)                       (1)
bool isordered(double x, double y)                     (2)
bool isordered(half x, half y)                         (3)

template<typename NonScalar1, typename NonScalar2>     (4)
/*return-type*/ isordered(NonScalar1 x, NonScalar2 y)
----
!====

*Overloads (1) - (3):*

_Effects:_ Tests if [code]#x# and [code]#y# are ordered.

_Returns:_ The value [code]#isequal(x, x) && isequal(y, y)#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzled_vec__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements
  and the same element type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Effects:_ Tests if each element of [code]#x# and [code]#y# are ordered.

_Returns:_ If [code]#NonScalar1# is [code]#marray#, the value
[code]#isequal(x[i], x[i]) && isequal(y[i], y[i])# for each element of
[code]#x# and [code]#y#.  If [code]#NonScalar1# is [code]#vec# or the
[code]#+__swizzled_vec__+# type, returns the value
[code]#((isequal(x[i], x[i]) && isequal(y[i], y[i]) ? -1 : 0)# for each element
of [code]#x# and [code]#y#.

The return type depends on [code]#NonScalar1#:
[options="header",cols="70%,30%"]
!====
!NonScalar1 ! Return Type
![code]#marray<float, N># +
 [code]#marray<double, N># +
 [code]#marray<half, N>#
![code]#marray<bool, N>#

![code]#vec<float, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<float, N>#
![code]#vec<int32_t, N>#

![code]#vec<double, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<double, N>#
![code]#vec<int64_t, N>#

![code]#vec<half, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<half, N>#
![code]#vec<int16_t, N>#
!====

a@
[frame=all,grid=none]
!====
a!
[source]
----
bool isunordered(float x, float y)                       (1)
bool isunordered(double x, double y)                     (2)
bool isunordered(half x, half y)                         (3)

template<typename NonScalar1, typename NonScalar2>       (4)
/*return-type*/ isunordered(NonScalar1 x, NonScalar2 y)
----
!====

*Overloads (1) - (3):*

_Effects:_ Tests if [code]#x# and [code]#y# are unordered.

_Returns:_ The value [code]#isnan(x) || isnan(y)#.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* One of the following conditions must hold for [code]#NonScalar1# and
  [code]#NonScalar2#:
** Both [code]#NonScalar1# and [code]#NonScalar2# are [code]#marray#; or
** [code]#NonScalar1# and [code]#NonScalar2# are any combination of [code]#vec#
   and the [code]#+__swizzled_vec__+# type;
* [code]#NonScalar1# and [code]#NonScalar2# have the same number of elements
  and the same element type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Effects:_ Tests if each element of [code]#x# and [code]#y# are unordered.

_Returns:_ If [code]#NonScalar1# is [code]#marray#, the value
[code]#isnan(x[i]) || isnan(y[i])# for each element of [code]#x# and [code]#y#.
If [code]#NonScalar1# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
returns the value [code]#((isnan(x[i]) || isnan(y[i]) ? -1 : 0)# for each
element of [code]#x# and [code]#y#.

The return type depends on [code]#NonScalar1#:
[options="header",cols="70%,30%"]
!====
!NonScalar1 ! Return Type
![code]#marray<float, N># +
 [code]#marray<double, N># +
 [code]#marray<half, N>#
![code]#marray<bool, N>#

![code]#vec<float, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<float, N>#
![code]#vec<int32_t, N>#

![code]#vec<double, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<double, N>#
![code]#vec<int64_t, N>#

![code]#vec<half, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<half, N>#
![code]#vec<int16_t, N>#
!====

a@
[frame=all,grid=none]
!====
a!
[source]
----
bool signbit(float x)                 (1)
bool signbit(double x)                (2)
bool signbit(half x)                  (3)

template<typename NonScalar>          (4)
/*return-type*/ signbit(NonScalar x)
----
!====

*Overloads (1) - (3):*

_Returns:_ The value [code]#true# only if the sign bit of [code]#x# is set.

*Overload (4):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar# is [code]#marray#, [code]#vec#, or the
  [code]#+__swizzled_vec__+# type; and
* The element type is [code]#float#, [code]#double#, or [code]#half#.

_Returns:_ If [code]#NonScalar# is [code]#marray#, returns true for each
element of [code]#x# only if the sign bit of [code]#x[i]# is set.  If
[code]#NonScalar# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
returns -1 for each element of [code]#x# if the sign bit of [code]#x[i]# is set
and returns 0 otherwise.

The return type depends on [code]#NonScalar#:
[options="header",cols="70%,30%"]
!====
!NonScalar ! Return Type
![code]#marray<float, N># +
 [code]#marray<double, N># +
 [code]#marray<half, N>#
![code]#marray<bool, N>#

![code]#vec<float, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<float, N>#
![code]#vec<int32_t, N>#

![code]#vec<double, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<double, N>#
![code]#vec<int64_t, N>#

![code]#vec<half, N># +
 [code]#+__swizzled_vec__+# that is convertible to [code]#vec<half, N>#
![code]#vec<int16_t, N>#
!====

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename GenInt>
/*return-type*/ any(GenInt x)
----
!====

_Constraints:_ Available only if [code]#GenInt# is one of the following types:

* [code]#signed char#
* [code]#short#
* [code]#int#
* [code]#long#
* [code]#long long#
* [code]#marray<signed char, N>#
* [code]#marray<short, N>#
* [code]#marray<int, N>#
* [code]#marray<long, N>#
* [code]#marray<long long, N>#
* [code]#vec<int8_t, N>#
* [code]#vec<int16_t, N>#
* [code]#vec<int32_t, N>#
* [code]#vec<int64_t, N>#
* [code]#+__swizzled_vec__+# that is convertible to [code]#vec<int8_t, N>#
* [code]#+__swizzled_vec__+# that is convertible to [code]#vec<int16_t, N>#
* [code]#+__swizzled_vec__+# that is convertible to [code]#vec<int32_t, N>#
* [code]#+__swizzled_vec__+# that is convertible to [code]#vec<int64_t, N>#

_Returns:_ When [code]#x# is a scalar, returns a Boolean telling whether the
most significant bit of [code]#x# is set.  When [code]#x# is [code]#marray#,
returns a Boolean telling whether the most significant bit of any element
in [code]#x# is set.  When [code]#x# is [code]#vec# or the
[code]#+__swizzled_vec__+# type, returns the value 1 if any element in
[code]#x# has its most significant bit set, otherwise returns the value 0.

The return type is [code]#bool# if [code]#GenInt# is a scalar or
[code]#marray#.  Otherwise, the return type is [code]#int#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename GenInt>
/*return-type*/ all(GenInt x)
----
!====

_Constraints:_ Available only if [code]#GenInt# is one of the following types:

* [code]#signed char#
* [code]#short#
* [code]#int#
* [code]#long#
* [code]#long long#
* [code]#marray<signed char, N>#
* [code]#marray<short, N>#
* [code]#marray<int, N>#
* [code]#marray<long, N>#
* [code]#marray<long long, N>#
* [code]#vec<int8_t, N>#
* [code]#vec<int16_t, N>#
* [code]#vec<int32_t, N>#
* [code]#vec<int64_t, N>#
* [code]#+__swizzled_vec__+# that is convertible to [code]#vec<int8_t, N>#
* [code]#+__swizzled_vec__+# that is convertible to [code]#vec<int16_t, N>#
* [code]#+__swizzled_vec__+# that is convertible to [code]#vec<int32_t, N>#
* [code]#+__swizzled_vec__+# that is convertible to [code]#vec<int64_t, N>#

_Returns:_ When [code]#x# is a scalar, returns a Boolean telling whether the
most significant bit of [code]#x# is set.  When [code]#x# is [code]#marray#,
returns a Boolean telling whether the most significant bit of all elements
in [code]#x# are set.  When [code]#x# is [code]#vec# or the
[code]#+__swizzled_vec__+# type, returns the value 1 if all elements in
[code]#x# have their most significant bit set, otherwise returns the value 0.

The return type is [code]#bool# if [code]#GenInt# is a scalar or
[code]#marray#.  Otherwise, the return type is [code]#int#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename GenType1, typename GenType2, typename GenType3>
/*return-type*/ bitselect(GenType1 a, GenType2 b, GenType3 c)
----
!====

_Constraints:_ Available only if all of the following conditions are met:

* [code]#GenType1# is one of the following types:
** One of the _generic scalar types_ as defined above;
** [code]#marray<T, N>#, where [code]#T# is one of the _generic scalar types_;
** [code]#vec<T, N>#, where [code]#T# is one of the _vector element types_ as
   defined above; or
** [code]#+__swizzled_vec__+# that is convertible to [code]#vec<T, N>#, where
   [code]#T# is one of the _vector element types_;
* If [code]#GenType1# is not [code]#vec# or the [code]#+__swizzled_vec__+#
  type, then [code]#GenType2# and [code]#GenType3# must be the same as
  [code]#GenType1#; and
* If [code]#GenType1# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
  then [code]#GenType2# and [code]#GenType3# must also be [code]#vec# or the
  [code]#+__swizzled_vec__+# type, and all three must have the same element
  type and the same number of elements.

_Returns:_ When the input parameters are scalars, returns a result where each
bit of the result is the corresponding bit of [code]#a# if the corresponding
bit of [code]#c# is 0.  Otherwise it is the corresponding bit of [code]#b#.

When the input parameters are not scalars, returns a result for each element
where each bit of the result for element [code]#i# is the corresponding bit of
[code]#a[i]# if the corresponding bit of [code]#c[i]# is 0.  Otherwise it is
the corresponding bit of [code]#b[i]#.

The return type is [code]#GenType1# unless [code]#GenType1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.

a@
[frame=all,grid=none]
!====
a!
[source]
----
template<typename Scalar>                                                (1)
Scalar select(Scalar a, Scalar b, bool c)

template<typename NonScalar1, typename NonScalar2, typename NonScalar3>  (2)
/*return-type*/ select(NonScalar1 a, NonScalar2 b, NonScalar3 c)
----
!====

*Overload (1):*

_Constraints:_ Available only if [code]#Scalar# is one of the _generic scalar
types_ as defined above.

_Returns:_ The value [code]#(c ? b : a)#.

*Overload (2):*

_Constraints:_ Available only if all of the following conditions are met:

* [code]#NonScalar1# is one of the following types:
** [code]#marray<T, N>#, where [code]#T# is one of the _generic scalar types_
   as defined above;
** [code]#vec<T, N>#, where [code]#T# is one of the _vector element types_
   as defined above; or
** [code]#+__swizzled_vec__+# that is convertible to [code]#vec<T, N>#, where
   [code]#T# is one of the _vector element types_;
* If [code]#NonScalar1# is [code]#marray#, then:
** [code]#NonScalar2# must be the same as [code]#NonScalar1#; and
** [code]#NonScalar3# must be [code]#marray# with element type [code]#bool#
   and the same number of elements as [code]#NonScalar1#;
* If [code]#NonScalar1# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
  then:
** [code]#NonScalar2# must also be [code]#vec# or the
   [code]#+__swizzled_vec__+# type, and both must have the same element type
   and the same number of elements; and
** [code]#NonScalar3# must be [code]#vec# or the [code]#+__swizzled_vec__+#
   type with the same number of elements as [code]#NonScalar1#.  The element
   type of [code]#NonScalar3# must be a signed or unsigned integer with the
   same number of bits as the element type of [code]#NonScalar1#.

_Returns:_ If [code]#NonScalar1# is [code]#marray#, return the value
[code]#(c[i] ? b[i] : a[i])# for each element of [code]#a#, [code]#b#, and
[code]#c#.

If [code]#NonScalar1# is [code]#vec# or the [code]#+__swizzled_vec__+# type,
returns the value [code]#((MSB of c[i] is set) ? b[i] : a[i])# for each element
of [code]#a#, [code]#b#, and [code]#c#.

The return type is [code]#NonScalar1# unless [code]#NonScalar1# is the
[code]#+__swizzled_vec__+# type, in which case the return type is the
corresponding [code]#vec#.
|====

// %%%%%%%%%%%%%%%%%%%%%%%%%%%% end builtin_functions %%%%%%%%%%%%%%%%%%%%%%%%%%%%


// %%%%%%%%%%%%%%%%%%%%%%%%%%%% end programming_interface %%%%%%%%%%%%%%%%%%%%%%%%%%%%
