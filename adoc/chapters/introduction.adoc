// %%%%%%%%%%%%%%%%%%%%%%%%%%%% begin introduction %%%%%%%%%%%%%%%%%%%%%%%%%%%%

[[introduction]]
= Introduction

// What is SYCL?
SYCL (pronounced "`sickle`") is a royalty-free, cross-platform API for
heterogeneous computing in {cpp}.

SYCL enables developers to write standard {cpp} code that executes on a wide
range of devices, using modern techniques such as inheritance, templates, and
lambda functions.
All computational kernels to be executed on a device can be written inside {cpp}
source files as normal {cpp} code, alongside any code intended to be run on a
system's host processor.
This concept, known as "`single-source`" programming, reduces the complexity of
heterogeneous programming for developers and gives compilers greater
opportunities to analyze/optimize across the host-device boundary.

// How does SYCL relate to C++?
SYCL is designed to be as close to standard {cpp} as possible, and some
implementations of SYCL may be able to use a standard {cpp} compiler to target
CPU devices.
However, to ensure portability of device code across a wide range of devices,
SYCL imposes some restrictions on the set of {cpp} features that SYCL
implementations are required to support within device code.
These restrictions may not be applicable to all devices and can therefore be
relaxed by specific Khronos extensions or vendor extensions.

// How does SYCL relate to lower-level APIs?
SYCL was originally based on OpenCL, and retains an execution model, runtime
feature set, and device capability set inspired by the OpenCL standard.
However, there is no requirement that SYCL implementations must use OpenCL; SYCL
implementations are free to support devices via any low-level API (or
"`backend`") they choose.

// What are some key features of SYCL?
Some of the key features of SYCL are:

  * Common parallel patterns, such as <<sec:reduction, reductions>> and
    <<sec:algorithms, group algorithms>>, are exposed via high-level
    abstractions.

  * Interoperability with the lower-level capabilities of specific
    <<sec:backends, backends>> guarantees access to platform-specific
    optimizations.

  * <<subsec:buffers, Buffers>> and <<subsec:accessors, accessors>> provide a
    simple way to build task-graphs without manually managing dependencies.

  * <<sec:usm, Unified Shared Memory>> (USM) provides an explicit,
    pointer-based, mechanism for managing and sharing data.

// How would you summarize SYCL?
SYCL has been designed to enable implementations on a wide variety of platforms,
permitting easy integration with other platform-specific technologies.
Both users and implementers are encouraged to build upon SYCL as an open
platform for system-wide heterogeneous programming.

// %%%%%%%%%%%%%%%%%%%%%%%%%%%% end introduction %%%%%%%%%%%%%%%%%%%%%%%%%%%%
