%!TEX root = sycl-1.2.1.tex
%***********************************************************************************
% Expressing parallelism through kernels
%***********************************************************************************
%\section{Expressing parallelism through kernels}

%***********************************************************************************
% Ranges and index space identifiers
%***********************************************************************************

\subsection{Ranges and index space identifiers}
\label{ranges-identifiers}

The data parallelism of the OpenCL execution model and its exposure
through SYCL requires instantiation of a parallel execution over a
range of iteration space coordinates. To achieve this we expose types
to define the range of execution and to identify a given execution
instance's point in the iteration space.

To achieve this we expose seven types: \codeinline{range},
\codeinline{nd_range}, \codeinline{id}, \codeinline{item}, \codeinline{h_item},
\codeinline{nd_item} and \codeinline{group}.

When constructing ids or ranges from integers, the elements are
written in row-major format.

%-------------------------------------------------------------------------------
\startTable{Type}
\addFootNotes{Summary of types used to identify points in an index space, and ranges over which those points can vary}
{table.id.summary}
  \addRow {id} {A point within a range}
  \addRow {range} {Bounds over which an \codeinline{id} may vary}
  \addRow {item} {Pairing of an \codeinline{id} (specific point) and the \codeinline{range} that it is bounded by}
  \addRow {nd_range} {Encapsules both global and local (work-group size) \mbox{\codeinline{range}s} over which work-item \mbox{\codeinline{id}s} will vary}
  \addRow {nd_item} {Encapsulates two \mbox{\codeinline{item}s}, one for global \codeinline{id} and \codeinline{range}, and one for local \codeinline{id} and \codeinline{range}}
  \addRow {h_item} {Index point queries within hierarchical parallelism (\codeinline{parallel_for_work_item}).  Encapsulates physical global and local \mbox{\codeinline{id}s} and \mbox{\codeinline{range}s}, as well as a logical local \codeinline{id} and \codeinline{range} defined by hierarchical parallelism}
  \addRow {group} {Work-group queries within hierarchical parallelism (\codeinline{parallel_for_work_group}), and exposes the \codeinline{parallel_for_work_item} construct that identifies code to be executed by each work-item.  Encapsulates work-group \mbox{\codeinline{id}s} and \mbox{\codeinline{range}s}}
\completeTable
%-------------------------------------------------------------------------------

%*******************************************************************************
% Range class
%*******************************************************************************

\subsubsection{\texttt{range} class}
\label{range-class}

\tclass{range}{\tf{int} dimensions} is a 1D, 2D or 3D vector that defines
the iteration domain of either a single work-group in a parallel
dispatch, or the overall dimensions of the dispatch. It can be
constructed from integers.

The SYCL \codeinline{range} class template provides the common by-value
semantics (see Section~\ref{sec:byval-semantics}).

A synopsis of the SYCL \codeinline{range} class is provided below. The constructors, member functions and non-member functions of the SYCL \codeinline{range} class are listed in Tables~\ref{table.constructors.id}, \ref{table.members.range} and \ref{table.functions.range} respectively. The additional common special member functions and common member functions are listed in \ref{sec:byval-semantics} in Tables~\ref{table.specialmembers.common.byval} and \ref{table.members.common.byval} respectively.

\lstinputlisting{headers/range.h}

%-------------------------------------------------------------------------------
\startTable{Constructor}
\addFootNotes{Constructors of the \codeinline{range} class template}
{table.constructors.range}
  \addRow
    {range(size_t dim0)}
    {
        Construct a 1D range with value dim0.
        Only valid when the template parameter \codeinline{dimensions} is equal
          to 1.
    }
  \addRow
    {range(size_t dim0, size_t dim1)}
    {
        Construct a 2D range with values dim0 and dim1.
        Only valid when the template parameter \codeinline{dimensions} is equal
        to 2.
    }
  \addRow
    {range(size_t dim0, size_t dim1, size_t dim2)}
    {
        Construct a 3D range with values dim0, dim1 and dim2.
        Only valid when the template parameter \codeinline{dimensions} is equal
  to 3.
    }
\completeTable
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\startTable{Member function}
\addFootNotes{Member functions of the \codeinline{range} class
  template}
{table.members.range}
  \addRow
    {size_t get(int dimension) const}
    {
        Return the value of the specified dimension of the
        \codeinline{range}.
    }
  \addRow
    {size_t \&operator[](int dimension)}
    {
        Return the l-value of the specified dimension of the
        \codeinline{range}.
    }
  \addRow
    {size_t operator[](int dimension) const}
    {
        Return the value of the specified dimension of the
        \codeinline{range}.
    }
  \addRow
    {size_t size() const}
    {
        Return the size of the range computed as dimension0*...*dimensionN.
    }
  \addRow
    { range<dimensions> operatorOP(const range<dimensions> \&rhs) const }
    {
      Where \codeinline{OP} is: \codeinline{+}, \codeinline{-}, \codeinline{*},
      \codeinline{/}, \codeinline{\%}, \codeinline{<<}, \codeinline{>>},
      \codeinline{\&}, \codeinline{|}, \codeinline{^}, \codeinline{\&\&},
      \codeinline{||}, \codeinline{<}, \codeinline{>}, \codeinline{<=},
      \codeinline{>=}.
      \newline
      Constructs and returns a new instance of the SYCL \codeinline{range} class
      template with the same dimensionality as this SYCL \codeinline{range},
      where each element of the new SYCL \codeinline{range} instance is the
      result of an element-wise \codeinline{OP} operator between each element of
      this SYCL \codeinline{range} and each element of the \codeinline{rhs}
      \codeinline{range}. If the operator returns a \codeinline{bool} the result
      is the cast to \codeinline{size_t}.
    }
  \addRow
    { range<dimensions> operatorOP(const size_t \&rhs) const }
    {
      Where \codeinline{OP} is: \codeinline{+}, \codeinline{-}, \codeinline{*},
      \codeinline{/}, \codeinline{\%}, \codeinline{<<}, \codeinline{>>},
      \codeinline{\&}, \codeinline{|}, \codeinline{^}, \codeinline{\&\&},
      \codeinline{||}, \codeinline{<}, \codeinline{>}, \codeinline{<=},
      \codeinline{>=}.
      \newline
      Constructs and returns a new instance of the SYCL \codeinline{range} class
      template with the same dimensionality as this SYCL \codeinline{range},
      where each element of the new SYCL \codeinline{range} instance is the result
      of an element-wise \codeinline{OP} operator between each element of this
      SYCL \codeinline{range} and the \codeinline{rhs} \codeinline{size_t}. If
      the operator returns a \codeinline{bool} the result is the cast to
      \codeinline{size_t}.
    }
  \addRow
    { range<dimensions> \&operatorOP(const range<dimensions> \&rhs) }
    {
      Where \codeinline{OP} is: \codeinline{+=}, \codeinline{-=},\codeinline{
      *=}, \codeinline{/=}, \codeinline{\%=}, \codeinline{<<=}, \codeinline{
      >>=}, \codeinline{\&=}, \codeinline{|=}, \codeinline{^=}.
      \newline
      Assigns each element of this SYCL \codeinline{range} instance with the
      result of an element-wise \codeinline{OP} operator between each element
      of this SYCL \codeinline{range} and each element of the \codeinline{rhs}
      \codeinline{range} and returns a reference to this SYCL \codeinline{
      range}. If the operator returns a \codeinline{bool} the result is the cast
      to \codeinline{size_t}.
    }
  \addRow
    { range<dimensions> \&operatorOP(const size_t \&rhs) }
    {
      Where \codeinline{OP} is: \codeinline{+=}, \codeinline{-=},\codeinline{
      *=}, \codeinline{/=}, \codeinline{\%=}, \codeinline{<<=}, \codeinline{
      >>=}, \codeinline{\&=}, \codeinline{|=}, \codeinline{^=}.
      \newline
      Assigns each element of this SYCL \codeinline{range} instance with the
      result of an element-wise \codeinline{OP} operator between each element
      of this SYCL \codeinline{range} and the \codeinline{rhs} \codeinline{
      size_t} and returns a reference to this SYCL \codeinline{range}. If the
      operator returns a \codeinline{bool} the result is the cast to
      \codeinline{size_t}.
    }
\completeTable
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\startTable{Non-member function}
\addFootNotes {Non-member functions of the SYCL \codeinline{range} class
  template}{table.functions.range}
  \addRowThreeL
    { template <int dimensions> }
    { range<dimensions> operatorOP(const size_t \&lhs, }
    { const range<dimensions> \&rhs) }
    {
      Where \codeinline{OP} is: \codeinline{+}, \codeinline{-}, \codeinline{*},
      \codeinline{/}, \codeinline{\%}, \codeinline{<<}, \codeinline{>>},
      \codeinline{\&}, \codeinline{|}, \codeinline{^}.
      \newline
      Constructs and returns a new instance of the SYCL \codeinline{range} class
      template with the same dimensionality as the \codeinline{rhs} SYCL
      \codeinline{range}, where each element of the new SYCL \codeinline{range}
      instance is the result of an element-wise \codeinline{OP} operator between
      the \codeinline{lhs} \codeinline{size_t} and each element of the
      \codeinline{rhs} SYCL \codeinline{range}. If the operator returns a
      \codeinline{bool} the result is the cast to \codeinline{size_t}.
    }
\completeTable
%-------------------------------------------------------------------------------


%*******************************************************************************
% nd_range class
%*******************************************************************************
\subsubsection{\texttt{nd_range} class}
\label{subsubsec:nd-range-class}

%Interface for class: nd_range
\lstinputlisting{headers/ndRange.h}

\tclass{nd_range}{\tf{int} dimensions} defines the iteration domain of both
the work-groups and the overall dispatch. To define this the
\codeinline{nd_range} comprises two ranges: the whole range over which
the kernel is to be executed, and the range of each work
group.

The SYCL \codeinline{nd_range} class template provides the common by-value
semantics (see Section~\ref{sec:byval-semantics}).

A synopsis of the SYCL \codeinline{nd_range} class is provided below. The constructors and member functions of the SYCL \codeinline{nd_range} class are listed in Tables~\ref{table.constructors.ndrange} and \ref{table.members.ndrange} respectively. The additional common special member functions and common member functions are listed in \ref{sec:byval-semantics} in Tables~\ref{table.specialmembers.common.byval} and \ref{table.members.common.byval} respectively.

\fixme{UPDATE: change parameter naming to match interface}
%------------------------------------------------------------------------------------------------------
\startTable{Constructor}
\addFootNotes{Constructors of the \codeinline{nd_range} class}{table.constructors.ndrange}
  \addRowFourL
    {nd_range<dimensions>(}
    {  range<dimensions> globalSize,}
    {  range<dimensions> localSize)}
    {  id<dimensions> offset = id<dimensions>())}
    {
        Construct an \codeinline{nd_range} from the local and global
        constituent ranges as well as an optional offset. If the
        offset is not provided it will default to no offset.
    }
  \completeTable
%------------------------------------------------------------------------------------------------------

%------------------------------------------------------------------------------------------------------
\startTable{Member function}
  \addFootNotes{Member functions for the \codeinline{nd_range} class}
  {table.members.ndrange}

  \addRow
    {range<dimensions> get_global_range() const}
    {
        Return the constituent global range.
    }
  \addRow
    {range<dimensions> get_local_range() const}
    {
        Return the constituent local range.
    }
  \addRow
    {range<dimensions> get_group_range() const}
    {
        Return a range representing the number of groups in each
        dimension.  This range would result from
        \codeinline{globalSize/localSize} as provided on construction.
    }
  \addRow
    {id<dimensions> get_offset() const}
    {
        Return the constituent offset.
    }
 \completeTable
%-------------------------------------------------------------------------------

%*******************************************************************************
% id class
%*******************************************************************************
\subsubsection{\texttt{id} class}
\label{id-class}

\tclass{id}{\tf{int} dimensions} is a vector of dimensions that is used to
represent an \gls{id} into a global or local
\codeinline{range}. It can be used as an index in an accessor of the
same rank. The \tf{[n]} operator returns the component \tf{n} as an
\tf{size_t}.

The SYCL \codeinline{id} class template provides the common by-value semantics
(see Section~\ref{sec:byval-semantics}).

A synopsis of the SYCL \codeinline{id} class is provided below. The constructors, member functions and non-member functions of the SYCL \codeinline{id} class are listed in Tables~\ref{table.constructors.id}, \ref{table.members.id} and \ref{table.functions.id} respectively. The additional common special member functions and common member functions are listed in \ref{sec:byval-semantics} in Tables~\ref{table.specialmembers.common.byval} and \ref{table.members.common.byval} respectively.

\lstinputlisting{headers/id.h}

\fixme{UPDATE: remove un-needed templates in the table, for consistency with
tables of other classes. No actual interface change.}
%-------------------------------------------------------------------------------
\startTable{Constructor}
\addFootNotes{Constructors of the \codeinline{id} class template}
{table.constructors.id}
  \addRow
    {id()}
    {
        Construct a SYCL \codeinline{id} with the value \codeinline{0} for each dimension.
    }
  \addRow
    {id(size_t dim0)}
    {
        Construct a 1D \codeinline{id} with value dim0.
        Only valid when the template parameter \codeinline{dimensions} is equal
        to 1.
    }
  \addRow
    {id(size_t dim0, size_t dim1)}
    {
        Construct a 2D \codeinline{id} with values dim0, dim1.
        Only valid when the template parameter \codeinline{dimensions} is equal
  to 2.
    }
  \addRow
    {id(size_t dim0, size_t dim1, size_t dim2)}
    {
        Construct a 3D \codeinline{id} with values dim0, dim1, dim2. 
        Only valid when the template parameter \codeinline{dimensions} is equal
  to 3.
    }
  \addRow
    {id(const range<dimensions> \&range)}
    {
        Construct an \codeinline{id} from the dimensions of \codeinline{r}.
    }
  \addRow
    {id(const item<dimensions> \&item)}
    {
        Construct an \codeinline{id} from \codeinline{item.get_id()}.
    }
\completeTable
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\startTable{Member function}
\addFootNotes{Member functions of the \codeinline{id} class template}
{table.members.id}
  \addRow
    {size_t get(int dimension) const}
    {
        Return the value of the \codeinline{id} for dimension
        \codeinline{dimension}.
    }
  \addRow
    {size_t \&operator[](int dimension)}
    {
        Return a reference to the requested dimension of the \codeinline{id}
        object.
    }
  \addRow
    {size_t operator[](int dimension) const}
    {
        Return the value of the requested dimension of the \codeinline{id}
        object.
    }
  \addRow
    { id<dimensions> operatorOP(const id<dimensions> \&rhs) const }
    {
      Where \codeinline{OP} is: \codeinline{+}, \codeinline{-}, \codeinline{*},
      \codeinline{/}, \codeinline{\%}, \codeinline{<<}, \codeinline{>>},
      \codeinline{\&}, \codeinline{|}, \codeinline{^}, \codeinline{\&\&},
      \codeinline{||}, \codeinline{<}, \codeinline{>}, \codeinline{<=},
      \codeinline{>=}.
      \newline
      Constructs and returns a new instance of the SYCL \codeinline{id} class
      template with the same dimensionality as this SYCL \codeinline{id}, where
      each element of the new SYCL \codeinline{id} instance is the result of an
      element-wise \codeinline{OP} operator between each element of this SYCL
      \codeinline{id} and each element of the \codeinline{rhs} \codeinline{id}.
      If the operator returns a \codeinline{bool} the result is the cast to
      \codeinline{size_t}.
    }
  \addRow
    { id<dimensions> operatorOP(const size_t \&rhs) const }
    {
      Where \codeinline{OP} is: \codeinline{+}, \codeinline{-}, \codeinline{*},
      \codeinline{/}, \codeinline{\%}, \codeinline{<<}, \codeinline{>>},
      \codeinline{\&}, \codeinline{|}, \codeinline{^}, \codeinline{\&\&},
      \codeinline{||}, \codeinline{<}, \codeinline{>}, \codeinline{<=},
      \codeinline{>=}.
      \newline
      Constructs and returns a new instance of the SYCL \codeinline{id} class
      template with the same dimensionality as this SYCL \codeinline{id}, where
      each element of the new SYCL \codeinline{id} instance is the result of an
      element-wise \codeinline{OP} operator between each element of this SYCL
      \codeinline{id} and the \codeinline{rhs} \codeinline{size_t}. If the
      operator returns a \codeinline{bool} the result is the cast to
      \codeinline{size_t}.
    }
  \addRow
    { id<dimensions> \&operatorOP(const id<dimensions> \&rhs) }
    {
      Where \codeinline{OP} is: \codeinline{+=}, \codeinline{-=},\codeinline{
      *=}, \codeinline{/=}, \codeinline{\%=}, \codeinline{<<=}, \codeinline{
      >>=}, \codeinline{\&=}, \codeinline{|=}, \codeinline{^=}.
      \newline
      Assigns each element of this SYCL \codeinline{id} instance with the
      result of an element-wise \codeinline{OP} operator between each element
      of this SYCL \codeinline{id} and each element of the \codeinline{rhs}
      \codeinline{id} and returns a reference to this SYCL \codeinline{id}. If
      the operator returns a \codeinline{bool} the result is the cast to
      \codeinline{size_t}.
    }
  \addRow
    { id<dimensions> \&operatorOP(const size_t \&rhs) }
    {
      Where \codeinline{OP} is: \codeinline{+=}, \codeinline{-=},\codeinline{
      *=}, \codeinline{/=}, \codeinline{\%=}, \codeinline{<<=}, \codeinline{
      >>=}, \codeinline{\&=}, \codeinline{|=}, \codeinline{^=}.
      \newline
      Assigns each element of this SYCL \codeinline{id} instance with the
      result of an element-wise \codeinline{OP} operator between each element
      of this SYCL \codeinline{id} and the \codeinline{rhs} \codeinline{size_t}
      and returns a reference to this SYCL \codeinline{id}. If the operator
      returns a \codeinline{bool} the result is the cast to \codeinline{size_t}.
    }
\completeTable
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\startTable{Non-member function}
\addFootNotes{Non-member functions of the \codeinline{id} class template}
{table.functions.id}
  \addRowThreeL
    { template <int dimensions> }
    { id<dimensions> operatorOP(const size_t \&lhs, }
    { const id<dimensions> \&rhs }
    {
      Where \codeinline{OP} is: \codeinline{+}, \codeinline{-}, \codeinline{*},
      \codeinline{/}, \codeinline{\%}, \codeinline{<<}, \codeinline{>>},
      \codeinline{\&}, \codeinline{|}, \codeinline{^}.
      \newline
      Constructs and returns a new instance of the SYCL \codeinline{id} class
      template with the same dimensionality as the \codeinline{rhs} SYCL
      \codeinline{id}, where each element of the new SYCL \codeinline{id}
      instance is the result of an element-wise \codeinline{OP} operator between
      the \codeinline{lhs} \codeinline{size_t} and each element of the
      \codeinline{rhs} SYCL \codeinline{id}. If the operator returns a
      \codeinline{bool} the result is the cast to \codeinline{size_t}.
    }
\completeTable
%-------------------------------------------------------------------------------

%*******************************************************************************
% item class
%*******************************************************************************
\subsubsection{\texttt{item} class}
\label{subsec:item.class}

\gls{item} identifies an instance of the function object
executing at each point in a \codeinline{range}. It is passed to a
\codeinline{parallel_for} call or returned by member functions of \codeinline{h_item}.
It encapsulates enough information to identify the work-item's range
of possible values and its ID in that range. It can optionally carry the offset of the
range if provided to the \codeinline{parallel_for}.
Instances of the \codeinline{item} class are
not user-constructible and are passed by the runtime to each instance
of the function object.

The SYCL \codeinline{item} class template provides the common by-value semantics
(see Section~\ref{sec:byval-semantics}).

\subsubsection{Item interface}

A synopsis of the SYCL \codeinline{item} class is provided below. The member functions of the SYCL \codeinline{item} class are listed in Table~\ref{table.members.id}. The additional common special member functions and common member functions are listed in \ref{sec:byval-semantics} in Tables~\ref{table.specialmembers.common.byval} and \ref{table.members.common.byval} respectively.

%Interface for class: item
\lstinputlisting{headers/item.h}

%-------------------------------------------------------------------------------
\startTable{Member function}
\addFootNotes{Member functions for the \codeinline{item} class}
{table.members.item}

  \addRow
    {id<dimensions> get_id() const}
    {
        Return the constituent \codeinline{id}
        representing the work-item's position in the iteration space.
    }
  \addRow
    {size_t get_id(int dimension) const}
    {
      Return the requested dimension of the constituent \codeinline{id}
      representing the work-item's position in the iteration space.
    }
  \addRow
    {size_t operator[](int dimension) const}
    {
      Return the constituent \codeinline{id} value representing the
      work-item's position in the iteration space in the given
      \codeinline{dimension}.
    }
  \addRow
    {range<dimensions> get_range() const}
    {
      Returns a \codeinline{range} representing the dimensions of the
      range of possible values of the \codeinline{item}.
    }
  \addRow
    {size_t get_range(int dimension) const}
    {
      Return the same value as get_range().get(dimension)
    }
  \addRow
    {id<dimensions> get_offset() const}
    {
      Returns an \codeinline{id} representing the $n$-dimensional offset
      provided to the \codeinline{parallel_for} and that is added by
      the runtime to the global-ID of each work-item, if this item
      represents a global range. For an item converted from an item with
      no offset this will always return an \codeinline{id} of all 0 values.

      This member function is only available if \codeinline{with_offset} is \codeinline{true}.
    }
  \addRow
    {operator item<dimensions, true>() const}
    {
      Returns an \codeinline{item} representing the same information as the object holds
      but also includes the offset set to 0. This conversion allow users to seamlessly
      write code that assumes an offset and still provides an offset-less \codeinline{item}.

      This member function is only available if \codeinline{with_offset} is \codeinline{false}.
    }
  \addRow
    {size_t get_linear_id() const}
    {
        Return the id as a linear index value. Calculating a linear
        address from the multi-dimensional index follow the equation 
  \ref{row-major-equation-buffer}.
    }
 \completeTable
%-------------------------------------------------------------------------------

%*******************************************************************************
% nd_item class
%*******************************************************************************

\subsubsection{\texttt{nd_item} class}
\label{nditem-class}

\codeinline{nd_item<int dimensions>} identifies an instance of the function object
executing at each point in an \codeinline{nd_range<int dimensions>} passed to a
\codeinline{parallel_for} call. It encapsulates enough
information to identify the \gls{work-item}'s local and global \glspl{id}, the
\gls{work-group-id} and also provides the \codeinline{barrier} and \codeinline{mem_fence} member functions, for performing \gls{work-group-barrier} and \gls{work-group-mem-fence} operations respectively. Instances of the \codeinline{nd_item<int dimensions>} class are not
user-constructible and are passed by the runtime to each instance of the
function object.

The SYCL \codeinline{nd_item} class template provides the common by-value
semantics (see Section~\ref{sec:byval-semantics}).

A synopsis of the SYCL \codeinline{nd_item} class is provided below. The member functions of the SYCL \codeinline{nd_item} class are listed in Table~\ref{table.members.nditem}. The additional common special member functions and common member functions are listed in \ref{sec:byval-semantics} in Tables~\ref{table.specialmembers.common.byval} and \ref{table.members.common.byval} respectively.

%interface for nd_item class
\lstinputlisting{headers/nditem.h}

%------------------------------------------------------------------------------------------------------
\startTable{Member function}
\addFootNotes{Member functions for the \codeinline{nd_item} class}
{table.members.nditem}
  \addRow
    {id<dimensions> get_global_id() const}
    {
        Return the constituent \gls{global-id} representing the
        work-item's position in the global iteration space.
    }
  \addRow
    {size_t get_global_id(int dimension) const}
    {
        Return the constituent element of the \gls{global-id}
        representing the work-item's position in the \gls{nd-range}
        in the given \codeinline{dimension}.
    }
  \addRow
   {size_t get_global_linear_id() const}
    {
      Return the flattened \gls{id} of the current work-item after subtracting the offset.
      Calculating a linear \gls{id}
      from a multi-dimensional index follows the equation \ref{row-major-equation-buffer}.
    }
  \addRow
    {id<dimensions> get_local_id() const}
    {
        Return the constituent \gls{local-id} representing the
        work-item's position within the current \gls{work-group}.
    }
  \addRow
    {size_t get_local_id(int dimension) const}
    {
      Return the constituent element of the \gls{local-id} representing the
      work-item's position within the current \gls{work-group} in the given
      \codeinline{dimension}.
    }
   \addRow
    {size_t get_local_linear_id() const}
   {
      Return the flattened \gls{id} of the current work-item within the current
      \gls{work-group}.
      Calculating a linear address
      from a multi-dimensional index follows the equation \ref{row-major-equation-buffer}.
   }
  \addRow
    {group<dimensions> get_group() const}
    {
        Return the constituent \gls{work-group}, \codeinline{group}
          representing the \gls{work-group}'s position within the overall
          \gls{nd-range}.
    }
   \addRow
    {size_t get_group(int dimension) const}
    {
        Return the constituent element of the group \codeinline{id} representing
        the work-group's position within the overall \codeinline{nd_range} in the
        given \codeinline{dimension}.
    }
    \addRow
   {size_t get_group_linear_id() const}
    {
        Return the group id as a linear index value. Calculating a linear address
      from a multi-dimensional index follows the equation \ref{row-major-equation-buffer}.
    }
  \addRow
    {range<dimensions> get_group_range() const}
    {Returns the number of \glspl{work-group} in the iteration space.}
  \addRow
    {size_t get_group_range(int dimension) const}
    {
    Return the number of \glspl{work-group} for \codeinline{dimension} in the
    iteration space.
    }
  \addRow
    {range<dimensions> get_global_range() const}
    {
        Returns a \codeinline{range} representing the dimensions of the
        global iteration space.
    }
  \addRow
    {size_t get_global_range(int dimension) const}
    {
      Return the same value as get_global_range().get(dimension)
    }
  \addRow
    {range<dimensions> get_local_range() const}
    {
        Returns a \codeinline{range} representing the dimensions of the current
        work-group.
    }
  \addRow
    {size_t get_local_range(int dimension) const}
    {
      Return the same value as get_local_range().get(dimension)
    }
  \addRow
    {id<dimensions> get_offset() const}
    {
        Returns an \gls{id} representing the n-dimensional offset
        provided to the constructor of the \codeinline{nd_range} and that
        is added by the runtime to the \gls{global-id} of each \gls{work-item}.
    }
  \addRow
    {nd_range<dimensions> get_nd_range() const}
    {
        Returns the \codeinline{nd_range} of the current execution.
    }
  \addRowThreeL
    {void barrier(}
    {access::fence_space accessSpace =}
    {access::fence_space::global_and_local) const}
    {
      Executes a \gls{work-group-barrier} with memory ordering on the local address
      space, global address space or both based on the value of
      \codeinline{accessSpace}. The current work-item will wait at the
      barrier until all work-items in the current work-group have
      reached the barrier. In addition the barrier performs a fence
      operation ensuring that all memory accesses in the specified
      address space issued before the barrier complete before those
      issued after the barrier.
    }
  \addRowFourL
    { template <access::mode accessMode = }
    { access::mode::read_write> }
    { void mem_fence(access::fence_space accessSpace = }
    { access::fence_space::global_and_local) const }
    {
      Available only when: \codeinline{accessMode == access::mode::read_write ||
      accessMode == access::mode::read || accessMode == access::mode::write}.
      \newline
      Executes a \gls{work-group-mem-fence} with memory ordering on the local
      address space, global address space or both based on the value of
      \codeinline{accessSpace}. If \codeinline{accessMode ==
      access::mode::read_write} the current work-item will ensure that all load
      and store memory accesses in the specified address space issued before the
      mem-fence complete before those issued after the mem-fence. If
      \codeinline{accessMode == access::mode::read} the current work-item will
      ensure that all load memory accesses in the specified address space issued
      before the mem-fence complete before those issued after the mem-fence. If
      \codeinline{accessMode == access::mode::write} the current work-item will
      ensure that all store memory accesses in the specified address space
      issued before the mem-fence complete before those issued after the mem-
      fence.
    }
  \addRowFourL
    { template <typename dataT> }
    { device_event async_work_group_copy( }
    { local_ptr<dataT> dest, global_ptr<dataT> src, }
    { size_t numElements) const }
    {
      Permitted types for \codeinline{dataT} are all scalar and vector types.
      Asynchronously copies a number of elements specified by \codeinline{
      numElements} from the source pointer \codeinline{src} to destination
      pointer \codeinline{dest} and returns a SYCL \codeinline{device_event}
      which can be used to wait on the completion of the copy. 
    }
  \addRowFourL
    { template <typename dataT> }
    { device_event async_work_group_copy( }
    { global_ptr<dataT> dest, local_ptr<dataT> src, }
    { size_t numElements) const }
    {
      Permitted types for \codeinline{dataT} are all scalar and vector types.
      Asynchronously copies a number of elements specified by \codeinline{
      numElements} from the source pointer \codeinline{src} to destination
      pointer \codeinline{dest} and returns a SYCL \codeinline{device_event}
      which can be used to wait on the completion of the copy. 
    }
  \addRowFourL
    { template <typename dataT> }
    { device_event async_work_group_copy( }
    { local_ptr<dataT> dest, global_ptr<dataT> src, }
    { size_t numElements, size_t srcStride) const }
    {
      Permitted types for \codeinline{dataT} are all scalar and vector types.
      Asynchronously copies a number of elements specified by \codeinline{
      numElements} from the source pointer \codeinline{src} to destination 
      pointer \codeinline{dest} with a source stride specified by
      \codeinline{srcStride} and returns a SYCL \codeinline{device_event}
      which can be used to wait on the completion of the copy. 
    }
  \addRowFourL
    { template <typename dataT> }
    { device_event async_work_group_copy( }
    { global_ptr<dataT> dest, local_ptr<dataT> src, }
    { size_t numElements, size_t destStride) const }
    {
      Permitted types for \codeinline{dataT} are all scalar and vector types.
      Asynchronously copies a number of elements specified by \codeinline{
      numElements} from the source pointer \codeinline{src} to destination
      pointer \codeinline{dest} with a destination stride specified by
      \codeinline{destStride} and returns a SYCL \codeinline{device_event}
      which can be used to wait on the completion of the copy. 
    }
  \addRowTwoL
    { template <typename... eventTN> }
    { void wait_for(eventTN... events) const }
    {
      Permitted type for \codeinline{eventTN} is \codeinline{device_event}.
      Waits for the asynchronous operations associated with each \codeinline{
      device_event} to complete.
    }
\completeTable
%-------------------------------------------------------------------------------

%*******************************************************************************
% h_item class
%*******************************************************************************

\subsubsection{\texttt{h_item} class}
\label{hitem-class}

\codeinline{h_item<int dimensions>} identifies an instance of a \codeinline{group::parallel_for_work_item} function object
executing at each point in a local \codeinline{range<int dimensions>} passed to a \codeinline{parallel_for_work_item}
call or to the corresponding \codeinline{parallel_for_work_group} call if no \codeinline{range}
is passed to the \codeinline{parallel_for_work_item} call.
It encapsulates enough information to identify the \gls{work-item}'s local and global \glspl{item}
according to the information given to \codeinline{parallel_for_work_group} (physical ids)
as well as the \gls{work-item}'s logical local \glspl{item} in the logical local range.
All returned \glspl{item} objects are offset-less.
Instances of the \codeinline{h_item<int dimensions>} class are not
user-constructible and are passed by the runtime to each instance of the
function object.

The SYCL \codeinline{h_item} class template provides the common by-value
semantics (see Section~\ref{sec:byval-semantics}).

A synopsis of the SYCL \codeinline{h_item} class is provided below. The member functions of the SYCL \codeinline{h_item} class are listed in Table~\ref{table.members.hitem}. The additional common special member functions and common member functions are listed in \ref{sec:byval-semantics} in Tables~\ref{table.specialmembers.common.byval} and \ref{table.members.common.byval} respectively.

\lstinputlisting{headers/hitem.h}

%------------------------------------------------------------------------------------------------------
\startTable{Member function}
\addFootNotes{Member functions for the \codeinline{h_item} class}
{table.members.hitem}
  \addRow
    {item<dimensions, false> get_global() const}
    {
        Return the constituent global \gls{item} representing the
        work-item's position in the global iteration space as provided upon kernel invocation.
    }
  \addRow
    {item<dimensions, false> get_local() const}
    {
        Return the same value as \codeinline{get_logical_local()}.
    }
  \addRow
    {item<dimensions, false> get_logical_local() const}
    {
        Return the constituent element of the logical local \gls{item}
        work-item's position in the local iteration space as provided upon the invocation of the
        \codeinline{group::parallel_for_work_item}.

        If the \codeinline{group::parallel_for_work_item} was called without any logical local range
        then the member function returns the physical local \gls{item}.

        A physical id can be computed from a logical id by getting the remainder of the integer division
        of the logical id and the physical range:
        \codeinline{get_logical_local().get() \% get_physical_local.get_range() == get_physical_local().get()}.
    }
  \addRow
    {item<dimensions, false> get_physical_local() const}
    {
        Return the constituent element of the physical local \gls{item}
        work-item's position in the local iteration space as provided (by the user or the runtime)
        upon the kernel invocation.
    }
  \addRow
    {range<dimensions> get_global_range() const}
    {
      Return the same value as \codeinline{get_global().get_range()}
    }
  \addRow
    {size_t get_global_range(int dimension) const}
    {
      Return the same value as \codeinline{get_global().get_range(dimension)}
    }
  \addRow
    {id<dimensions> get_global_id() const}
    {
      Return the same value as \codeinline{get_global().get_id()}
    }
  \addRow
    {size_t get_global_id(int dimension) const}
    {
      Return the same value as \codeinline{get_global().get_id(dimension)}
    }

  \addRow
    {range<dimensions> get_local_range() const}
    {
      Return the same value as \codeinline{get_local().get_range()}
    }
  \addRow
    {size_t get_local_range(int dimension) const}
    {
      Return the same value as \codeinline{get_local().get_range(dimension)}
    }
  \addRow
    {id<dimensions> get_local_id() const}
    {
      Return the same value as \codeinline{get_local().get_id()}
    }
  \addRow
    {size_t get_local_id(int dimension) const}
    {
      Return the same value as \codeinline{get_local().get_id(dimension)}
    }

  \addRow
    {range<dimensions> get_logical_local_range() const}
    {
      Return the same value as \codeinline{get_logical_local().get_range()}
    }
  \addRow
    {size_t get_logical_local_range(int dimension) const}
    {
      Return the same value as \codeinline{get_logical_local().get_range(dimension)}
    }
  \addRow
    {id<dimensions> get_logical_local_id() const}
    {
      Return the same value as \codeinline{get_logical_local().get_id()}
    }
  \addRow
    {size_t get_logical_local_id(int dimension) const}
    {
      Return the same value as \codeinline{get_logical_local().get_id(dimension)}
    }

  \addRow
    {range<dimensions> get_physical_local_range() const}
    {
      Return the same value as \codeinline{get_physical_local().get_range()}
    }
  \addRow
    {size_t get_physical_local_range(int dimension) const}
    {
      Return the same value as \codeinline{get_physical_local().get_range(dimension)}
    }
  \addRow
    {id<dimensions> get_physical_local_id() const}
    {
      Return the same value as \codeinline{get_physical_local().get_id()}
    }
  \addRow
    {size_t get_physical_local_id(int dimension) const}
    {
      Return the same value as \codeinline{get_physical_local().get_id(dimension)}
    }

 \completeTable
%-------------------------------------------------------------------------------

%*******************************************************************************
% group class
%*******************************************************************************
\subsubsection{\texttt{group} class}
\label{group-class}

The \codeinline{group<int dimensions>} encapsulates all functionality
required to represent a particular \gls{work-group} within a
parallel execution. It is not user-constructable.

The local range stored in the group class is provided either by
the programmer, when it is passed as an optional parameter to
\codeinline{parallel_for_work_group}, or by the runtime system when it
selects the optimal work-group size. This allows the developer to
always know how many concurrent work-items are active in each
executing work-group, even through the abstracted iteration range of the
\codeinline{parallel_for_work_item} loops.

The SYCL \codeinline{group} class template provides the common by-value
semantics (see Section~\ref{sec:byval-semantics}).

A synopsis of the SYCL \codeinline{group} class is provided below. The member functions of the SYCL \codeinline{group} class are listed in Table~\ref{table.members.group}. The additional common special member functions and common member functions are listed in \ref{sec:byval-semantics} in Tables~\ref{table.specialmembers.common.byval} and \ref{table.members.common.byval} respectively.

The \codeinline{group} class also provides the \codeinline{
mem_fence} member function for performing a \gls{work-group-mem-fence}
operation.

%Interface for class: group
\lstinputlisting{headers/group.h}

%-------------------------------------------------------------------------------
\startTable{Member function}
\addFootNotes{Member functions for the \codeinline{group} class}
{table.members.group}
  \addRow
    {id<dimensions> get_id() const}
    {
        Return an \gls{id} representing the index of the work-group
        within the \gls{nd-range} for every dimension.
    }
  \addRow
    {size_t get_id(int dimension) const}
    {
        Return the index of the work-group in the given \codeinline{dimension}.
    }
  \addRow
    {range<dimensions> get_global_range() const}
    {
        Return a SYCL \codeinline{range} representing all dimensions of the global range.
    }
  \addRow
    {size_t get_global_range(int dimension) const}
    {
        Return the dimension of the global range specified by the \codeinline{dimension} parameter.
    }
  \addRow
    {range<dimensions> get_local_range() const}
    {
        Return a SYCL \codeinline{range} representing all dimensions of the local range.
        This local range may have been provided by the programmer, or chosen by the \gls{sycl-runtime}.
    }
  \addRow
    {size_t get_local_range(int dimension) const}
    {
        Return the dimension of the local range specified by the \codeinline{dimension} parameter.
    }
  \addRow
    {range<dimensions> get_group_range() const}
    {
        Return a \codeinline{range} representing the number of \glspl{work-group} in the \codeinline{nd_range}.
    }
  \addRow
    {size_t get_group_range(int dimension) const}
    {
        Return element \codeinline{dimension} from the constituent group range.
    }
  \addRow
    {size_t operator[](int dimension) const}
    {
        Return the index of the group in the given \codeinline{dimension}
        within the \codeinline{nd_range}.
    }
  \addRow
    {size_t get_linear_id() const}
    {
        Get a linearized version of the \gls{work-group-id}.
        Calculating a linear \gls{work-group-id}
        from a multi-dimensional index follows the equation \ref{row-major-equation-buffer}.
    }
  \addRowTwoL
    {template <typename workItemFunctionT>}
    {void parallel_for_work_item(workItemFunctionT func) const}
    {
      Launch the work-items for this work-group.

      \codeinline{func} is a function object type with a public member function
      \codeinline{void F::operator()(h_item<dimensions>)}
      representing the work-item computation.

      This member function can only be invoked within a
      \codeinline{parallel_for_work_group} context.  It is
      undefined behavior for this member function to be invoked
      from within the \codeinline{parallel_for_work_group} form that
      does not define work-group size, because then the number of
      work-items that should execute the code is not defined.  It is
      expected that this form of \codeinline{parallel_for_work_item}
      is invoked within the \codeinline{parallel_for_work_group} form
      that specififies the size of a work-group.
    }
  \addRowThreeL
    {template <typename workItemFunctionT>}
    {void parallel_for_work_item(range<dimensions> }
    { logicalRange, workItemFunctionT func) const}
    {
      Launch the work-items for this work-group using a logical local range.
      The function object \codeinline{func} is executed as if the kernel where
      invoked with \codeinline{logicalRange} as the local range. This new local
      range is emulated and may not map one-to-one with the physical range.
      
      \codeinline{logicalRange} is the new local range to be used.
      This range can be smaller or larger than the one used to invoke the kernel.
      \codeinline{func} is a function object type with a public member function
      \codeinline{void F::operator()(h_item<dimensions>)}
      representing the work-item computation.

      Note that the logical range does not need to be uniform
      across all work-groups in a kernel.  For example the logical range may depend on
      a work-group varying query (e.g. \codeinline{group::get_linear_id}),
      such that different work-groups in the same kernel invocation execute
      different logical range sizes.

      This member function can only be invoked within a
      \codeinline{parallel_for_work_group} context.
    }
  \addRowFourL
    { template <access::mode accessMode = }
    { access::mode::read_write> }
    { void mem_fence(access::fence_space accessSpace = }
    { access::fence_space::global_and_local) const }
    {
      Available only when: \codeinline{accessMode == access::mode::read_write ||
      accessMode == access::mode::read || accessMode == access::mode::write}.
      \newline
      Executes a \gls{work-group-mem-fence} with memory ordering on the local
      address space, global address space or both based on the value of
      \codeinline{accessSpace}. If \codeinline{accessMode ==
      access::mode::read_write} the current work-item will ensure that all load
      and store memory accesses in the specified address space issued before the
      mem-fence complete before those issued after the mem-fence. If
      \codeinline{accessMode == access::mode::read} the current work-item will
      ensure that all load memory accesses in the specified address space issued
      before the mem-fence complete before those issued after the mem-fence. If
      \codeinline{accessMode == access::mode::write} the current work-item will
      ensure that all store memory accesses in the specified address space
      issued before the mem-fence complete before those issued after the mem-
      fence.
    }
  \addRowFourL
    { template <typename dataT> }
    { device_event async_work_group_copy( }
    { local_ptr<dataT> dest, global_ptr<dataT> src, }
    { size_t numElements) const }
    {
      Permitted types for \codeinline{dataT} are all scalar and vector types.
      Asynchronously copies a number of elements specified by \codeinline{
      numElements} from the source pointer \codeinline{src} to destination
      pointer \codeinline{dest} and returns a SYCL \codeinline{device_event}
      which can be used to wait on the completion of the copy. 
    }
  \addRowFourL
    { template <typename dataT> }
    { device_event async_work_group_copy( }
    { global_ptr<dataT> dest, local_ptr<dataT> src, }
    { size_t numElements) const }
    {
      Permitted types for \codeinline{dataT} are all scalar and vector types.
      Asynchronously copies a number of elements specified by \codeinline{
      numElements} from the source pointer \codeinline{src} to destination
      pointer \codeinline{dest} and returns a SYCL \codeinline{device_event}
      which can be used to wait on the completion of the copy. 
    }
  \addRowFourL
    { template <typename dataT> }
    { device_event async_work_group_copy( }
    { local_ptr<dataT> dest, global_ptr<dataT> src, }
    { size_t numElements, size_t srcStride) const }
    {
      Permitted types for \codeinline{dataT} are all scalar and vector types.
      Asynchronously copies a number of elements specified by \codeinline{
      numElements} from the source pointer \codeinline{src} to destination 
      pointer \codeinline{dest} with a source stride specified by
      \codeinline{srcStride} and returns a SYCL \codeinline{device_event}
      which can be used to wait on the completion of the copy. 
    }
  \addRowFourL
    { template <typename dataT> }
    { device_event async_work_group_copy( }
    { global_ptr<dataT> dest, local_ptr<dataT> src, }
    { size_t numElements, size_t destStride) const }
    {
      Permitted types for \codeinline{dataT} are all scalar and vector types.
      Asynchronously copies a number of elements specified by \codeinline{
      numElements} from the source pointer \codeinline{src} to destination
      pointer \codeinline{dest} with a destination stride specified by
      \codeinline{destStride} and returns a SYCL \codeinline{device_event}
      which can be used to wait on the completion of the copy. 
    }
  \addRowTwoL
    { template <typename... eventTN> }
    { void wait_for(eventTN... events) const }
    {
      Permitted type for \codeinline{eventTN} is \codeinline{device_event}.
      Waits for the asynchronous operations associated with each \codeinline{
      device_event} to complete.
    }
\completeTable
%-------------------------------------------------------------------------------

%*******************************************************************************
% device_event class
%*******************************************************************************
\subsubsection{\texttt{device_event} class}
\label{device-event-class}

The SYCL \codeinline{device_event} class encapsulates a single SYCL device event
which is available only within SYCL kernel functions and can be used to wait for
asynchronous operations within a SYCL kernel function to complete. A SYCL device
event may be an OpenCL device event, in which case it must encapsulate a valid
underlying OpenCL \codeinline{event_t}, or it may be a SYCL host device event,
in which case it must not.

All member functions of the \codeinline{device_event} class must not throw a
SYCL exception.

\subsubsection{Device event interface}

A synopsis of the SYCL \codeinline{device_event} class is provided below. The
constructors and member functions of the SYCL \codeinline{device_event} class
are listed in Table~\ref{table.constructors.device-event} and
\ref{table.members.device-event} respectively.

%Interface of device event class
\lstinputlisting{headers/deviceEvent.h}

%-------------------------------------------------------------------------------
\startTable{Member function}
\addFootNotes{Member functions of the SYCL \codeinline{device_event} class}{table.members.device-event}
  \addRow
    { void wait() }
    {
      Waits for the asynchronous operation associated with this SYCL
      \codeinline{device_event} to complete.
    }
\completeTable
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\startTable{Constructor}
\addFootNotes{Constructors of the \codeinline{device_event} class}
{table.constructors.device-event}
  \addRow
    {device_event(___unspecified___)}
    {
      Unspecified implementation defined constructor.
    }
\completeTable
%-------------------------------------------------------------------------------

%***********************************************************************************
% Command group scope
%***********************************************************************************
\subsection{Command group scope}
\label{sec:command.group.scope}

A \gls{command-group-scope} in SYCL, as it is defined in 
Section~\ref{sec:executionmodel}, consists of a single kernel or explicit memory
operation (\codeinline{handler} methods such as \codeinline{copy}, \codeinline{update_host},
\codeinline{fill}), together with its \textbf{requirements}.
The commands that enqueue a kernel or explicit memory operation and the requirements
for its execution form the \gls{command-group-function-object}.
The command group
function object takes as a parameter an instance of the \gls{handler} class which 
encapsulates all the member functions executed in the command group scope. 
The methods and objects defined in this scope will define the requirements for the
kernel execution or explicit memory operation, and will be used by the \gls{sycl-runtime}
to evaluate if the operation is ready for execution.
Host code within a \gls{command-group-function-object} (typically setting up
requirements) is executed once, before the command group submit call returns.
This abstraction of the kernel
execution unifies the data with its processing, and consequently allows more
abstraction and flexibility in the parallel programming models that can be
implemented on top of SYCL.

The \gls{command-group-function-object} and the \codeinline{handler} class
serve as an interface for the encapsulation of \gls{command-group-scope}.
A \gls{sycl-kernel-function} is defined as a function object. All the device data accesses are
defined inside this group and any transfers are managed by the \gls{sycl-runtime}. The
rules for the data transfers regarding device and
host data accesses are better described in the data management section
(\ref{sec:data.access.and.storage}), where buffers (\ref{subsec:buffers}) and
accessor (\ref{subsec:accessors}) classes are described.
The overall memory model of the SYCL application is described in
Section~\ref{sub.section.memmodel.app}.

It is possible to obtain events for the start of the \gls{command-group-function-object},
the kernel starting, and the command group completing.
These events are most useful for
profiling, because safe synchronization in SYCL requires synchronization on
buffer availability, not on kernel completion. This is because
the memory that data is stored in upon kernel
completion is not rigidly specified. The events are provided at the submission of the
\gls{command-group-function-object} to the queue to be executed on.

It is possible for a \gls{command-group-function-object} to fail to enqueue to a queue,
or for it to fail to execute correctly. A user can therefore supply a secondary
queue when submitting a command group to the primary queue. If the \gls{sycl-runtime}
fails to enqueue or execute a command group on a primary queue, it can attempt
to run the command group on the secondary queue. The circumstances in which it
is, or is not, possible for a \gls{sycl-runtime} to fall-back from primary to
secondary queue are unspecified in the specification.  Even if a command group
is run on the secondary queue, the requirement that host code within the command group
is executed exactly once remains, regardless of whether the fallback queue is used for
execution.

The command group \codeinline{handler} class provides the interface
for all of the member functions that are able to be executed inside the command group
scope, and it is also provided as a scoped object to all of the data access
requests. The \gls{handler} class provides the interface
in which every command in the command group scope will be submitted to a queue.

%***********************************************************************************
% Command group handler class
%***********************************************************************************

\subsection{Command group \texttt{handler} class}
\label{sec:handlerClass}

A \gls{handler} object can only be constructed by the SYCL
runtime. All of the accessors defined in \gls{command-group-scope} take as a
parameter an instance of the \gls{handler}, and all the
kernel invocation functions are member functions of this class.

The constructors of the SYCL \codeinline{handler} class are described in Table~\ref{table.constructors.handler}.

It is disallowed for an instance of the SYCL \codeinline{handler} class to be moved or copied.

%Interface for class: handler
\lstinputlisting{headers/commandGroupHandler.h}

%-------------------------------------------------------------------------------
\startTable{Constructor}
\addFootNotes{Constructors of the \codeinline{handler} class}
{table.constructors.handler}
  \addRow
    {handler(___unspecified___)}
    {
      Unspecified implementation defined constructor.
    }
\completeTable
%-------------------------------------------------------------------------------

%***********************************************************************************
% SYCL API for definition requisites
%***********************************************************************************
\subsection{SYCL functions for adding requirements}
\label{sub.section.requirement}

Requirements for execution of SYCL kernels can be specified directly using
handler methods.

\startTable{Member function}
\addFootNotes{Member functions of the \codeinline{handler} class}
{table.members.handler.requirements}
  \addRowFourSL
    { template <typename dataT, int dimensions, }
    { access::mode accessMode, access::target accessTarget> }
    { void require(accessor<dataT, dimensions, accessMode, accessTarget, }
    { placeholder::true_t> acc) }
    {
      Requires access to the memory object associated with the placeholder
      accessor. 
      The \gls{command-group} now has a \textbf{requirement} to gain access 
      to the given memory object before executing the kernel.
    }
\completeTable

%***********************************************************************************
% SYCL functions for invoking kernels
%***********************************************************************************

\subsection{SYCL functions for invoking kernels}
\label{subsec:invokingkernels}

\Glspl{kernel} can be invoked as \keyword{single tasks}, basic
\keyword{data-parallel} \glspl{kernel}, OpenCL-style \gls{nd-range} in
\glspl{work-group}, or SYCL \keyword{hierarchical parallelism}.

Each function takes a kernel name template parameter. The \gls{kernel-name}
must be a datatype that is unique for each kernel invocation. If a
kernel is a named function object, and its type is globally visible,  then the
kernel's function object type will be automatically used as the kernel name and so the user does
not need to supply a name. If the kernel function is a C++11 lambda function,
then the user must manually provide a kernel name to enable linking
between host and device code to occur.

All the functions for invoking kernels are member functions of the command group
\codeinline{handler} class~\ref{sec:handlerClass}, which 
is used to encapsulate all the member functions provided in a command group scope.
Table~\ref{table.members.handler.kernel} lists all the members of the 
\codeinline{handler} class related to the kernel invocation.

%-------------------------------------------------------------------------------
\startTable{Member function}
\addFootNotes{Member functions of the \codeinline{handler} class}
{table.members.handler.kernel}
  \addRowTwoL
    {template <typename T>}
    {void set_arg(int argIndex, T \&\&arg)}
    {
      Set a kernel argument for an OpenCL kernel through the
      SYCL/OpenCL interoperability interface. The \codeinline{index}
      value specifies which parameter of the OpenCL kernel is being
      set and \codeinline{arg} specifies the kernel argument.

      Index 0 is the first parameter.

      The argument can be either a SYCL accessor, a SYCL sampler or a
      trivially copyable and standard-layout C++ type.
     }

  \addRowTwoL
    {template <typename... Ts>}
    {void set_args(Ts \&\&... args)}
    {
      Set all the given kernel \codeinline{args} arguments for an
      OpenCL kernel, as if \codeinline{set_arg()} was used with each
      of them in the same order and increasing index always starting
      at 0.
    }

   \addRowTwoL
    {template <typename KernelName, typename KernelType>}
    {void single_task(KernelType kernelFunc)}
    {
      Defines and invokes a \gls{sycl-kernel-function} as a lambda function
      or a named function object type.
      If it is a named function object and the function object type is globally
      visible there is no need for the developer
      to provide a \gls{kernel-name} (\codeinline{typename KernelName}) for it,
      as described in~\ref{subsec:invokingkernels}.
    }
   \addRowThreeL
    {template <typename KernelName, typename KernelType, int dimensions>}
    {void parallel_for(}
    {range<dimensions> numWorkItems, KernelType kernelFunc)}
    {
      Defines and invokes a \gls{sycl-kernel-function} as a lambda function
      or a named function object type,
      for the specified range and given an id or item for indexing in the
      indexing space defined by range.
      If it is a named function object and the function object type is globally
      visible there is no need for the developer
      to provide a \gls{kernel-name} (\codeinline{typename KernelName}) for it,
      as described in~\ref{subsec:invokingkernels}.
    }
    \addRowFourL
    {template <typename KernelName, typename KernelType, int dimensions>}
    {void parallel_for(}
    { range<dimensions> numWorkItems,}
    { id<dimensions> workItemOffset, KernelType kernelFunc)}
    {
      Defines and invokes a \gls{sycl-kernel-function} as a lambda function
      or a named function object type,
      for the specified range and offset and given an id or item for indexing in
      the indexing space defined by range.
      If it is a named function object and the function object type is globally
      visible there is no need for the developer
      to provide a \gls{kernel-name} (\codeinline{typename KernelName}) for it,
      as described in~\ref{subsec:invokingkernels}.
    }
  \addRowThreeL
    {template <typename KernelName, typename KernelType, int dimensions>}
    {void parallel_for(}
    {nd_range<dimensions> executionRange, KernelType kernelFunc)}
    {
      Defines and invokes a \gls{sycl-kernel-function} as a lambda function
      or a named function object type,
      for the specified \gls{nd-range} and given an \gls{nd-item}
      for indexing in the indexing space defined by the \gls{nd-range}.
      If it is a named function object and the function object type is globally
      visible there is no need for the developer
      to provide a \gls{kernel-name} (\codeinline{typename KernelName}) for it,
      as described in~\ref{subsec:invokingkernels}.
    }
  \addRowFourL
    {template <typename KernelName, typename WorkgroupFunctionType, int dimensions>}
    {void parallel_for_work_group(}
    { range<dimensions> numWorkGroups,}
    { WorkgroupFunctionType kernelFunc)}
    {
      Hierarchical kernel invocation method of a kernel defined as a
      lambda encoding the body of each work-group to launch. May
      contain multiple calls to
      \codeinline{parallel_for_work_item(..)} methods representing the
      execution on each work-item. Launches
      \codeinline{num_work_groups} work-groups of runtime-defined
      size. Described in detail in~\ref{subsec:invokingkernels}.
    }
\addRowFiveL
  {template <typename KernelName, typename WorkgroupFunctionType, int dimensions>}
  {void parallel_for_work_group(}
  { range<dimensions> numWorkGroups,}
  { range<dimensions> workGroupSize,}
  { WorkgroupFunctionType kernelFunc)}
  {
    Hierarchical kernel invocation method of a kernel defined as a
    lambda encoding the body of each work-group to launch. May
    contain multiple calls to
    \codeinline{parallel_for_work_item} methods representing the
    execution on each work-item. Launches
    \codeinline{num_work_groups} work-groups of
    \codeinline{work_roup_size} work-items each. Described in
    detail in~\ref{subsec:invokingkernels}.
  }
  \addRow
    {void single_task(kernel syclKernel)}
    {
      Defines and invokes a \gls{sycl-kernel-function} as a lambda function
      or a named function object type, executes exactly once.
    }
  \addRowThreeL
    { template <int dimensions> void parallel_for(}
    { range<dimensions> numWorkItems,}
    { kernel syclKernel)}
    {
      Kernel invocation method of a pre-compiled \gls{kernel} defined by SYCL
      \codeinline{sycl-kernel-function} instance,
      for the specified range and given an id or item for indexing in the
      indexing space defined by range,
      described in detail in~\ref{subsec:invokingkernels}
    }
  \addRowThreeL
    { template <int dimensions> void parallel_for(}
    { range<dimensions> numWorkItems, }
    { id<dimensions> workItemOffset, kernel syclKernel) }
    {
      Kernel invocation method of a pre-compiled \gls{kernel} defined by SYCL
      \codeinline{sycl-kernel-function} instance,
      for the specified range and offset and given an id or item for indexing in the
      indexing space defined by range,
      described in detail in~\ref{subsec:invokingkernels}
    }
   \addRowThreeL
    { template <int dimensions> void parallel_for(}
    { nd_range<dimensions> ndRange,}
    { kernel syclKernel)}
    {
      Kernel invocation method of a pre-compiled \gls{kernel} defined by SYCL \codeinline{kernel} instance,
      for the specified \codeinline{ndrange} and given an \codeinline{nd_item}
      for indexing in the indexing space defined by the \codeinline{nd_range},
      described in detail in~\ref{subsec:invokingkernels}
    }
\completeTable

%Interface for apis
%\lstinputlisting{headers/parallelFor.h}

%***********************************************************************************
% single_task invoke
%***********************************************************************************

\subsubsection{\texttt{single_task} invoke}

SYCL provides a simple interface to enqueue a kernel that will be
sequentially executed on an OpenCL device. Only one instance of the
kernel will be executed. This interface is useful as a primitive for more
complicated parallel algorithms, as it can easily create a chain of
sequential tasks on an OpenCL device with each of them managing its
own data transfers.

This function can only be called inside a command group using the
\codeinline{handler} object created by the runtime.
Any accessors that are used in a kernel should be defined inside the
same command group.

Local accessors are disallowed for single task invocations.

\lstinputlisting{code/singletask.cpp}

For single tasks, the kernel method takes no parameters, as there
is no need for \gls{index-space-classes} in a unary index space.

%***********************************************************************************
% parallel_for invoke
%***********************************************************************************
\subsubsection{\texttt{parallel_for} invoke}

The \codeinline{parallel_for} member function of the SYCL \codeinline{handler} class provides
an interface to define and invoke a SYCL kernel function in a command group, to execute in
parallel execution over a 3 dimensional index space.
There are three overloads of the \codeinline{parallel_for} member function which provide
variations of this interface, each with a different level of complexity and providing a
different set of features.

For the simplest case, users need only provide the global range (the total number of work-items in the index space) via a SYCL \codeinline{range} parameter, and the \gls{sycl-runtime} will select a local range (the number of work-items in each work-group).
The local range chosen by the \gls{sycl-runtime} is entirely implementation defined.
In this case the function object that represents the SYCL kernel function must take either a single SYCL \codeinline{id} parameter, or a single SYCL \codeinline{item} parameter, representing the currently executing work-item within the range specified by the \codeinline{range} parameter.

The execution of the kernel function is the same whether the parameter to the SYCL kernel function is
a SYCL \codeinline{id} or a SYCL \codeinline{item}.
What differs is the functionality that is available to the SYCL kernel function via the respective interfaces.

Below is an example of invoking a SYCL kernel function with \codeinline{parallel_for} using a lambda function,
and passing a SYCL \codeinline{id} parameter. In this case only the global id is available. This variant of
\codeinline{parallel_for} is designed for when it is not necessary to query the global range of the index space
being executed across, or the local (work-group) size chosen by the implementation.

\lstinputlisting{code/basicparallelfor.cpp}

Below is an example of invoking a SYCL kernel function with \codeinline{parallel_for} using a lambda function
and passing a SYCL \codeinline{item} parameter. In this case both the global id and global range are queryable.
This variant of \codeinline{parallel_for} is designed for when it is necessary to query the global range within
which the global id will vary.  No information is queryable on the local (work-group) size chosen by the
implementation.

\lstinputlisting{code/basicParallelForItem.cpp}

For SYCL kernel functions invoked via the above described overload of the \codeinline{parallel_for} member function,
it is disallowed to use local accessors or to use a \gls{work-group-barrier} or \gls{work-group-mem-fence} operation.

The following two examples show how a kernel function object can be launched
over a 3D grid, with 3 elements in each dimension. In the first case
work-item ids range from 0 to 2 inclusive, and in the second case
work-item ids run from 1 to 3.

\lstinputlisting{code/parallelfor.cpp}

The last case of a parallel_for invocation enables
low-level functionality of work-items and work-groups. This becomes
valuable when an execution requires groups of work-items that communicate and
synchronize. These are exposed in SYCL through 
\codeinline{parallel_for (nd_range,...)}
and the \codeinline{nd_item} class, 
which provides all the functionality of OpenCL for an nd-range.
In this case, the developer needs to define the
 \codeinline{nd_range} that the kernel will execute on in order to
 have fine grained  control of the enqueing of the kernel. 
 This variation of parallel_for expects an
 \codeinline{nd_range}, specifying both local and global ranges,
 defining the global
 number of work-items and the number in each cooperating work-group.
 The resulting function object is passed an \codeinline{nd_item}
 instance making all the information available, as well as
 \gls{work-group-barrier} and \gls{work-group-mem-fence} operations
 to synchronize or guarantee memory consistency between the \gls{work-item}s in the \gls{work-group}.

The following example shows how sixty-four work-items may be launched
in a three-dimensional grid with four in each dimension, and divided
into eight work-groups. Each group of work-items synchronizes with a
\gls{work-group-barrier}.

\lstinputlisting{code/parallelforbarrier.cpp}

Optionally, in any of these variations of parallel_for invocations,
the developer may also pass an offset. An offset is an
instance of the \codeinline{id} class added to the identifier 
for each point in the range.

In all of these cases the underlying \gls{nd-range} will be created
and the kernel defined as a function object will be created and enqueued
as part of the command group scope.

%***********************************************************************************
% Parallel For hierarchical invoke invoke
%***********************************************************************************

\subsubsection{Parallel For hierarchical invoke}

The hierarchical parallel kernel execution interface provides the same
functionality as is available from the \gls{nd-range} interface, but
exposed differently. To execute the same sixty-four work-items in
sixteen work-groups that we saw in the previous example, we execute an
outer \codeinline{parallel_for_work_group} call to create the
groups. The member function
\codeinline{handler::parallel_for_work_group} is parameterized by the
number of work-groups, such that the size of each group is chosen by
the runtime, or by the number of work-groups and number of work-items
for users who need more control.

The body of the outer \codeinline{parallel_for_work_group} call
consists of a lambda function or function object. The body of this
function object contains code that is executed only once for the
entire work-group. If the code has no side-effects and the compiler
heuristic suggests that it is more efficient to do so, this code will be
executed for each work-item.

Within this region any variable declared will have the semantics of
\gls{local-memory}, shared between all \glspl{work-item} in the 
\gls{work-group}. If the
device compiler can prove that an array of such variables is accessed only by
a single work-item throughout the lifetime of the work-group, for
example if access is derived from the id of the work-item with no
transformation, then it can allocate the data in private memory or
registers instead.

To guarantee use of private per-work-item memory, the
\codeinline{private_memory} class can be used to wrap the data.
This class very simply constructs private data for a given group across the
entire group. The id of the current work-item is passed to any access
to grab the correct data.

The \codeinline{private_memory} class has the following interface:
\label{paragraph.private.memory}
\lstinputlisting{headers/priv.h}
%-------------------------------------------------------------------------------
\startTable{Constructor}
\addFootNotes{Constructor of the \codeinline{private_memory} class}
{table.constructors.private.memory}
  \addRow
    {private_memory(const group<Dimensions> \&)}
    {
      Place an object of type \codeinline{T} in the underlying private memory of each \glspl{work-item}.
      The type \codeinline{T} must be default constructible.
      The underlying constructor will be called for each \gls{work-item}.
    }
\completeTable
%-------------------------------------------------------------------------------
\startTable{Member functions}
\addFootNotes{Member functions of the \codeinline{private_memory} class}
{table.members.private.memory}
  \addRow
    {T \&operator()(const h_item<Dimensions> \&id)}
    {
      Retrieve a reference to the object for the \glspl{work-item}.
    }
\completeTable
%-------------------------------------------------------------------------------

\Gls{private-memory} is allocated per underlying \gls{work-item}, not per
iteration of the \codeinline{parallel_for_work_item} loop. The number
of instances of a private memory object is only under direct control
if a work-group size is passed to the
\codeinline{parallel_for_work_group} call. If the underlying
work-group size is chosen by the runtime, the number of private memory
instances is opaque to the program. Explicit private memory
declarations should therefore be used with care and with a full
understanding of which instances of a
\codeinline{parallel_for_work_item} loop will share the same
underlying variable.

Also within the lambda body can be a sequence of calls to
\codeinline{parallel_for_work_item}. At the edges of these inner
parallel executions the work-group synchronizes. As a result the pair
of \codeinline{parallel_for_work_item} calls in the code below is
equivalent to the parallel execution with a \gls{work-group-barrier} in the earlier example.

\lstinputlisting{code/parallelforworkgroup.cpp}

It is valid to use more flexible dimensions of the work-item loops. In
the following example we issue 8 work-groups but let the runtime
choose their size, by not passing a work-group size to the
\codeinline{parallel_for_work_group} call. The
\codeinline{parallel_for_work_item} loops may also vary in size, with
their execution ranges unrelated to the dimensions of the work-group,
and the compiler generating an appropriate iteration space to fill the
gap. In this case, the \codeinline{h_item} provides access to local ids and
ranges that reflect both kernel and \codeinline{parallel_for_work_item} invocation ranges.

\lstinputlisting{code/parallelforworkgroup2.cpp}

This interface offers a more intuitive way for tiling parallel
programming paradigms. In summary, the hierarchical model allows a
developer to distinguish the execution at work-group level and at
work-item level using the \codeinline{parallel_for_work_group} and the nested
\tf{parallel_for_work_item} functions. It also provides this visibility
to the compiler without the need for difficult loop fission such that
host execution may be more efficient.


%***********************************************************************************
% SYCL functions for explicit memory operations
%***********************************************************************************
\input{sycl_explicit_memory}

%*******************************************************************************
% Kernel class
%*******************************************************************************
\subsection{Kernel class}
\label{subsec:kernel.class}

The \codeinline{kernel} class is an abstraction of a \gls{kernel} object
in SYCL. In the
most common case the kernel object will contain the compiled version of a kernel
invoked inside a command group using one of the parallel interface functions as
described in~\ref{subsec:invokingkernels}. The \gls{sycl-runtime} will create
a kernel object, when it needs to enqueue the kernel on a command queue.

In the case where a developer would like to pre-compile a kernel or compile and
link it with an existing program, then the kernel object will be created and
contain that kernel using the program class, as defined
in~\ref{sec:interfaces.program.class}. In both of the above cases, the developer
cannot instantiate a kernel object but can instantiate a named function object type
that they could use, or create a function object from a kernel method using C++11 features.
The kernel class object needs a \codeinline{parallel_for(...)} invocation or an
explicitly built SYCL \codeinline{kernel} instance, for this compilation of the kernel to be triggered.

The SYCL \codeinline{kernel} class provides the common reference semantics
(see Section~\ref{sec:reference-semantics}).

The kernel class also provides the interface for getting information from a
kernel object. The kernel information descriptor interface is described in%
~\ref{appendix.kernel.descriptors} and the description is in the
Table~\ref{table.kernel.info}.

The constructors and member functions of the SYCL \codeinline{kernel} class are listed in Tables~\ref{table.constructors.kernel} and \ref{table.members.kernel}, respectively. The additional common special member functions and common member functions are listed in Tables~\ref{table.specialmembers.common.reference} and \ref{table.members.common.reference}, respectively.

%Interface for class: kernel
\lstinputlisting{headers/kernelWIP.h}

%-------------------------------------------------------------------------------
\startTable{Constructor}
\addFootNotes{Constructors of the SYCL \codeinline{kernel} class}
{table.constructors.kernel}
  \addRow{kernel (cl_kernel clKernel, const context\& syclContext)}
  {
    Constructs a SYCL \codeinline{kernel} instance from an OpenCL \codeinline{cl_kernel} in accordance with the requirements described in \ref{sec:opencl-interoperability}.
    The SYCL \codeinline{context} must represent the same underlying OpenCL context associated with the OpenCL kernel object.
  }
\completeTable
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\startTable{Member functions}
\addFootNotes{Member functions of the \codeinline{kernel} class}
{table.members.kernel}
  \addRow
    {cl_kernel get() const}
    {   
      Returns a valid \codeinline{cl_kernel} instance in accordance with the requirements described in \ref{sec:opencl-interoperability}.
     }
  \addRow
  {bool is_host() const}
  {
    Returns true if this SYCL \codeinline{kernel} is a host kernel.
  }
  \addRow
    {context get_context() const}
    {
        Return the context that this kernel is defined for.
        The value returned must be equal to that returned by \codeinline{get_info<info::kernel::context>()}.
    }

  \addRow
    {program get_program() const}
    {
        Return the program that this kernel is part of.
        The value returned must be equal to that returned by \codeinline{get_info<info::kernel::program>()}.
    }

  \addRowFourL
    {template <info::kernel param>}
    {typename info::param_traits<}
    {info::kernel, param>::return_type}
    {get_info() const}
    {
        Query information from the kernel object using the
        \codeinline{info::kernel_info} descriptor.
    }


  \addRowFourL
    {template <info::kernel_work_group param>}
    {typename info::param_traits<}
    {info::kernel_work_group, param>::return_type}
    {get_work_group_info(const device \&dev) const}
    {
        Query information from the work-group from a kernel using the
        \codeinline{info::kernel_work_group} descriptor for a specific
        device
    }

\completeTable
%-------------------------------------------------------------------------------
\fixme{info table consistency changes: add namespace and enum class to the
descriptor.}

%-------------------------------------------------------------------------------
\startInfoTable{Kernel Descriptors}
\addInfoFootNotes{Kernel class information descriptors}
{table.kernel.info}

\addInfoRow
{info::kernel::function_name}
{string_class}
{Return the kernel function name.}

\addInfoRow
{info::kernel::num_args}
{cl_uint}
{Return the number of arguments to the extracted OpenCL C kernel.}

\addInfoRow
{info::kernel::context}
{context}
{Return the SYCL \codeinline{context} associated with this SYCL \codeinline{kernel}.}

\addInfoRow
{info::kernel::program}
{program}
{Return the SYCL \codeinline{program} associated with this SYCL \codeinline{kernel}.}

\addInfoRow
{info::kernel::reference_count}
{cl_uint}
{
  Returns the reference count of the encapsulated SYCL \codeinline{cl_kernel},
  if this SYCL \codeinline{kernel} is an OpenCL program. Must thrown a \codeinline{invalid_object_error} SYCL exception if this SYCL \codeinline{kernel} is a host kernel.
}

\addInfoRow
{info::kernel::attributes}
{string_class}
{
  % Curious in this case we need to escape this __
  Return any attributes specified using the \codeinline{\__attribute__} qualifier
  with the kernel function declaration in the program source.
}

\completeInfoTable

\startInfoTable{Kernel Work-group Information Descriptors}
\addInfoFootNotes{Kernel work-group information descriptors}
{table.kernel.workgroupinfo}

\addInfoRow
{info::kernel_work_group::global_work_size}
{range<3>}
{Returns the maximum global work size. Only valid if device is of device_type 
 custom or the kernel is a built-in OpenCL kernel.}

\addInfoRow
{info::kernel_work_group::work_group_size}
{size_t}
{Returns the maximum work-group size that can be used to execute 
  a kernel on a specific device. }

\addInfoRow
{info::kernel_work_group::compile_work_group_size}
{range<3>}
{Returns the work-group size specified by the device compiler if applicable, 
  otherwise returns $(0,0,0)$}

\addInfoRow
{info::kernel_work_group::preferred_work_group_size_multiple}
{size_t}
{
  Returns the preferred work-group size for executing a kernel on a particular
  device.
}

\addInfoRow
{info::kernel_work_group::private_mem_size}
{cl_ulong}
{
  Returns the minimum amount of private memory, in bytes, used by each work-item
  in the kernel. This value may include any private memory needed by an 
  implementation to execute the kernel, including that used by the language
  built-ins and variables declared inside the kernel in the private address
  space.
}

\completeInfoTable

%-------------------------------------------------------------------------------

%*******************************************************************************
% Program class
%*******************************************************************************
\subsection{Program class}
\label{sec:interfaces.program.class}

The SYCL \codeinline{program} class encapsulates a single SYCL program. A SYCL program may be an OpenCL program, in which case it must encapsulate a valid underlying OpenCL \codeinline{cl_program}, depending on it's state, or it may be a SYCL host program, in which case it must not.

A SYCL \codeinline{program} can be used to compile and link both SYCL programs and OpenCL programs.

A SYCL \codeinline{program} instance can be in one of three states defined by \codeinline{program_state}: 
\begin{itemize}
\item A SYCL \codeinline{program} in the \codeinline{program_state::none} state must have no encapsulated \codeinline{cl_program}.
\item A SYCL \codeinline{program} in the \codeinline{program_state::compiled} state must encapsulate a \codeinline{cl_program} that has been compiled but not yet linked, if that SYCL \codeinline{program} is an OpenCL program. It must have no encapsulated \codeinline{cl_program} if that SYCL \codeinline{program} is a host program.
\item A SYCL \codeinline{program} in the \codeinline{program_state::linked} state must encapsulate a \codeinline{cl_program} that has been either compiled and linked or built, if that SYCL \codeinline{program} is an OpenCL program. It must have no encapsulated \codeinline{cl_program} if that SYCL \codeinline{program} is a host program.
\end{itemize}

A SYCL \codeinline{program} host program must follow the same state changes as an OpenCL program, however the transitions are implementation defined.

All member functions of the \codeinline{program} class are synchronous and errors are handled by throwing synchronous SYCL exceptions.

There is no default constructor for the SYCL \codeinline{program} as all constructors require a SYCL \codeinline{context} instance to be provided. 
The only exception is a constructor taking a \codeinline{vector_class} containing SYCL \codeinline{program} instances.
This constructor links them together into a new SYCL \codeinline{program}.

The encapsulated \codeinline{cl_program} of an OpenCL program can contain either SYCL kernel functions or OpenCL C kernel functions. When a \codeinline{program} instance is constructed using a non-OpenCL interoperability constructor, it is in the \codeinline{program_state::none} state and should then be compiled or built by specifying the SYCL kernel name (either the type of the function object or the explicit kernel name type specified when defining the SYCL kernel function). When a \codeinline{program} instance is constructed using an OpenCL interoperability constructor, it can be in either the \codeinline{program_state::compiled} or \codeinline{program_state::linked} state  and should not be compiled or built, only linked.

The compiler options that can be provided are described in the OpenCL specification \cite[p.~145, \S~5.6.4]{opencl12} and the linker options that can be provided are described in \cite[p.~148,\S~5.6.5]{opencl12}.

The SYCL \codeinline{program} class provides the common reference semantics
(see Section~\ref{sec:reference-semantics}).

\subsubsection{Program interface}

A synopsis of the SYCL \codeinline{program} class is provided below. The constructors and member functions of the SYCL \codeinline{program} class are listed in Tables~\ref{table.constructors.program} and \ref{table.members.program} respectively. The additional common special member functions and common member functions are listed in
\ref{sec:reference-semantics} in Tables~\ref{table.specialmembers.common.reference} and \ref{table.members.common.reference}, respectively.

%Interface for class: program
\lstinputlisting{headers/programWIP.h}

%------------------------------------------------------------------------------------------------------
\startTable{Constructor}
\addFootNotes{Constructors of the SYCL \codeinline{program} class}
{table.constructors.program}
  \addRow
    {program () = delete}
    {
      Default constructor is deleted.
    }
  \addRowTwoL
    {explicit program (}
    {const context \&context)}
    {
      Constructs an instance of SYCL \codeinline{program} in the \codeinline{program_state::none} state, associated with the \codeinline{context} provides and the SYCL \codeinline{device}s that are associated with the \codeinline{context}.
    }
  \addRowThreeL
    {program (}
    {const context \&context,}
    {vector_class<device> deviceList)}
    {
      Constructs an instance of SYCL \codeinline{program} in the \codeinline{program_state::none} state, associated with the \codeinline{context} provides and \codeinline{deviceList}.
    }
  \addRowThreeL
    {program (}
    {vector_class<program> programList,}
    {string_class linkOptions = "")}
    {
      Constructs an instance of SYCL \codeinline{program} in the \codeinline{program_state::linked} by linking together each SYCL \codeinline{program} instance in \codeinline{programList}. Each SYCL \codeinline{program} in \codeinline{programList} must be in the \codeinline{program_state::compiled} state and must be associated with the same SYCL \codeinline{context}. Otherwise must throw an \codeinline{invalid_object_error} SYCL exception.  Must throw a \codeinline{feature_not_supported} SYCL exception if any device that the program is to be linked for returns \codeinline{false} for the device information query \codeinline{info::device::is_linker_available}.

    }
  \addRowThreeL
    {program (}
    {const context \&context,}
    {cl_program clProgram)}
    {
      Constructs a SYCL \codeinline{program} instance from an OpenCL \codeinline{cl_program} in accordance with the requirements described in \ref{sec:opencl-interoperability}. The state of the constructed SYCL \codeinline{program} can be either \codeinline{program_state::compiled} or \codeinline{program_state::linked}, depending on the state of the \codeinline{clProgram}. Otherwise must throw an \codeinline{invalid_object_error} SYCL exception.
    }
\completeTable
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\startTable{Member functions}
\addFootNotes{Member functions of the SYCL \codeinline{program} class}{table.members.program}
  \addRow
    {cl_program get() const}
    {
      Returns a valid \codeinline{cl_program} instance in accordance with the requirements described in \ref{sec:opencl-interoperability}. Must throw an \codeinline{invalid_object_error} SYCL exception if this \codeinline{program} is in the \codeinline{program_state::none} state.
    }
  \addRow
    {bool is_host() const}
    {
      Returns true if this SYCL \codeinline{program} is a host program.
    }
  \addRowThreeL
    {template<typename kernelT>}
    {void compile_with_kernel_type(}
    {string_class compileOptions = "")}
    {
      Compiles the SYCL kernel function defined by the type \codeinline{kernelT} into the encapsulated \codeinline{cl_program} with the compiler options specified by \codeinline{compileOptions}, if this SYCL \codeinline{program} is an OpenCL program. Sets the state of this SYCL \codeinline{program} to \codeinline{program_state::compiled}. Must throw an \codeinline{invalid_object_error} SYCL exception if this \codeinline{program} was not in the \codeinline{program_state::none} state when called. Must throw a  \codeinline{compile_program_error} SYCL exception if the compilation fails.  Must throw a \codeinline{feature_not_supported} SYCL exception if any device that the program is to be compiled for returns \codeinline{false} for the device information query \codeinline{info::device::is_compiler_available}.
    }
  \addRowTwoL
    {void compile_with_source(string_class kernelSource, }
    {string_class compileOptions = "")}
    {
      Compiles the OpenCL C kernel function defined by \codeinline{kernelSource} into the encapsulated \codeinline{cl_program} with the compiler options specified by \codeinline{compileOptions}, if this SYCL \codeinline{program} is an OpenCL program. Sets the state of this SYCL \codeinline{program} to \codeinline{program_state::compiled}. Must throw an \codeinline{invalid_object_error} SYCL exception if this \codeinline{program} was not in the \codeinline{program_state::none} state when called. Must throw a  \codeinline{compile_program_error} SYCL exception if the compilation fails.  Must throw a \codeinline{feature_not_supported} SYCL exception if any device that the program is to be compiled for returns \codeinline{false} for the device information query \codeinline{info::device::is_compiler_available}.
    }
  \addRowThreeL
    {template<typename kernelT>}
    {void build_with_kernel_type(}
    {string_class buildOptions = "")}
    {
      Builds the SYCL kernel function defined by the type \codeinline{kernelT} into the encapsulated \codeinline{cl_program} with the compiler options specified by \codeinline{buildOptions}, if this SYCL \codeinline{program} is an OpenCL program. Sets the state of this SYCL \codeinline{program} to \codeinline{program_state::linked}. Must throw an \codeinline{invalid_object_error} SYCL exception if this \codeinline{program} was not in the \codeinline{program_state::none} state when called. Must throw a  \codeinline{compile_program_error} SYCL exception if the compilation fails.  Must throw a \codeinline{feature_not_supported} SYCL exception if any device that the program is to be built for returns \codeinline{false} for the device information queries \codeinline{info::device::is_compiler_available} or \codeinline{info::device::is_linker_available}.

    }
  \addRowTwoL
    {void build_with_source(string_class kernelSource, }
    {string_class buildOptions = "")}
    {
      Builds the OpenCL C kernel function defined by \codeinline{kernelSource} into the encapsulated \codeinline{cl_program} with the compiler options specified by \codeinline{buildOptions}, if this SYCL \codeinline{program} is an OpenCL program. Sets the state of this SYCL \codeinline{program} to \codeinline{program_state::linked}. Must throw an \codeinline{invalid_object_error} SYCL exception if this \codeinline{program} was not in the \codeinline{program_state::none} state when called. Must throw a  \codeinline{compile_program_error} SYCL exception if the compilation fails.  Must throw a \codeinline{feature_not_supported} SYCL exception if any device that the program is to be built for returns \codeinline{false} for the device information queries \codeinline{info::device::is_compiler_available} or \codeinline{info::device::is_linker_available}.
    }
  \addRow
    {void link(string_class linkOptions = "")}
    {
      Links the encapsulated \codeinline{cl_program} with the compiler options specified by \codeinline{linkOptions}, if this SYCL \codeinline{program} is an OpenCL program. Sets the state of this SYCL \codeinline{program} to \codeinline{program_state::linked}. Must throw an \codeinline{invalid_object_error} SYCL exception if this \codeinline{program} was not in the \codeinline{program_state::compiled} state when called. Must throw a \codeinline{compile_program_error} SYCL exception if the linking fails.  Must throw a \codeinline{feature_not_supported} SYCL exception if any device that the program is to be linked for returns \codeinline{false} for the device information query \codeinline{info::device::is_linker_available}.
    }
  \addRowTwoL
    {template <typename kernelT>}
    {bool has_kernel<kernelT>() const}
    {
      Returns true if the SYCL kernel function defined by the type \codeinline{kernelT} is an available kernel, either within the the encapsulated \codeinline{cl_program}, if this SYCL \codeinline{program} is an OpenCL program, or on the host if this SYCL \codeinline{program} is a host program, otherwise returns false. Must throw an \codeinline{invalid_object_error} SYCL exception if this SYCL \codeinline{program} is in the \codeinline{program_state::none} state.
    }
  \addRow
    {bool has_kernel(string_class kernelName) const}
    {
      Returns true if the OpenCL C kernel function defined by the \codeinline{string_class} \codeinline{kernelName} is an available kernel within the encapsulated \codeinline{cl_program} and this SYCL \codeinline{program} is not a host program, otherwise returns false. Must throw an \codeinline{invalid_object_error} SYCL exception if this SYCL \codeinline{program} is in the \codeinline{program_state::none} state.
    }
  \addRowTwoL
    {template <typename kernelT>}
    {kernel get_kernel<kernelT>() const}
    {
      Returns a SYCL \codeinline{kernel} OpenCL kernel instance encapsulating a \codeinline{cl_kernel} for the SYCL kernel function defined by the type \codeinline{kernelT}, if this SYCL \codeinline{program} is an OpenCL program. Returns a SYCL \codeinline{kernel} host kernel if this SYCL \codeinline{program} is a host program. Must throw an \codeinline{invalid_object_error} SYCL exception if this SYCL \codeinline{program} is in the \codeinline{program_state::none} state or if the SYCL kernel function specified by \codeinline{kernelT} is not available in this SYCL \codeinline{program}.
    }
  \addRow
    {kernel get_kernel(string_class kernelName) const}
    {
      Returns a SYCL \codeinline{kernel} OpenCL kernel instance encapsulating a \codeinline{cl_kernel} for the OpenCL C kernel function defined by the \codeinline{string_class} \codeinline{kernelName}, if this SYCL \codeinline{program} is an OpenCL program. Must throw an \codeinline{invalid_object_error} SYCL exception if this SYCL \codeinline{program} is a host program, this SYCL \codeinline{program} is in the \codeinline{program_state::none} state or the \codeinline{cl_program} encapsulated by this SYCL \codeinline{program} does not contain the OpenCL C kernel function specified by \codeinline{kernelName}. Returns a SYCL \codeinline{kernel} host kernel if this SYCL \codeinline{program} is a host program.
    }
  \addRowFourL
    {template<info::program param>}
    {typename info::param_traits<}
    {info::program, param>::return_type}
    { get_info() const}
    {
      Queries this SYCL \codeinline{program} for information requested by the template parameter \codeinline{param}.
      Specializations of \codeinline{info::param_traits} must be defined in accordance with the info parameters in Table~\ref{table.program.info} to facilitate returning the type associated with the \codeinline{param} parameter.
    }
    \addRow
    {vector_class<vector_class<char>> get_binaries() const}
    {
      Returns a \codeinline{vector_class} of \codeinline{vector_class<char>} representing the compiled binaries for each associated SYCL \codeinline{device}. Must throw an \codeinline{invalid_object_error} SYCL exception if this \codeinline{program} was not in the \codeinline{program_state::compiled} or \codeinline{program_state::linked} states when called.
    }
  \addRow
    {context get_context() const}
    {
        Returns the SYCL \codeinline{context} that this SYCL \codeinline{program} was constructed with.
        The value returned must be equal to that returned by \codeinline{get_info<info::program::context>()}.
        }
  \addRow
    {vector_class<device> get_devices() const}
    {
        Returns a \codeinline{vector_class} containing all SYCL \codeinline{device}s that are associated with this SYCL \codeinline{program}.
        The value returned must be equal to that returned by \codeinline{get_info<info::program::devices>()}.
    }
  \addRow
    {string_class get_compile_options() const}
    {
       Returns the compile options that were provided when the encapsulated \codeinline{cl_program} was explicitly compiled.  If the program was built instead of explicitly compiled, if the program has not yet been compiled, or if the program has been compiled for only the host device (which does not have an underlying \codeinline{cl_program}), then an empty string is returned.  If the program was constructed from a \codeinline{cl_program}, then an empty string is returned unless the \codeinline{cl_program} was explicitly compiled, in which case the compile options used in the explicit compile are returned.
    }
  \addRow
    {string_class get_link_options() const}
    {
       Returns the link options that were provided to the most recent invocation of \codeinline{program::link}.  If the program has not been explicitly linked using \codeinline{program::link}, constructed with an explicitly linking constructor, or if the program has been linked for only the host device, then an empty string is returned.  If the program was constructed from a \codeinline{cl_program}, then an empty string is returned unless the \codeinline{cl_program} was explicitly linked, in which case the link options used in that explicit link are returned.  If the program object was constructed using a contructor form that links a vector of programs (and leaves the program in \codeinline{program_state::linked}), then the link options passed to this constructor are returned.
    }
  \addRow
    {string_class get_build_options() const}
    {
       Returns the compile, link, or build options, from whichever of those operations was performed most recently on the encapsulated \codeinline{cl_program}.  If no compile, link, or build operations have been performed on this SYCL \codeinline{program} object, or if the \codeinline{program} only includes the host device in its \codeinline{deviceList}, then an empty string is returned.
    }
  \addRow
    {program_state get_state() const}
    {
       Returns the current state of this SYCL \codeinline{program}.
    }
\completeTable
%-------------------------------------------------------------------------------

\subsubsection{Program information descriptors}

A SYCL \codeinline{program} can be queried for all of the following information using the \codeinline{get_info} member function. All SYCL \codeinline{program}s must have valid values for every query, including a host program. The information that can be queried is described in Table~\ref{table.program.info}. The interface for all information types and enumerations are described in appendix~\ref{appendix.program.descriptors}.

%-------------------------------------------------------------------------------
\startInfoTable{Program Descriptor}
\addInfoFootNotes{Program class information descriptors}
{table.program.info}
\addInfoRow
    {info::program::reference_count}
    {cl_uint}
    {
      Returns the reference count of the encapsulated SYCL \codeinline{cl_program},
  if this SYCL \codeinline{program} is an OpenCL program. Must throw an \codeinline{invalid_object_error} SYCL exception if this SYCL \codeinline{program} is a host program.
    }
\addInfoRow
    {info::program::context}
    {context}
    {
      Returns the SYCL \codeinline{context} associated with this \codeinline{program}.
    }
  \addInfoRow
    {info::program::devices}
    {vector_class<device>}
    {
      Returns a \codeinline{vector_class} containing the SYCL \codeinline{device}s that this \codeinline{program} has been compiled for.
    }
\completeInfoTable

%*******************************************************************************
% Defining kernels
%*******************************************************************************
\subsection{Defining kernels}
\fixme{updated text for kernel functions.}
In SYCL functions that are executed in parallel on a SYCL device are referred to
as \gls{sycl-kernel-function}. A \gls{kernel} containing such a
\gls{sycl-kernel-function} is enqueued on a device queue in order to
be executed on
that particular device. The return type of the \gls{sycl-kernel-function} is
\tf{void}, and all kernel accesses between host and device are defined using the
accessor class~\ref{subsec:accessors}.

There are three ways of defining kernels, defining them as named function objects,
lambda functions or as OpenCL \tf{cl_kernel} objects. However, in the case of
OpenCL kernels, the developer is expected to have created the kernel and set the
kernel arguments.

\subsubsection{Defining kernels as named function objects}
\label{sec:interfaces.kernels.as.function-objects}

A kernel can be defined as a named function object type. These function objects
provide the same functionality as any C++ function object, with the
restriction that they need to follow C++11 standard layout rules.
The kernel function can be templated via templating the kernel
function object type. The \tf{operator()} function may take different
parameters depending on the data accesses defined for the
specific kernel. For details on restrictions for kernel naming,
please refer to~\ref{sec:naming.kernels}.

The following example defines a \gls{sycl-kernel-function}, \textit{RandomFiller},
which initializes a buffer with a random number. 
The random number is generated during the construction of the function 
object while processing the command group.
The \codeinline{operator()} member function of the function object receives an \codeinline{item} object.
This method will be called for each work item of the execution range.
The value of the random number will be assigned to each element of the
buffer.
In this case, the accessor and the scalar random number are members of the
function object and therefore will be parameters to the device kernel.
Usual restrictions of passing parameters to kernels apply.


\lstinputlisting{code/myfunctor.cpp}

%*******************************************************************************
% Defining kernels as lambda functions
%*******************************************************************************
\subsubsection{Defining kernels as lambda functions}
\label{sec:interfaces.kernels.as.lambdas}

In C++11, function objects can be defined using lambda functions. We allow lambda
functions to define kernels in SYCL, but we have an extra requirement to
name \keyword{lambda functions} in order to enable the linking of the SYCL
device kernels with the host code to invoke them. The name of a lambda function
in SYCL is a C++ class. If the lambda function relies on template arguments,
then the name of the lambda function must contain those template arguments. The
class used for the name of a lambda function is only used for naming purposes
and is not required to be defined. For details on restrictions for kernel
naming, please refer to~\ref{sec:naming.kernels}.

To invoke a C++11 lambda, the kernel name must be included explicitly by the
user as a template parameter to the kernel invoke function.

The kernel function for the lambda function is the lambda function itself.
The kernel lambda must use copy for all of its captures (i.e.\ \tf{[=]}).

\lstinputlisting{code/mykernel.cpp}

%*******************************************************************************
% Defining kernels using program objects
%*******************************************************************************
\subsubsection{Defining kernels using program objects}

In case the developer needs to specify compiler flags or special linkage options
for a kernel, then a kernel object can be used, as described in
\ref{sec:interfaces.program.class}. The \gls{sycl-kernel-function} is defined
as a named function object
\ref{sec:interfaces.kernels.as.function-objects} or lambda function
\ref{sec:interfaces.kernels.as.lambdas}. The user can obtain a program
object for the kernel with the \codeinline{get_kernel} method. This
method is templated by the \gls{kernel-name}, so that the user
can specify the kernel whose associated kernel they wish to obtain.

In the following example, the kernel is defined as a lambda function.
The example obtains the program object for the lambda function kernel
and then passes it to the \codeinline{parallel_for}.

\lstinputlisting{code/myprogram.cpp}

In the above example, the \gls{sycl-kernel-function} is defined in the
\codeinline{parallel_for} invocation as part of a lambda function which is named
using the type of the forward declared class ``myKernel''. The type of the
function object and the program object enable the compilation and linking of the kernel
in the program class, \emph{a priori} of its actual invocation as a kernel
object. For more details on the SYCL device compiler please refer to
chapter~\ref{chapter.device.compiler}.

In the next example, a SYCL kernel is linked with an existing pre-compiled
OpenCL C program object to create a combined program object, which is then
called in a \codeinline{parallel_for}.

\lstinputlisting{code/myprogramlink.cpp}

%*******************************************************************************
% Defining kernels using OpenCL C kernel objects
%*******************************************************************************
\subsubsection{Defining kernels using OpenCL C kernel objects}
\label{sec:interfaces.kernels.opencl.objects}

In OpenCL C \cite{opencl12} program and kernel objects can be created
using the OpenCL C API, which is available in the SYCL
system. Interoperability of OpenCL C kernels and the SYCL system is
achieved by allowing the creation of a SYCL \codeinline{kernel} object from
an OpenCL \gls{kernel} object.

The constructor using kernel objects from \ref{table.constructors.kernel}:
\begin{lstlisting}[style=nonumbers]
kernel::kernel(cl_kernel kernel, const context& syclContext)
\end{lstlisting}

creates a \codeinline{kernel} which can be enqueued using
all of the \tf{parallel_for} functions that can enqueue a kernel object.
This way of defining kernels assumes that
the developer is using OpenCL C to create the kernel and to set the
kernel arguments. The system assumes that the developer has already
set kernel arguments when they are trying to enqueue the
kernel. Buffers do give ownership to their accessors on specific
contexts and the developer can enqueue OpenCL kernels in the same way
as enqueuing SYCL kernels.  However, the system is not responsible for
data management at this point.  Note that like all constructors from
OpenCL API objects, constructing a \codeinline{kernel} from
a \codeinline{cl_kernel} will retain a reference to the kernel and the
user code should call \codeinline{clReleaseKernel} if the
\codeinline{cl_kernel} is no longer needed in the calling context.


%*******************************************************************************
% OpenCL Kernel Conventions and SYCL
%*******************************************************************************
\subsection{OpenCL Kernel Conventions and SYCL}
\label{sec:opencl_kern_conventions_and_sycl}

OpenCL and SYCL use opposite conventions for the unit stride dimension.  SYCL
aligns with C++ conventions, which is important to understand from a performance
perspective when porting code to SYCL.  The unit stride dimension, at least for data, is implicit in the
linearization equations in SYCL (Equation~\ref{row-major-equation-buffer}) and OpenCL.  SYCL aligns with C++ array subscript ordering
\codeinline{arr[a][b][c]}, in that range constructor dimension ordering used to launch a kernel
(e.g. \codeinline{range<3> R\{a,b,c\}}) and range and ID queries within a kernel, are ordered in
the same way as the C++ multi-dimensional subscript operators (unit stride on the right).

When specifying a \codeinline{range} as the global or local size
in a \codeinline{parallel_for} that invokes an OpenCL interop kernel (through
\codeinline{cl_kernel} interop or \codeinline{compile_with_source}/
\codeinline{build_with_source}),
the highest dimension of the range in SYCL will map to the
lowest dimension within the OpenCL kernel.  That statement applies to both
an underlying enqueue operation such as \codeinline{clEnqueueNDRangeKernel}
in OpenCL, and also ID and size queries within the OpenCL kernel.
For example, a 3D global range specified in SYCL as:

\begin{lstlisting}[style=nonumbers]
range<3> R{r0,r1,r2};
\end{lstlisting}

maps to an \codeinline{clEnqueueNDRangeKernel} \codeinline{global_work_size} argument
of:

\begin{lstlisting}[style=nonumbers]
size_t cl_interop_range[3] = {r2,r1,r0};
\end{lstlisting}

Likewise, a 2D global range specified in SYCL as:

\begin{lstlisting}[style=nonumbers]
range<2> R{r0,r1};
\end{lstlisting}

maps to an \codeinline{clEnqueueNDRangeKernel} \codeinline{global_work_size} argument
of:

\begin{lstlisting}[style=nonumbers]
size_t cl_interop_range[2] = {r1,r0};
\end{lstlisting}

The mapping of highest dimension in SYCL to lowest dimension in OpenCL applies to all
operations where a multi-dimensional construct must be mapped, such as when mapping SYCL
explicit memory operations to OpenCL APIs like \codeinline{clEnqueueCopyBufferRect}.

Work-item and work-group ID and range queries have the same reversed convention for unit
stride dimension between SYCL and OpenCL.  For example, with three, two, or one dimensional SYCL
global ranges, OpenCL and SYCL kernel code queries relate to the range as shown in Table~\ref{table.syclOpenCL.mapping}.
The ``SYCL kernel query'' column applies for SYCL-defined kernels, and the ``OpenCL kernel query'' column
applies for kernels defined through OpenCL interop.

\startGenericThreeColTable{8cm}{3cm}{3cm}{SYCL kernel query}{OpenCL kernel query}{Returned Value}
\multicolumn{3}{|c|}{\cellcolor{Gray}With enqueued 3D SYCL global \codeinline{range} of \codeinline{range<3> R\{r0,r1,r2\}}} \\ \hline
\genericThreeColRow {nd_item::get_global_range(0) / item::get_range(0)}{get_global_size(2)}{\codeinline{r0}}
\genericThreeColRow {nd_item::get_global_range(1) / item::get_range(1)}{get_global_size(1)}{\codeinline{r1}}
\genericThreeColRow {nd_item::get_global_range(2) / item::get_range(2)}{get_global_size(0)}{\codeinline{r2}}
\genericThreeColRow {nd_item::get_global_id(0) / item::get_id(0)}{get_global_id(2)}{Value in range 0..(\codeinline{r0}-1)}
\genericThreeColRow {nd_item::get_global_id(1) / item::get_id(1)}{get_global_id(1)}{Value in range 0..(\codeinline{r1}-1)}
\genericThreeColRow {nd_item::get_global_id(2) / item::get_id(2)}{get_global_id(0)}{Value in range 0..(\codeinline{r2}-1)}
\multicolumn{3}{|c|}{\cellcolor{Gray}With enqueued 2D SYCL global \codeinline{range} of \codeinline{range<2> R\{r0,r1\}}} \\ \hline
\genericThreeColRow {nd_item::get_global_range(0) / item::get_range(0)}{get_global_size(1)}{\codeinline{r0}}
\genericThreeColRow {nd_item::get_global_range(1) / item::get_range(1)}{get_global_size(0)}{\codeinline{r1}}
\genericThreeColRow {nd_item::get_global_id(0) / item::get_id(0)}{get_global_id(1)}{Value in range 0..(\codeinline{r0}-1)}
\genericThreeColRow {nd_item::get_global_id(1) / item::get_id(1)}{get_global_id(0)}{Value in range 0..(\codeinline{r1}-1)}
\multicolumn{3}{|c|}{\cellcolor{Gray}With enqueued 1D SYCL global \codeinline{range} of \codeinline{range<1> R\{r0\}}} \\ \hline
\genericThreeColRow {nd_item::get_global_range(0) / item::get_range(0)}{get_global_size(0)}{\codeinline{r0}}
\genericThreeColRow {nd_item::get_global_id(0) / item::get_id(0)}{get_global_id(0)}{Value in range 0..(\codeinline{r0}-1)}
\completeGenericTabular
\captionGenericTable{Example range mapping from SYCL enqueued three dimensional global \codeinline{range} to OpenCL and SYCL queries}
\label{table.syclOpenCL.mapping}
\completeGenericTable


%***********************************************************************************
% Rules for parameter passing to kernels
%***********************************************************************************
\subsection{Rules for parameter passing to kernels}
\label{sec:kernel.parameter.passing}
In a case where a kernel is a named function object or a lambda function, any
member variables encapsulated within the function object or variables captured by
the lambda function must be treated according to the following rules:

\begin{itemize}
  \item
    Any accessor must be passed as an argument to the device kernel in
    a form that allows the device kernel to access the data in the
    specified way. For OpenCL 1.0--1.2 class devices, this means that
    the argument must be passed via \tf{clSetKernelArg} and be
    compiled as a kernel parameter of the valid reference type. For
    global shared data access, the parameter must be an OpenCL
    \tf{global} pointer. For an accessor that specifies OpenCL
    \tf{constant} access, the parameter must be an OpenCL
    \tf{constant} pointer. For images, the accessor must be passed as
    an \tf{image_t} and/or sampler.

  \item
    The \gls{sycl-runtime} and compiler(s) must produce the necessary
    conversions to enable accessor arguments from the host to be
    converted to the correct type of parameter on the device.

  \item
    A local accessor provides access to work-group-local memory. The
    accessor is not constructed with any buffer, but instead
    constructed with a size and base data type. The runtime must
    ensure that the work-group-local memory is allocated per
    work-group and available to be used by the kernel via the local
    accessor.

  \item
    C++ standard layout values must be passed by value to the kernel.

  \item
    C++ non-standard layout values must not be passed as arguments to
    a kernel that is compiled for a device.

  \item
    It is illegal to pass a buffer or image (instead of an accessor
    class) as an argument to a kernel. Generation of a compiler error
    in this illegal case is optional.

  \item
    Sampler objects (\codeinline{sampler}) can be passed as
    parameters to kernels.

  \item
    It is illegal to pass a pointer or reference argument to a
    kernel. Generation of a compiler error in this illegal case is
    optional.  \item Any aggregate types such as structs or classes
    should follow the rules above recursively. It is not necessary to
    separate struct or class members into separate OpenCL kernel
    parameters if all members of the aggregate type are unaffected by
    the rules above.

\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "sycl-1.2.1"
%%% TeX-auto-untabify: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "american"
%%% End:
